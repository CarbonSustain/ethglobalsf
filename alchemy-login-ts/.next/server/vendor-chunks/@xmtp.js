/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xmtp";
exports.ids = ["vendor-chunks/@xmtp"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b64Decode: () => (/* binding */ b64Decode),\n/* harmony export */   b64Encode: () => (/* binding */ b64Encode),\n/* harmony export */   fetchReq: () => (/* binding */ fetchReq),\n/* harmony export */   fetchStreamingRequest: () => (/* binding */ fetchStreamingRequest),\n/* harmony export */   renderURLSearchParams: () => (/* binding */ renderURLSearchParams),\n/* harmony export */   replacer: () => (/* binding */ replacer)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n/*\n* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY\n*/\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * base64 encoder and decoder\n * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js\n */\n// Base64 encoding table\nconst b64 = new Array(64);\n// Base64 decoding table\nconst s64 = new Array(123);\n// 65..90, 97..122, 48..57, 43, 47\nfor (let i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\nfunction b64Encode(buffer, start, end) {\n    let parts = null;\n    const chunk = [];\n    let i = 0, // output index\n    j = 0, // goto index\n    t; // temporary\n    while (start < end) {\n        const b = buffer[start++];\n        switch (j) {\n            case 0:\n                chunk[i++] = b64[b >> 2];\n                t = (b & 3) << 4;\n                j = 1;\n                break;\n            case 1:\n                chunk[i++] = b64[t | b >> 4];\n                t = (b & 15) << 2;\n                j = 2;\n                break;\n            case 2:\n                chunk[i++] = b64[t | b >> 6];\n                chunk[i++] = b64[b & 63];\n                j = 0;\n                break;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (j) {\n        chunk[i++] = b64[t];\n        chunk[i++] = 61;\n        if (j === 1)\n            chunk[i++] = 61;\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\nconst invalidEncoding = \"invalid encoding\";\nfunction b64Decode(s) {\n    const buffer = [];\n    let offset = 0;\n    let j = 0, // goto index\n    t; // temporary\n    for (let i = 0; i < s.length;) {\n        let c = s.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error(invalidEncoding);\n        switch (j) {\n            case 0:\n                t = c;\n                j = 1;\n                break;\n            case 1:\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            case 2:\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            case 3:\n                buffer[offset++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n        }\n    }\n    if (j === 1)\n        throw Error(invalidEncoding);\n    return new Uint8Array(buffer);\n}\nfunction b64Test(s) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);\n}\nfunction replacer(key, value) {\n    if (value && value.constructor === Uint8Array) {\n        return b64Encode(value, 0, value.length);\n    }\n    return value;\n}\nfunction fetchReq(path, init) {\n    const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [\"pathPrefix\"]);\n    const url = pathPrefix ? `${pathPrefix}${path}` : path;\n    return fetch(url, req).then(r => r.json().then((body) => {\n        if (!r.ok) {\n            throw body;\n        }\n        return body;\n    }));\n}\n/**\n * fetchStreamingRequest is able to handle grpc-gateway server side streaming call\n * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call\n * all entities will be returned as an array after the call finishes.\n **/\nfunction fetchStreamingRequest(path, callback, init) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [\"pathPrefix\"]);\n        const url = pathPrefix ? `${pathPrefix}${path}` : path;\n        const result = yield fetch(url, req);\n        // needs to use the .ok to check the status of HTTP status code\n        // http other than 200 will not throw an error, instead the .ok will become false.\n        // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#\n        if (!result.ok) {\n            const resp = yield result.json();\n            const errMsg = resp.error && resp.error.message ? resp.error.message : \"\";\n            throw new Error(errMsg);\n        }\n        if (!result.body) {\n            throw new Error(\"response doesnt have a body\");\n        }\n        yield result.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(getNewLineDelimitedJSONDecodingStream())\n            .pipeTo(getNotifyEntityArrivalSink((e) => {\n            if (callback) {\n                callback(e);\n            }\n        }));\n        // wait for the streaming to finish and return the success respond\n        return;\n    });\n}\n/**\n * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities\n */\nfunction getNewLineDelimitedJSONDecodingStream() {\n    return new TransformStream({\n        start(controller) {\n            controller.buf = '';\n            controller.pos = 0;\n        },\n        transform(chunk, controller) {\n            if (controller.buf === undefined) {\n                controller.buf = '';\n            }\n            if (controller.pos === undefined) {\n                controller.pos = 0;\n            }\n            controller.buf += chunk;\n            while (controller.pos < controller.buf.length) {\n                if (controller.buf[controller.pos] === '\\n') {\n                    const line = controller.buf.substring(0, controller.pos);\n                    const response = JSON.parse(line);\n                    controller.enqueue(response.result);\n                    controller.buf = controller.buf.substring(controller.pos + 1);\n                    controller.pos = 0;\n                }\n                else {\n                    ++controller.pos;\n                }\n            }\n        }\n    });\n}\n/**\n * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return\n * a sink that will call the callback on entity arrival\n * @param notifyCallback\n */\nfunction getNotifyEntityArrivalSink(notifyCallback) {\n    return new WritableStream({\n        write(entity) {\n            notifyCallback(entity);\n        }\n    });\n}\n/**\n * Checks if given value is a plain object\n * Logic copied and adapted from below source:\n * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n    const isObject = Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n    const isObjLike = value !== null && isObject;\n    if (!isObjLike || !isObject) {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    const hasObjectConstructor = typeof proto === \"object\" &&\n        proto.constructor === Object.prototype.constructor;\n    return hasObjectConstructor;\n}\n/**\n * Checks if given value is of a primitive type\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPrimitive(value) {\n    return [\"string\", \"number\", \"boolean\"].some(t => typeof value === t);\n}\n/**\n * Checks if given primitive is zero-value\n * @param  {Primitive} value\n * @return {boolean}\n */\nfunction isZeroValuePrimitive(value) {\n    return value === false || value === 0 || value === \"\";\n}\n/**\n * Flattens a deeply nested request payload and returns an object\n * with only primitive values and non-empty array of primitive values\n * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto\n * @param  {RequestPayload} requestPayload\n * @param  {String} path\n * @return {FlattenedRequestPayload>}\n */\nfunction flattenRequestPayload(requestPayload, path = \"\") {\n    return Object.keys(requestPayload).reduce((acc, key) => {\n        const value = requestPayload[key];\n        const newPath = path ? [path, key].join(\".\") : key;\n        const isNonEmptyPrimitiveArray = Array.isArray(value) &&\n            value.every(v => isPrimitive(v)) &&\n            value.length > 0;\n        const isNonZeroValuePrimitive = isPrimitive(value) && !isZeroValuePrimitive(value);\n        let objectToMerge = {};\n        if (isPlainObject(value)) {\n            objectToMerge = flattenRequestPayload(value, newPath);\n        }\n        else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {\n            objectToMerge = { [newPath]: value };\n        }\n        return Object.assign(Object.assign({}, acc), objectToMerge);\n    }, {});\n}\n/**\n * Renders a deeply nested request payload into a string of URL search\n * parameters by first flattening the request payload and then removing keys\n * which are already present in the URL path.\n * @param  {RequestPayload} requestPayload\n * @param  {string[]} urlPathParams\n * @return {string}\n */\nfunction renderURLSearchParams(requestPayload, urlPathParams = []) {\n    const flattenedRequestPayload = flattenRequestPayload(requestPayload);\n    const urlSearchParams = Object.keys(flattenedRequestPayload).reduce((acc, key) => {\n        // key should not be present in the url path as a parameter\n        const value = flattenedRequestPayload[key];\n        if (urlPathParams.find(f => f === key)) {\n            return acc;\n        }\n        return Array.isArray(value)\n            ? [...acc, ...value.map(m => [key, m.toString()])]\n            : (acc = [...acc, [key, value.toString()]]);\n    }, []);\n    return new URLSearchParams(urlSearchParams).toString();\n}\n//# sourceMappingURL=fetch.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2ZldGNoLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUN4RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLElBQUksYUFBYTtBQUMxQyxnQ0FBZ0MsV0FBVyxFQUFFLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkJBQTZCLElBQUksYUFBYTtBQUM5QyxvQ0FBb0MsV0FBVyxFQUFFLEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNkNBQTZDO0FBQzdDLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vZmV0Y2gucGIuanM/YWU3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8qXG4qIFRoaXMgZmlsZSBpcyBhIGdlbmVyYXRlZCBUeXBlc2NyaXB0IGZpbGUgZm9yIEdSUEMgR2F0ZXdheSwgRE8gTk9UIE1PRElGWVxuKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuLyoqXG4gKiBiYXNlNjQgZW5jb2RlciBhbmQgZGVjb2RlclxuICogQ29waWVkIGFuZCBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvYnVmanMvcHJvdG9idWYuanMvYmxvYi9tYXN0ZXIvbGliL2Jhc2U2NC9pbmRleC5qc1xuICovXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcbmNvbnN0IGI2NCA9IG5ldyBBcnJheSg2NCk7XG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcbmNvbnN0IHM2NCA9IG5ldyBBcnJheSgxMjMpO1xuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xuZm9yIChsZXQgaSA9IDA7IGkgPCA2NDspXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xuZXhwb3J0IGZ1bmN0aW9uIGI2NEVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcGFydHMgPSBudWxsO1xuICAgIGNvbnN0IGNodW5rID0gW107XG4gICAgbGV0IGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcbiAgICBqID0gMCwgLy8gZ290byBpbmRleFxuICAgIHQ7IC8vIHRlbXBvcmFyeVxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBjb25zdCBiID0gYnVmZmVyW3N0YXJ0KytdO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDRdO1xuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xuICAgICAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiICYgNjNdO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gODE5MSkge1xuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChqKSB7XG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcbiAgICAgICAgaWYgKGogPT09IDEpXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XG4gICAgfVxuICAgIGlmIChwYXJ0cykge1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcbn1cbmNvbnN0IGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGI2NERlY29kZShzKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGogPSAwLCAvLyBnb3RvIGluZGV4XG4gICAgdDsgLy8gdGVtcG9yYXJ5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGMgPSBzLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XG4gICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xuICAgICAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcbiAgICAgICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgICAgICBqID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGI2NFRlc3Qocykge1xuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBiNjRFbmNvZGUodmFsdWUsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaFJlcShwYXRoLCBpbml0KSB7XG4gICAgY29uc3QgX2EgPSBpbml0IHx8IHt9LCB7IHBhdGhQcmVmaXggfSA9IF9hLCByZXEgPSBfX3Jlc3QoX2EsIFtcInBhdGhQcmVmaXhcIl0pO1xuICAgIGNvbnN0IHVybCA9IHBhdGhQcmVmaXggPyBgJHtwYXRoUHJlZml4fSR7cGF0aH1gIDogcGF0aDtcbiAgICByZXR1cm4gZmV0Y2godXJsLCByZXEpLnRoZW4ociA9PiByLmpzb24oKS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgIGlmICghci5vaykge1xuICAgICAgICAgICAgdGhyb3cgYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9KSk7XG59XG4vKipcbiAqIGZldGNoU3RyZWFtaW5nUmVxdWVzdCBpcyBhYmxlIHRvIGhhbmRsZSBncnBjLWdhdGV3YXkgc2VydmVyIHNpZGUgc3RyZWFtaW5nIGNhbGxcbiAqIGl0IHRha2VzIE5vdGlmeVN0cmVhbUVudGl0eUFycml2YWwgdGhhdCBsZXRzIHVzZXJzIHJlc3BvbmQgdG8gZW50aXR5IGFycml2YWwgZHVyaW5nIHRoZSBjYWxsXG4gKiBhbGwgZW50aXRpZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBhcnJheSBhZnRlciB0aGUgY2FsbCBmaW5pc2hlcy5cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaFN0cmVhbWluZ1JlcXVlc3QocGF0aCwgY2FsbGJhY2ssIGluaXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBfYSA9IGluaXQgfHwge30sIHsgcGF0aFByZWZpeCB9ID0gX2EsIHJlcSA9IF9fcmVzdChfYSwgW1wicGF0aFByZWZpeFwiXSk7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhdGhQcmVmaXggPyBgJHtwYXRoUHJlZml4fSR7cGF0aH1gIDogcGF0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZmV0Y2godXJsLCByZXEpO1xuICAgICAgICAvLyBuZWVkcyB0byB1c2UgdGhlIC5vayB0byBjaGVjayB0aGUgc3RhdHVzIG9mIEhUVFAgc3RhdHVzIGNvZGVcbiAgICAgICAgLy8gaHR0cCBvdGhlciB0aGFuIDIwMCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciwgaW5zdGVhZCB0aGUgLm9rIHdpbGwgYmVjb21lIGZhbHNlLlxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaCNcbiAgICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCByZXN1bHQuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gcmVzcC5lcnJvciAmJiByZXNwLmVycm9yLm1lc3NhZ2UgPyByZXNwLmVycm9yLm1lc3NhZ2UgOiBcIlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuYm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2UgZG9lc250IGhhdmUgYSBib2R5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHJlc3VsdC5ib2R5XG4gICAgICAgICAgICAucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgICAgICAgICAucGlwZVRocm91Z2goZ2V0TmV3TGluZURlbGltaXRlZEpTT05EZWNvZGluZ1N0cmVhbSgpKVxuICAgICAgICAgICAgLnBpcGVUbyhnZXROb3RpZnlFbnRpdHlBcnJpdmFsU2luaygoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHN0cmVhbWluZyB0byBmaW5pc2ggYW5kIHJldHVybiB0aGUgc3VjY2VzcyByZXNwb25kXG4gICAgICAgIHJldHVybjtcbiAgICB9KTtcbn1cbi8qKlxuICogZ2V0TmV3TGluZURlbGltaXRlZEpTT05EZWNvZGluZ1N0cmVhbSByZXR1cm5zIGEgVHJhbnNmb3JtU3RyZWFtIHRoYXQncyBhYmxlIHRvIGhhbmRsZSBuZXcgbGluZSBkZWxpbWl0ZWQganNvbiBzdHJlYW0gY29udGVudCBpbnRvIHBhcnNlZCBlbnRpdGllc1xuICovXG5mdW5jdGlvbiBnZXROZXdMaW5lRGVsaW1pdGVkSlNPTkRlY29kaW5nU3RyZWFtKCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5idWYgPSAnJztcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucG9zID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5idWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYnVmID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5wb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYnVmICs9IGNodW5rO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIucG9zIDwgY29udHJvbGxlci5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuYnVmW2NvbnRyb2xsZXIucG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGNvbnRyb2xsZXIuYnVmLnN1YnN0cmluZygwLCBjb250cm9sbGVyLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYnVmID0gY29udHJvbGxlci5idWYuc3Vic3RyaW5nKGNvbnRyb2xsZXIucG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIucG9zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrY29udHJvbGxlci5wb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIGdldE5vdGlmeUVudGl0eUFycml2YWxTaW5rIHRha2VzIHRoZSBOb3RpZnlTdHJlYW1FbnRpdHlBcnJpdmFsIGNhbGxiYWNrIGFuZCByZXR1cm5cbiAqIGEgc2luayB0aGF0IHdpbGwgY2FsbCB0aGUgY2FsbGJhY2sgb24gZW50aXR5IGFycml2YWxcbiAqIEBwYXJhbSBub3RpZnlDYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXROb3RpZnlFbnRpdHlBcnJpdmFsU2luayhub3RpZnlDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICB3cml0ZShlbnRpdHkpIHtcbiAgICAgICAgICAgIG5vdGlmeUNhbGxiYWNrKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGdpdmVuIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0XG4gKiBMb2dpYyBjb3BpZWQgYW5kIGFkYXB0ZWQgZnJvbSBiZWxvdyBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcjBuL3JhbWRhLWFkanVuY3QvYmxvYi9tYXN0ZXIvc3JjL2lzUGxhaW5PYmouanNcbiAqIEBwYXJhbSAge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgY29uc3QgaXNPYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSA9PT0gXCJPYmplY3RcIjtcbiAgICBjb25zdCBpc09iakxpa2UgPSB2YWx1ZSAhPT0gbnVsbCAmJiBpc09iamVjdDtcbiAgICBpZiAoIWlzT2JqTGlrZSB8fCAhaXNPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgY29uc3QgaGFzT2JqZWN0Q29uc3RydWN0b3IgPSB0eXBlb2YgcHJvdG8gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcHJvdG8uY29uc3RydWN0b3IgPT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGhhc09iamVjdENvbnN0cnVjdG9yO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgb2YgYSBwcmltaXRpdmUgdHlwZVxuICogQHBhcmFtICB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uc29tZSh0ID0+IHR5cGVvZiB2YWx1ZSA9PT0gdCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBnaXZlbiBwcmltaXRpdmUgaXMgemVyby12YWx1ZVxuICogQHBhcmFtICB7UHJpbWl0aXZlfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNaZXJvVmFsdWVQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAwIHx8IHZhbHVlID09PSBcIlwiO1xufVxuLyoqXG4gKiBGbGF0dGVucyBhIGRlZXBseSBuZXN0ZWQgcmVxdWVzdCBwYXlsb2FkIGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICogd2l0aCBvbmx5IHByaW1pdGl2ZSB2YWx1ZXMgYW5kIG5vbi1lbXB0eSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG4gKiBhcyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlYXBpcy9ibG9iL21hc3Rlci9nb29nbGUvYXBpL2h0dHAucHJvdG9cbiAqIEBwYXJhbSAge1JlcXVlc3RQYXlsb2FkfSByZXF1ZXN0UGF5bG9hZFxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtGbGF0dGVuZWRSZXF1ZXN0UGF5bG9hZD59XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5SZXF1ZXN0UGF5bG9hZChyZXF1ZXN0UGF5bG9hZCwgcGF0aCA9IFwiXCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVxdWVzdFBheWxvYWQpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXF1ZXN0UGF5bG9hZFtrZXldO1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aCA/IFtwYXRoLCBrZXldLmpvaW4oXCIuXCIpIDoga2V5O1xuICAgICAgICBjb25zdCBpc05vbkVtcHR5UHJpbWl0aXZlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgdmFsdWUuZXZlcnkodiA9PiBpc1ByaW1pdGl2ZSh2KSkgJiZcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGlzTm9uWmVyb1ZhbHVlUHJpbWl0aXZlID0gaXNQcmltaXRpdmUodmFsdWUpICYmICFpc1plcm9WYWx1ZVByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgICAgIGxldCBvYmplY3RUb01lcmdlID0ge307XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IGZsYXR0ZW5SZXF1ZXN0UGF5bG9hZCh2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb25aZXJvVmFsdWVQcmltaXRpdmUgfHwgaXNOb25FbXB0eVByaW1pdGl2ZUFycmF5KSB7XG4gICAgICAgICAgICBvYmplY3RUb01lcmdlID0geyBbbmV3UGF0aF06IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgb2JqZWN0VG9NZXJnZSk7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBSZW5kZXJzIGEgZGVlcGx5IG5lc3RlZCByZXF1ZXN0IHBheWxvYWQgaW50byBhIHN0cmluZyBvZiBVUkwgc2VhcmNoXG4gKiBwYXJhbWV0ZXJzIGJ5IGZpcnN0IGZsYXR0ZW5pbmcgdGhlIHJlcXVlc3QgcGF5bG9hZCBhbmQgdGhlbiByZW1vdmluZyBrZXlzXG4gKiB3aGljaCBhcmUgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBVUkwgcGF0aC5cbiAqIEBwYXJhbSAge1JlcXVlc3RQYXlsb2FkfSByZXF1ZXN0UGF5bG9hZFxuICogQHBhcmFtICB7c3RyaW5nW119IHVybFBhdGhQYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclVSTFNlYXJjaFBhcmFtcyhyZXF1ZXN0UGF5bG9hZCwgdXJsUGF0aFBhcmFtcyA9IFtdKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkUmVxdWVzdFBheWxvYWQgPSBmbGF0dGVuUmVxdWVzdFBheWxvYWQocmVxdWVzdFBheWxvYWQpO1xuICAgIGNvbnN0IHVybFNlYXJjaFBhcmFtcyA9IE9iamVjdC5rZXlzKGZsYXR0ZW5lZFJlcXVlc3RQYXlsb2FkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIC8vIGtleSBzaG91bGQgbm90IGJlIHByZXNlbnQgaW4gdGhlIHVybCBwYXRoIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmxhdHRlbmVkUmVxdWVzdFBheWxvYWRba2V5XTtcbiAgICAgICAgaWYgKHVybFBhdGhQYXJhbXMuZmluZChmID0+IGYgPT09IGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IFsuLi5hY2MsIC4uLnZhbHVlLm1hcChtID0+IFtrZXksIG0udG9TdHJpbmcoKV0pXVxuICAgICAgICAgICAgOiAoYWNjID0gWy4uLmFjYywgW2tleSwgdmFsdWUudG9TdHJpbmcoKV1dKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModXJsU2VhcmNoUGFyYW1zKS50b1N0cmluZygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authn: () => (/* reexport module object */ _message_api_v1_authn_pb__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   ciphertext: () => (/* reexport module object */ _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   composite: () => (/* reexport module object */ _message_contents_composite_pb__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   contact: () => (/* reexport module object */ _message_contents_contact_pb__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   content: () => (/* reexport module object */ _message_contents_content_pb__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   conversationReference: () => (/* reexport module object */ _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   ecies: () => (/* reexport module object */ _message_contents_ecies_pb__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   fetcher: () => (/* reexport module object */ _fetch_pb__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   frames: () => (/* reexport module object */ _message_contents_frames_pb__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   invitation: () => (/* reexport module object */ _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   keystore: () => (/* reexport module object */ _keystore_api_v1_keystore_pb__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   message: () => (/* reexport module object */ _message_contents_message_pb__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   messageApi: () => (/* reexport module object */ _message_api_v1_message_api_pb__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   privateKey: () => (/* reexport module object */ _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   privatePreferences: () => (/* reexport module object */ _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   publicKey: () => (/* reexport module object */ _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   signature: () => (/* reexport module object */ _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   signedPayload: () => (/* reexport module object */ _message_contents_signed_payload_pb__WEBPACK_IMPORTED_MODULE_16__)\n/* harmony export */ });\n/* harmony import */ var _message_api_v1_message_api_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message_api/v1/message_api.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js\");\n/* harmony import */ var _fetch_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\");\n/* harmony import */ var _message_api_v1_authn_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message_api/v1/authn.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js\");\n/* harmony import */ var _message_contents_message_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message_contents/message.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js\");\n/* harmony import */ var _message_contents_content_pb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message_contents/content.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\");\n/* harmony import */ var _message_contents_frames_pb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message_contents/frames.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js\");\n/* harmony import */ var _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./message_contents/conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var _message_contents_composite_pb__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./message_contents/composite.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js\");\n/* harmony import */ var _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./message_contents/private_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./message_contents/signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./message_contents/ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _message_contents_contact_pb__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./message_contents/contact.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js\");\n/* harmony import */ var _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./message_contents/invitation.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var _keystore_api_v1_keystore_pb__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./keystore_api/v1/keystore.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js\");\n/* harmony import */ var _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./message_contents/private_preferences.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js\");\n/* harmony import */ var _message_contents_signed_payload_pb__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./message_contents/signed_payload.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js\");\n/* harmony import */ var _message_contents_ecies_pb__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./message_contents/ecies.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN4QjtBQUNhO0FBQ007QUFDQTtBQUNGO0FBQytCO0FBQ3pCO0FBQ0c7QUFDRjtBQUNEO0FBQ0U7QUFDTjtBQUNNO0FBQ0w7QUFDc0I7QUFDVjtBQUNqQjtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9pbmRleC5qcz84YTM1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGFzIG1lc3NhZ2VBcGkgZnJvbSBcIi4vbWVzc2FnZV9hcGkvdjEvbWVzc2FnZV9hcGkucGJcIjtcbmV4cG9ydCAqIGFzIGZldGNoZXIgZnJvbSBcIi4vZmV0Y2gucGJcIjtcbmV4cG9ydCAqIGFzIGF1dGhuIGZyb20gXCIuL21lc3NhZ2VfYXBpL3YxL2F1dGhuLnBiXCI7XG5leHBvcnQgKiBhcyBtZXNzYWdlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvbWVzc2FnZS5wYlwiO1xuZXhwb3J0ICogYXMgY29udGVudCBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2NvbnRlbnQucGJcIjtcbmV4cG9ydCAqIGFzIGZyYW1lcyBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2ZyYW1lcy5wYlwiO1xuZXhwb3J0ICogYXMgY29udmVyc2F0aW9uUmVmZXJlbmNlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvY29udmVyc2F0aW9uX3JlZmVyZW5jZS5wYlwiO1xuZXhwb3J0ICogYXMgY29tcG9zaXRlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvY29tcG9zaXRlLnBiXCI7XG5leHBvcnQgKiBhcyBwcml2YXRlS2V5IGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvcHJpdmF0ZV9rZXkucGJcIjtcbmV4cG9ydCAqIGFzIHB1YmxpY0tleSBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL3B1YmxpY19rZXkucGJcIjtcbmV4cG9ydCAqIGFzIHNpZ25hdHVyZSBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL3NpZ25hdHVyZS5wYlwiO1xuZXhwb3J0ICogYXMgY2lwaGVydGV4dCBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2NpcGhlcnRleHQucGJcIjtcbmV4cG9ydCAqIGFzIGNvbnRhY3QgZnJvbSBcIi4vbWVzc2FnZV9jb250ZW50cy9jb250YWN0LnBiXCI7XG5leHBvcnQgKiBhcyBpbnZpdGF0aW9uIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvaW52aXRhdGlvbi5wYlwiO1xuZXhwb3J0ICogYXMga2V5c3RvcmUgZnJvbSBcIi4va2V5c3RvcmVfYXBpL3YxL2tleXN0b3JlLnBiXCI7XG5leHBvcnQgKiBhcyBwcml2YXRlUHJlZmVyZW5jZXMgZnJvbSBcIi4vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX3ByZWZlcmVuY2VzLnBiXCI7XG5leHBvcnQgKiBhcyBzaWduZWRQYXlsb2FkIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvc2lnbmVkX3BheWxvYWQucGJcIjtcbmV4cG9ydCAqIGFzIGVjaWVzIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvZWNpZXMucGJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateAuthTokenRequest: () => (/* binding */ CreateAuthTokenRequest),\n/* harmony export */   CreateInviteRequest: () => (/* binding */ CreateInviteRequest),\n/* harmony export */   CreateInviteResponse: () => (/* binding */ CreateInviteResponse),\n/* harmony export */   DecryptResponse: () => (/* binding */ DecryptResponse),\n/* harmony export */   DecryptResponse_Response: () => (/* binding */ DecryptResponse_Response),\n/* harmony export */   DecryptResponse_Response_Success: () => (/* binding */ DecryptResponse_Response_Success),\n/* harmony export */   DecryptV1Request: () => (/* binding */ DecryptV1Request),\n/* harmony export */   DecryptV1Request_Request: () => (/* binding */ DecryptV1Request_Request),\n/* harmony export */   DecryptV2Request: () => (/* binding */ DecryptV2Request),\n/* harmony export */   DecryptV2Request_Request: () => (/* binding */ DecryptV2Request_Request),\n/* harmony export */   EncryptResponse: () => (/* binding */ EncryptResponse),\n/* harmony export */   EncryptResponse_Response: () => (/* binding */ EncryptResponse_Response),\n/* harmony export */   EncryptResponse_Response_Success: () => (/* binding */ EncryptResponse_Response_Success),\n/* harmony export */   EncryptV1Request: () => (/* binding */ EncryptV1Request),\n/* harmony export */   EncryptV1Request_Request: () => (/* binding */ EncryptV1Request_Request),\n/* harmony export */   EncryptV2Request: () => (/* binding */ EncryptV2Request),\n/* harmony export */   EncryptV2Request_Request: () => (/* binding */ EncryptV2Request_Request),\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   GetConversationHmacKeysRequest: () => (/* binding */ GetConversationHmacKeysRequest),\n/* harmony export */   GetConversationHmacKeysResponse: () => (/* binding */ GetConversationHmacKeysResponse),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeyData: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeyData),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeys: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeys),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeysEntry: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeysEntry),\n/* harmony export */   GetConversationsResponse: () => (/* binding */ GetConversationsResponse),\n/* harmony export */   GetKeystoreStatusRequest: () => (/* binding */ GetKeystoreStatusRequest),\n/* harmony export */   GetKeystoreStatusResponse: () => (/* binding */ GetKeystoreStatusResponse),\n/* harmony export */   GetKeystoreStatusResponse_KeystoreStatus: () => (/* binding */ GetKeystoreStatusResponse_KeystoreStatus),\n/* harmony export */   GetPrivatePreferencesTopicIdentifierResponse: () => (/* binding */ GetPrivatePreferencesTopicIdentifierResponse),\n/* harmony export */   GetRefreshJobRequest: () => (/* binding */ GetRefreshJobRequest),\n/* harmony export */   GetRefreshJobResponse: () => (/* binding */ GetRefreshJobResponse),\n/* harmony export */   InitKeystoreRequest: () => (/* binding */ InitKeystoreRequest),\n/* harmony export */   InitKeystoreResponse: () => (/* binding */ InitKeystoreResponse),\n/* harmony export */   JobType: () => (/* binding */ JobType),\n/* harmony export */   KeystoreError: () => (/* binding */ KeystoreError),\n/* harmony export */   SaveInvitesRequest: () => (/* binding */ SaveInvitesRequest),\n/* harmony export */   SaveInvitesRequest_Request: () => (/* binding */ SaveInvitesRequest_Request),\n/* harmony export */   SaveInvitesResponse: () => (/* binding */ SaveInvitesResponse),\n/* harmony export */   SaveInvitesResponse_Response: () => (/* binding */ SaveInvitesResponse_Response),\n/* harmony export */   SaveInvitesResponse_Response_Success: () => (/* binding */ SaveInvitesResponse_Response_Success),\n/* harmony export */   SaveV1ConversationsRequest: () => (/* binding */ SaveV1ConversationsRequest),\n/* harmony export */   SaveV1ConversationsResponse: () => (/* binding */ SaveV1ConversationsResponse),\n/* harmony export */   SelfDecryptRequest: () => (/* binding */ SelfDecryptRequest),\n/* harmony export */   SelfDecryptRequest_Request: () => (/* binding */ SelfDecryptRequest_Request),\n/* harmony export */   SelfEncryptRequest: () => (/* binding */ SelfEncryptRequest),\n/* harmony export */   SelfEncryptRequest_Request: () => (/* binding */ SelfEncryptRequest_Request),\n/* harmony export */   SelfEncryptResponse: () => (/* binding */ SelfEncryptResponse),\n/* harmony export */   SelfEncryptResponse_Response: () => (/* binding */ SelfEncryptResponse_Response),\n/* harmony export */   SelfEncryptResponse_Response_Success: () => (/* binding */ SelfEncryptResponse_Response_Success),\n/* harmony export */   SetRefeshJobRequest: () => (/* binding */ SetRefeshJobRequest),\n/* harmony export */   SetRefreshJobResponse: () => (/* binding */ SetRefreshJobResponse),\n/* harmony export */   SignDigestRequest: () => (/* binding */ SignDigestRequest),\n/* harmony export */   TopicMap: () => (/* binding */ TopicMap),\n/* harmony export */   TopicMap_TopicData: () => (/* binding */ TopicMap_TopicData),\n/* harmony export */   TopicMap_TopicsEntry: () => (/* binding */ TopicMap_TopicsEntry),\n/* harmony export */   errorCodeFromJSON: () => (/* binding */ errorCodeFromJSON),\n/* harmony export */   errorCodeToJSON: () => (/* binding */ errorCodeToJSON),\n/* harmony export */   getKeystoreStatusResponse_KeystoreStatusFromJSON: () => (/* binding */ getKeystoreStatusResponse_KeystoreStatusFromJSON),\n/* harmony export */   getKeystoreStatusResponse_KeystoreStatusToJSON: () => (/* binding */ getKeystoreStatusResponse_KeystoreStatusToJSON),\n/* harmony export */   jobTypeFromJSON: () => (/* binding */ jobTypeFromJSON),\n/* harmony export */   jobTypeToJSON: () => (/* binding */ jobTypeToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../message_contents/ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../message_contents/invitation.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../message_contents/conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../message_contents/private_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6__);\n/* eslint-disable */\n\n\n\n\n\n\n\nconst protobufPackage = \"xmtp.keystore_api.v1\";\n/** Message content encoding structures */\n/** Application-specific error codes for the Keystore API. */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"ERROR_CODE_UNSPECIFIED\"] = 0] = \"ERROR_CODE_UNSPECIFIED\";\n    ErrorCode[ErrorCode[\"ERROR_CODE_INVALID_INPUT\"] = 1] = \"ERROR_CODE_INVALID_INPUT\";\n    ErrorCode[ErrorCode[\"ERROR_CODE_NO_MATCHING_PREKEY\"] = 2] = \"ERROR_CODE_NO_MATCHING_PREKEY\";\n    ErrorCode[ErrorCode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ErrorCode || (ErrorCode = {}));\nfunction errorCodeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"ERROR_CODE_UNSPECIFIED\":\n            return ErrorCode.ERROR_CODE_UNSPECIFIED;\n        case 1:\n        case \"ERROR_CODE_INVALID_INPUT\":\n            return ErrorCode.ERROR_CODE_INVALID_INPUT;\n        case 2:\n        case \"ERROR_CODE_NO_MATCHING_PREKEY\":\n            return ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ErrorCode.UNRECOGNIZED;\n    }\n}\nfunction errorCodeToJSON(object) {\n    switch (object) {\n        case ErrorCode.ERROR_CODE_UNSPECIFIED:\n            return \"ERROR_CODE_UNSPECIFIED\";\n        case ErrorCode.ERROR_CODE_INVALID_INPUT:\n            return \"ERROR_CODE_INVALID_INPUT\";\n        case ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY:\n            return \"ERROR_CODE_NO_MATCHING_PREKEY\";\n        case ErrorCode.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** JobType is used to specify the type of job the caller would like info on */\nvar JobType;\n(function (JobType) {\n    JobType[JobType[\"JOB_TYPE_UNSPECIFIED\"] = 0] = \"JOB_TYPE_UNSPECIFIED\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_V1\"] = 1] = \"JOB_TYPE_REFRESH_V1\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_V2\"] = 2] = \"JOB_TYPE_REFRESH_V2\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_PPPP\"] = 3] = \"JOB_TYPE_REFRESH_PPPP\";\n    JobType[JobType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(JobType || (JobType = {}));\nfunction jobTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"JOB_TYPE_UNSPECIFIED\":\n            return JobType.JOB_TYPE_UNSPECIFIED;\n        case 1:\n        case \"JOB_TYPE_REFRESH_V1\":\n            return JobType.JOB_TYPE_REFRESH_V1;\n        case 2:\n        case \"JOB_TYPE_REFRESH_V2\":\n            return JobType.JOB_TYPE_REFRESH_V2;\n        case 3:\n        case \"JOB_TYPE_REFRESH_PPPP\":\n            return JobType.JOB_TYPE_REFRESH_PPPP;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return JobType.UNRECOGNIZED;\n    }\n}\nfunction jobTypeToJSON(object) {\n    switch (object) {\n        case JobType.JOB_TYPE_UNSPECIFIED:\n            return \"JOB_TYPE_UNSPECIFIED\";\n        case JobType.JOB_TYPE_REFRESH_V1:\n            return \"JOB_TYPE_REFRESH_V1\";\n        case JobType.JOB_TYPE_REFRESH_V2:\n            return \"JOB_TYPE_REFRESH_V2\";\n        case JobType.JOB_TYPE_REFRESH_PPPP:\n            return \"JOB_TYPE_REFRESH_PPPP\";\n        case JobType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** Status of the Keystore for the specified wallet address */\nvar GetKeystoreStatusResponse_KeystoreStatus;\n(function (GetKeystoreStatusResponse_KeystoreStatus) {\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_UNSPECIFIED\"] = 0] = \"KEYSTORE_STATUS_UNSPECIFIED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_UNINITIALIZED\"] = 1] = \"KEYSTORE_STATUS_UNINITIALIZED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_INITIALIZED\"] = 2] = \"KEYSTORE_STATUS_INITIALIZED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(GetKeystoreStatusResponse_KeystoreStatus || (GetKeystoreStatusResponse_KeystoreStatus = {}));\nfunction getKeystoreStatusResponse_KeystoreStatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"KEYSTORE_STATUS_UNSPECIFIED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED;\n        case 1:\n        case \"KEYSTORE_STATUS_UNINITIALIZED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED;\n        case 2:\n        case \"KEYSTORE_STATUS_INITIALIZED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED;\n    }\n}\nfunction getKeystoreStatusResponse_KeystoreStatusToJSON(object) {\n    switch (object) {\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED:\n            return \"KEYSTORE_STATUS_UNSPECIFIED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED:\n            return \"KEYSTORE_STATUS_UNINITIALIZED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED:\n            return \"KEYSTORE_STATUS_INITIALIZED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseKeystoreError() {\n    return { message: \"\", code: 0 };\n}\nconst KeystoreError = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.message !== \"\") {\n            writer.uint32(10).string(message.message);\n        }\n        if (message.code !== 0) {\n            writer.uint32(16).int32(message.code);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseKeystoreError();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    message.code = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            message: isSet(object.message) ? String(object.message) : \"\",\n            code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.message !== undefined && (obj.message = message.message);\n        message.code !== undefined && (obj.code = errorCodeToJSON(message.code));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseKeystoreError();\n        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : \"\";\n        message.code = (_b = object.code) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseDecryptV1Request() {\n    return { requests: [] };\n}\nconst DecryptV1Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            DecryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV1Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(DecryptV1Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => DecryptV1Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? DecryptV1Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptV1Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptV1Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptV1Request_Request() {\n    return {\n        payload: undefined,\n        peerKeys: undefined,\n        headerBytes: new Uint8Array(),\n        isSender: false,\n    };\n}\nconst DecryptV1Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.payload !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.payload, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.peerKeys !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.encode(message.peerKeys, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(26).bytes(message.headerBytes);\n        }\n        if (message.isSender === true) {\n            writer.uint32(32).bool(message.isSender);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV1Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.peerKeys = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 4:\n                    message.isSender = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.payload)\n                : undefined,\n            peerKeys: isSet(object.peerKeys)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromJSON(object.peerKeys)\n                : undefined,\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            isSender: isSet(object.isSender) ? Boolean(object.isSender) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = message.payload\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.payload)\n                : undefined);\n        message.peerKeys !== undefined &&\n            (obj.peerKeys = message.peerKeys\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.toJSON(message.peerKeys)\n                : undefined);\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.isSender !== undefined && (obj.isSender = message.isSender);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDecryptV1Request_Request();\n        message.payload =\n            object.payload !== undefined && object.payload !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.payload)\n                : undefined;\n        message.peerKeys =\n            object.peerKeys !== undefined && object.peerKeys !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromPartial(object.peerKeys)\n                : undefined;\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.isSender = (_b = object.isSender) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseDecryptResponse() {\n    return { responses: [] };\n}\nconst DecryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.responses) {\n            DecryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(DecryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => DecryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? DecryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptResponse_Response.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst DecryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.result !== undefined) {\n            DecryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = DecryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? DecryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? DecryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDecryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? DecryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseDecryptResponse_Response_Success() {\n    return { decrypted: new Uint8Array() };\n}\nconst DecryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.decrypted.length !== 0) {\n            writer.uint32(10).bytes(message.decrypted);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.decrypted = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            decrypted: isSet(object.decrypted)\n                ? bytesFromBase64(object.decrypted)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.decrypted !== undefined &&\n            (obj.decrypted = base64FromBytes(message.decrypted !== undefined ? message.decrypted : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptResponse_Response_Success();\n        message.decrypted = (_a = object.decrypted) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseDecryptV2Request() {\n    return { requests: [] };\n}\nconst DecryptV2Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            DecryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV2Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(DecryptV2Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => DecryptV2Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? DecryptV2Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptV2Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptV2Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptV2Request_Request() {\n    return {\n        payload: undefined,\n        headerBytes: new Uint8Array(),\n        contentTopic: \"\",\n    };\n}\nconst DecryptV2Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.payload !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.payload, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(18).bytes(message.headerBytes);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(26).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV2Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.payload)\n                : undefined,\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = message.payload\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.payload)\n                : undefined);\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDecryptV2Request_Request();\n        message.payload =\n            object.payload !== undefined && object.payload !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.payload)\n                : undefined;\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.contentTopic = (_b = object.contentTopic) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseEncryptV1Request() {\n    return { requests: [] };\n}\nconst EncryptV1Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            EncryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV1Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(EncryptV1Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => EncryptV1Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? EncryptV1Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptV1Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptV1Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptV1Request_Request() {\n    return {\n        recipient: undefined,\n        payload: new Uint8Array(),\n        headerBytes: new Uint8Array(),\n    };\n}\nconst EncryptV1Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.recipient !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.encode(message.recipient, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(18).bytes(message.payload);\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(26).bytes(message.headerBytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV1Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.recipient = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.payload = reader.bytes();\n                    break;\n                case 3:\n                    message.headerBytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            recipient: isSet(object.recipient)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEncryptV1Request_Request();\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncryptResponse() {\n    return { responses: [] };\n}\nconst EncryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.responses) {\n            EncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(EncryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => EncryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? EncryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptResponse_Response.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst EncryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.result !== undefined) {\n            EncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = EncryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? EncryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? EncryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseEncryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? EncryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptResponse_Response_Success() {\n    return { encrypted: undefined, senderHmac: new Uint8Array() };\n}\nconst EncryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.encrypted !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.encrypted, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.senderHmac.length !== 0) {\n            writer.uint32(18).bytes(message.senderHmac);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.encrypted = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.senderHmac = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            encrypted: isSet(object.encrypted)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.encrypted)\n                : undefined,\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.encrypted !== undefined &&\n            (obj.encrypted = message.encrypted\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.encrypted)\n                : undefined);\n        message.senderHmac !== undefined &&\n            (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptResponse_Response_Success();\n        message.encrypted =\n            object.encrypted !== undefined && object.encrypted !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.encrypted)\n                : undefined;\n        message.senderHmac = (_a = object.senderHmac) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncryptV2Request() {\n    return { requests: [] };\n}\nconst EncryptV2Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            EncryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV2Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(EncryptV2Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => EncryptV2Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? EncryptV2Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptV2Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptV2Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptV2Request_Request() {\n    return {\n        payload: new Uint8Array(),\n        headerBytes: new Uint8Array(),\n        contentTopic: \"\",\n    };\n}\nconst EncryptV2Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(18).bytes(message.headerBytes);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(26).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV2Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseEncryptV2Request_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.contentTopic = (_c = object.contentTopic) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseSelfEncryptRequest() {\n    return { requests: [] };\n}\nconst SelfEncryptRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            SelfEncryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SelfEncryptRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SelfEncryptRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SelfEncryptRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SelfEncryptRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSelfEncryptRequest_Request() {\n    return { payload: new Uint8Array() };\n}\nconst SelfEncryptRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptRequest_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse() {\n    return { responses: [] };\n}\nconst SelfEncryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.responses) {\n            SelfEncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(SelfEncryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => SelfEncryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? SelfEncryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => SelfEncryptResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst SelfEncryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.result !== undefined) {\n            SelfEncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = SelfEncryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? SelfEncryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? SelfEncryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSelfEncryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? SelfEncryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse_Response_Success() {\n    return { encrypted: new Uint8Array() };\n}\nconst SelfEncryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.encrypted.length !== 0) {\n            writer.uint32(10).bytes(message.encrypted);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.encrypted = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            encrypted: isSet(object.encrypted)\n                ? bytesFromBase64(object.encrypted)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.encrypted !== undefined &&\n            (obj.encrypted = base64FromBytes(message.encrypted !== undefined ? message.encrypted : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptResponse_Response_Success();\n        message.encrypted = (_a = object.encrypted) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSelfDecryptRequest() {\n    return { requests: [] };\n}\nconst SelfDecryptRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            SelfDecryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfDecryptRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SelfDecryptRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SelfDecryptRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SelfDecryptRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfDecryptRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SelfDecryptRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSelfDecryptRequest_Request() {\n    return { payload: new Uint8Array() };\n}\nconst SelfDecryptRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfDecryptRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfDecryptRequest_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetPrivatePreferencesTopicIdentifierResponse() {\n    return { identifier: \"\" };\n}\nconst GetPrivatePreferencesTopicIdentifierResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.identifier !== \"\") {\n            writer.uint32(10).string(message.identifier);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identifier = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identifier: isSet(object.identifier) ? String(object.identifier) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identifier !== undefined && (obj.identifier = message.identifier);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();\n        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseCreateInviteRequest() {\n    return {\n        context: undefined,\n        recipient: undefined,\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        consentProof: undefined,\n    };\n}\nconst CreateInviteRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.context !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.encode(message.context, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        if (message.consentProof !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.encode(message.consentProof, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateInviteRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.context = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 4:\n                    message.consentProof = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            context: isSet(object.context)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            consentProof: isSet(object.consentProof)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.fromJSON(object.consentProof)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.consentProof !== undefined &&\n            (obj.consentProof = message.consentProof\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.toJSON(message.consentProof)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCreateInviteRequest();\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.consentProof =\n            object.consentProof !== undefined && object.consentProof !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.fromPartial(object.consentProof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateInviteResponse() {\n    return { conversation: undefined, payload: new Uint8Array() };\n}\nconst CreateInviteResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.conversation !== undefined) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(message.conversation, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(18).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateInviteResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversation = _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversation: isSet(object.conversation)\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseCreateInviteResponse();\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSaveInvitesRequest() {\n    return { requests: [] };\n}\nconst SaveInvitesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.requests) {\n            SaveInvitesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SaveInvitesRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SaveInvitesRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SaveInvitesRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveInvitesRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SaveInvitesRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSaveInvitesRequest_Request() {\n    return {\n        contentTopic: \"\",\n        timestampNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        payload: new Uint8Array(),\n    };\n}\nconst SaveInvitesRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.contentTopic !== \"\") {\n            writer.uint32(10).string(message.contentTopic);\n        }\n        if (!message.timestampNs.isZero()) {\n            writer.uint32(16).uint64(message.timestampNs);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(26).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.contentTopic = reader.string();\n                    break;\n                case 2:\n                    message.timestampNs = reader.uint64();\n                    break;\n                case 3:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n            timestampNs: isSet(object.timestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.timestampNs !== undefined &&\n            (obj.timestampNs = (message.timestampNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSaveInvitesRequest_Request();\n        message.contentTopic = (_a = object.contentTopic) !== null && _a !== void 0 ? _a : \"\";\n        message.timestampNs =\n            object.timestampNs !== undefined && object.timestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse() {\n    return { responses: [] };\n}\nconst SaveInvitesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.responses) {\n            SaveInvitesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(SaveInvitesResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => SaveInvitesResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? SaveInvitesResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveInvitesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => SaveInvitesResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst SaveInvitesResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.result !== undefined) {\n            SaveInvitesResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = SaveInvitesResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? SaveInvitesResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? SaveInvitesResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSaveInvitesResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? SaveInvitesResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse_Response_Success() {\n    return { conversation: undefined };\n}\nconst SaveInvitesResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.conversation !== undefined) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(message.conversation, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversation = _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversation: isSet(object.conversation)\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSaveInvitesResponse_Response_Success();\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateAuthTokenRequest() {\n    return { timestampNs: undefined };\n}\nconst CreateAuthTokenRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.timestampNs !== undefined) {\n            writer.uint32(8).uint64(message.timestampNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateAuthTokenRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestampNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestampNs: isSet(object.timestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestampNs !== undefined &&\n            (obj.timestampNs = (message.timestampNs || undefined).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCreateAuthTokenRequest();\n        message.timestampNs =\n            object.timestampNs !== undefined && object.timestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSaveV1ConversationsRequest() {\n    return { conversations: [] };\n}\nconst SaveV1ConversationsRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.conversations) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveV1ConversationsRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversations.push(_message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations)\n                ? object.conversations.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.conversations) {\n            obj.conversations = message.conversations.map((e) => e ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(e) : undefined);\n        }\n        else {\n            obj.conversations = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveV1ConversationsRequest();\n        message.conversations =\n            ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSaveV1ConversationsResponse() {\n    return {};\n}\nconst SaveV1ConversationsResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveV1ConversationsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSaveV1ConversationsResponse();\n        return message;\n    },\n};\nfunction createBaseGetConversationsResponse() {\n    return { conversations: [] };\n}\nconst GetConversationsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.conversations) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversations.push(_message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations)\n                ? object.conversations.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.conversations) {\n            obj.conversations = message.conversations.map((e) => e ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(e) : undefined);\n        }\n        else {\n            obj.conversations = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationsResponse();\n        message.conversations =\n            ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseGetKeystoreStatusRequest() {\n    return { walletAddress: \"\" };\n}\nconst GetKeystoreStatusRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.walletAddress !== \"\") {\n            writer.uint32(10).string(message.walletAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetKeystoreStatusRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddress: isSet(object.walletAddress)\n                ? String(object.walletAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletAddress !== undefined &&\n            (obj.walletAddress = message.walletAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetKeystoreStatusRequest();\n        message.walletAddress = (_a = object.walletAddress) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetKeystoreStatusResponse() {\n    return { status: 0 };\n}\nconst GetKeystoreStatusResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.status !== 0) {\n            writer.uint32(8).int32(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetKeystoreStatusResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            status: isSet(object.status)\n                ? getKeystoreStatusResponse_KeystoreStatusFromJSON(object.status)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.status !== undefined &&\n            (obj.status = getKeystoreStatusResponse_KeystoreStatusToJSON(message.status));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetKeystoreStatusResponse();\n        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseInitKeystoreRequest() {\n    return { v1: undefined };\n}\nconst InitKeystoreRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitKeystoreRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseInitKeystoreRequest();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseInitKeystoreResponse() {\n    return { error: undefined };\n}\nconst InitKeystoreResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitKeystoreResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseInitKeystoreResponse();\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignDigestRequest() {\n    return {\n        digest: new Uint8Array(),\n        identityKey: undefined,\n        prekeyIndex: undefined,\n    };\n}\nconst SignDigestRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.digest.length !== 0) {\n            writer.uint32(10).bytes(message.digest);\n        }\n        if (message.identityKey !== undefined) {\n            writer.uint32(16).bool(message.identityKey);\n        }\n        if (message.prekeyIndex !== undefined) {\n            writer.uint32(24).uint32(message.prekeyIndex);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignDigestRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.digest = reader.bytes();\n                    break;\n                case 2:\n                    message.identityKey = reader.bool();\n                    break;\n                case 3:\n                    message.prekeyIndex = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            digest: isSet(object.digest)\n                ? bytesFromBase64(object.digest)\n                : new Uint8Array(),\n            identityKey: isSet(object.identityKey)\n                ? Boolean(object.identityKey)\n                : undefined,\n            prekeyIndex: isSet(object.prekeyIndex)\n                ? Number(object.prekeyIndex)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.digest !== undefined &&\n            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey);\n        message.prekeyIndex !== undefined &&\n            (obj.prekeyIndex = Math.round(message.prekeyIndex));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseSignDigestRequest();\n        message.digest = (_a = object.digest) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.identityKey = (_b = object.identityKey) !== null && _b !== void 0 ? _b : undefined;\n        message.prekeyIndex = (_c = object.prekeyIndex) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBaseGetRefreshJobRequest() {\n    return { jobType: 0 };\n}\nconst GetRefreshJobRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.jobType !== 0) {\n            writer.uint32(8).int32(message.jobType);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetRefreshJobRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jobType = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jobType !== undefined &&\n            (obj.jobType = jobTypeToJSON(message.jobType));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetRefreshJobRequest();\n        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseGetRefreshJobResponse() {\n    return { lastRunNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO };\n}\nconst GetRefreshJobResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (!message.lastRunNs.isZero()) {\n            writer.uint32(8).int64(message.lastRunNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetRefreshJobResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.lastRunNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            lastRunNs: isSet(object.lastRunNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.lastRunNs !== undefined &&\n            (obj.lastRunNs = (message.lastRunNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetRefreshJobResponse();\n        message.lastRunNs =\n            object.lastRunNs !== undefined && object.lastRunNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO;\n        return message;\n    },\n};\nfunction createBaseSetRefeshJobRequest() {\n    return { jobType: 0, lastRunNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO };\n}\nconst SetRefeshJobRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.jobType !== 0) {\n            writer.uint32(8).int32(message.jobType);\n        }\n        if (!message.lastRunNs.isZero()) {\n            writer.uint32(16).int64(message.lastRunNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSetRefeshJobRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jobType = reader.int32();\n                    break;\n                case 2:\n                    message.lastRunNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,\n            lastRunNs: isSet(object.lastRunNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jobType !== undefined &&\n            (obj.jobType = jobTypeToJSON(message.jobType));\n        message.lastRunNs !== undefined &&\n            (obj.lastRunNs = (message.lastRunNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSetRefeshJobRequest();\n        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;\n        message.lastRunNs =\n            object.lastRunNs !== undefined && object.lastRunNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO;\n        return message;\n    },\n};\nfunction createBaseSetRefreshJobResponse() {\n    return {};\n}\nconst SetRefreshJobResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSetRefreshJobResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSetRefreshJobResponse();\n        return message;\n    },\n};\nfunction createBaseTopicMap() {\n    return { topics: {} };\n}\nconst TopicMap = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        Object.entries(message.topics).forEach(([key, value]) => {\n            TopicMap_TopicsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = TopicMap_TopicsEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.topics[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topics: isObject(object.topics)\n                ? Object.entries(object.topics).reduce((acc, [key, value]) => {\n                    acc[key] = TopicMap_TopicData.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.topics = {};\n        if (message.topics) {\n            Object.entries(message.topics).forEach(([k, v]) => {\n                obj.topics[k] = TopicMap_TopicData.toJSON(v);\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap();\n        message.topics = Object.entries((_a = object.topics) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = TopicMap_TopicData.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseTopicMap_TopicData() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, peerAddress: \"\", invitation: undefined };\n}\nconst TopicMap_TopicData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.peerAddress !== \"\") {\n            writer.uint32(18).string(message.peerAddress);\n        }\n        if (message.invitation !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.encode(message.invitation, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap_TopicData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.peerAddress = reader.string();\n                    break;\n                case 3:\n                    message.invitation = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : \"\",\n            invitation: isSet(object.invitation)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.fromJSON(object.invitation)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.peerAddress !== undefined &&\n            (obj.peerAddress = message.peerAddress);\n        message.invitation !== undefined &&\n            (obj.invitation = message.invitation\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.toJSON(message.invitation)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap_TopicData();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.peerAddress = (_a = object.peerAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.invitation =\n            object.invitation !== undefined && object.invitation !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.fromPartial(object.invitation)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseTopicMap_TopicsEntry() {\n    return { key: \"\", value: undefined };\n}\nconst TopicMap_TopicsEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            TopicMap_TopicData.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap_TopicsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = TopicMap_TopicData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value)\n                ? TopicMap_TopicData.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = message.value\n                ? TopicMap_TopicData.toJSON(message.value)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap_TopicsEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? TopicMap_TopicData.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysRequest() {\n    return { topics: [] };\n}\nconst GetConversationHmacKeysRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.topics) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topics.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topics: Array.isArray(object === null || object === void 0 ? void 0 : object.topics)\n                ? object.topics.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.topics) {\n            obj.topics = message.topics.map((e) => e);\n        }\n        else {\n            obj.topics = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysRequest();\n        message.topics = ((_a = object.topics) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse() {\n    return { hmacKeys: {} };\n}\nconst GetConversationHmacKeysResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        Object.entries(message.hmacKeys).forEach(([key, value]) => {\n            GetConversationHmacKeysResponse_HmacKeysEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = GetConversationHmacKeysResponse_HmacKeysEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.hmacKeys[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hmacKeys: isObject(object.hmacKeys)\n                ? Object.entries(object.hmacKeys).reduce((acc, [key, value]) => {\n                    acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.hmacKeys = {};\n        if (message.hmacKeys) {\n            Object.entries(message.hmacKeys).forEach(([k, v]) => {\n                obj.hmacKeys[k] = GetConversationHmacKeysResponse_HmacKeys.toJSON(v);\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse();\n        message.hmacKeys = Object.entries((_a = object.hmacKeys) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeyData() {\n    return { thirtyDayPeriodsSinceEpoch: 0, hmacKey: new Uint8Array() };\n}\nconst GetConversationHmacKeysResponse_HmacKeyData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.thirtyDayPeriodsSinceEpoch !== 0) {\n            writer.uint32(8).int32(message.thirtyDayPeriodsSinceEpoch);\n        }\n        if (message.hmacKey.length !== 0) {\n            writer.uint32(18).bytes(message.hmacKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.thirtyDayPeriodsSinceEpoch = reader.int32();\n                    break;\n                case 2:\n                    message.hmacKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            thirtyDayPeriodsSinceEpoch: isSet(object.thirtyDayPeriodsSinceEpoch)\n                ? Number(object.thirtyDayPeriodsSinceEpoch)\n                : 0,\n            hmacKey: isSet(object.hmacKey)\n                ? bytesFromBase64(object.hmacKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.thirtyDayPeriodsSinceEpoch !== undefined &&\n            (obj.thirtyDayPeriodsSinceEpoch = Math.round(message.thirtyDayPeriodsSinceEpoch));\n        message.hmacKey !== undefined &&\n            (obj.hmacKey = base64FromBytes(message.hmacKey !== undefined ? message.hmacKey : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();\n        message.thirtyDayPeriodsSinceEpoch = (_a = object.thirtyDayPeriodsSinceEpoch) !== null && _a !== void 0 ? _a : 0;\n        message.hmacKey = (_b = object.hmacKey) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeys() {\n    return { values: [] };\n}\nconst GetConversationHmacKeysResponse_HmacKeys = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        for (const v of message.values) {\n            GetConversationHmacKeysResponse_HmacKeyData.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.values.push(GetConversationHmacKeysResponse_HmacKeyData.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            values: Array.isArray(object === null || object === void 0 ? void 0 : object.values)\n                ? object.values.map((e) => GetConversationHmacKeysResponse_HmacKeyData.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.values) {\n            obj.values = message.values.map((e) => e ? GetConversationHmacKeysResponse_HmacKeyData.toJSON(e) : undefined);\n        }\n        else {\n            obj.values = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();\n        message.values =\n            ((_a = object.values) === null || _a === void 0 ? void 0 : _a.map((e) => GetConversationHmacKeysResponse_HmacKeyData.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeysEntry() {\n    return { key: \"\", value: undefined };\n}\nconst GetConversationHmacKeysResponse_HmacKeysEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            GetConversationHmacKeysResponse_HmacKeys.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = GetConversationHmacKeysResponse_HmacKeys.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value)\n                ? GetConversationHmacKeysResponse_HmacKeys.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = message.value\n                ? GetConversationHmacKeysResponse_HmacKeys.toJSON(message.value)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? GetConversationHmacKeysResponse_HmacKeys.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_6___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=keystore.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2tleXN0b3JlX2FwaS92MS9rZXlzdG9yZS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUMwQztBQUM2QjtBQUNpQjtBQUN2QjtBQUNkO0FBQ3RDO0FBQzlCO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQ3hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRGQUE0RjtBQUN0RjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20va2V5c3RvcmVfYXBpL3YxL2tleXN0b3JlLnBiLmpzPzhiMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBDaXBoZXJ0ZXh0IH0gZnJvbSBcIi4uLy4uL21lc3NhZ2VfY29udGVudHMvY2lwaGVydGV4dC5wYlwiO1xuaW1wb3J0IHsgUHVibGljS2V5QnVuZGxlLCBTaWduZWRQdWJsaWNLZXlCdW5kbGUsIH0gZnJvbSBcIi4uLy4uL21lc3NhZ2VfY29udGVudHMvcHVibGljX2tleS5wYlwiO1xuaW1wb3J0IHsgSW52aXRhdGlvblYxX0NvbnRleHQsIENvbnNlbnRQcm9vZlBheWxvYWQsIEludml0YXRpb25WMSwgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9pbnZpdGF0aW9uLnBiXCI7XG5pbXBvcnQgeyBDb252ZXJzYXRpb25SZWZlcmVuY2UgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9jb252ZXJzYXRpb25fcmVmZXJlbmNlLnBiXCI7XG5pbXBvcnQgeyBQcml2YXRlS2V5QnVuZGxlVjEgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX2tleS5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLmtleXN0b3JlX2FwaS52MVwiO1xuLyoqIE1lc3NhZ2UgY29udGVudCBlbmNvZGluZyBzdHJ1Y3R1cmVzICovXG4vKiogQXBwbGljYXRpb24tc3BlY2lmaWMgZXJyb3IgY29kZXMgZm9yIHRoZSBLZXlzdG9yZSBBUEkuICovXG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUk9SX0NPREVfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiRVJST1JfQ09ERV9VTlNQRUNJRklFRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJPUl9DT0RFX0lOVkFMSURfSU5QVVRcIl0gPSAxXSA9IFwiRVJST1JfQ09ERV9JTlZBTElEX0lOUFVUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZXCJdID0gMl0gPSBcIkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JDb2RlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiRVJST1JfQ09ERV9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29kZS5FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJFUlJPUl9DT0RFX0lOVkFMSURfSU5QVVRcIjpcbiAgICAgICAgICAgIHJldHVybiBFcnJvckNvZGUuRVJST1JfQ09ERV9JTlZBTElEX0lOUFVUO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJFUlJPUl9DT0RFX05PX01BVENISU5HX1BSRUtFWVwiOlxuICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29kZS5FUlJPUl9DT0RFX05PX01BVENISU5HX1BSRUtFWTtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29kZS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yQ29kZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIEVycm9yQ29kZS5FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiRVJST1JfQ09ERV9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQ6XG4gICAgICAgICAgICByZXR1cm4gXCJFUlJPUl9DT0RFX0lOVkFMSURfSU5QVVRcIjtcbiAgICAgICAgY2FzZSBFcnJvckNvZGUuRVJST1JfQ09ERV9OT19NQVRDSElOR19QUkVLRVk6XG4gICAgICAgICAgICByZXR1cm4gXCJFUlJPUl9DT0RFX05PX01BVENISU5HX1BSRUtFWVwiO1xuICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTlJFQ09HTklaRURcIjtcbiAgICB9XG59XG4vKiogSm9iVHlwZSBpcyB1c2VkIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2Ygam9iIHRoZSBjYWxsZXIgd291bGQgbGlrZSBpbmZvIG9uICovXG5leHBvcnQgdmFyIEpvYlR5cGU7XG4oZnVuY3Rpb24gKEpvYlR5cGUpIHtcbiAgICBKb2JUeXBlW0pvYlR5cGVbXCJKT0JfVFlQRV9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJKT0JfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIEpvYlR5cGVbSm9iVHlwZVtcIkpPQl9UWVBFX1JFRlJFU0hfVjFcIl0gPSAxXSA9IFwiSk9CX1RZUEVfUkVGUkVTSF9WMVwiO1xuICAgIEpvYlR5cGVbSm9iVHlwZVtcIkpPQl9UWVBFX1JFRlJFU0hfVjJcIl0gPSAyXSA9IFwiSk9CX1RZUEVfUkVGUkVTSF9WMlwiO1xuICAgIEpvYlR5cGVbSm9iVHlwZVtcIkpPQl9UWVBFX1JFRlJFU0hfUFBQUFwiXSA9IDNdID0gXCJKT0JfVFlQRV9SRUZSRVNIX1BQUFBcIjtcbiAgICBKb2JUeXBlW0pvYlR5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoSm9iVHlwZSB8fCAoSm9iVHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gam9iVHlwZUZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIkpPQl9UWVBFX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gSm9iVHlwZS5KT0JfVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiSk9CX1RZUEVfUkVGUkVTSF9WMVwiOlxuICAgICAgICAgICAgcmV0dXJuIEpvYlR5cGUuSk9CX1RZUEVfUkVGUkVTSF9WMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiSk9CX1RZUEVfUkVGUkVTSF9WMlwiOlxuICAgICAgICAgICAgcmV0dXJuIEpvYlR5cGUuSk9CX1RZUEVfUkVGUkVTSF9WMjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiSk9CX1RZUEVfUkVGUkVTSF9QUFBQXCI6XG4gICAgICAgICAgICByZXR1cm4gSm9iVHlwZS5KT0JfVFlQRV9SRUZSRVNIX1BQUFA7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKb2JUeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gam9iVHlwZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIEpvYlR5cGUuSk9CX1RZUEVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJKT0JfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIEpvYlR5cGUuSk9CX1RZUEVfUkVGUkVTSF9WMTpcbiAgICAgICAgICAgIHJldHVybiBcIkpPQl9UWVBFX1JFRlJFU0hfVjFcIjtcbiAgICAgICAgY2FzZSBKb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfVjI6XG4gICAgICAgICAgICByZXR1cm4gXCJKT0JfVFlQRV9SRUZSRVNIX1YyXCI7XG4gICAgICAgIGNhc2UgSm9iVHlwZS5KT0JfVFlQRV9SRUZSRVNIX1BQUFA6XG4gICAgICAgICAgICByZXR1cm4gXCJKT0JfVFlQRV9SRUZSRVNIX1BQUFBcIjtcbiAgICAgICAgY2FzZSBKb2JUeXBlLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOUkVDT0dOSVpFRFwiO1xuICAgIH1cbn1cbi8qKiBTdGF0dXMgb2YgdGhlIEtleXN0b3JlIGZvciB0aGUgc3BlY2lmaWVkIHdhbGxldCBhZGRyZXNzICovXG5leHBvcnQgdmFyIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXM7XG4oZnVuY3Rpb24gKEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMpIHtcbiAgICBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW0dldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbXCJLRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiS0VZU1RPUkVfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c1tHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW1wiS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRURcIl0gPSAxXSA9IFwiS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRURcIjtcbiAgICBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW0dldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbXCJLRVlTVE9SRV9TVEFUVVNfSU5JVElBTElaRURcIl0gPSAyXSA9IFwiS0VZU1RPUkVfU1RBVFVTX0lOSVRJQUxJWkVEXCI7XG4gICAgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c1tHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMgfHwgKEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJLRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19VTlNQRUNJRklFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRURcIjpcbiAgICAgICAgICAgIHJldHVybiBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19VTklOSVRJQUxJWkVEO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJLRVlTVE9SRV9TVEFUVVNfSU5JVElBTElaRURcIjpcbiAgICAgICAgICAgIHJldHVybiBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRDtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cy5LRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJLRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19VTklOSVRJQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRURcIjtcbiAgICAgICAgY2FzZSBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRDpcbiAgICAgICAgICAgIHJldHVybiBcIktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRFwiO1xuICAgICAgICBjYXNlIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmFzZUtleXN0b3JlRXJyb3IoKSB7XG4gICAgcmV0dXJuIHsgbWVzc2FnZTogXCJcIiwgY29kZTogMCB9O1xufVxuZXhwb3J0IGNvbnN0IEtleXN0b3JlRXJyb3IgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS5jb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUtleXN0b3JlRXJyb3IoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzU2V0KG9iamVjdC5tZXNzYWdlKSA/IFN0cmluZyhvYmplY3QubWVzc2FnZSkgOiBcIlwiLFxuICAgICAgICAgICAgY29kZTogaXNTZXQob2JqZWN0LmNvZGUpID8gZXJyb3JDb2RlRnJvbUpTT04ob2JqZWN0LmNvZGUpIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJiAob2JqLm1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBtZXNzYWdlLmNvZGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNvZGUgPSBlcnJvckNvZGVUb0pTT04obWVzc2FnZS5jb2RlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VLZXlzdG9yZUVycm9yKCk7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IChfYSA9IG9iamVjdC5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvZGUgPSAoX2IgPSBvYmplY3QuY29kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjcnlwdFYxUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBEZWNyeXB0VjFSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0VjFSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKERlY3J5cHRWMVJlcXVlc3RfUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlcXVlc3RzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlcXVlc3RzLm1hcCgoZSkgPT4gRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IG1lc3NhZ2UucmVxdWVzdHMubWFwKChlKSA9PiBlID8gRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0VjFSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdHMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXF1ZXN0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcGVlcktleXM6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGlzU2VuZGVyOiBmYWxzZSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IERlY3J5cHRWMVJlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENpcGhlcnRleHQuZW5jb2RlKG1lc3NhZ2UucGF5bG9hZCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wZWVyS2V5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2UucGVlcktleXMsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc1NlbmRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikuYm9vbChtZXNzYWdlLmlzU2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMVJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBlZXJLZXlzID0gUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNTZW5kZXIgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwZWVyS2V5czogaXNTZXQob2JqZWN0LnBlZXJLZXlzKVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5wZWVyS2V5cylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzOiBpc1NldChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGlzU2VuZGVyOiBpc1NldChvYmplY3QuaXNTZW5kZXIpID8gQm9vbGVhbihvYmplY3QuaXNTZW5kZXIpIDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5wZWVyS2V5cyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBlZXJLZXlzID0gbWVzc2FnZS5wZWVyS2V5c1xuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnBlZXJLZXlzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlckJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5oZWFkZXJCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmlzU2VuZGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5pc1NlbmRlciA9IG1lc3NhZ2UuaXNTZW5kZXIpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9XG4gICAgICAgICAgICBvYmplY3QucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXlsb2FkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBlZXJLZXlzID1cbiAgICAgICAgICAgIG9iamVjdC5wZWVyS2V5cyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wZWVyS2V5cyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5wZWVyS2V5cylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYSA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5pc1NlbmRlciA9IChfYiA9IG9iamVjdC5pc1NlbmRlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURlY3J5cHRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3BvbnNlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVzcG9uc2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlc3BvbnNlcy5tYXAoKGUpID0+IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IG1lc3NhZ2UucmVzcG9uc2VzLm1hcCgoZSkgPT4gZSA/IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlc3BvbnNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3VsdDogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5lbmNvZGUobWVzc2FnZS5yZXN1bHQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgS2V5c3RvcmVFcnJvci5lbmNvZGUobWVzc2FnZS5lcnJvciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRSZXNwb25zZV9SZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gS2V5c3RvcmVFcnJvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGlzU2V0KG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgPyBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5mcm9tSlNPTihvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXJyb3I6IGlzU2V0KG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IuZnJvbUpTT04ob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVzdWx0ID0gbWVzc2FnZS5yZXN1bHRcbiAgICAgICAgICAgICAgICA/IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLnRvSlNPTihtZXNzYWdlLnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lcnJvciA9IG1lc3NhZ2UuZXJyb3JcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IudG9KU09OKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ID1cbiAgICAgICAgICAgIG9iamVjdC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzdWx0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5mcm9tUGFydGlhbChvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmVycm9yID1cbiAgICAgICAgICAgIG9iamVjdC5lcnJvciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lcnJvciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tUGFydGlhbChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCkge1xuICAgIHJldHVybiB7IGRlY3J5cHRlZDogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlY3J5cHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZGVjcnlwdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWNyeXB0ZWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVjcnlwdGVkOiBpc1NldChvYmplY3QuZGVjcnlwdGVkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kZWNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVjcnlwdGVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVjcnlwdGVkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZGVjcnlwdGVkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRlY3J5cHRlZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKTtcbiAgICAgICAgbWVzc2FnZS5kZWNyeXB0ZWQgPSAoX2EgPSBvYmplY3QuZGVjcnlwdGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNyeXB0VjJSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IERlY3J5cHRWMlJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIERlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMlJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goRGVjcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMlJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgY29udGVudFRvcGljOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFYyUmVxdWVzdF9SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5wYXlsb2FkLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlYWRlckJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udGVudFRvcGljICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFYyUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gQ2lwaGVydGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWRcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQudG9KU09OKG1lc3NhZ2UucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oZWFkZXJCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaGVhZGVyQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID1cbiAgICAgICAgICAgIG9iamVjdC5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBheWxvYWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSAoX2EgPSBvYmplY3QuaGVhZGVyQnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gKF9iID0gb2JqZWN0LmNvbnRlbnRUb3BpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFYxUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0VjFSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKEVuY3J5cHRWMVJlcXVlc3RfUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlcXVlc3RzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlcXVlc3RzLm1hcCgoZSkgPT4gRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IG1lc3NhZ2UucmVxdWVzdHMubWFwKChlKSA9PiBlID8gRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdHMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXF1ZXN0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlY2lwaWVudDogdW5kZWZpbmVkLFxuICAgICAgICBwYXlsb2FkOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBoZWFkZXJCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRWMVJlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnJlY2lwaWVudCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgPSBQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlY2lwaWVudDogaXNTZXQob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjaXBpZW50ID0gbWVzc2FnZS5yZWNpcGllbnRcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVhZGVyQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmhlYWRlckJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgPVxuICAgICAgICAgICAgb2JqZWN0LnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZWNpcGllbnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYiA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcy5wdXNoKEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdFJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB1bmRlZmluZWQsIGVycm9yOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmVuY29kZShtZXNzYWdlLnJlc3VsdCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBLZXlzdG9yZUVycm9yLmVuY29kZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBLZXlzdG9yZUVycm9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogaXNTZXQob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA/IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21KU09OKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tSlNPTihvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXN1bHQgPSBtZXNzYWdlLnJlc3VsdFxuICAgICAgICAgICAgICAgID8gRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MudG9KU09OKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci50b0pTT04obWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgPVxuICAgICAgICAgICAgb2JqZWN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXN1bHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21QYXJ0aWFsKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmVycm9yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVycm9yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21QYXJ0aWFsKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHsgZW5jcnlwdGVkOiB1bmRlZmluZWQsIHNlbmRlckhtYWM6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5lbmNyeXB0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5lbmNyeXB0ZWQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVySG1hYy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uuc2VuZGVySG1hYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5jcnlwdGVkID0gQ2lwaGVydGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNyeXB0ZWQ6IGlzU2V0KG9iamVjdC5lbmNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5lbmNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZW5kZXJIbWFjOiBpc1NldChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lbmNyeXB0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lbmNyeXB0ZWQgPSBtZXNzYWdlLmVuY3J5cHRlZFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5lbmNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXJIbWFjID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uuc2VuZGVySG1hYyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5zZW5kZXJIbWFjIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICBtZXNzYWdlLmVuY3J5cHRlZCA9XG4gICAgICAgICAgICBvYmplY3QuZW5jcnlwdGVkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVuY3J5cHRlZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tUGFydGlhbChvYmplY3QuZW5jcnlwdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgPSAoX2EgPSBvYmplY3Quc2VuZGVySG1hYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFYyUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0VjJSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjJSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKEVuY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlcXVlc3RzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlcXVlc3RzLm1hcCgoZSkgPT4gRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IG1lc3NhZ2UucmVxdWVzdHMubWFwKChlKSA9PiBlID8gRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjJSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdHMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXF1ZXN0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGhlYWRlckJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjb250ZW50VG9waWM6IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50VG9waWMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzOiBpc1NldChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogaXNTZXQob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVhZGVyQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmhlYWRlckJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGVudFRvcGljID0gbWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMlJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYiA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAoX2MgPSBvYmplY3QuY29udGVudFRvcGljKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgcmVxdWVzdHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgU2VsZkVuY3J5cHRSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdHMucHVzaChTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlcXVlc3RzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlcXVlc3RzLm1hcCgoZSkgPT4gU2VsZkVuY3J5cHRSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdC50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdHMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXF1ZXN0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gU2VsZkVuY3J5cHRSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBwYXlsb2FkOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgU2VsZkVuY3J5cHRSZXF1ZXN0X1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gKF9hID0gb2JqZWN0LnBheWxvYWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzcG9uc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbGZFbmNyeXB0UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzLnB1c2goU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IG1lc3NhZ2UucmVzcG9uc2VzLm1hcCgoZSkgPT4gZSA/IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB1bmRlZmluZWQsIGVycm9yOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZW5jb2RlKG1lc3NhZ2UucmVzdWx0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEtleXN0b3JlRXJyb3IuZW5jb2RlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gS2V5c3RvcmVFcnJvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGlzU2V0KG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgPyBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbUpTT04ob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlc3VsdCA9IG1lc3NhZ2UucmVzdWx0XG4gICAgICAgICAgICAgICAgPyBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MudG9KU09OKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci50b0pTT04obWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ID1cbiAgICAgICAgICAgIG9iamVjdC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzdWx0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbVBhcnRpYWwob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5lcnJvciA9XG4gICAgICAgICAgICBvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IuZnJvbVBhcnRpYWwob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHsgZW5jcnlwdGVkOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVuY3J5cHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZW5jcnlwdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5jcnlwdGVkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRlZDogaXNTZXQob2JqZWN0LmVuY3J5cHRlZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZW5jcnlwdGVkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmVuY3J5cHRlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVuY3J5cHRlZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmVuY3J5cHRlZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5lbmNyeXB0ZWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICBtZXNzYWdlLmVuY3J5cHRlZCA9IChfYSA9IG9iamVjdC5lbmNyeXB0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZEZWNyeXB0UmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRGVjcnlwdFJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkRlY3J5cHRSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBTZWxmRGVjcnlwdFJlcXVlc3RfUmVxdWVzdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBtZXNzYWdlLnJlcXVlc3RzLm1hcCgoZSkgPT4gZSA/IFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRGVjcnlwdFJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTZWxmRGVjcnlwdFJlcXVlc3RfUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRGVjcnlwdFJlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRGVjcnlwdFJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgaWRlbnRpZmllcjogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IEdldFByaXZhdGVQcmVmZXJlbmNlc1RvcGljSWRlbnRpZmllclJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aWZpZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aWZpZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGlzU2V0KG9iamVjdC5pZGVudGlmaWVyKSA/IFN0cmluZyhvYmplY3QuaWRlbnRpZmllcikgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpZmllciAhPT0gdW5kZWZpbmVkICYmIChvYmouaWRlbnRpZmllciA9IG1lc3NhZ2UuaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldFByaXZhdGVQcmVmZXJlbmNlc1RvcGljSWRlbnRpZmllclJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpZmllciA9IChfYSA9IG9iamVjdC5pZGVudGlmaWVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDcmVhdGVJbnZpdGVSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVjaXBpZW50OiB1bmRlZmluZWQsXG4gICAgICAgIGNyZWF0ZWROczogTG9uZy5VWkVSTyxcbiAgICAgICAgY29uc2VudFByb29mOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBDcmVhdGVJbnZpdGVSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW52aXRhdGlvblYxX0NvbnRleHQuZW5jb2RlKG1lc3NhZ2UuY29udGV4dCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnJlY2lwaWVudCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnNlbnRQcm9vZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb25zZW50UHJvb2ZQYXlsb2FkLmVuY29kZShtZXNzYWdlLmNvbnNlbnRQcm9vZiwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNyZWF0ZUludml0ZVJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRleHQgPSBJbnZpdGF0aW9uVjFfQ29udGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ID0gU2lnbmVkUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2YgPSBDb25zZW50UHJvb2ZQYXlsb2FkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGlzU2V0KG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0NvbnRleHQuZnJvbUpTT04ob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWNpcGllbnQ6IGlzU2V0KG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgY29uc2VudFByb29mOiBpc1NldChvYmplY3QuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC5mcm9tSlNPTihvYmplY3QuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRleHQgPSBtZXNzYWdlLmNvbnRleHRcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LnRvSlNPTihtZXNzYWdlLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlY2lwaWVudCA9IG1lc3NhZ2UucmVjaXBpZW50XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2UucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuY29uc2VudFByb29mICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29uc2VudFByb29mID0gbWVzc2FnZS5jb25zZW50UHJvb2ZcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQudG9KU09OKG1lc3NhZ2UuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNyZWF0ZUludml0ZVJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9XG4gICAgICAgICAgICBvYmplY3QucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlY2lwaWVudCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2YgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnNlbnRQcm9vZiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb25zZW50UHJvb2YgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQuZnJvbVBhcnRpYWwob2JqZWN0LmNvbnNlbnRQcm9vZilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ3JlYXRlSW52aXRlUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgY29udmVyc2F0aW9uOiB1bmRlZmluZWQsIHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBDcmVhdGVJbnZpdGVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ29udmVyc2F0aW9uUmVmZXJlbmNlLmVuY29kZShtZXNzYWdlLmNvbnZlcnNhdGlvbiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNyZWF0ZUludml0ZVJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPSBDb252ZXJzYXRpb25SZWZlcmVuY2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2F0aW9uOiBpc1NldChvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21KU09OKG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb252ZXJzYXRpb24gPSBtZXNzYWdlLmNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLnRvSlNPTihtZXNzYWdlLmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnBheWxvYWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNyZWF0ZUludml0ZVJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uID1cbiAgICAgICAgICAgIG9iamVjdC5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udmVyc2F0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbVBhcnRpYWwob2JqZWN0LmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gKF9hID0gb2JqZWN0LnBheWxvYWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlSW52aXRlc1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBTYXZlSW52aXRlc1JlcXVlc3RfUmVxdWVzdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBtZXNzYWdlLnJlcXVlc3RzLm1hcCgoZSkgPT4gZSA/IFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTYXZlSW52aXRlc1JlcXVlc3RfUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnRUb3BpYzogXCJcIixcbiAgICAgICAgdGltZXN0YW1wTnM6IExvbmcuVVpFUk8sXG4gICAgICAgIHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlSW52aXRlc1JlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50VG9waWMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVzdGFtcE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXBOcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1JlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogaXNTZXQob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcE5zOiBpc1NldChvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGVudFRvcGljID0gbWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wTnMgPSAobWVzc2FnZS50aW1lc3RhbXBOcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gKF9hID0gb2JqZWN0LmNvbnRlbnRUb3BpYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYiA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlSW52aXRlc1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcy5wdXNoKFNhdmVJbnZpdGVzUmVzcG9uc2VfUmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3BvbnNlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVzcG9uc2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlc3BvbnNlcy5tYXAoKGUpID0+IFNhdmVJbnZpdGVzUmVzcG9uc2VfUmVzcG9uc2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBtZXNzYWdlLnJlc3BvbnNlcy5tYXAoKGUpID0+IGUgPyBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlc3BvbnNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3VsdDogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmVuY29kZShtZXNzYWdlLnJlc3VsdCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBLZXlzdG9yZUVycm9yLmVuY29kZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEtleXN0b3JlRXJyb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBpc1NldChvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgID8gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21KU09OKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tSlNPTihvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXN1bHQgPSBtZXNzYWdlLnJlc3VsdFxuICAgICAgICAgICAgICAgID8gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLnRvSlNPTihtZXNzYWdlLnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lcnJvciA9IG1lc3NhZ2UuZXJyb3JcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IudG9KU09OKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3VsdCA9XG4gICAgICAgICAgICBvYmplY3QucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlc3VsdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21QYXJ0aWFsKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmVycm9yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVycm9yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21QYXJ0aWFsKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCkge1xuICAgIHJldHVybiB7IGNvbnZlcnNhdGlvbjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb252ZXJzYXRpb25SZWZlcmVuY2UuZW5jb2RlKG1lc3NhZ2UuY29udmVyc2F0aW9uLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPSBDb252ZXJzYXRpb25SZWZlcmVuY2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2F0aW9uOiBpc1NldChvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21KU09OKG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb252ZXJzYXRpb24gPSBtZXNzYWdlLmNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLnRvSlNPTihtZXNzYWdlLmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb252ZXJzYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tUGFydGlhbChvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDcmVhdGVBdXRoVG9rZW5SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHRpbWVzdGFtcE5zOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBDcmVhdGVBdXRoVG9rZW5SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UudGltZXN0YW1wTnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlQXV0aFRva2VuUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcE5zOiBpc1NldChvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcE5zID0gKG1lc3NhZ2UudGltZXN0YW1wTnMgfHwgdW5kZWZpbmVkKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNyZWF0ZUF1dGhUb2tlblJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2F2ZVYxQ29udmVyc2F0aW9uc1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgY29udmVyc2F0aW9uczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlVjFDb252ZXJzYXRpb25zUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICBDb252ZXJzYXRpb25SZWZlcmVuY2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlVjFDb252ZXJzYXRpb25zUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9ucy5wdXNoKENvbnZlcnNhdGlvblJlZmVyZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2F0aW9uczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuY29udmVyc2F0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5jb252ZXJzYXRpb25zLm1hcCgoZSkgPT4gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udmVyc2F0aW9ucykge1xuICAgICAgICAgICAgb2JqLmNvbnZlcnNhdGlvbnMgPSBtZXNzYWdlLmNvbnZlcnNhdGlvbnMubWFwKChlKSA9PiBlID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouY29udmVyc2F0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVWMUNvbnZlcnNhdGlvbnNSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9ucyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LmNvbnZlcnNhdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNhdmVWMUNvbnZlcnNhdGlvbnNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnQgY29uc3QgU2F2ZVYxQ29udmVyc2F0aW9uc1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZVYxQ29udmVyc2F0aW9uc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHRvSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwoXykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVWMUNvbnZlcnNhdGlvbnNSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25zUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgY29udmVyc2F0aW9uczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRDb252ZXJzYXRpb25zUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuY29udmVyc2F0aW9ucykge1xuICAgICAgICAgICAgQ29udmVyc2F0aW9uUmVmZXJlbmNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25zLnB1c2goQ29udmVyc2F0aW9uUmVmZXJlbmNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb25zOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5jb252ZXJzYXRpb25zKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmNvbnZlcnNhdGlvbnMubWFwKChlKSA9PiBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICBvYmouY29udmVyc2F0aW9ucyA9IG1lc3NhZ2UuY29udmVyc2F0aW9ucy5tYXAoKGUpID0+IGUgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5jb252ZXJzYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uc1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9ucyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LmNvbnZlcnNhdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldEtleXN0b3JlU3RhdHVzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyB3YWxsZXRBZGRyZXNzOiBcIlwiIH07XG59XG5leHBvcnQgY29uc3QgR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLndhbGxldEFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLndhbGxldEFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3YWxsZXRBZGRyZXNzOiBpc1NldChvYmplY3Qud2FsbGV0QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Qud2FsbGV0QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoud2FsbGV0QWRkcmVzcyA9IG1lc3NhZ2Uud2FsbGV0QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEtleXN0b3JlU3RhdHVzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLndhbGxldEFkZHJlc3MgPSAoX2EgPSBvYmplY3Qud2FsbGV0QWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IDAgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGF0dXMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBpc1NldChvYmplY3Quc3RhdHVzKVxuICAgICAgICAgICAgICAgID8gZ2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c0Zyb21KU09OKG9iamVjdC5zdGF0dXMpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3RhdHVzID0gZ2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c1RvSlNPTihtZXNzYWdlLnN0YXR1cykpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzID0gKF9hID0gb2JqZWN0LnN0YXR1cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW5pdEtleXN0b3JlUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgSW5pdEtleXN0b3JlUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQcml2YXRlS2V5QnVuZGxlVjEuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbml0S2V5c3RvcmVSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFByaXZhdGVLZXlCdW5kbGVWMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IFByaXZhdGVLZXlCdW5kbGVWMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBQcml2YXRlS2V5QnVuZGxlVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluaXRLZXlzdG9yZVJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXlCdW5kbGVWMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUluaXRLZXlzdG9yZVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IGVycm9yOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBJbml0S2V5c3RvcmVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBLZXlzdG9yZUVycm9yLmVuY29kZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5pdEtleXN0b3JlUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gS2V5c3RvcmVFcnJvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tSlNPTihvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci50b0pTT04obWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbml0S2V5c3RvcmVSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmVycm9yID1cbiAgICAgICAgICAgIG9iamVjdC5lcnJvciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lcnJvciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tUGFydGlhbChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25EaWdlc3RSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpZ2VzdDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaWRlbnRpdHlLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJla2V5SW5kZXg6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25EaWdlc3RSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRpZ2VzdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2UuaWRlbnRpdHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByZWtleUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQzMihtZXNzYWdlLnByZWtleUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25EaWdlc3RSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaWdlc3QgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWtleUluZGV4ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWdlc3Q6IGlzU2V0KG9iamVjdC5kaWdlc3QpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBpZGVudGl0eUtleTogaXNTZXQob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgID8gQm9vbGVhbihvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVrZXlJbmRleDogaXNTZXQob2JqZWN0LnByZWtleUluZGV4KVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKG9iamVjdC5wcmVrZXlJbmRleClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRpZ2VzdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRpZ2VzdCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRpZ2VzdCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kaWdlc3QgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZGVudGl0eUtleSA9IG1lc3NhZ2UuaWRlbnRpdHlLZXkpO1xuICAgICAgICBtZXNzYWdlLnByZWtleUluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJla2V5SW5kZXggPSBNYXRoLnJvdW5kKG1lc3NhZ2UucHJla2V5SW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduRGlnZXN0UmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmRpZ2VzdCA9IChfYSA9IG9iamVjdC5kaWdlc3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSAoX2IgPSBvYmplY3QuaWRlbnRpdHlLZXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wcmVrZXlJbmRleCA9IChfYyA9IG9iamVjdC5wcmVrZXlJbmRleCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRSZWZyZXNoSm9iUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBqb2JUeXBlOiAwIH07XG59XG5leHBvcnQgY29uc3QgR2V0UmVmcmVzaEpvYlJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuam9iVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLmpvYlR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0UmVmcmVzaEpvYlJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmpvYlR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgam9iVHlwZTogaXNTZXQob2JqZWN0LmpvYlR5cGUpID8gam9iVHlwZUZyb21KU09OKG9iamVjdC5qb2JUeXBlKSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5qb2JUeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouam9iVHlwZSA9IGpvYlR5cGVUb0pTT04obWVzc2FnZS5qb2JUeXBlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldFJlZnJlc2hKb2JSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2Uuam9iVHlwZSA9IChfYSA9IG9iamVjdC5qb2JUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRSZWZyZXNoSm9iUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgbGFzdFJ1bk5zOiBMb25nLlpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRSZWZyZXNoSm9iUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmxhc3RSdW5Ocy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQ2NChtZXNzYWdlLmxhc3RSdW5Ocyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRSZWZyZXNoSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxhc3RSdW5OcyA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXN0UnVuTnM6IGlzU2V0KG9iamVjdC5sYXN0UnVuTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QubGFzdFJ1bk5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5aRVJPLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubGFzdFJ1bk5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubGFzdFJ1bk5zID0gKG1lc3NhZ2UubGFzdFJ1bk5zIHx8IExvbmcuWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRSZWZyZXNoSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5sYXN0UnVuTnMgPVxuICAgICAgICAgICAgb2JqZWN0Lmxhc3RSdW5OcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5sYXN0UnVuTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5sYXN0UnVuTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNldFJlZmVzaEpvYlJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgam9iVHlwZTogMCwgbGFzdFJ1bk5zOiBMb25nLlpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBTZXRSZWZlc2hKb2JSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmpvYlR5cGUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS5qb2JUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UubGFzdFJ1bk5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQ2NChtZXNzYWdlLmxhc3RSdW5Ocyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZXRSZWZlc2hKb2JSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5qb2JUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sYXN0UnVuTnMgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgam9iVHlwZTogaXNTZXQob2JqZWN0LmpvYlR5cGUpID8gam9iVHlwZUZyb21KU09OKG9iamVjdC5qb2JUeXBlKSA6IDAsXG4gICAgICAgICAgICBsYXN0UnVuTnM6IGlzU2V0KG9iamVjdC5sYXN0UnVuTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QubGFzdFJ1bk5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5aRVJPLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuam9iVHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmpvYlR5cGUgPSBqb2JUeXBlVG9KU09OKG1lc3NhZ2Uuam9iVHlwZSkpO1xuICAgICAgICBtZXNzYWdlLmxhc3RSdW5OcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmxhc3RSdW5OcyA9IChtZXNzYWdlLmxhc3RSdW5OcyB8fCBMb25nLlpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZXRSZWZlc2hKb2JSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2Uuam9iVHlwZSA9IChfYSA9IG9iamVjdC5qb2JUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLmxhc3RSdW5OcyA9XG4gICAgICAgICAgICBvYmplY3QubGFzdFJ1bk5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmxhc3RSdW5OcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0Lmxhc3RSdW5OcylcbiAgICAgICAgICAgICAgICA6IExvbmcuWkVSTztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2V0UmVmcmVzaEpvYlJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydCBjb25zdCBTZXRSZWZyZXNoSm9iUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZXRSZWZyZXNoSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2V0UmVmcmVzaEpvYlJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVRvcGljTWFwKCkge1xuICAgIHJldHVybiB7IHRvcGljczoge30gfTtcbn1cbmV4cG9ydCBjb25zdCBUb3BpY01hcCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLnRvcGljcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBUb3BpY01hcF9Ub3BpY3NFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9waWNNYXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeTEgPSBUb3BpY01hcF9Ub3BpY3NFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkxLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9waWNzW2VudHJ5MS5rZXldID0gZW50cnkxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcGljczogaXNPYmplY3Qob2JqZWN0LnRvcGljcylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC50b3BpY3MpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBUb3BpY01hcF9Ub3BpY0RhdGEuZnJvbUpTT04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLnRvcGljcyA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50b3BpY3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UudG9waWNzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBvYmoudG9waWNzW2tdID0gVG9waWNNYXBfVG9waWNEYXRhLnRvSlNPTih2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRvcGljTWFwKCk7XG4gICAgICAgIG1lc3NhZ2UudG9waWNzID0gT2JqZWN0LmVudHJpZXMoKF9hID0gb2JqZWN0LnRvcGljcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBUb3BpY01hcF9Ub3BpY0RhdGEuZnJvbVBhcnRpYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUb3BpY01hcF9Ub3BpY0RhdGEoKSB7XG4gICAgcmV0dXJuIHsgY3JlYXRlZE5zOiBMb25nLlVaRVJPLCBwZWVyQWRkcmVzczogXCJcIiwgaW52aXRhdGlvbjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgVG9waWNNYXBfVG9waWNEYXRhID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wZWVyQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UucGVlckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmludml0YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW52aXRhdGlvblYxLmVuY29kZShtZXNzYWdlLmludml0YXRpb24sIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb3BpY01hcF9Ub3BpY0RhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBlZXJBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW52aXRhdGlvbiA9IEludml0YXRpb25WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkTnM6IGlzU2V0KG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBpc1NldChvYmplY3QucGVlckFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5wZWVyQWRkcmVzcykgOiBcIlwiLFxuICAgICAgICAgICAgaW52aXRhdGlvbjogaXNTZXQob2JqZWN0Lmludml0YXRpb24pXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjEuZnJvbUpTT04ob2JqZWN0Lmludml0YXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UucGVlckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wZWVyQWRkcmVzcyA9IG1lc3NhZ2UucGVlckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmludml0YXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnZpdGF0aW9uID0gbWVzc2FnZS5pbnZpdGF0aW9uXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjEudG9KU09OKG1lc3NhZ2UuaW52aXRhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljRGF0YSgpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZWROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UucGVlckFkZHJlc3MgPSAoX2EgPSBvYmplY3QucGVlckFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaW52aXRhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QuaW52aXRhdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pbnZpdGF0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjEuZnJvbVBhcnRpYWwob2JqZWN0Lmludml0YXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljc0VudHJ5KCkge1xuICAgIHJldHVybiB7IGtleTogXCJcIiwgdmFsdWU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFRvcGljTWFwX1RvcGljc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBUb3BpY01hcF9Ub3BpY0RhdGEuZW5jb2RlKG1lc3NhZ2UudmFsdWUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb3BpY01hcF9Ub3BpY3NFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBUb3BpY01hcF9Ub3BpY0RhdGEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IFN0cmluZyhvYmplY3Qua2V5KSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gVG9waWNNYXBfVG9waWNEYXRhLmZyb21KU09OKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsdWUgPSBtZXNzYWdlLnZhbHVlXG4gICAgICAgICAgICAgICAgPyBUb3BpY01hcF9Ub3BpY0RhdGEudG9KU09OKG1lc3NhZ2UudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb3BpY01hcF9Ub3BpY3NFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBUb3BpY01hcF9Ub3BpY0RhdGEuZnJvbVBhcnRpYWwob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgdG9waWNzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50b3BpY3MpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9waWNzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9waWNzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC50b3BpY3MpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudG9waWNzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9waWNzKSB7XG4gICAgICAgICAgICBvYmoudG9waWNzID0gbWVzc2FnZS50b3BpY3MubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50b3BpY3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS50b3BpY3MgPSAoKF9hID0gb2JqZWN0LnRvcGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IGhtYWNLZXlzOiB7fSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5obWFjS2V5cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzRW50cnkuZW5jb2RlKHsga2V5OiBrZXksIHZhbHVlIH0sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeTEgPSBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5MS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhtYWNLZXlzW2VudHJ5MS5rZXldID0gZW50cnkxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhtYWNLZXlzOiBpc09iamVjdChvYmplY3QuaG1hY0tleXMpXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyhvYmplY3QuaG1hY0tleXMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLmZyb21KU09OKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG9iai5obWFjS2V5cyA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5obWFjS2V5cykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5obWFjS2V5cykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqLmhtYWNLZXlzW2tdID0gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy50b0pTT04odik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuaG1hY0tleXMgPSBPYmplY3QuZW50cmllcygoX2EgPSBvYmplY3QuaG1hY0tleXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy5mcm9tUGFydGlhbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEoKSB7XG4gICAgcmV0dXJuIHsgdGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2g6IDAsIGhtYWNLZXk6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhtYWNLZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmhtYWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2ggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhtYWNLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2g6IGlzU2V0KG9iamVjdC50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaClcbiAgICAgICAgICAgICAgICA/IE51bWJlcihvYmplY3QudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2gpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaG1hY0tleTogaXNTZXQob2JqZWN0LmhtYWNLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmhtYWNLZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCA9IE1hdGgucm91bmQobWVzc2FnZS50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCkpO1xuICAgICAgICBtZXNzYWdlLmhtYWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5obWFjS2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaG1hY0tleSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5obWFjS2V5IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YSgpO1xuICAgICAgICBtZXNzYWdlLnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoID0gKF9hID0gb2JqZWN0LnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLmhtYWNLZXkgPSAoX2IgPSBvYmplY3QuaG1hY0tleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cygpIHtcbiAgICByZXR1cm4geyB2YWx1ZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS52YWx1ZXMpIHtcbiAgICAgICAgICAgIEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaChHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnZhbHVlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC52YWx1ZXMubWFwKChlKSA9PiBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzKSB7XG4gICAgICAgICAgICBvYmoudmFsdWVzID0gbWVzc2FnZS52YWx1ZXMubWFwKChlKSA9PiBlID8gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnZhbHVlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMoKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC52YWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5c0VudHJ5KCkge1xuICAgIHJldHVybiB7IGtleTogXCJcIiwgdmFsdWU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXNFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy5lbmNvZGUobWVzc2FnZS52YWx1ZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXNFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA/IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMuZnJvbUpTT04ob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgJiYgKG9iai5rZXkgPSBtZXNzYWdlLmtleSk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWVcbiAgICAgICAgICAgICAgICA/IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMudG9KU09OKG1lc3NhZ2UudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2EgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID1cbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52YWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy5mcm9tUGFydGlhbChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5c3RvcmUucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthData: () => (/* binding */ AuthData),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../message_contents/signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_api.v1\";\nfunction createBaseToken() {\n    return {\n        identityKey: undefined,\n        authDataBytes: new Uint8Array(),\n        authDataSignature: undefined,\n    };\n}\nconst Token = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.authDataBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authDataBytes);\n        }\n        if (message.authDataSignature !== undefined) {\n            _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.encode(message.authDataSignature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseToken();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.authDataBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.authDataSignature = _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromJSON(object.identityKey)\n                : undefined,\n            authDataBytes: isSet(object.authDataBytes)\n                ? bytesFromBase64(object.authDataBytes)\n                : new Uint8Array(),\n            authDataSignature: isSet(object.authDataSignature)\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromJSON(object.authDataSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.authDataBytes !== undefined &&\n            (obj.authDataBytes = base64FromBytes(message.authDataBytes !== undefined\n                ? message.authDataBytes\n                : new Uint8Array()));\n        message.authDataSignature !== undefined &&\n            (obj.authDataSignature = message.authDataSignature\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.toJSON(message.authDataSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseToken();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.authDataBytes = (_a = object.authDataBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authDataSignature =\n            object.authDataSignature !== undefined &&\n                object.authDataSignature !== null\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromPartial(object.authDataSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAuthData() {\n    return { walletAddr: \"\", createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst AuthData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.walletAddr !== \"\") {\n            writer.uint32(10).string(message.walletAddr);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(16).uint64(message.createdNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAuthData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddr = reader.string();\n                    break;\n                case 2:\n                    message.createdNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddr: isSet(object.walletAddr) ? String(object.walletAddr) : \"\",\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletAddr !== undefined && (obj.walletAddr = message.walletAddr);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAuthData();\n        message.walletAddr = (_a = object.walletAddr) !== null && _a !== void 0 ? _a : \"\";\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=authn.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfYXBpL3YxL2F1dGhuLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDeUM7QUFDRDtBQUMzQjtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLHNFQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFTO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0VBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxRUFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxRUFBUztBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNFQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsMkJBQTJCLDRDQUFJO0FBQzVDO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBSTtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfYXBpL3YxL2F1dGhuLnBiLmpzPzdlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9wdWJsaWNfa2V5LnBiXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9zaWduYXR1cmUucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2FwaS52MVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVRva2VuKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aXR5S2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGF1dGhEYXRhQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGF1dGhEYXRhU2lnbmF0dXJlOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBUb2tlbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXV0aERhdGFCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuYXV0aERhdGFCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXV0aERhdGFTaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID0gUHVibGljS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRoRGF0YUJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRoRGF0YVNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZGVudGl0eUtleTogaXNTZXQob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LmZyb21KU09OKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF1dGhEYXRhQnl0ZXM6IGlzU2V0KG9iamVjdC5hdXRoRGF0YUJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5hdXRoRGF0YUJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGF1dGhEYXRhU2lnbmF0dXJlOiBpc1NldChvYmplY3QuYXV0aERhdGFTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LmF1dGhEYXRhU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZGVudGl0eUtleSA9IG1lc3NhZ2UuaWRlbnRpdHlLZXlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS50b0pTT04obWVzc2FnZS5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aERhdGFCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmF1dGhEYXRhQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5hdXRoRGF0YUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuYXV0aERhdGFCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYXV0aERhdGFTaWduYXR1cmUgPSBtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2UuYXV0aERhdGFTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbigpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5hdXRoRGF0YUJ5dGVzID0gKF9hID0gb2JqZWN0LmF1dGhEYXRhQnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aERhdGFTaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LmF1dGhEYXRhU2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuYXV0aERhdGFTaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3QuYXV0aERhdGFTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUF1dGhEYXRhKCkge1xuICAgIHJldHVybiB7IHdhbGxldEFkZHI6IFwiXCIsIGNyZWF0ZWROczogTG9uZy5VWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IEF1dGhEYXRhID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLndhbGxldEFkZHIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLndhbGxldEFkZHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLmNyZWF0ZWROcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBdXRoRGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0QWRkcjogaXNTZXQob2JqZWN0LndhbGxldEFkZHIpID8gU3RyaW5nKG9iamVjdC53YWxsZXRBZGRyKSA6IFwiXCIsXG4gICAgICAgICAgICBjcmVhdGVkTnM6IGlzU2V0KG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLndhbGxldEFkZHIgIT09IHVuZGVmaW5lZCAmJiAob2JqLndhbGxldEFkZHIgPSBtZXNzYWdlLndhbGxldEFkZHIpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQXV0aERhdGEoKTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyID0gKF9hID0gb2JqZWN0LndhbGxldEFkZHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRobi5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageApi: () => (/* binding */ MessageApi),\n/* harmony export */   SortDirection: () => (/* binding */ SortDirection)\n/* harmony export */ });\n/* harmony import */ var _fetch_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../fetch.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\");\n/* eslint-disable */\n// @ts-nocheck\n/*\n* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY\n*/\n\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection[\"SORT_DIRECTION_UNSPECIFIED\"] = \"SORT_DIRECTION_UNSPECIFIED\";\n    SortDirection[\"SORT_DIRECTION_ASCENDING\"] = \"SORT_DIRECTION_ASCENDING\";\n    SortDirection[\"SORT_DIRECTION_DESCENDING\"] = \"SORT_DIRECTION_DESCENDING\";\n})(SortDirection || (SortDirection = {}));\nclass MessageApi {\n    static Publish(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/publish`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static Subscribe(req, entityNotifier, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchStreamingRequest(`/message/v1/subscribe`, entityNotifier, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static SubscribeAll(req, entityNotifier, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchStreamingRequest(`/message/v1/subscribe-all`, entityNotifier, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static Query(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/query`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static BatchQuery(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/batch-query`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n}\n//# sourceMappingURL=message_api.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfYXBpL3YxL21lc3NhZ2VfYXBpLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ2hDO0FBQ1A7QUFDQSxlQUFlLCtDQUFXLHNEQUFzRCxjQUFjLDBDQUEwQywrQ0FBVyxHQUFHO0FBQ3RKO0FBQ0E7QUFDQSxlQUFlLDREQUF3Qix3RUFBd0UsY0FBYywwQ0FBMEMsK0NBQVcsR0FBRztBQUNyTDtBQUNBO0FBQ0EsZUFBZSw0REFBd0IsNEVBQTRFLGNBQWMsMENBQTBDLCtDQUFXLEdBQUc7QUFDekw7QUFDQTtBQUNBLGVBQWUsK0NBQVcsb0RBQW9ELGNBQWMsMENBQTBDLCtDQUFXLEdBQUc7QUFDcEo7QUFDQTtBQUNBLGVBQWUsK0NBQVcsMERBQTBELGNBQWMsMENBQTBDLCtDQUFXLEdBQUc7QUFDMUo7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfYXBpL3YxL21lc3NhZ2VfYXBpLnBiLmpzPzFiZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vKlxuKiBUaGlzIGZpbGUgaXMgYSBnZW5lcmF0ZWQgVHlwZXNjcmlwdCBmaWxlIGZvciBHUlBDIEdhdGV3YXksIERPIE5PVCBNT0RJRllcbiovXG5pbXBvcnQgKiBhcyBmbSBmcm9tIFwiLi4vLi4vZmV0Y2gucGJcIjtcbmV4cG9ydCB2YXIgU29ydERpcmVjdGlvbjtcbihmdW5jdGlvbiAoU29ydERpcmVjdGlvbikge1xuICAgIFNvcnREaXJlY3Rpb25bXCJTT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiU09SVF9ESVJFQ1RJT05fVU5TUEVDSUZJRURcIjtcbiAgICBTb3J0RGlyZWN0aW9uW1wiU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HXCJdID0gXCJTT1JUX0RJUkVDVElPTl9BU0NFTkRJTkdcIjtcbiAgICBTb3J0RGlyZWN0aW9uW1wiU09SVF9ESVJFQ1RJT05fREVTQ0VORElOR1wiXSA9IFwiU09SVF9ESVJFQ1RJT05fREVTQ0VORElOR1wiO1xufSkoU29ydERpcmVjdGlvbiB8fCAoU29ydERpcmVjdGlvbiA9IHt9KSk7XG5leHBvcnQgY2xhc3MgTWVzc2FnZUFwaSB7XG4gICAgc3RhdGljIFB1Ymxpc2gocmVxLCBpbml0UmVxKSB7XG4gICAgICAgIHJldHVybiBmbS5mZXRjaFJlcShgL21lc3NhZ2UvdjEvcHVibGlzaGAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFJlcSksIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxLCBmbS5yZXBsYWNlcikgfSkpO1xuICAgIH1cbiAgICBzdGF0aWMgU3Vic2NyaWJlKHJlcSwgZW50aXR5Tm90aWZpZXIsIGluaXRSZXEpIHtcbiAgICAgICAgcmV0dXJuIGZtLmZldGNoU3RyZWFtaW5nUmVxdWVzdChgL21lc3NhZ2UvdjEvc3Vic2NyaWJlYCwgZW50aXR5Tm90aWZpZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFJlcSksIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxLCBmbS5yZXBsYWNlcikgfSkpO1xuICAgIH1cbiAgICBzdGF0aWMgU3Vic2NyaWJlQWxsKHJlcSwgZW50aXR5Tm90aWZpZXIsIGluaXRSZXEpIHtcbiAgICAgICAgcmV0dXJuIGZtLmZldGNoU3RyZWFtaW5nUmVxdWVzdChgL21lc3NhZ2UvdjEvc3Vic2NyaWJlLWFsbGAsIGVudGl0eU5vdGlmaWVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRSZXEpLCB7IG1ldGhvZDogXCJQT1NUXCIsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcSwgZm0ucmVwbGFjZXIpIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIFF1ZXJ5KHJlcSwgaW5pdFJlcSkge1xuICAgICAgICByZXR1cm4gZm0uZmV0Y2hSZXEoYC9tZXNzYWdlL3YxL3F1ZXJ5YCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0UmVxKSwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBKU09OLnN0cmluZ2lmeShyZXEsIGZtLnJlcGxhY2VyKSB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBCYXRjaFF1ZXJ5KHJlcSwgaW5pdFJlcSkge1xuICAgICAgICByZXR1cm4gZm0uZmV0Y2hSZXEoYC9tZXNzYWdlL3YxL2JhdGNoLXF1ZXJ5YCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0UmVxKSwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBKU09OLnN0cmluZ2lmeShyZXEsIGZtLnJlcGxhY2VyKSB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZV9hcGkucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ciphertext: () => (/* binding */ Ciphertext),\n/* harmony export */   Ciphertext_Aes256gcmHkdfsha256: () => (/* binding */ Ciphertext_Aes256gcmHkdfsha256),\n/* harmony export */   SignedEciesCiphertext: () => (/* binding */ SignedEciesCiphertext),\n/* harmony export */   SignedEciesCiphertext_Ecies: () => (/* binding */ SignedEciesCiphertext_Ecies),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseCiphertext() {\n    return { aes256GcmHkdfSha256: undefined };\n}\nconst Ciphertext = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.aes256GcmHkdfSha256 !== undefined) {\n            Ciphertext_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCiphertext();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.aes256GcmHkdfSha256 = Ciphertext_Aes256gcmHkdfsha256.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256)\n                ? Ciphertext_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.aes256GcmHkdfSha256 !== undefined &&\n            (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256\n                ? Ciphertext_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCiphertext();\n        message.aes256GcmHkdfSha256 =\n            object.aes256GcmHkdfSha256 !== undefined &&\n                object.aes256GcmHkdfSha256 !== null\n                ? Ciphertext_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCiphertext_Aes256gcmHkdfsha256() {\n    return {\n        hkdfSalt: new Uint8Array(),\n        gcmNonce: new Uint8Array(),\n        payload: new Uint8Array(),\n    };\n}\nconst Ciphertext_Aes256gcmHkdfsha256 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.hkdfSalt.length !== 0) {\n            writer.uint32(10).bytes(message.hkdfSalt);\n        }\n        if (message.gcmNonce.length !== 0) {\n            writer.uint32(18).bytes(message.gcmNonce);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(26).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCiphertext_Aes256gcmHkdfsha256();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hkdfSalt = reader.bytes();\n                    break;\n                case 2:\n                    message.gcmNonce = reader.bytes();\n                    break;\n                case 3:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hkdfSalt: isSet(object.hkdfSalt)\n                ? bytesFromBase64(object.hkdfSalt)\n                : new Uint8Array(),\n            gcmNonce: isSet(object.gcmNonce)\n                ? bytesFromBase64(object.gcmNonce)\n                : new Uint8Array(),\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hkdfSalt !== undefined &&\n            (obj.hkdfSalt = base64FromBytes(message.hkdfSalt !== undefined ? message.hkdfSalt : new Uint8Array()));\n        message.gcmNonce !== undefined &&\n            (obj.gcmNonce = base64FromBytes(message.gcmNonce !== undefined ? message.gcmNonce : new Uint8Array()));\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseCiphertext_Aes256gcmHkdfsha256();\n        message.hkdfSalt = (_a = object.hkdfSalt) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.gcmNonce = (_b = object.gcmNonce) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.payload = (_c = object.payload) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignedEciesCiphertext() {\n    return { eciesBytes: new Uint8Array(), signature: undefined };\n}\nconst SignedEciesCiphertext = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.eciesBytes.length !== 0) {\n            writer.uint32(10).bytes(message.eciesBytes);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedEciesCiphertext();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eciesBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            eciesBytes: isSet(object.eciesBytes)\n                ? bytesFromBase64(object.eciesBytes)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.eciesBytes !== undefined &&\n            (obj.eciesBytes = base64FromBytes(message.eciesBytes !== undefined ? message.eciesBytes : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedEciesCiphertext();\n        message.eciesBytes = (_a = object.eciesBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedEciesCiphertext_Ecies() {\n    return {\n        ephemeralPublicKey: new Uint8Array(),\n        iv: new Uint8Array(),\n        mac: new Uint8Array(),\n        ciphertext: new Uint8Array(),\n    };\n}\nconst SignedEciesCiphertext_Ecies = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.ephemeralPublicKey.length !== 0) {\n            writer.uint32(10).bytes(message.ephemeralPublicKey);\n        }\n        if (message.iv.length !== 0) {\n            writer.uint32(18).bytes(message.iv);\n        }\n        if (message.mac.length !== 0) {\n            writer.uint32(26).bytes(message.mac);\n        }\n        if (message.ciphertext.length !== 0) {\n            writer.uint32(34).bytes(message.ciphertext);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedEciesCiphertext_Ecies();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ephemeralPublicKey = reader.bytes();\n                    break;\n                case 2:\n                    message.iv = reader.bytes();\n                    break;\n                case 3:\n                    message.mac = reader.bytes();\n                    break;\n                case 4:\n                    message.ciphertext = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ephemeralPublicKey: isSet(object.ephemeralPublicKey)\n                ? bytesFromBase64(object.ephemeralPublicKey)\n                : new Uint8Array(),\n            iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(),\n            mac: isSet(object.mac) ? bytesFromBase64(object.mac) : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? bytesFromBase64(object.ciphertext)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ephemeralPublicKey !== undefined &&\n            (obj.ephemeralPublicKey = base64FromBytes(message.ephemeralPublicKey !== undefined\n                ? message.ephemeralPublicKey\n                : new Uint8Array()));\n        message.iv !== undefined &&\n            (obj.iv = base64FromBytes(message.iv !== undefined ? message.iv : new Uint8Array()));\n        message.mac !== undefined &&\n            (obj.mac = base64FromBytes(message.mac !== undefined ? message.mac : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = base64FromBytes(message.ciphertext !== undefined ? message.ciphertext : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseSignedEciesCiphertext_Ecies();\n        message.ephemeralPublicKey = (_a = object.ephemeralPublicKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.iv = (_b = object.iv) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.mac = (_c = object.mac) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.ciphertext = (_d = object.ciphertext) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=ciphertext.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY2lwaGVydGV4dC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNtQjtBQUNOO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVM7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY2lwaGVydGV4dC5wYi5qcz8zZDk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNpcGhlcnRleHQoKSB7XG4gICAgcmV0dXJuIHsgYWVzMjU2R2NtSGtkZlNoYTI1NjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgQ2lwaGVydGV4dCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5lbmNvZGUobWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2lwaGVydGV4dCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NiA9IENpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZXMyNTZHY21Ia2RmU2hhMjU2OiBpc1NldChvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5mcm9tSlNPTihvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZXMyNTZHY21Ia2RmU2hhMjU2ID0gbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2XG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYudG9KU09OKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDaXBoZXJ0ZXh0KCk7XG4gICAgICAgIG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NiA9XG4gICAgICAgICAgICBvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5mcm9tUGFydGlhbChvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ2lwaGVydGV4dF9BZXMyNTZnY21Ia2Rmc2hhMjU2KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhrZGZTYWx0OiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBnY21Ob25jZTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IENpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1NiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5oa2RmU2FsdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGtkZlNhbHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdjbU5vbmNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5nY21Ob25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhrZGZTYWx0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nY21Ob25jZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoa2RmU2FsdDogaXNTZXQob2JqZWN0LmhrZGZTYWx0KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oa2RmU2FsdClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBnY21Ob25jZTogaXNTZXQob2JqZWN0LmdjbU5vbmNlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5nY21Ob25jZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5oa2RmU2FsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhrZGZTYWx0ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGtkZlNhbHQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuaGtkZlNhbHQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuZ2NtTm9uY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5nY21Ob25jZSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmdjbU5vbmNlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmdjbU5vbmNlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1NigpO1xuICAgICAgICBtZXNzYWdlLmhrZGZTYWx0ID0gKF9hID0gb2JqZWN0LmhrZGZTYWx0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmdjbU5vbmNlID0gKF9iID0gb2JqZWN0LmdjbU5vbmNlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2MgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0KCkge1xuICAgIHJldHVybiB7IGVjaWVzQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVjaWVzQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmVjaWVzQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lY2llc0J5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWNpZXNCeXRlczogaXNTZXQob2JqZWN0LmVjaWVzQnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmVjaWVzQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lY2llc0J5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZWNpZXNCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmVjaWVzQnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZWNpZXNCeXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEVjaWVzQ2lwaGVydGV4dCgpO1xuICAgICAgICBtZXNzYWdlLmVjaWVzQnl0ZXMgPSAoX2EgPSBvYmplY3QuZWNpZXNCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZWRFY2llc0NpcGhlcnRleHRfRWNpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXBoZW1lcmFsUHVibGljS2V5OiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBpdjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgbWFjOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjaXBoZXJ0ZXh0OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0X0VjaWVzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVwaGVtZXJhbFB1YmxpY0tleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pdi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1hYy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UubWFjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jaXBoZXJ0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEVjaWVzQ2lwaGVydGV4dF9FY2llcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pdiA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFjID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVwaGVtZXJhbFB1YmxpY0tleTogaXNTZXQob2JqZWN0LmVwaGVtZXJhbFB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZXBoZW1lcmFsUHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGl2OiBpc1NldChvYmplY3QuaXYpID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5pdikgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgbWFjOiBpc1NldChvYmplY3QubWFjKSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QubWFjKSA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBpc1NldChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lcGhlbWVyYWxQdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lcGhlbWVyYWxQdWJsaWNLZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5lcGhlbWVyYWxQdWJsaWNLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5lcGhlbWVyYWxQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5pdiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLml2ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaXYgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuaXYgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UubWFjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWFjID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UubWFjICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLm1hYyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2lwaGVydGV4dCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuY2lwaGVydGV4dCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0X0VjaWVzKCk7XG4gICAgICAgIG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5ID0gKF9hID0gb2JqZWN0LmVwaGVtZXJhbFB1YmxpY0tleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5pdiA9IChfYiA9IG9iamVjdC5pdikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5tYWMgPSAoX2MgPSBvYmplY3QubWFjKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgPSAoX2QgPSBvYmplY3QuY2lwaGVydGV4dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaXBoZXJ0ZXh0LnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   Composite_Part: () => (/* binding */ Composite_Part),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _content_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseComposite() {\n    return { parts: [] };\n}\nconst Composite = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.parts) {\n            Composite_Part.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComposite();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.parts.push(Composite_Part.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            parts: Array.isArray(object === null || object === void 0 ? void 0 : object.parts)\n                ? object.parts.map((e) => Composite_Part.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.parts) {\n            obj.parts = message.parts.map((e) => e ? Composite_Part.toJSON(e) : undefined);\n        }\n        else {\n            obj.parts = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseComposite();\n        message.parts =\n            ((_a = object.parts) === null || _a === void 0 ? void 0 : _a.map((e) => Composite_Part.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseComposite_Part() {\n    return { part: undefined, composite: undefined };\n}\nconst Composite_Part = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.part !== undefined) {\n            _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.encode(message.part, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.composite !== undefined) {\n            Composite.encode(message.composite, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComposite_Part();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.part = _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.composite = Composite.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            part: isSet(object.part)\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.fromJSON(object.part)\n                : undefined,\n            composite: isSet(object.composite)\n                ? Composite.fromJSON(object.composite)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.part !== undefined &&\n            (obj.part = message.part\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.toJSON(message.part)\n                : undefined);\n        message.composite !== undefined &&\n            (obj.composite = message.composite\n                ? Composite.toJSON(message.composite)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseComposite_Part();\n        message.part =\n            object.part !== undefined && object.part !== null\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.fromPartial(object.part)\n                : undefined;\n        message.composite =\n            object.composite !== undefined && object.composite !== null\n                ? Composite.fromPartial(object.composite)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=composite.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29tcG9zaXRlLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNzQjtBQUNUO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSx1REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL2NvbXBvc2l0ZS5wYi5qcz83ODA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgRW5jb2RlZENvbnRlbnQgfSBmcm9tIFwiLi9jb250ZW50LnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbXBvc2l0ZSgpIHtcbiAgICByZXR1cm4geyBwYXJ0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBDb21wb3NpdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZV9QYXJ0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcG9zaXRlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKENvbXBvc2l0ZV9QYXJ0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucGFydHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucGFydHMubWFwKChlKSA9PiBDb21wb3NpdGVfUGFydC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRzKSB7XG4gICAgICAgICAgICBvYmoucGFydHMgPSBtZXNzYWdlLnBhcnRzLm1hcCgoZSkgPT4gZSA/IENvbXBvc2l0ZV9QYXJ0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucGFydHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb21wb3NpdGUoKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnBhcnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBDb21wb3NpdGVfUGFydC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb21wb3NpdGVfUGFydCgpIHtcbiAgICByZXR1cm4geyBwYXJ0OiB1bmRlZmluZWQsIGNvbXBvc2l0ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgQ29tcG9zaXRlX1BhcnQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBFbmNvZGVkQ29udGVudC5lbmNvZGUobWVzc2FnZS5wYXJ0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbXBvc2l0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb21wb3NpdGUuZW5jb2RlKG1lc3NhZ2UuY29tcG9zaXRlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcG9zaXRlX1BhcnQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnQgPSBFbmNvZGVkQ29udGVudC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tcG9zaXRlID0gQ29tcG9zaXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnQ6IGlzU2V0KG9iamVjdC5wYXJ0KVxuICAgICAgICAgICAgICAgID8gRW5jb2RlZENvbnRlbnQuZnJvbUpTT04ob2JqZWN0LnBhcnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb21wb3NpdGU6IGlzU2V0KG9iamVjdC5jb21wb3NpdGUpXG4gICAgICAgICAgICAgICAgPyBDb21wb3NpdGUuZnJvbUpTT04ob2JqZWN0LmNvbXBvc2l0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBhcnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXJ0ID0gbWVzc2FnZS5wYXJ0XG4gICAgICAgICAgICAgICAgPyBFbmNvZGVkQ29udGVudC50b0pTT04obWVzc2FnZS5wYXJ0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jb21wb3NpdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wb3NpdGUgPSBtZXNzYWdlLmNvbXBvc2l0ZVxuICAgICAgICAgICAgICAgID8gQ29tcG9zaXRlLnRvSlNPTihtZXNzYWdlLmNvbXBvc2l0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb21wb3NpdGVfUGFydCgpO1xuICAgICAgICBtZXNzYWdlLnBhcnQgPVxuICAgICAgICAgICAgb2JqZWN0LnBhcnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFydCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gRW5jb2RlZENvbnRlbnQuZnJvbVBhcnRpYWwob2JqZWN0LnBhcnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29tcG9zaXRlID1cbiAgICAgICAgICAgIG9iamVjdC5jb21wb3NpdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29tcG9zaXRlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb21wb3NpdGUuZnJvbVBhcnRpYWwob2JqZWN0LmNvbXBvc2l0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NpdGUucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactBundle: () => (/* binding */ ContactBundle),\n/* harmony export */   ContactBundleV1: () => (/* binding */ ContactBundleV1),\n/* harmony export */   ContactBundleV2: () => (/* binding */ ContactBundleV2),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseContactBundleV1() {\n    return { keyBundle: undefined };\n}\nconst ContactBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.keyBundle, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBundle: isSet(object.keyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.keyBundle)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBundle !== undefined &&\n            (obj.keyBundle = message.keyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.keyBundle)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundleV1();\n        message.keyBundle =\n            object.keyBundle !== undefined && object.keyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.keyBundle)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContactBundleV2() {\n    return { keyBundle: undefined };\n}\nconst ContactBundleV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.keyBundle, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundleV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBundle: isSet(object.keyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.keyBundle)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBundle !== undefined &&\n            (obj.keyBundle = message.keyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.keyBundle)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundleV2();\n        message.keyBundle =\n            object.keyBundle !== undefined && object.keyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.keyBundle)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContactBundle() {\n    return { v1: undefined, v2: undefined };\n}\nconst ContactBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            ContactBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            ContactBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = ContactBundleV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = ContactBundleV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? ContactBundleV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? ContactBundleV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? ContactBundleV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? ContactBundleV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? ContactBundleV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? ContactBundleV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=contact.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29udGFjdC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2lEO0FBQ3BDO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBLFlBQVksMkRBQWU7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyREFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSxpRUFBcUI7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpRUFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFxQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFxQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFxQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb250YWN0LnBiLmpzP2Y1YmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBQdWJsaWNLZXlCdW5kbGUsIFNpZ25lZFB1YmxpY0tleUJ1bmRsZSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29udGFjdEJ1bmRsZVYxKCkge1xuICAgIHJldHVybiB7IGtleUJ1bmRsZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgQ29udGFjdEJ1bmRsZVYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2Uua2V5QnVuZGxlLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGFjdEJ1bmRsZVYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgPSBQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5QnVuZGxlOiBpc1NldChvYmplY3Qua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5rZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXlCdW5kbGUgPSBtZXNzYWdlLmtleUJ1bmRsZVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLmtleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlVjEoKTtcbiAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgPVxuICAgICAgICAgICAgb2JqZWN0LmtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5rZXlCdW5kbGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3Qua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlVjIoKSB7XG4gICAgcmV0dXJuIHsga2V5QnVuZGxlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBDb250YWN0QnVuZGxlVjIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5QnVuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5lbmNvZGUobWVzc2FnZS5rZXlCdW5kbGUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlVjIoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleUJ1bmRsZSA9IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlCdW5kbGU6IGlzU2V0KG9iamVjdC5rZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LmtleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleUJ1bmRsZSA9IG1lc3NhZ2Uua2V5QnVuZGxlXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2Uua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGVWMigpO1xuICAgICAgICBtZXNzYWdlLmtleUJ1bmRsZSA9XG4gICAgICAgICAgICBvYmplY3Qua2V5QnVuZGxlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmtleUJ1bmRsZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5rZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGUoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCwgdjI6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IENvbnRhY3RCdW5kbGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ29udGFjdEJ1bmRsZVYxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnRhY3RCdW5kbGVWMi5lbmNvZGUobWVzc2FnZS52Miwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gQ29udGFjdEJ1bmRsZVYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MiA9IENvbnRhY3RCdW5kbGVWMi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IENvbnRhY3RCdW5kbGVWMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdjI6IGlzU2V0KG9iamVjdC52MikgPyBDb250YWN0QnVuZGxlVjIuZnJvbUpTT04ob2JqZWN0LnYyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxID8gQ29udGFjdEJ1bmRsZVYxLnRvSlNPTihtZXNzYWdlLnYxKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudjIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MiA9IG1lc3NhZ2UudjIgPyBDb250YWN0QnVuZGxlVjIudG9KU09OKG1lc3NhZ2UudjIpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGUoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnRhY3RCdW5kbGVWMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudjIgPVxuICAgICAgICAgICAgb2JqZWN0LnYyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb250YWN0QnVuZGxlVjIuZnJvbVBhcnRpYWwob2JqZWN0LnYyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhY3QucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compression: () => (/* binding */ Compression),\n/* harmony export */   ContentTypeId: () => (/* binding */ ContentTypeId),\n/* harmony export */   EncodedContent: () => (/* binding */ EncodedContent),\n/* harmony export */   EncodedContent_ParametersEntry: () => (/* binding */ EncodedContent_ParametersEntry),\n/* harmony export */   SignedContent: () => (/* binding */ SignedContent),\n/* harmony export */   compressionFromJSON: () => (/* binding */ compressionFromJSON),\n/* harmony export */   compressionToJSON: () => (/* binding */ compressionToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\n/** Message content encoding structures */\n/**\n * Recognized compression algorithms\n * protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH\n */\nvar Compression;\n(function (Compression) {\n    Compression[Compression[\"COMPRESSION_DEFLATE\"] = 0] = \"COMPRESSION_DEFLATE\";\n    Compression[Compression[\"COMPRESSION_GZIP\"] = 1] = \"COMPRESSION_GZIP\";\n    Compression[Compression[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Compression || (Compression = {}));\nfunction compressionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"COMPRESSION_DEFLATE\":\n            return Compression.COMPRESSION_DEFLATE;\n        case 1:\n        case \"COMPRESSION_GZIP\":\n            return Compression.COMPRESSION_GZIP;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Compression.UNRECOGNIZED;\n    }\n}\nfunction compressionToJSON(object) {\n    switch (object) {\n        case Compression.COMPRESSION_DEFLATE:\n            return \"COMPRESSION_DEFLATE\";\n        case Compression.COMPRESSION_GZIP:\n            return \"COMPRESSION_GZIP\";\n        case Compression.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseContentTypeId() {\n    return { authorityId: \"\", typeId: \"\", versionMajor: 0, versionMinor: 0 };\n}\nconst ContentTypeId = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.authorityId !== \"\") {\n            writer.uint32(10).string(message.authorityId);\n        }\n        if (message.typeId !== \"\") {\n            writer.uint32(18).string(message.typeId);\n        }\n        if (message.versionMajor !== 0) {\n            writer.uint32(24).uint32(message.versionMajor);\n        }\n        if (message.versionMinor !== 0) {\n            writer.uint32(32).uint32(message.versionMinor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContentTypeId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authorityId = reader.string();\n                    break;\n                case 2:\n                    message.typeId = reader.string();\n                    break;\n                case 3:\n                    message.versionMajor = reader.uint32();\n                    break;\n                case 4:\n                    message.versionMinor = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            authorityId: isSet(object.authorityId) ? String(object.authorityId) : \"\",\n            typeId: isSet(object.typeId) ? String(object.typeId) : \"\",\n            versionMajor: isSet(object.versionMajor)\n                ? Number(object.versionMajor)\n                : 0,\n            versionMinor: isSet(object.versionMinor)\n                ? Number(object.versionMinor)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authorityId !== undefined &&\n            (obj.authorityId = message.authorityId);\n        message.typeId !== undefined && (obj.typeId = message.typeId);\n        message.versionMajor !== undefined &&\n            (obj.versionMajor = Math.round(message.versionMajor));\n        message.versionMinor !== undefined &&\n            (obj.versionMinor = Math.round(message.versionMinor));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseContentTypeId();\n        message.authorityId = (_a = object.authorityId) !== null && _a !== void 0 ? _a : \"\";\n        message.typeId = (_b = object.typeId) !== null && _b !== void 0 ? _b : \"\";\n        message.versionMajor = (_c = object.versionMajor) !== null && _c !== void 0 ? _c : 0;\n        message.versionMinor = (_d = object.versionMinor) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBaseEncodedContent() {\n    return {\n        type: undefined,\n        parameters: {},\n        fallback: undefined,\n        compression: undefined,\n        content: new Uint8Array(),\n    };\n}\nconst EncodedContent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.type !== undefined) {\n            ContentTypeId.encode(message.type, writer.uint32(10).fork()).ldelim();\n        }\n        Object.entries(message.parameters).forEach(([key, value]) => {\n            EncodedContent_ParametersEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\n        });\n        if (message.fallback !== undefined) {\n            writer.uint32(26).string(message.fallback);\n        }\n        if (message.compression !== undefined) {\n            writer.uint32(40).int32(message.compression);\n        }\n        if (message.content.length !== 0) {\n            writer.uint32(34).bytes(message.content);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = ContentTypeId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    const entry2 = EncodedContent_ParametersEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.parameters[entry2.key] = entry2.value;\n                    }\n                    break;\n                case 3:\n                    message.fallback = reader.string();\n                    break;\n                case 5:\n                    message.compression = reader.int32();\n                    break;\n                case 4:\n                    message.content = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type)\n                ? ContentTypeId.fromJSON(object.type)\n                : undefined,\n            parameters: isObject(object.parameters)\n                ? Object.entries(object.parameters).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n            fallback: isSet(object.fallback) ? String(object.fallback) : undefined,\n            compression: isSet(object.compression)\n                ? compressionFromJSON(object.compression)\n                : undefined,\n            content: isSet(object.content)\n                ? bytesFromBase64(object.content)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined &&\n            (obj.type = message.type\n                ? ContentTypeId.toJSON(message.type)\n                : undefined);\n        obj.parameters = {};\n        if (message.parameters) {\n            Object.entries(message.parameters).forEach(([k, v]) => {\n                obj.parameters[k] = v;\n            });\n        }\n        message.fallback !== undefined && (obj.fallback = message.fallback);\n        message.compression !== undefined &&\n            (obj.compression =\n                message.compression !== undefined\n                    ? compressionToJSON(message.compression)\n                    : undefined);\n        message.content !== undefined &&\n            (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseEncodedContent();\n        message.type =\n            object.type !== undefined && object.type !== null\n                ? ContentTypeId.fromPartial(object.type)\n                : undefined;\n        message.parameters = Object.entries((_a = object.parameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        message.fallback = (_b = object.fallback) !== null && _b !== void 0 ? _b : undefined;\n        message.compression = (_c = object.compression) !== null && _c !== void 0 ? _c : undefined;\n        message.content = (_d = object.content) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncodedContent_ParametersEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst EncodedContent_ParametersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent_ParametersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEncodedContent_ParametersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSignedContent() {\n    return { payload: new Uint8Array(), sender: undefined, signature: undefined };\n}\nconst SignedContent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.sender, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.encode(message.signature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedContent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedContent();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=content.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29udGVudC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDZ0M7QUFDYjtBQUNOO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUM1QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb250ZW50LnBiLmpzPzEwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduZWRQdWJsaWNLZXlCdW5kbGUgfSBmcm9tIFwiLi9wdWJsaWNfa2V5LnBiXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG4vKiogTWVzc2FnZSBjb250ZW50IGVuY29kaW5nIHN0cnVjdHVyZXMgKi9cbi8qKlxuICogUmVjb2duaXplZCBjb21wcmVzc2lvbiBhbGdvcml0aG1zXG4gKiBwcm90b2xpbnQ6ZGlzYWJsZSBFTlVNX0ZJRUxEX05BTUVTX1pFUk9fVkFMVUVfRU5EX1dJVEhcbiAqL1xuZXhwb3J0IHZhciBDb21wcmVzc2lvbjtcbihmdW5jdGlvbiAoQ29tcHJlc3Npb24pIHtcbiAgICBDb21wcmVzc2lvbltDb21wcmVzc2lvbltcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIl0gPSAwXSA9IFwiQ09NUFJFU1NJT05fREVGTEFURVwiO1xuICAgIENvbXByZXNzaW9uW0NvbXByZXNzaW9uW1wiQ09NUFJFU1NJT05fR1pJUFwiXSA9IDFdID0gXCJDT01QUkVTU0lPTl9HWklQXCI7XG4gICAgQ29tcHJlc3Npb25bQ29tcHJlc3Npb25bXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQ29tcHJlc3Npb24gfHwgKENvbXByZXNzaW9uID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzc2lvbkZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIjpcbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2lvbi5DT01QUkVTU0lPTl9ERUZMQVRFO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJDT01QUkVTU0lPTl9HWklQXCI6XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fR1pJUDtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENvbXByZXNzaW9uLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Npb25Ub0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBDb21wcmVzc2lvbi5DT01QUkVTU0lPTl9ERUZMQVRFOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ09NUFJFU1NJT05fREVGTEFURVwiO1xuICAgICAgICBjYXNlIENvbXByZXNzaW9uLkNPTVBSRVNTSU9OX0daSVA6XG4gICAgICAgICAgICByZXR1cm4gXCJDT01QUkVTU0lPTl9HWklQXCI7XG4gICAgICAgIGNhc2UgQ29tcHJlc3Npb24uVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbnRlbnRUeXBlSWQoKSB7XG4gICAgcmV0dXJuIHsgYXV0aG9yaXR5SWQ6IFwiXCIsIHR5cGVJZDogXCJcIiwgdmVyc2lvbk1ham9yOiAwLCB2ZXJzaW9uTWlub3I6IDAgfTtcbn1cbmV4cG9ydCBjb25zdCBDb250ZW50VHlwZUlkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhvcml0eUlkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hdXRob3JpdHlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZUlkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS50eXBlSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb25NYWpvciAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDMyKG1lc3NhZ2UudmVyc2lvbk1ham9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uTWlub3IgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLnVpbnQzMihtZXNzYWdlLnZlcnNpb25NaW5vcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250ZW50VHlwZUlkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdXRob3JpdHlJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb25NYWpvciA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb25NaW5vciA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0aG9yaXR5SWQ6IGlzU2V0KG9iamVjdC5hdXRob3JpdHlJZCkgPyBTdHJpbmcob2JqZWN0LmF1dGhvcml0eUlkKSA6IFwiXCIsXG4gICAgICAgICAgICB0eXBlSWQ6IGlzU2V0KG9iamVjdC50eXBlSWQpID8gU3RyaW5nKG9iamVjdC50eXBlSWQpIDogXCJcIixcbiAgICAgICAgICAgIHZlcnNpb25NYWpvcjogaXNTZXQob2JqZWN0LnZlcnNpb25NYWpvcilcbiAgICAgICAgICAgICAgICA/IE51bWJlcihvYmplY3QudmVyc2lvbk1ham9yKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHZlcnNpb25NaW5vcjogaXNTZXQob2JqZWN0LnZlcnNpb25NaW5vcilcbiAgICAgICAgICAgICAgICA/IE51bWJlcihvYmplY3QudmVyc2lvbk1pbm9yKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml0eUlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYXV0aG9yaXR5SWQgPSBtZXNzYWdlLmF1dGhvcml0eUlkKTtcbiAgICAgICAgbWVzc2FnZS50eXBlSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnR5cGVJZCA9IG1lc3NhZ2UudHlwZUlkKTtcbiAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWFqb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52ZXJzaW9uTWFqb3IgPSBNYXRoLnJvdW5kKG1lc3NhZ2UudmVyc2lvbk1ham9yKSk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbk1pbm9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmVyc2lvbk1pbm9yID0gTWF0aC5yb3VuZChtZXNzYWdlLnZlcnNpb25NaW5vcikpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250ZW50VHlwZUlkKCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aG9yaXR5SWQgPSAoX2EgPSBvYmplY3QuYXV0aG9yaXR5SWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudHlwZUlkID0gKF9iID0gb2JqZWN0LnR5cGVJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWFqb3IgPSAoX2MgPSBvYmplY3QudmVyc2lvbk1ham9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb25NaW5vciA9IChfZCA9IG9iamVjdC52ZXJzaW9uTWlub3IpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1ldGVyczoge30sXG4gICAgICAgIGZhbGxiYWNrOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbXByZXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRlbnQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNvZGVkQ29udGVudCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnRlbnRUeXBlSWQuZW5jb2RlKG1lc3NhZ2UudHlwZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBhcmFtZXRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgRW5jb2RlZENvbnRlbnRfUGFyYW1ldGVyc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuZmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDApLmludDMyKG1lc3NhZ2UuY29tcHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyhtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jb2RlZENvbnRlbnQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBDb250ZW50VHlwZUlkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkyID0gRW5jb2RlZENvbnRlbnRfUGFyYW1ldGVyc0VudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeTIudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJhbWV0ZXJzW2VudHJ5Mi5rZXldID0gZW50cnkyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mYWxsYmFjayA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXByZXNzaW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGlzU2V0KG9iamVjdC50eXBlKVxuICAgICAgICAgICAgICAgID8gQ29udGVudFR5cGVJZC5mcm9tSlNPTihvYmplY3QudHlwZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGlzT2JqZWN0KG9iamVjdC5wYXJhbWV0ZXJzKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqZWN0LnBhcmFtZXRlcnMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBmYWxsYmFjazogaXNTZXQob2JqZWN0LmZhbGxiYWNrKSA/IFN0cmluZyhvYmplY3QuZmFsbGJhY2spIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGlzU2V0KG9iamVjdC5jb21wcmVzc2lvbilcbiAgICAgICAgICAgICAgICA/IGNvbXByZXNzaW9uRnJvbUpTT04ob2JqZWN0LmNvbXByZXNzaW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29udGVudDogaXNTZXQob2JqZWN0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnR5cGUgPSBtZXNzYWdlLnR5cGVcbiAgICAgICAgICAgICAgICA/IENvbnRlbnRUeXBlSWQudG9KU09OKG1lc3NhZ2UudHlwZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG9iai5wYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UucGFyYW1ldGVycykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqLnBhcmFtZXRlcnNba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5mYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIChvYmouZmFsbGJhY2sgPSBtZXNzYWdlLmZhbGxiYWNrKTtcbiAgICAgICAgbWVzc2FnZS5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbXByZXNzaW9uID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wcmVzc2lvblRvSlNPTihtZXNzYWdlLmNvbXByZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRlbnQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5jb250ZW50ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmNvbnRlbnQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50KCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9XG4gICAgICAgICAgICBvYmplY3QudHlwZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50eXBlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb250ZW50VHlwZUlkLmZyb21QYXJ0aWFsKG9iamVjdC50eXBlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBhcmFtZXRlcnMgPSBPYmplY3QuZW50cmllcygoX2EgPSBvYmplY3QucGFyYW1ldGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBtZXNzYWdlLmZhbGxiYWNrID0gKF9iID0gb2JqZWN0LmZhbGxiYWNrKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29tcHJlc3Npb24gPSAoX2MgPSBvYmplY3QuY29tcHJlc3Npb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gKF9kID0gb2JqZWN0LmNvbnRlbnQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6IFwiXCIsIHZhbHVlOiBcIlwiIH07XG59XG5leHBvcnQgY29uc3QgRW5jb2RlZENvbnRlbnRfUGFyYW1ldGVyc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jb2RlZENvbnRlbnRfUGFyYW1ldGVyc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IFN0cmluZyhvYmplY3Qua2V5KSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKSA/IFN0cmluZyhvYmplY3QudmFsdWUpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jb2RlZENvbnRlbnRfUGFyYW1ldGVyc0VudHJ5KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gKF9hID0gb2JqZWN0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9IChfYiA9IG9iamVjdC52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmVkQ29udGVudCgpIHtcbiAgICByZXR1cm4geyBwYXlsb2FkOiBuZXcgVWludDhBcnJheSgpLCBzZW5kZXI6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRDb250ZW50ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2Uuc2VuZGVyLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkQ29udGVudCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gU2lnbmVkUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgc2VuZGVyOiBpc1NldChvYmplY3Quc2VuZGVyKVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbmRlciA9IG1lc3NhZ2Uuc2VuZGVyXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2Uuc2VuZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZENvbnRlbnQoKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gKF9hID0gb2JqZWN0LnBheWxvYWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyID1cbiAgICAgICAgICAgIG9iamVjdC5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VuZGVyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRlbnQucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConversationReference: () => (/* binding */ ConversationReference),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _invitation_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invitation.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseConversationReference() {\n    return {\n        topic: \"\",\n        peerAddress: \"\",\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        context: undefined,\n        consentProofPayload: undefined,\n    };\n}\nconst ConversationReference = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.topic !== \"\") {\n            writer.uint32(10).string(message.topic);\n        }\n        if (message.peerAddress !== \"\") {\n            writer.uint32(18).string(message.peerAddress);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        if (message.context !== undefined) {\n            _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.encode(message.context, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.consentProofPayload !== undefined) {\n            _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.encode(message.consentProofPayload, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConversationReference();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topic = reader.string();\n                    break;\n                case 2:\n                    message.peerAddress = reader.string();\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 4:\n                    message.context = _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.consentProofPayload = _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : \"\",\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            context: isSet(object.context)\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            consentProofPayload: isSet(object.consentProofPayload)\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.fromJSON(object.consentProofPayload)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.topic !== undefined && (obj.topic = message.topic);\n        message.peerAddress !== undefined &&\n            (obj.peerAddress = message.peerAddress);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.consentProofPayload !== undefined &&\n            (obj.consentProofPayload = message.consentProofPayload\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.toJSON(message.consentProofPayload)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConversationReference();\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        message.peerAddress = (_b = object.peerAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.consentProofPayload =\n            object.consentProofPayload !== undefined &&\n                object.consentProofPayload !== null\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.fromPartial(object.consentProofPayload)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=conversation_reference.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29udmVyc2F0aW9uX3JlZmVyZW5jZS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNvRDtBQUN2QztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFvQjtBQUNoQztBQUNBO0FBQ0EsWUFBWSwrREFBbUI7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnRUFBb0I7QUFDMUQ7QUFDQTtBQUNBLGtEQUFrRCwrREFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQSxrQkFBa0IsZ0VBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBbUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQixnRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL2NvbnZlcnNhdGlvbl9yZWZlcmVuY2UucGIuanM/MzY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IEludml0YXRpb25WMV9Db250ZXh0LCBDb25zZW50UHJvb2ZQYXlsb2FkIH0gZnJvbSBcIi4vaW52aXRhdGlvbi5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb252ZXJzYXRpb25SZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9waWM6IFwiXCIsXG4gICAgICAgIHBlZXJBZGRyZXNzOiBcIlwiLFxuICAgICAgICBjcmVhdGVkTnM6IExvbmcuVVpFUk8sXG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29uc2VudFByb29mUGF5bG9hZDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgQ29udmVyc2F0aW9uUmVmZXJlbmNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50b3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnBlZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW52aXRhdGlvblYxX0NvbnRleHQuZW5jb2RlKG1lc3NhZ2UuY29udGV4dCwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb25zZW50UHJvb2ZQYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnNlbnRQcm9vZlBheWxvYWQuZW5jb2RlKG1lc3NhZ2UuY29uc2VudFByb29mUGF5bG9hZCwgd3JpdGVyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnZlcnNhdGlvblJlZmVyZW5jZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRleHQgPSBJbnZpdGF0aW9uVjFfQ29udGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29uc2VudFByb29mUGF5bG9hZCA9IENvbnNlbnRQcm9vZlBheWxvYWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9waWM6IGlzU2V0KG9iamVjdC50b3BpYykgPyBTdHJpbmcob2JqZWN0LnRvcGljKSA6IFwiXCIsXG4gICAgICAgICAgICBwZWVyQWRkcmVzczogaXNTZXQob2JqZWN0LnBlZXJBZGRyZXNzKSA/IFN0cmluZyhvYmplY3QucGVlckFkZHJlc3MpIDogXCJcIixcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgY29udGV4dDogaXNTZXQob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC5mcm9tSlNPTihvYmplY3QuY29udGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnNlbnRQcm9vZlBheWxvYWQ6IGlzU2V0KG9iamVjdC5jb25zZW50UHJvb2ZQYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC5mcm9tSlNPTihvYmplY3QuY29uc2VudFByb29mUGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRvcGljICE9PSB1bmRlZmluZWQgJiYgKG9iai50b3BpYyA9IG1lc3NhZ2UudG9waWMpO1xuICAgICAgICBtZXNzYWdlLnBlZXJBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGVlckFkZHJlc3MgPSBtZXNzYWdlLnBlZXJBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRleHQgPSBtZXNzYWdlLmNvbnRleHRcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LnRvSlNPTihtZXNzYWdlLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZlBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb25zZW50UHJvb2ZQYXlsb2FkID0gbWVzc2FnZS5jb25zZW50UHJvb2ZQYXlsb2FkXG4gICAgICAgICAgICAgICAgPyBDb25zZW50UHJvb2ZQYXlsb2FkLnRvSlNPTihtZXNzYWdlLmNvbnNlbnRQcm9vZlBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udmVyc2F0aW9uUmVmZXJlbmNlKCk7XG4gICAgICAgIG1lc3NhZ2UudG9waWMgPSAoX2EgPSBvYmplY3QudG9waWMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucGVlckFkZHJlc3MgPSAoX2IgPSBvYmplY3QucGVlckFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5jb250ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZlBheWxvYWQgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnNlbnRQcm9vZlBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5jb25zZW50UHJvb2ZQYXlsb2FkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb25zZW50UHJvb2ZQYXlsb2FkLmZyb21QYXJ0aWFsKG9iamVjdC5jb25zZW50UHJvb2ZQYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnNhdGlvbl9yZWZlcmVuY2UucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EciesMessage: () => (/* binding */ EciesMessage),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseEciesMessage() {\n    return { v1: undefined };\n}\nconst EciesMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            writer.uint32(10).bytes(message.v1);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEciesMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? bytesFromBase64(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 =\n                message.v1 !== undefined ? base64FromBytes(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEciesMessage();\n        message.v1 = (_a = object.v1) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=ecies.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvZWNpZXMucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNhO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9lY2llcy5wYi5qcz8wYTJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFY2llc01lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEVjaWVzTWVzc2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnYxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVjaWVzTWVzc2FnZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSkgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnYxKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCA/IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnYxKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVjaWVzTWVzc2FnZSgpO1xuICAgICAgICBtZXNzYWdlLnYxID0gKF9hID0gb2JqZWN0LnYxKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWNpZXMucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FrameAction: () => (/* binding */ FrameAction),\n/* harmony export */   FrameActionBody: () => (/* binding */ FrameActionBody),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseFrameActionBody() {\n    return {\n        frameUrl: \"\",\n        buttonIndex: 0,\n        timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        opaqueConversationIdentifier: \"\",\n        unixTimestamp: 0,\n        inputText: \"\",\n        state: \"\",\n        address: \"\",\n    };\n}\nconst FrameActionBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.frameUrl !== \"\") {\n            writer.uint32(10).string(message.frameUrl);\n        }\n        if (message.buttonIndex !== 0) {\n            writer.uint32(16).int32(message.buttonIndex);\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(24).uint64(message.timestamp);\n        }\n        if (message.opaqueConversationIdentifier !== \"\") {\n            writer.uint32(34).string(message.opaqueConversationIdentifier);\n        }\n        if (message.unixTimestamp !== 0) {\n            writer.uint32(40).uint32(message.unixTimestamp);\n        }\n        if (message.inputText !== \"\") {\n            writer.uint32(50).string(message.inputText);\n        }\n        if (message.state !== \"\") {\n            writer.uint32(58).string(message.state);\n        }\n        if (message.address !== \"\") {\n            writer.uint32(66).string(message.address);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFrameActionBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.frameUrl = reader.string();\n                    break;\n                case 2:\n                    message.buttonIndex = reader.int32();\n                    break;\n                case 3:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 4:\n                    message.opaqueConversationIdentifier = reader.string();\n                    break;\n                case 5:\n                    message.unixTimestamp = reader.uint32();\n                    break;\n                case 6:\n                    message.inputText = reader.string();\n                    break;\n                case 7:\n                    message.state = reader.string();\n                    break;\n                case 8:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            frameUrl: isSet(object.frameUrl) ? String(object.frameUrl) : \"\",\n            buttonIndex: isSet(object.buttonIndex) ? Number(object.buttonIndex) : 0,\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            opaqueConversationIdentifier: isSet(object.opaqueConversationIdentifier)\n                ? String(object.opaqueConversationIdentifier)\n                : \"\",\n            unixTimestamp: isSet(object.unixTimestamp)\n                ? Number(object.unixTimestamp)\n                : 0,\n            inputText: isSet(object.inputText) ? String(object.inputText) : \"\",\n            state: isSet(object.state) ? String(object.state) : \"\",\n            address: isSet(object.address) ? String(object.address) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.frameUrl !== undefined && (obj.frameUrl = message.frameUrl);\n        message.buttonIndex !== undefined &&\n            (obj.buttonIndex = Math.round(message.buttonIndex));\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.opaqueConversationIdentifier !== undefined &&\n            (obj.opaqueConversationIdentifier = message.opaqueConversationIdentifier);\n        message.unixTimestamp !== undefined &&\n            (obj.unixTimestamp = Math.round(message.unixTimestamp));\n        message.inputText !== undefined && (obj.inputText = message.inputText);\n        message.state !== undefined && (obj.state = message.state);\n        message.address !== undefined && (obj.address = message.address);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const message = createBaseFrameActionBody();\n        message.frameUrl = (_a = object.frameUrl) !== null && _a !== void 0 ? _a : \"\";\n        message.buttonIndex = (_b = object.buttonIndex) !== null && _b !== void 0 ? _b : 0;\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.opaqueConversationIdentifier =\n            (_c = object.opaqueConversationIdentifier) !== null && _c !== void 0 ? _c : \"\";\n        message.unixTimestamp = (_d = object.unixTimestamp) !== null && _d !== void 0 ? _d : 0;\n        message.inputText = (_e = object.inputText) !== null && _e !== void 0 ? _e : \"\";\n        message.state = (_f = object.state) !== null && _f !== void 0 ? _f : \"\";\n        message.address = (_g = object.address) !== null && _g !== void 0 ? _g : \"\";\n        return message;\n    },\n};\nfunction createBaseFrameAction() {\n    return {\n        signature: undefined,\n        signedPublicKeyBundle: undefined,\n        actionBody: new Uint8Array(),\n    };\n}\nconst FrameAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.signedPublicKeyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.encode(message.signedPublicKeyBundle, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.actionBody.length !== 0) {\n            writer.uint32(26).bytes(message.actionBody);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFrameAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signedPublicKeyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.actionBody = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n            signedPublicKeyBundle: isSet(object.signedPublicKeyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromJSON(object.signedPublicKeyBundle)\n                : undefined,\n            actionBody: isSet(object.actionBody)\n                ? bytesFromBase64(object.actionBody)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        message.signedPublicKeyBundle !== undefined &&\n            (obj.signedPublicKeyBundle = message.signedPublicKeyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.toJSON(message.signedPublicKeyBundle)\n                : undefined);\n        message.actionBody !== undefined &&\n            (obj.actionBody = base64FromBytes(message.actionBody !== undefined ? message.actionBody : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseFrameAction();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        message.signedPublicKeyBundle =\n            object.signedPublicKeyBundle !== undefined &&\n                object.signedPublicKeyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromPartial(object.signedPublicKeyBundle)\n                : undefined;\n        message.actionBody = (_a = object.actionBody) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=frames.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvZnJhbWVzLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDbUI7QUFDYTtBQUNuQjtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLG9EQUFTO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLGlFQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFTO0FBQ2pEO0FBQ0E7QUFDQSxvREFBb0QsaUVBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvZnJhbWVzLnBiLmpzPzRlY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUucGJcIjtcbmltcG9ydCB7IFNpZ25lZFB1YmxpY0tleUJ1bmRsZSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlRnJhbWVBY3Rpb25Cb2R5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyYW1lVXJsOiBcIlwiLFxuICAgICAgICBidXR0b25JbmRleDogMCxcbiAgICAgICAgdGltZXN0YW1wOiBMb25nLlVaRVJPLFxuICAgICAgICBvcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyOiBcIlwiLFxuICAgICAgICB1bml4VGltZXN0YW1wOiAwLFxuICAgICAgICBpbnB1dFRleHQ6IFwiXCIsXG4gICAgICAgIHN0YXRlOiBcIlwiLFxuICAgICAgICBhZGRyZXNzOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRnJhbWVBY3Rpb25Cb2R5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmZyYW1lVXJsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5mcmFtZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnV0dG9uSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UuYnV0dG9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXAuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudW5peFRpbWVzdGFtcCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDMyKG1lc3NhZ2UudW5peFRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXRUZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5zdHJpbmcobWVzc2FnZS5pbnB1dFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXRlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU4KS5zdHJpbmcobWVzc2FnZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig2Nikuc3RyaW5nKG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGcmFtZUFjdGlvbkJvZHkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZyYW1lVXJsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnV0dG9uSW5kZXggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wYXF1ZUNvbnZlcnNhdGlvbklkZW50aWZpZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51bml4VGltZXN0YW1wID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXRUZXh0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcmFtZVVybDogaXNTZXQob2JqZWN0LmZyYW1lVXJsKSA/IFN0cmluZyhvYmplY3QuZnJhbWVVcmwpIDogXCJcIixcbiAgICAgICAgICAgIGJ1dHRvbkluZGV4OiBpc1NldChvYmplY3QuYnV0dG9uSW5kZXgpID8gTnVtYmVyKG9iamVjdC5idXR0b25JbmRleCkgOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBvcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyOiBpc1NldChvYmplY3Qub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Qub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB1bml4VGltZXN0YW1wOiBpc1NldChvYmplY3QudW5peFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IE51bWJlcihvYmplY3QudW5peFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpbnB1dFRleHQ6IGlzU2V0KG9iamVjdC5pbnB1dFRleHQpID8gU3RyaW5nKG9iamVjdC5pbnB1dFRleHQpIDogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiBpc1NldChvYmplY3Quc3RhdGUpID8gU3RyaW5nKG9iamVjdC5zdGF0ZSkgOiBcIlwiLFxuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5hZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5mcmFtZVVybCAhPT0gdW5kZWZpbmVkICYmIChvYmouZnJhbWVVcmwgPSBtZXNzYWdlLmZyYW1lVXJsKTtcbiAgICAgICAgbWVzc2FnZS5idXR0b25JbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJ1dHRvbkluZGV4ID0gTWF0aC5yb3VuZChtZXNzYWdlLmJ1dHRvbkluZGV4KSk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gKG1lc3NhZ2UudGltZXN0YW1wIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLm9wYXF1ZUNvbnZlcnNhdGlvbklkZW50aWZpZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5vcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyID0gbWVzc2FnZS5vcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyKTtcbiAgICAgICAgbWVzc2FnZS51bml4VGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudW5peFRpbWVzdGFtcCA9IE1hdGgucm91bmQobWVzc2FnZS51bml4VGltZXN0YW1wKSk7XG4gICAgICAgIG1lc3NhZ2UuaW5wdXRUZXh0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbnB1dFRleHQgPSBtZXNzYWdlLmlucHV0VGV4dCk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnN0YXRlID0gbWVzc2FnZS5zdGF0ZSk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWRkcmVzcyA9IG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZyYW1lQWN0aW9uQm9keSgpO1xuICAgICAgICBtZXNzYWdlLmZyYW1lVXJsID0gKF9hID0gb2JqZWN0LmZyYW1lVXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmJ1dHRvbkluZGV4ID0gKF9iID0gb2JqZWN0LmJ1dHRvbkluZGV4KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRpbWVzdGFtcCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllciA9XG4gICAgICAgICAgICAoX2MgPSBvYmplY3Qub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS51bml4VGltZXN0YW1wID0gKF9kID0gb2JqZWN0LnVuaXhUaW1lc3RhbXApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaW5wdXRUZXh0ID0gKF9lID0gb2JqZWN0LmlucHV0VGV4dCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IChfZiA9IG9iamVjdC5zdGF0ZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKF9nID0gb2JqZWN0LmFkZHJlc3MpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZyYW1lQWN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hdHVyZTogdW5kZWZpbmVkLFxuICAgICAgICBzaWduZWRQdWJsaWNLZXlCdW5kbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgYWN0aW9uQm9keTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IEZyYW1lQWN0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbkJvZHkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLmFjdGlvbkJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRnJhbWVBY3Rpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlID0gU2lnbmVkUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb25Cb2R5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmVkUHVibGljS2V5QnVuZGxlOiBpc1NldChvYmplY3Quc2lnbmVkUHVibGljS2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5zaWduZWRQdWJsaWNLZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3Rpb25Cb2R5OiBpc1NldChvYmplY3QuYWN0aW9uQm9keSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYWN0aW9uQm9keSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmVkUHVibGljS2V5QnVuZGxlID0gbWVzc2FnZS5zaWduZWRQdWJsaWNLZXlCdW5kbGVcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5zaWduZWRQdWJsaWNLZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmFjdGlvbkJvZHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hY3Rpb25Cb2R5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYWN0aW9uQm9keSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5hY3Rpb25Cb2R5IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGcmFtZUFjdGlvbigpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3Quc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlID1cbiAgICAgICAgICAgIG9iamVjdC5zaWduZWRQdWJsaWNLZXlCdW5kbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5zaWduZWRQdWJsaWNLZXlCdW5kbGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmVkUHVibGljS2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmFjdGlvbkJvZHkgPSAoX2EgPSBvYmplY3QuYWN0aW9uQm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFtZXMucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsentProofPayload: () => (/* binding */ ConsentProofPayload),\n/* harmony export */   ConsentProofPayloadVersion: () => (/* binding */ ConsentProofPayloadVersion),\n/* harmony export */   InvitationV1: () => (/* binding */ InvitationV1),\n/* harmony export */   InvitationV1_Aes256gcmHkdfsha256: () => (/* binding */ InvitationV1_Aes256gcmHkdfsha256),\n/* harmony export */   InvitationV1_Context: () => (/* binding */ InvitationV1_Context),\n/* harmony export */   InvitationV1_Context_MetadataEntry: () => (/* binding */ InvitationV1_Context_MetadataEntry),\n/* harmony export */   SealedInvitation: () => (/* binding */ SealedInvitation),\n/* harmony export */   SealedInvitationHeaderV1: () => (/* binding */ SealedInvitationHeaderV1),\n/* harmony export */   SealedInvitationV1: () => (/* binding */ SealedInvitationV1),\n/* harmony export */   consentProofPayloadVersionFromJSON: () => (/* binding */ consentProofPayloadVersionFromJSON),\n/* harmony export */   consentProofPayloadVersionToJSON: () => (/* binding */ consentProofPayloadVersionToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\n/**\n * Invitation is used by an initiator to invite participants\n * into a new conversation. Invitation carries the chosen topic name\n * and encryption scheme and key material to be used for message encryption.\n */\n/** Version of consent proof payload */\nvar ConsentProofPayloadVersion;\n(function (ConsentProofPayloadVersion) {\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\"] = 0] = \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\";\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"CONSENT_PROOF_PAYLOAD_VERSION_1\"] = 1] = \"CONSENT_PROOF_PAYLOAD_VERSION_1\";\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ConsentProofPayloadVersion || (ConsentProofPayloadVersion = {}));\nfunction consentProofPayloadVersionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\":\n            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED;\n        case 1:\n        case \"CONSENT_PROOF_PAYLOAD_VERSION_1\":\n            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ConsentProofPayloadVersion.UNRECOGNIZED;\n    }\n}\nfunction consentProofPayloadVersionToJSON(object) {\n    switch (object) {\n        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED:\n            return \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\";\n        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1:\n            return \"CONSENT_PROOF_PAYLOAD_VERSION_1\";\n        case ConsentProofPayloadVersion.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseInvitationV1() {\n    return {\n        topic: \"\",\n        context: undefined,\n        aes256GcmHkdfSha256: undefined,\n        consentProof: undefined,\n    };\n}\nconst InvitationV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.topic !== \"\") {\n            writer.uint32(10).string(message.topic);\n        }\n        if (message.context !== undefined) {\n            InvitationV1_Context.encode(message.context, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.aes256GcmHkdfSha256 !== undefined) {\n            InvitationV1_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.consentProof !== undefined) {\n            ConsentProofPayload.encode(message.consentProof, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topic = reader.string();\n                    break;\n                case 2:\n                    message.context = InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.aes256GcmHkdfSha256 = InvitationV1_Aes256gcmHkdfsha256.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.consentProof = ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n            context: isSet(object.context)\n                ? InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256)\n                ? InvitationV1_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256)\n                : undefined,\n            consentProof: isSet(object.consentProof)\n                ? ConsentProofPayload.fromJSON(object.consentProof)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.topic !== undefined && (obj.topic = message.topic);\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.aes256GcmHkdfSha256 !== undefined &&\n            (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256\n                ? InvitationV1_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256)\n                : undefined);\n        message.consentProof !== undefined &&\n            (obj.consentProof = message.consentProof\n                ? ConsentProofPayload.toJSON(message.consentProof)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInvitationV1();\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.aes256GcmHkdfSha256 =\n            object.aes256GcmHkdfSha256 !== undefined &&\n                object.aes256GcmHkdfSha256 !== null\n                ? InvitationV1_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256)\n                : undefined;\n        message.consentProof =\n            object.consentProof !== undefined && object.consentProof !== null\n                ? ConsentProofPayload.fromPartial(object.consentProof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Aes256gcmHkdfsha256() {\n    return { keyMaterial: new Uint8Array() };\n}\nconst InvitationV1_Aes256gcmHkdfsha256 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyMaterial.length !== 0) {\n            writer.uint32(10).bytes(message.keyMaterial);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyMaterial = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyMaterial: isSet(object.keyMaterial)\n                ? bytesFromBase64(object.keyMaterial)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyMaterial !== undefined &&\n            (obj.keyMaterial = base64FromBytes(message.keyMaterial !== undefined\n                ? message.keyMaterial\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();\n        message.keyMaterial = (_a = object.keyMaterial) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Context() {\n    return { conversationId: \"\", metadata: {} };\n}\nconst InvitationV1_Context = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.conversationId !== \"\") {\n            writer.uint32(10).string(message.conversationId);\n        }\n        Object.entries(message.metadata).forEach(([key, value]) => {\n            InvitationV1_Context_MetadataEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Context();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversationId = reader.string();\n                    break;\n                case 2:\n                    const entry2 = InvitationV1_Context_MetadataEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.metadata[entry2.key] = entry2.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversationId: isSet(object.conversationId)\n                ? String(object.conversationId)\n                : \"\",\n            metadata: isObject(object.metadata)\n                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversationId !== undefined &&\n            (obj.conversationId = message.conversationId);\n        obj.metadata = {};\n        if (message.metadata) {\n            Object.entries(message.metadata).forEach(([k, v]) => {\n                obj.metadata[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseInvitationV1_Context();\n        message.conversationId = (_a = object.conversationId) !== null && _a !== void 0 ? _a : \"\";\n        message.metadata = Object.entries((_b = object.metadata) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Context_MetadataEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst InvitationV1_Context_MetadataEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Context_MetadataEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseInvitationV1_Context_MetadataEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSealedInvitationHeaderV1() {\n    return { sender: undefined, recipient: undefined, createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst SealedInvitationHeaderV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.sender, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitationHeaderV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSealedInvitationHeaderV1();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseSealedInvitationV1() {\n    return { headerBytes: new Uint8Array(), ciphertext: undefined };\n}\nconst SealedInvitationV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitationV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSealedInvitationV1();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSealedInvitation() {\n    return { v1: undefined };\n}\nconst SealedInvitation = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            SealedInvitationV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = SealedInvitationV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? SealedInvitationV1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? SealedInvitationV1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSealedInvitation();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? SealedInvitationV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseConsentProofPayload() {\n    return { signature: \"\", timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, payloadVersion: 0 };\n}\nconst ConsentProofPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.signature !== \"\") {\n            writer.uint32(10).string(message.signature);\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(16).uint64(message.timestamp);\n        }\n        if (message.payloadVersion !== 0) {\n            writer.uint32(24).int32(message.payloadVersion);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConsentProofPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signature = reader.string();\n                    break;\n                case 2:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 3:\n                    message.payloadVersion = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signature: isSet(object.signature) ? String(object.signature) : \"\",\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            payloadVersion: isSet(object.payloadVersion)\n                ? consentProofPayloadVersionFromJSON(object.payloadVersion)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.signature !== undefined && (obj.signature = message.signature);\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.payloadVersion !== undefined &&\n            (obj.payloadVersion = consentProofPayloadVersionToJSON(message.payloadVersion));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConsentProofPayload();\n        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : \"\";\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.payloadVersion = (_b = object.payloadVersion) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=invitation.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvaW52aXRhdGlvbi5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2dDO0FBQ1g7QUFDUjtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdFQUFnRTtBQUMxRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvaW52aXRhdGlvbi5wYi5qcz85ZGMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmVkUHVibGljS2V5QnVuZGxlIH0gZnJvbSBcIi4vcHVibGljX2tleS5wYlwiO1xuaW1wb3J0IHsgQ2lwaGVydGV4dCB9IGZyb20gXCIuL2NpcGhlcnRleHQucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG4vKipcbiAqIEludml0YXRpb24gaXMgdXNlZCBieSBhbiBpbml0aWF0b3IgdG8gaW52aXRlIHBhcnRpY2lwYW50c1xuICogaW50byBhIG5ldyBjb252ZXJzYXRpb24uIEludml0YXRpb24gY2FycmllcyB0aGUgY2hvc2VuIHRvcGljIG5hbWVcbiAqIGFuZCBlbmNyeXB0aW9uIHNjaGVtZSBhbmQga2V5IG1hdGVyaWFsIHRvIGJlIHVzZWQgZm9yIG1lc3NhZ2UgZW5jcnlwdGlvbi5cbiAqL1xuLyoqIFZlcnNpb24gb2YgY29uc2VudCBwcm9vZiBwYXlsb2FkICovXG5leHBvcnQgdmFyIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uO1xuKGZ1bmN0aW9uIChDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbikge1xuICAgIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uW0NvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uW1wiQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fVU5TUEVDSUZJRURcIjtcbiAgICBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OXzFcIl0gPSAxXSA9IFwiQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fMVwiO1xuICAgIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uW0NvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uIHx8IChDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbiA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29uc2VudFByb29mUGF5bG9hZFZlcnNpb25Gcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJDT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uLkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJDT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl8xXCI6XG4gICAgICAgICAgICByZXR1cm4gQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24uQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fMTtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29uc2VudFByb29mUGF5bG9hZFZlcnNpb25Ub0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbi5DT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl9VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24uQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fMTpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OXzFcIjtcbiAgICAgICAgY2FzZSBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbi5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTlJFQ09HTklaRURcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW52aXRhdGlvblYxKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcGljOiBcIlwiLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGFlczI1NkdjbUhrZGZTaGEyNTY6IHVuZGVmaW5lZCxcbiAgICAgICAgY29uc2VudFByb29mOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBJbnZpdGF0aW9uVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9waWMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEludml0YXRpb25WMV9Db250ZXh0LmVuY29kZShtZXNzYWdlLmNvbnRleHQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5lbmNvZGUobWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnNlbnRQcm9vZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb25zZW50UHJvb2ZQYXlsb2FkLmVuY29kZShtZXNzYWdlLmNvbnNlbnRQcm9vZiwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludml0YXRpb25WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZXh0ID0gSW52aXRhdGlvblYxX0NvbnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgPSBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29uc2VudFByb29mID0gQ29uc2VudFByb29mUGF5bG9hZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3BpYzogaXNTZXQob2JqZWN0LnRvcGljKSA/IFN0cmluZyhvYmplY3QudG9waWMpIDogXCJcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IGlzU2V0KG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0NvbnRleHQuZnJvbUpTT04ob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhZXMyNTZHY21Ia2RmU2hhMjU2OiBpc1NldChvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9BZXMyNTZnY21Ia2Rmc2hhMjU2LmZyb21KU09OKG9iamVjdC5hZXMyNTZHY21Ia2RmU2hhMjU2KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uc2VudFByb29mOiBpc1NldChvYmplY3QuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC5mcm9tSlNPTihvYmplY3QuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudG9waWMgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvcGljID0gbWVzc2FnZS50b3BpYyk7XG4gICAgICAgIG1lc3NhZ2UuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRleHQgPSBtZXNzYWdlLmNvbnRleHRcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LnRvSlNPTihtZXNzYWdlLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZXMyNTZHY21Ia2RmU2hhMjU2ID0gbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2XG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1Ni50b0pTT04obWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2YgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb25zZW50UHJvb2YgPSBtZXNzYWdlLmNvbnNlbnRQcm9vZlxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC50b0pTT04obWVzc2FnZS5jb25zZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjEoKTtcbiAgICAgICAgbWVzc2FnZS50b3BpYyA9IChfYSA9IG9iamVjdC50b3BpYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb250ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgPVxuICAgICAgICAgICAgb2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5mcm9tUGFydGlhbChvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2YgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnNlbnRQcm9vZiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb25zZW50UHJvb2YgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQuZnJvbVBhcnRpYWwob2JqZWN0LmNvbnNlbnRQcm9vZilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYoKSB7XG4gICAgcmV0dXJuIHsga2V5TWF0ZXJpYWw6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1NiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlNYXRlcmlhbC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uua2V5TWF0ZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleU1hdGVyaWFsID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleU1hdGVyaWFsOiBpc1NldChvYmplY3Qua2V5TWF0ZXJpYWwpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmtleU1hdGVyaWFsKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleU1hdGVyaWFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5TWF0ZXJpYWwgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5rZXlNYXRlcmlhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmtleU1hdGVyaWFsXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludml0YXRpb25WMV9BZXMyNTZnY21Ia2Rmc2hhMjU2KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5TWF0ZXJpYWwgPSAoX2EgPSBvYmplY3Qua2V5TWF0ZXJpYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUludml0YXRpb25WMV9Db250ZXh0KCkge1xuICAgIHJldHVybiB7IGNvbnZlcnNhdGlvbklkOiBcIlwiLCBtZXRhZGF0YToge30gfTtcbn1cbmV4cG9ydCBjb25zdCBJbnZpdGF0aW9uVjFfQ29udGV4dCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25JZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuY29udmVyc2F0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UubWV0YWRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgSW52aXRhdGlvblYxX0NvbnRleHRfTWV0YWRhdGFFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0NvbnRleHQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MiA9IEludml0YXRpb25WMV9Db250ZXh0X01ldGFkYXRhRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Mi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhW2VudHJ5Mi5rZXldID0gZW50cnkyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkOiBpc1NldChvYmplY3QuY29udmVyc2F0aW9uSWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNvbnZlcnNhdGlvbklkKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBpc09iamVjdChvYmplY3QubWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyhvYmplY3QubWV0YWRhdGEpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnZlcnNhdGlvbklkID0gbWVzc2FnZS5jb252ZXJzYXRpb25JZCk7XG4gICAgICAgIG9iai5tZXRhZGF0YSA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5tZXRhZGF0YSkuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqLm1ldGFkYXRhW2tdID0gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjFfQ29udGV4dCgpO1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbklkID0gKF9hID0gb2JqZWN0LmNvbnZlcnNhdGlvbklkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm1ldGFkYXRhID0gT2JqZWN0LmVudHJpZXMoKF9iID0gb2JqZWN0Lm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUludml0YXRpb25WMV9Db250ZXh0X01ldGFkYXRhRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IEludml0YXRpb25WMV9Db250ZXh0X01ldGFkYXRhRW50cnkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjFfQ29udGV4dF9NZXRhZGF0YUVudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IFN0cmluZyhvYmplY3Qua2V5KSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKSA/IFN0cmluZyhvYmplY3QudmFsdWUpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0NvbnRleHRfTWV0YWRhdGFFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPSAoX2IgPSBvYmplY3QudmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb25IZWFkZXJWMSgpIHtcbiAgICByZXR1cm4geyBzZW5kZXI6IHVuZGVmaW5lZCwgcmVjaXBpZW50OiB1bmRlZmluZWQsIGNyZWF0ZWROczogTG9uZy5VWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IFNlYWxlZEludml0YXRpb25IZWFkZXJWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnNlbmRlciwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnJlY2lwaWVudCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvbkhlYWRlclYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kZXI6IGlzU2V0KG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlY2lwaWVudDogaXNTZXQob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3JlYXRlZE5zOiBpc1NldChvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXIgPSBtZXNzYWdlLnNlbmRlclxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjaXBpZW50ID0gbWVzc2FnZS5yZWNpcGllbnRcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb25IZWFkZXJWMSgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciA9XG4gICAgICAgICAgICBvYmplY3Quc2VuZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRlciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ID1cbiAgICAgICAgICAgIG9iamVjdC5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjaXBpZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPVxuICAgICAgICAgICAgb2JqZWN0LmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVhdGVkTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWFsZWRJbnZpdGF0aW9uVjEoKSB7XG4gICAgcmV0dXJuIHsgaGVhZGVyQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksIGNpcGhlcnRleHQ6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFNlYWxlZEludml0YXRpb25WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5jaXBoZXJ0ZXh0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvblYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaXNTZXQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oZWFkZXJCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaGVhZGVyQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2lwaGVydGV4dCA9IG1lc3NhZ2UuY2lwaGVydGV4dFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvblYxKCk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSAoX2EgPSBvYmplY3QuaGVhZGVyQnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9XG4gICAgICAgICAgICBvYmplY3QuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWFsZWRJbnZpdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWFsZWRJbnZpdGF0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNlYWxlZEludml0YXRpb25WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gU2VhbGVkSW52aXRhdGlvblYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gU2VhbGVkSW52aXRhdGlvblYxLmZyb21KU09OKG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MSA/IFNlYWxlZEludml0YXRpb25WMS50b0pTT04obWVzc2FnZS52MSkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvbigpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2VhbGVkSW52aXRhdGlvblYxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29uc2VudFByb29mUGF5bG9hZCgpIHtcbiAgICByZXR1cm4geyBzaWduYXR1cmU6IFwiXCIsIHRpbWVzdGFtcDogTG9uZy5VWkVSTywgcGF5bG9hZFZlcnNpb246IDAgfTtcbn1cbmV4cG9ydCBjb25zdCBDb25zZW50UHJvb2ZQYXlsb2FkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UudGltZXN0YW1wLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWRWZXJzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQzMihtZXNzYWdlLnBheWxvYWRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnNlbnRQcm9vZlBheWxvYWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWRWZXJzaW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSkgPyBTdHJpbmcob2JqZWN0LnNpZ25hdHVyZSkgOiBcIlwiLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBwYXlsb2FkVmVyc2lvbjogaXNTZXQob2JqZWN0LnBheWxvYWRWZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gY29uc2VudFByb29mUGF5bG9hZFZlcnNpb25Gcm9tSlNPTihvYmplY3QucGF5bG9hZFZlcnNpb24pXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZSk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gKG1lc3NhZ2UudGltZXN0YW1wIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWRWZXJzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZFZlcnNpb24gPSBjb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvblRvSlNPTihtZXNzYWdlLnBheWxvYWRWZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb25zZW50UHJvb2ZQYXlsb2FkKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gKF9hID0gb2JqZWN0LnNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPVxuICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXAgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWRWZXJzaW9uID0gKF9iID0gb2JqZWN0LnBheWxvYWRWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludml0YXRpb24ucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodedMessage: () => (/* binding */ DecodedMessage),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageHeaderV1: () => (/* binding */ MessageHeaderV1),\n/* harmony export */   MessageHeaderV2: () => (/* binding */ MessageHeaderV2),\n/* harmony export */   MessageV1: () => (/* binding */ MessageV1),\n/* harmony export */   MessageV2: () => (/* binding */ MessageV2),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__);\n/* eslint-disable */\n\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseMessageHeaderV1() {\n    return { sender: undefined, recipient: undefined, timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst MessageHeaderV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.sender, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(24).uint64(message.timestamp);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHeaderV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.timestamp = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMessageHeaderV1();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseMessageV1() {\n    return { headerBytes: new Uint8Array(), ciphertext: undefined };\n}\nconst MessageV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageV1();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMessageHeaderV2() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, topic: \"\" };\n}\nconst MessageHeaderV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.topic !== \"\") {\n            writer.uint32(18).string(message.topic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHeaderV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.topic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.topic !== undefined && (obj.topic = message.topic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageHeaderV2();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseMessageV2() {\n    return {\n        headerBytes: new Uint8Array(),\n        ciphertext: undefined,\n        senderHmac: undefined,\n        shouldPush: undefined,\n    };\n}\nconst MessageV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.senderHmac !== undefined) {\n            writer.uint32(26).bytes(message.senderHmac);\n        }\n        if (message.shouldPush !== undefined) {\n            writer.uint32(32).bool(message.shouldPush);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.senderHmac = reader.bytes();\n                    break;\n                case 4:\n                    message.shouldPush = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : undefined,\n            shouldPush: isSet(object.shouldPush)\n                ? Boolean(object.shouldPush)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        message.senderHmac !== undefined &&\n            (obj.senderHmac =\n                message.senderHmac !== undefined\n                    ? base64FromBytes(message.senderHmac)\n                    : undefined);\n        message.shouldPush !== undefined && (obj.shouldPush = message.shouldPush);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMessageV2();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        message.senderHmac = (_b = object.senderHmac) !== null && _b !== void 0 ? _b : undefined;\n        message.shouldPush = (_c = object.shouldPush) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBaseMessage() {\n    return { v1: undefined, v2: undefined };\n}\nconst Message = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            MessageV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            MessageV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = MessageV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = MessageV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? MessageV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? MessageV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? MessageV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? MessageV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMessage();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? MessageV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? MessageV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseDecodedMessage() {\n    return {\n        id: \"\",\n        messageVersion: \"\",\n        senderAddress: \"\",\n        recipientAddress: undefined,\n        sentNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        contentTopic: \"\",\n        conversation: undefined,\n        contentBytes: new Uint8Array(),\n    };\n}\nconst DecodedMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.messageVersion !== \"\") {\n            writer.uint32(18).string(message.messageVersion);\n        }\n        if (message.senderAddress !== \"\") {\n            writer.uint32(26).string(message.senderAddress);\n        }\n        if (message.recipientAddress !== undefined) {\n            writer.uint32(34).string(message.recipientAddress);\n        }\n        if (!message.sentNs.isZero()) {\n            writer.uint32(40).uint64(message.sentNs);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(50).string(message.contentTopic);\n        }\n        if (message.conversation !== undefined) {\n            _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.encode(message.conversation, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.contentBytes.length !== 0) {\n            writer.uint32(66).bytes(message.contentBytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecodedMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.messageVersion = reader.string();\n                    break;\n                case 3:\n                    message.senderAddress = reader.string();\n                    break;\n                case 4:\n                    message.recipientAddress = reader.string();\n                    break;\n                case 5:\n                    message.sentNs = reader.uint64();\n                    break;\n                case 6:\n                    message.contentTopic = reader.string();\n                    break;\n                case 7:\n                    message.conversation = _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.contentBytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            messageVersion: isSet(object.messageVersion)\n                ? String(object.messageVersion)\n                : \"\",\n            senderAddress: isSet(object.senderAddress)\n                ? String(object.senderAddress)\n                : \"\",\n            recipientAddress: isSet(object.recipientAddress)\n                ? String(object.recipientAddress)\n                : undefined,\n            sentNs: isSet(object.sentNs) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sentNs) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n            conversation: isSet(object.conversation)\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n            contentBytes: isSet(object.contentBytes)\n                ? bytesFromBase64(object.contentBytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.messageVersion !== undefined &&\n            (obj.messageVersion = message.messageVersion);\n        message.senderAddress !== undefined &&\n            (obj.senderAddress = message.senderAddress);\n        message.recipientAddress !== undefined &&\n            (obj.recipientAddress = message.recipientAddress);\n        message.sentNs !== undefined &&\n            (obj.sentNs = (message.sentNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        message.contentBytes !== undefined &&\n            (obj.contentBytes = base64FromBytes(message.contentBytes !== undefined\n                ? message.contentBytes\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseDecodedMessage();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.messageVersion = (_b = object.messageVersion) !== null && _b !== void 0 ? _b : \"\";\n        message.senderAddress = (_c = object.senderAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.recipientAddress = (_d = object.recipientAddress) !== null && _d !== void 0 ? _d : undefined;\n        message.sentNs =\n            object.sentNs !== undefined && object.sentNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sentNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.contentTopic = (_e = object.contentTopic) !== null && _e !== void 0 ? _e : \"\";\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        message.contentBytes = (_f = object.contentBytes) !== null && _f !== void 0 ? _f : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=message.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvbWVzc2FnZS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDMEI7QUFDTDtBQUN1QjtBQUMvQjtBQUM5QjtBQUNQO0FBQ0EsYUFBYSxvREFBb0QsNENBQUk7QUFDckU7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBLFlBQVksMkRBQWU7QUFDM0I7QUFDQTtBQUNBLFlBQVksMkRBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBZTtBQUNwRDtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkVBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkVBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBSSw0QkFBNEIsNENBQUk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2RUFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvbWVzc2FnZS5wYi5qcz9jODE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgUHVibGljS2V5QnVuZGxlIH0gZnJvbSBcIi4vcHVibGljX2tleS5wYlwiO1xuaW1wb3J0IHsgQ2lwaGVydGV4dCB9IGZyb20gXCIuL2NpcGhlcnRleHQucGJcIjtcbmltcG9ydCB7IENvbnZlcnNhdGlvblJlZmVyZW5jZSB9IGZyb20gXCIuL2NvbnZlcnNhdGlvbl9yZWZlcmVuY2UucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTWVzc2FnZUhlYWRlclYxKCkge1xuICAgIHJldHVybiB7IHNlbmRlcjogdW5kZWZpbmVkLCByZWNpcGllbnQ6IHVuZGVmaW5lZCwgdGltZXN0YW1wOiBMb25nLlVaRVJPIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZUhlYWRlclYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2Uuc2VuZGVyLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2UucmVjaXBpZW50LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXAuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlSGVhZGVyVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlciA9IFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ID0gUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmRlcjogaXNTZXQob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3Quc2VuZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVjaXBpZW50OiBpc1NldChvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbmRlciA9IG1lc3NhZ2Uuc2VuZGVyXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2Uuc2VuZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZWNpcGllbnQgPSBtZXNzYWdlLnJlY2lwaWVudFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gKG1lc3NhZ2UudGltZXN0YW1wIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhlYWRlclYxKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyID1cbiAgICAgICAgICAgIG9iamVjdC5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VuZGVyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgPVxuICAgICAgICAgICAgb2JqZWN0LnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZWNpcGllbnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRpbWVzdGFtcCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2VWMSgpIHtcbiAgICByZXR1cm4geyBoZWFkZXJCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSwgY2lwaGVydGV4dDogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZVYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmhlYWRlckJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLmNpcGhlcnRleHQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gQ2lwaGVydGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJCeXRlczogaXNTZXQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBpc1NldChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlckJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5oZWFkZXJCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jaXBoZXJ0ZXh0ID0gbWVzc2FnZS5jaXBoZXJ0ZXh0XG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LnRvSlNPTihtZXNzYWdlLmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlVjEoKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYSA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNpcGhlcnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2VIZWFkZXJWMigpIHtcbiAgICByZXR1cm4geyBjcmVhdGVkTnM6IExvbmcuVVpFUk8sIHRvcGljOiBcIlwiIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZUhlYWRlclYyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b3BpYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhlYWRlclYyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlZE5zOiBpc1NldChvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICB0b3BpYzogaXNTZXQob2JqZWN0LnRvcGljKSA/IFN0cmluZyhvYmplY3QudG9waWMpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS50b3BpYyAhPT0gdW5kZWZpbmVkICYmIChvYmoudG9waWMgPSBtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhlYWRlclYyKCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS50b3BpYyA9IChfYSA9IG9iamVjdC50b3BpYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTWVzc2FnZVYyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlckJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjaXBoZXJ0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHNlbmRlckhtYWM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2hvdWxkUHVzaDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZVYyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmhlYWRlckJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLmNpcGhlcnRleHQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVySG1hYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLnNlbmRlckhtYWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNob3VsZFB1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikuYm9vbChtZXNzYWdlLnNob3VsZFB1c2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZVYyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNob3VsZFB1c2ggPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJCeXRlczogaXNTZXQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBpc1NldChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZW5kZXJIbWFjOiBpc1NldChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNob3VsZFB1c2g6IGlzU2V0KG9iamVjdC5zaG91bGRQdXNoKVxuICAgICAgICAgICAgICAgID8gQm9vbGVhbihvYmplY3Quc2hvdWxkUHVzaClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVhZGVyQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmhlYWRlckJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNpcGhlcnRleHQgPSBtZXNzYWdlLmNpcGhlcnRleHRcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQudG9KU09OKG1lc3NhZ2UuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbmRlckhtYWMgPVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uuc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNob3VsZFB1c2ggIT09IHVuZGVmaW5lZCAmJiAob2JqLnNob3VsZFB1c2ggPSBtZXNzYWdlLnNob3VsZFB1c2gpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VWMigpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gKF9hID0gb2JqZWN0LmhlYWRlckJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgPVxuICAgICAgICAgICAgb2JqZWN0LmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY2lwaGVydGV4dCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tUGFydGlhbChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXJIbWFjID0gKF9iID0gb2JqZWN0LnNlbmRlckhtYWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zaG91bGRQdXNoID0gKF9jID0gb2JqZWN0LnNob3VsZFB1c2gpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTWVzc2FnZSgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkLCB2MjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlVjEuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWVzc2FnZVYyLmVuY29kZShtZXNzYWdlLnYyLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBNZXNzYWdlVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYyID0gTWVzc2FnZVYyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gTWVzc2FnZVYxLmZyb21KU09OKG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2MjogaXNTZXQob2JqZWN0LnYyKSA/IE1lc3NhZ2VWMi5mcm9tSlNPTihvYmplY3QudjIpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBNZXNzYWdlVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYyID0gbWVzc2FnZS52MiA/IE1lc3NhZ2VWMi50b0pTT04obWVzc2FnZS52MikgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTWVzc2FnZVYxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52MiA9XG4gICAgICAgICAgICBvYmplY3QudjIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VWMi5mcm9tUGFydGlhbChvYmplY3QudjIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURlY29kZWRNZXNzYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBcIlwiLFxuICAgICAgICBtZXNzYWdlVmVyc2lvbjogXCJcIixcbiAgICAgICAgc2VuZGVyQWRkcmVzczogXCJcIixcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgICBzZW50TnM6IExvbmcuVVpFUk8sXG4gICAgICAgIGNvbnRlbnRUb3BpYzogXCJcIixcbiAgICAgICAgY29udmVyc2F0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRlbnRCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IERlY29kZWRNZXNzYWdlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZVZlcnNpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2VWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXJBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5zZW5kZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNpcGllbnRBZGRyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLnN0cmluZyhtZXNzYWdlLnJlY2lwaWVudEFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS5zZW50TnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDApLnVpbnQ2NChtZXNzYWdlLnNlbnROcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udGVudFRvcGljICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5zdHJpbmcobWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb252ZXJzYXRpb25SZWZlcmVuY2UuZW5jb2RlKG1lc3NhZ2UuY29udmVyc2F0aW9uLCB3cml0ZXIudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnRCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjYpLmJ5dGVzKG1lc3NhZ2UuY29udGVudEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY29kZWRNZXNzYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2VWZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY2lwaWVudEFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW50TnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPSBDb252ZXJzYXRpb25SZWZlcmVuY2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaXNTZXQob2JqZWN0LmlkKSA/IFN0cmluZyhvYmplY3QuaWQpIDogXCJcIixcbiAgICAgICAgICAgIG1lc3NhZ2VWZXJzaW9uOiBpc1NldChvYmplY3QubWVzc2FnZVZlcnNpb24pXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0Lm1lc3NhZ2VWZXJzaW9uKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHNlbmRlckFkZHJlc3M6IGlzU2V0KG9iamVjdC5zZW5kZXJBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5zZW5kZXJBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHJlY2lwaWVudEFkZHJlc3M6IGlzU2V0KG9iamVjdC5yZWNpcGllbnRBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5yZWNpcGllbnRBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VudE5zOiBpc1NldChvYmplY3Quc2VudE5zKSA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5zZW50TnMpIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogaXNTZXQob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbjogaXNTZXQob2JqZWN0LmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tSlNPTihvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29udGVudEJ5dGVzOiBpc1NldChvYmplY3QuY29udGVudEJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5jb250ZW50Qnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlkID0gbWVzc2FnZS5pZCk7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZVZlcnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tZXNzYWdlVmVyc2lvbiA9IG1lc3NhZ2UubWVzc2FnZVZlcnNpb24pO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXJBZGRyZXNzID0gbWVzc2FnZS5zZW5kZXJBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5yZWNpcGllbnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjaXBpZW50QWRkcmVzcyA9IG1lc3NhZ2UucmVjaXBpZW50QWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2Uuc2VudE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VudE5zID0gKG1lc3NhZ2Uuc2VudE5zIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb252ZXJzYXRpb24gPSBtZXNzYWdlLmNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLnRvSlNPTihtZXNzYWdlLmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudEJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGVudEJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuY29udGVudEJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuY29udGVudEJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjb2RlZE1lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS5pZCA9IChfYSA9IG9iamVjdC5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlVmVyc2lvbiA9IChfYiA9IG9iamVjdC5tZXNzYWdlVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXJBZGRyZXNzID0gKF9jID0gb2JqZWN0LnNlbmRlckFkZHJlc3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50QWRkcmVzcyA9IChfZCA9IG9iamVjdC5yZWNpcGllbnRBZGRyZXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2VudE5zID1cbiAgICAgICAgICAgIG9iamVjdC5zZW50TnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VudE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3Quc2VudE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAoX2UgPSBvYmplY3QuY29udGVudFRvcGljKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QuY29udmVyc2F0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnZlcnNhdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21QYXJ0aWFsKG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudEJ5dGVzID0gKF9mID0gb2JqZWN0LmNvbnRlbnRCeXRlcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptedPrivateKeyBundle: () => (/* binding */ EncryptedPrivateKeyBundle),\n/* harmony export */   EncryptedPrivateKeyBundleV1: () => (/* binding */ EncryptedPrivateKeyBundleV1),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyBundle: () => (/* binding */ PrivateKeyBundle),\n/* harmony export */   PrivateKeyBundleV1: () => (/* binding */ PrivateKeyBundleV1),\n/* harmony export */   PrivateKeyBundleV2: () => (/* binding */ PrivateKeyBundleV2),\n/* harmony export */   PrivateKey_Secp256k1: () => (/* binding */ PrivateKey_Secp256k1),\n/* harmony export */   SignedPrivateKey: () => (/* binding */ SignedPrivateKey),\n/* harmony export */   SignedPrivateKey_Secp256k1: () => (/* binding */ SignedPrivateKey_Secp256k1),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignedPrivateKey() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1: undefined, publicKey: undefined };\n}\nconst SignedPrivateKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.secp256k1 !== undefined) {\n            SignedPrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.publicKey !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.encode(message.publicKey, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPrivateKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.secp256k1 = SignedPrivateKey_Secp256k1.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.publicKey = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1: isSet(object.secp256k1)\n                ? SignedPrivateKey_Secp256k1.fromJSON(object.secp256k1)\n                : undefined,\n            publicKey: isSet(object.publicKey)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromJSON(object.publicKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1 !== undefined &&\n            (obj.secp256k1 = message.secp256k1\n                ? SignedPrivateKey_Secp256k1.toJSON(message.secp256k1)\n                : undefined);\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.toJSON(message.publicKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignedPrivateKey();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1 =\n            object.secp256k1 !== undefined && object.secp256k1 !== null\n                ? SignedPrivateKey_Secp256k1.fromPartial(object.secp256k1)\n                : undefined;\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromPartial(object.publicKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedPrivateKey_Secp256k1() {\n    return { bytes: new Uint8Array() };\n}\nconst SignedPrivateKey_Secp256k1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPrivateKey_Secp256k1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPrivateKey_Secp256k1();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundleV2() {\n    return { identityKey: undefined, preKeys: [] };\n}\nconst PrivateKeyBundleV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            SignedPrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.preKeys) {\n            SignedPrivateKey.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundleV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = SignedPrivateKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKeys.push(SignedPrivateKey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? SignedPrivateKey.fromJSON(object.identityKey)\n                : undefined,\n            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys)\n                ? object.preKeys.map((e) => SignedPrivateKey.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? SignedPrivateKey.toJSON(message.identityKey)\n                : undefined);\n        if (message.preKeys) {\n            obj.preKeys = message.preKeys.map((e) => e ? SignedPrivateKey.toJSON(e) : undefined);\n        }\n        else {\n            obj.preKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKeyBundleV2();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? SignedPrivateKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKeys =\n            ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e) => SignedPrivateKey.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePrivateKey() {\n    return { timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1: undefined, publicKey: undefined };\n}\nconst PrivateKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.timestamp.isZero()) {\n            writer.uint32(8).uint64(message.timestamp);\n        }\n        if (message.secp256k1 !== undefined) {\n            PrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.publicKey !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.encode(message.publicKey, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 2:\n                    message.secp256k1 = PrivateKey_Secp256k1.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.publicKey = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1: isSet(object.secp256k1)\n                ? PrivateKey_Secp256k1.fromJSON(object.secp256k1)\n                : undefined,\n            publicKey: isSet(object.publicKey)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromJSON(object.publicKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1 !== undefined &&\n            (obj.secp256k1 = message.secp256k1\n                ? PrivateKey_Secp256k1.toJSON(message.secp256k1)\n                : undefined);\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.toJSON(message.publicKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivateKey();\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1 =\n            object.secp256k1 !== undefined && object.secp256k1 !== null\n                ? PrivateKey_Secp256k1.fromPartial(object.secp256k1)\n                : undefined;\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromPartial(object.publicKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePrivateKey_Secp256k1() {\n    return { bytes: new Uint8Array() };\n}\nconst PrivateKey_Secp256k1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKey_Secp256k1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKey_Secp256k1();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundleV1() {\n    return { identityKey: undefined, preKeys: [] };\n}\nconst PrivateKeyBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            PrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.preKeys) {\n            PrivateKey.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = PrivateKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKeys.push(PrivateKey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? PrivateKey.fromJSON(object.identityKey)\n                : undefined,\n            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys)\n                ? object.preKeys.map((e) => PrivateKey.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? PrivateKey.toJSON(message.identityKey)\n                : undefined);\n        if (message.preKeys) {\n            obj.preKeys = message.preKeys.map((e) => e ? PrivateKey.toJSON(e) : undefined);\n        }\n        else {\n            obj.preKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKeyBundleV1();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? PrivateKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKeys =\n            ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e) => PrivateKey.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundle() {\n    return { v1: undefined, v2: undefined };\n}\nconst PrivateKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            PrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            PrivateKeyBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = PrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = PrivateKeyBundleV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? PrivateKeyBundleV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? PrivateKeyBundleV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? PrivateKeyBundleV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? PrivateKeyBundleV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivateKeyBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? PrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? PrivateKeyBundleV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptedPrivateKeyBundleV1() {\n    return { walletPreKey: new Uint8Array(), ciphertext: undefined };\n}\nconst EncryptedPrivateKeyBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.walletPreKey.length !== 0) {\n            writer.uint32(10).bytes(message.walletPreKey);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptedPrivateKeyBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletPreKey = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletPreKey: isSet(object.walletPreKey)\n                ? bytesFromBase64(object.walletPreKey)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletPreKey !== undefined &&\n            (obj.walletPreKey = base64FromBytes(message.walletPreKey !== undefined\n                ? message.walletPreKey\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptedPrivateKeyBundleV1();\n        message.walletPreKey = (_a = object.walletPreKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptedPrivateKeyBundle() {\n    return { v1: undefined };\n}\nconst EncryptedPrivateKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            EncryptedPrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptedPrivateKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = EncryptedPrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? EncryptedPrivateKeyBundleV1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? EncryptedPrivateKeyBundleV1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseEncryptedPrivateKeyBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? EncryptedPrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=private_key.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvcHJpdmF0ZV9rZXkucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDcUM7QUFDaEI7QUFDUjtBQUM5QjtBQUNQO0FBQ0EsYUFBYSxXQUFXLDRDQUFJO0FBQzVCO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFlO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVU7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVU7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL3ByaXZhdGVfa2V5LnBiLmpzPzVmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduZWRQdWJsaWNLZXksIFB1YmxpY0tleSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCB7IENpcGhlcnRleHQgfSBmcm9tIFwiLi9jaXBoZXJ0ZXh0LnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZFByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIHsgY3JlYXRlZE5zOiBMb25nLlVaRVJPLCBzZWNwMjU2azE6IHVuZGVmaW5lZCwgcHVibGljS2V5OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRQcml2YXRlS2V5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEuZW5jb2RlKG1lc3NhZ2Uuc2VjcDI1NmsxLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UucHVibGljS2V5LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUHJpdmF0ZUtleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxID0gU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IFNpZ25lZFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkTnM6IGlzU2V0KG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIHNlY3AyNTZrMTogaXNTZXQob2JqZWN0LnNlY3AyNTZrMSlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxLmZyb21KU09OKG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGlzU2V0KG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZWNwMjU2azEgPSBtZXNzYWdlLnNlY3AyNTZrMVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEudG9KU09OKG1lc3NhZ2Uuc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wdWJsaWNLZXkgPSBtZXNzYWdlLnB1YmxpY0tleVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LnRvSlNPTihtZXNzYWdlLnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQcml2YXRlS2V5KCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgPVxuICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZWNwMjU2azEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxLmZyb21QYXJ0aWFsKG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHVibGljS2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbVBhcnRpYWwob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEoKSB7XG4gICAgcmV0dXJuIHsgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRQcml2YXRlS2V5X1NlY3AyNTZrMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBpc1NldChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEoKTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IChfYSA9IG9iamVjdC5ieXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZVYyKCkge1xuICAgIHJldHVybiB7IGlkZW50aXR5S2V5OiB1bmRlZmluZWQsIHByZUtleXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZUtleUJ1bmRsZVYyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFByaXZhdGVLZXkuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucHJlS2V5cykge1xuICAgICAgICAgICAgU2lnbmVkUHJpdmF0ZUtleS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVLZXlCdW5kbGVWMigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSBTaWduZWRQcml2YXRlS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVLZXlzLnB1c2goU2lnbmVkUHJpdmF0ZUtleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IGlzU2V0KG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXkuZnJvbUpTT04ob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlS2V5czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucHJlS2V5cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5wcmVLZXlzLm1hcCgoZSkgPT4gU2lnbmVkUHJpdmF0ZUtleS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZGVudGl0eUtleSA9IG1lc3NhZ2UuaWRlbnRpdHlLZXlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXkudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXlzKSB7XG4gICAgICAgICAgICBvYmoucHJlS2V5cyA9IG1lc3NhZ2UucHJlS2V5cy5tYXAoKGUpID0+IGUgPyBTaWduZWRQcml2YXRlS2V5LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucHJlS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVLZXlCdW5kbGVWMigpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHJpdmF0ZUtleS5mcm9tUGFydGlhbChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucHJlS2V5cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnByZUtleXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFNpZ25lZFByaXZhdGVLZXkuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZUtleSgpIHtcbiAgICByZXR1cm4geyB0aW1lc3RhbXA6IExvbmcuVVpFUk8sIHNlY3AyNTZrMTogdW5kZWZpbmVkLCBwdWJsaWNLZXk6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVLZXkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVzdGFtcC5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlY3AyNTZrMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQcml2YXRlS2V5X1NlY3AyNTZrMS5lbmNvZGUobWVzc2FnZS5zZWNwMjU2azEsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFB1YmxpY0tleS5lbmNvZGUobWVzc2FnZS5wdWJsaWNLZXksIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgPSBQcml2YXRlS2V5X1NlY3AyNTZrMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID0gUHVibGljS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgc2VjcDI1NmsxOiBpc1NldChvYmplY3Quc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleV9TZWNwMjU2azEuZnJvbUpTT04ob2JqZWN0LnNlY3AyNTZrMSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogaXNTZXQob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gKG1lc3NhZ2UudGltZXN0YW1wIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlY3AyNTZrMSA9IG1lc3NhZ2Uuc2VjcDI1NmsxXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlS2V5X1NlY3AyNTZrMS50b0pTT04obWVzc2FnZS5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnB1YmxpY0tleSA9IG1lc3NhZ2UucHVibGljS2V5XG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVLZXkoKTtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPVxuICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXAgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMSA9XG4gICAgICAgICAgICBvYmplY3Quc2VjcDI1NmsxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlY3AyNTZrMSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleV9TZWNwMjU2azEuZnJvbVBhcnRpYWwob2JqZWN0LnNlY3AyNTZrMSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgPVxuICAgICAgICAgICAgb2JqZWN0LnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wdWJsaWNLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlS2V5X1NlY3AyNTZrMSgpIHtcbiAgICByZXR1cm4geyBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVLZXlfU2VjcDI1NmsxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5X1NlY3AyNTZrMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXM6IGlzU2V0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ieXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5X1NlY3AyNTZrMSgpO1xuICAgICAgICBtZXNzYWdlLmJ5dGVzID0gKF9hID0gb2JqZWN0LmJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlVjEoKSB7XG4gICAgcmV0dXJuIHsgaWRlbnRpdHlLZXk6IHVuZGVmaW5lZCwgcHJlS2V5czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5QnVuZGxlVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZUtleS5lbmNvZGUobWVzc2FnZS5pZGVudGl0eUtleSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5wcmVLZXlzKSB7XG4gICAgICAgICAgICBQcml2YXRlS2V5LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZVYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9IFByaXZhdGVLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZUtleXMucHVzaChQcml2YXRlS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZGVudGl0eUtleTogaXNTZXQob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleS5mcm9tSlNPTihvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVLZXlzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5wcmVLZXlzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnByZUtleXMubWFwKChlKSA9PiBQcml2YXRlS2V5LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW50aXR5S2V5ID0gbWVzc2FnZS5pZGVudGl0eUtleVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleS50b0pTT04obWVzc2FnZS5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLnByZUtleXMpIHtcbiAgICAgICAgICAgIG9iai5wcmVLZXlzID0gbWVzc2FnZS5wcmVLZXlzLm1hcCgoZSkgPT4gZSA/IFByaXZhdGVLZXkudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5wcmVLZXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZVYxKCk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPVxuICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlkZW50aXR5S2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wcmVLZXlzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucHJlS2V5cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gUHJpdmF0ZUtleS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQsIHYyOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5QnVuZGxlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFByaXZhdGVLZXlCdW5kbGVWMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQcml2YXRlS2V5QnVuZGxlVjIuZW5jb2RlKG1lc3NhZ2UudjIsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFByaXZhdGVLZXlCdW5kbGVWMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjIgPSBQcml2YXRlS2V5QnVuZGxlVjIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSkgPyBQcml2YXRlS2V5QnVuZGxlVjEuZnJvbUpTT04ob2JqZWN0LnYxKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHYyOiBpc1NldChvYmplY3QudjIpID8gUHJpdmF0ZUtleUJ1bmRsZVYyLmZyb21KU09OKG9iamVjdC52MikgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MSA/IFByaXZhdGVLZXlCdW5kbGVWMS50b0pTT04obWVzc2FnZS52MSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnYyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjIgPSBtZXNzYWdlLnYyID8gUHJpdmF0ZUtleUJ1bmRsZVYyLnRvSlNPTihtZXNzYWdlLnYyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlS2V5QnVuZGxlVjEuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnYyID1cbiAgICAgICAgICAgIG9iamVjdC52MiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleUJ1bmRsZVYyLmZyb21QYXJ0aWFsKG9iamVjdC52MilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxKCkge1xuICAgIHJldHVybiB7IHdhbGxldFByZUtleTogbmV3IFVpbnQ4QXJyYXkoKSwgY2lwaGVydGV4dDogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLndhbGxldFByZUtleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uud2FsbGV0UHJlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENpcGhlcnRleHQuZW5jb2RlKG1lc3NhZ2UuY2lwaGVydGV4dCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2FsbGV0UHJlS2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gQ2lwaGVydGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3YWxsZXRQcmVLZXk6IGlzU2V0KG9iamVjdC53YWxsZXRQcmVLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LndhbGxldFByZUtleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0OiBpc1NldChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRQcmVLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai53YWxsZXRQcmVLZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS53YWxsZXRQcmVLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS53YWxsZXRQcmVLZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2lwaGVydGV4dCA9IG1lc3NhZ2UuY2lwaGVydGV4dFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxKCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0UHJlS2V5ID0gKF9hID0gb2JqZWN0LndhbGxldFByZUtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNpcGhlcnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGUoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA/IEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MVxuICAgICAgICAgICAgICAgID8gRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxLnRvSlNPTihtZXNzYWdlLnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGUoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpdmF0ZV9rZXkucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrivatePreferencesAction: () => (/* binding */ PrivatePreferencesAction),\n/* harmony export */   PrivatePreferencesAction_AllowAddress: () => (/* binding */ PrivatePreferencesAction_AllowAddress),\n/* harmony export */   PrivatePreferencesAction_AllowGroup: () => (/* binding */ PrivatePreferencesAction_AllowGroup),\n/* harmony export */   PrivatePreferencesAction_DenyAddress: () => (/* binding */ PrivatePreferencesAction_DenyAddress),\n/* harmony export */   PrivatePreferencesAction_DenyGroup: () => (/* binding */ PrivatePreferencesAction_DenyGroup),\n/* harmony export */   PrivatePreferencesPayload: () => (/* binding */ PrivatePreferencesPayload),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBasePrivatePreferencesAction() {\n    return {\n        allowAddress: undefined,\n        denyAddress: undefined,\n        allowGroup: undefined,\n        denyGroup: undefined,\n    };\n}\nconst PrivatePreferencesAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.allowAddress !== undefined) {\n            PrivatePreferencesAction_AllowAddress.encode(message.allowAddress, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.denyAddress !== undefined) {\n            PrivatePreferencesAction_DenyAddress.encode(message.denyAddress, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.allowGroup !== undefined) {\n            PrivatePreferencesAction_AllowGroup.encode(message.allowGroup, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.denyGroup !== undefined) {\n            PrivatePreferencesAction_DenyGroup.encode(message.denyGroup, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.allowAddress = PrivatePreferencesAction_AllowAddress.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.denyAddress = PrivatePreferencesAction_DenyAddress.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.allowGroup = PrivatePreferencesAction_AllowGroup.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.denyGroup = PrivatePreferencesAction_DenyGroup.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            allowAddress: isSet(object.allowAddress)\n                ? PrivatePreferencesAction_AllowAddress.fromJSON(object.allowAddress)\n                : undefined,\n            denyAddress: isSet(object.denyAddress)\n                ? PrivatePreferencesAction_DenyAddress.fromJSON(object.denyAddress)\n                : undefined,\n            allowGroup: isSet(object.allowGroup)\n                ? PrivatePreferencesAction_AllowGroup.fromJSON(object.allowGroup)\n                : undefined,\n            denyGroup: isSet(object.denyGroup)\n                ? PrivatePreferencesAction_DenyGroup.fromJSON(object.denyGroup)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.allowAddress !== undefined &&\n            (obj.allowAddress = message.allowAddress\n                ? PrivatePreferencesAction_AllowAddress.toJSON(message.allowAddress)\n                : undefined);\n        message.denyAddress !== undefined &&\n            (obj.denyAddress = message.denyAddress\n                ? PrivatePreferencesAction_DenyAddress.toJSON(message.denyAddress)\n                : undefined);\n        message.allowGroup !== undefined &&\n            (obj.allowGroup = message.allowGroup\n                ? PrivatePreferencesAction_AllowGroup.toJSON(message.allowGroup)\n                : undefined);\n        message.denyGroup !== undefined &&\n            (obj.denyGroup = message.denyGroup\n                ? PrivatePreferencesAction_DenyGroup.toJSON(message.denyGroup)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivatePreferencesAction();\n        message.allowAddress =\n            object.allowAddress !== undefined && object.allowAddress !== null\n                ? PrivatePreferencesAction_AllowAddress.fromPartial(object.allowAddress)\n                : undefined;\n        message.denyAddress =\n            object.denyAddress !== undefined && object.denyAddress !== null\n                ? PrivatePreferencesAction_DenyAddress.fromPartial(object.denyAddress)\n                : undefined;\n        message.allowGroup =\n            object.allowGroup !== undefined && object.allowGroup !== null\n                ? PrivatePreferencesAction_AllowGroup.fromPartial(object.allowGroup)\n                : undefined;\n        message.denyGroup =\n            object.denyGroup !== undefined && object.denyGroup !== null\n                ? PrivatePreferencesAction_DenyGroup.fromPartial(object.denyGroup)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_AllowAddress() {\n    return { walletAddresses: [] };\n}\nconst PrivatePreferencesAction_AllowAddress = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.walletAddresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_AllowAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses)\n                ? object.walletAddresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.walletAddresses) {\n            obj.walletAddresses = message.walletAddresses.map((e) => e);\n        }\n        else {\n            obj.walletAddresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_AllowAddress();\n        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_DenyAddress() {\n    return { walletAddresses: [] };\n}\nconst PrivatePreferencesAction_DenyAddress = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.walletAddresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_DenyAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses)\n                ? object.walletAddresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.walletAddresses) {\n            obj.walletAddresses = message.walletAddresses.map((e) => e);\n        }\n        else {\n            obj.walletAddresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_DenyAddress();\n        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_AllowGroup() {\n    return { groupIds: [] };\n}\nconst PrivatePreferencesAction_AllowGroup = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.groupIds) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_AllowGroup();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupIds.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds)\n                ? object.groupIds.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groupIds) {\n            obj.groupIds = message.groupIds.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.groupIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_AllowGroup();\n        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_DenyGroup() {\n    return { groupIds: [] };\n}\nconst PrivatePreferencesAction_DenyGroup = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.groupIds) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_DenyGroup();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupIds.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds)\n                ? object.groupIds.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groupIds) {\n            obj.groupIds = message.groupIds.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.groupIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_DenyGroup();\n        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesPayload() {\n    return { v1: undefined };\n}\nconst PrivatePreferencesPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivatePreferencesPayload();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=private_preferences.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvcHJpdmF0ZV9wcmVmZXJlbmNlcy5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ3FCO0FBQ1I7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLHNEQUFVO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxzREFBVTtBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQVU7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVU7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL3ByaXZhdGVfcHJlZmVyZW5jZXMucGIuanM/MjI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IENpcGhlcnRleHQgfSBmcm9tIFwiLi9jaXBoZXJ0ZXh0LnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0FkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVueUFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dHcm91cDogdW5kZWZpbmVkLFxuICAgICAgICBkZW55R3JvdXA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hbGxvd0FkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5lbmNvZGUobWVzc2FnZS5hbGxvd0FkZHJlc3MsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVueUFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzLmVuY29kZShtZXNzYWdlLmRlbnlBZGRyZXNzLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFsbG93R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAuZW5jb2RlKG1lc3NhZ2UuYWxsb3dHcm91cCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZW55R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5lbmNvZGUobWVzc2FnZS5kZW55R3JvdXAsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsbG93QWRkcmVzcyA9IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbnlBZGRyZXNzID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGxvd0dyb3VwID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbnlHcm91cCA9IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dBZGRyZXNzOiBpc1NldChvYmplY3QuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5mcm9tSlNPTihvYmplY3QuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueUFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZW55QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55QWRkcmVzcy5mcm9tSlNPTihvYmplY3QuZGVueUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvd0dyb3VwOiBpc1NldChvYmplY3QuYWxsb3dHcm91cClcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0dyb3VwLmZyb21KU09OKG9iamVjdC5hbGxvd0dyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueUdyb3VwOiBpc1NldChvYmplY3QuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5mcm9tSlNPTihvYmplY3QuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWxsb3dBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWxsb3dBZGRyZXNzID0gbWVzc2FnZS5hbGxvd0FkZHJlc3NcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MudG9KU09OKG1lc3NhZ2UuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5kZW55QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlbnlBZGRyZXNzID0gbWVzc2FnZS5kZW55QWRkcmVzc1xuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzLnRvSlNPTihtZXNzYWdlLmRlbnlBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5hbGxvd0dyb3VwICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWxsb3dHcm91cCA9IG1lc3NhZ2UuYWxsb3dHcm91cFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAudG9KU09OKG1lc3NhZ2UuYWxsb3dHcm91cClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZGVueUdyb3VwICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVueUdyb3VwID0gbWVzc2FnZS5kZW55R3JvdXBcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAudG9KU09OKG1lc3NhZ2UuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbigpO1xuICAgICAgICBtZXNzYWdlLmFsbG93QWRkcmVzcyA9XG4gICAgICAgICAgICBvYmplY3QuYWxsb3dBZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFsbG93QWRkcmVzcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5mcm9tUGFydGlhbChvYmplY3QuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmRlbnlBZGRyZXNzID1cbiAgICAgICAgICAgIG9iamVjdC5kZW55QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kZW55QWRkcmVzcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzLmZyb21QYXJ0aWFsKG9iamVjdC5kZW55QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5hbGxvd0dyb3VwID1cbiAgICAgICAgICAgIG9iamVjdC5hbGxvd0dyb3VwICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFsbG93R3JvdXAgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0dyb3VwLmZyb21QYXJ0aWFsKG9iamVjdC5hbGxvd0dyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmRlbnlHcm91cCA9XG4gICAgICAgICAgICBvYmplY3QuZGVueUdyb3VwICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRlbnlHcm91cCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5mcm9tUGFydGlhbChvYmplY3QuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dBZGRyZXNzKCkge1xuICAgIHJldHVybiB7IHdhbGxldEFkZHJlc3NlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dBZGRyZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLndhbGxldEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0QWRkcmVzc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC53YWxsZXRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Qud2FsbGV0QWRkcmVzc2VzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBvYmoud2FsbGV0QWRkcmVzc2VzID0gbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai53YWxsZXRBZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dBZGRyZXNzKCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzID0gKChfYSA9IG9iamVjdC53YWxsZXRBZGRyZXNzZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzKCkge1xuICAgIHJldHVybiB7IHdhbGxldEFkZHJlc3NlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldEFkZHJlc3Nlcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdhbGxldEFkZHJlc3NlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Qud2FsbGV0QWRkcmVzc2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LndhbGxldEFkZHJlc3Nlcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLndhbGxldEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgb2JqLndhbGxldEFkZHJlc3NlcyA9IG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoud2FsbGV0QWRkcmVzc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzKCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzID0gKChfYSA9IG9iamVjdC53YWxsZXRBZGRyZXNzZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAoKSB7XG4gICAgcmV0dXJuIHsgZ3JvdXBJZHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBJZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwSWRzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cElkczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuZ3JvdXBJZHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZ3JvdXBJZHMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5ncm91cElkcykge1xuICAgICAgICAgICAgb2JqLmdyb3VwSWRzID0gbWVzc2FnZS5ncm91cElkcy5tYXAoKGUpID0+IGJhc2U2NEZyb21CeXRlcyhlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmdyb3VwSWRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAoKTtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkcyA9ICgoX2EgPSBvYmplY3QuZ3JvdXBJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cCgpIHtcbiAgICByZXR1cm4geyBncm91cElkczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUdyb3VwID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmdyb3VwSWRzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwSWRzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cElkczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuZ3JvdXBJZHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZ3JvdXBJZHMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5ncm91cElkcykge1xuICAgICAgICAgICAgb2JqLmdyb3VwSWRzID0gbWVzc2FnZS5ncm91cElkcy5tYXAoKGUpID0+IGJhc2U2NEZyb21CeXRlcyhlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmdyb3VwSWRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cCgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwSWRzID0gKChfYSA9IG9iamVjdC5ncm91cElkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNQYXlsb2FkKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlUHJlZmVyZW5jZXNQYXlsb2FkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENpcGhlcnRleHQuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNQYXlsb2FkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSkgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MSA/IENpcGhlcnRleHQudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc1BheWxvYWQoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaXZhdGVfcHJlZmVyZW5jZXMucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   PublicKeyBundle: () => (/* binding */ PublicKeyBundle),\n/* harmony export */   PublicKey_Secp256k1Uncompressed: () => (/* binding */ PublicKey_Secp256k1Uncompressed),\n/* harmony export */   SignedPublicKey: () => (/* binding */ SignedPublicKey),\n/* harmony export */   SignedPublicKeyBundle: () => (/* binding */ SignedPublicKeyBundle),\n/* harmony export */   UnsignedPublicKey: () => (/* binding */ UnsignedPublicKey),\n/* harmony export */   UnsignedPublicKey_Secp256k1Uncompressed: () => (/* binding */ UnsignedPublicKey_Secp256k1Uncompressed),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseUnsignedPublicKey() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1Uncompressed: undefined };\n}\nconst UnsignedPublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.secp256k1Uncompressed !== undefined) {\n            UnsignedPublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsignedPublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 3:\n                    message.secp256k1Uncompressed =\n                        UnsignedPublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed)\n                ? UnsignedPublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1Uncompressed !== undefined &&\n            (obj.secp256k1Uncompressed = message.secp256k1Uncompressed\n                ? UnsignedPublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUnsignedPublicKey();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1Uncompressed =\n            object.secp256k1Uncompressed !== undefined &&\n                object.secp256k1Uncompressed !== null\n                ? UnsignedPublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUnsignedPublicKey_Secp256k1Uncompressed() {\n    return { bytes: new Uint8Array() };\n}\nconst UnsignedPublicKey_Secp256k1Uncompressed = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignedPublicKey() {\n    return { keyBytes: new Uint8Array(), signature: undefined };\n}\nconst SignedPublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.keyBytes);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBytes: isSet(object.keyBytes)\n                ? bytesFromBase64(object.keyBytes)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBytes !== undefined &&\n            (obj.keyBytes = base64FromBytes(message.keyBytes !== undefined ? message.keyBytes : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPublicKey();\n        message.keyBytes = (_a = object.keyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedPublicKeyBundle() {\n    return { identityKey: undefined, preKey: undefined };\n}\nconst SignedPublicKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            SignedPublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.preKey !== undefined) {\n            SignedPublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPublicKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKey = SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? SignedPublicKey.fromJSON(object.identityKey)\n                : undefined,\n            preKey: isSet(object.preKey)\n                ? SignedPublicKey.fromJSON(object.preKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? SignedPublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.preKey !== undefined &&\n            (obj.preKey = message.preKey\n                ? SignedPublicKey.toJSON(message.preKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignedPublicKeyBundle();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? SignedPublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKey =\n            object.preKey !== undefined && object.preKey !== null\n                ? SignedPublicKey.fromPartial(object.preKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePublicKey() {\n    return {\n        timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        signature: undefined,\n        secp256k1Uncompressed: undefined,\n    };\n}\nconst PublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (!message.timestamp.isZero()) {\n            writer.uint32(8).uint64(message.timestamp);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.secp256k1Uncompressed !== undefined) {\n            PublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.secp256k1Uncompressed =\n                        PublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed)\n                ? PublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        message.secp256k1Uncompressed !== undefined &&\n            (obj.secp256k1Uncompressed = message.secp256k1Uncompressed\n                ? PublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePublicKey();\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        message.secp256k1Uncompressed =\n            object.secp256k1Uncompressed !== undefined &&\n                object.secp256k1Uncompressed !== null\n                ? PublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePublicKey_Secp256k1Uncompressed() {\n    return { bytes: new Uint8Array() };\n}\nconst PublicKey_Secp256k1Uncompressed = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKey_Secp256k1Uncompressed();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePublicKey_Secp256k1Uncompressed();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePublicKeyBundle() {\n    return { identityKey: undefined, preKey: undefined };\n}\nconst PublicKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            PublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.preKey !== undefined) {\n            PublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKey = PublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? PublicKey.fromJSON(object.identityKey)\n                : undefined,\n            preKey: isSet(object.preKey)\n                ? PublicKey.fromJSON(object.preKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? PublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.preKey !== undefined &&\n            (obj.preKey = message.preKey\n                ? PublicKey.toJSON(message.preKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePublicKeyBundle();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? PublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKey =\n            object.preKey !== undefined && object.preKey !== null\n                ? PublicKey.fromPartial(object.preKey)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=public_key.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvcHVibGljX2tleS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNtQjtBQUNOO0FBQzlCO0FBQ1A7QUFDQSxhQUFhLFdBQVcsNENBQUk7QUFDNUI7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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eG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9wdWJsaWNfa2V5LnBiLmpzP2ViY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlVW5zaWduZWRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIHsgY3JlYXRlZE5zOiBMb25nLlVaRVJPLCBzZWNwMjU2azFVbmNvbXByZXNzZWQ6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFVuc2lnbmVkUHVibGljS2V5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmVuY29kZShtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVuc2lnbmVkUHVibGljS2V5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiBpc1NldChvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgID8gVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmZyb21KU09OKG9iamVjdC5zZWNwMjU2azFVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VjcDI1NmsxVW5jb21wcmVzc2VkID0gbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICA/IFVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC50b0pTT04obWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVW5zaWduZWRQdWJsaWNLZXkoKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPVxuICAgICAgICAgICAgb2JqZWN0LmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVhdGVkTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCA9XG4gICAgICAgICAgICBvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBVbnNpZ25lZFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQuZnJvbVBhcnRpYWwob2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVbnNpZ25lZFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBpc1NldChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4geyBrZXlCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRQdWJsaWNLZXkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5Qnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmtleUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFB1YmxpY0tleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5Qnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlCeXRlczogaXNTZXQob2JqZWN0LmtleUJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5rZXlCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleUJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5Qnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5rZXlCeXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5rZXlCeXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFB1YmxpY0tleSgpO1xuICAgICAgICBtZXNzYWdlLmtleUJ5dGVzID0gKF9hID0gb2JqZWN0LmtleUJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3Quc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZFB1YmxpY0tleUJ1bmRsZSgpIHtcbiAgICByZXR1cm4geyBpZGVudGl0eUtleTogdW5kZWZpbmVkLCBwcmVLZXk6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25lZFB1YmxpY0tleUJ1bmRsZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFB1YmxpY0tleS5lbmNvZGUobWVzc2FnZS5wcmVLZXksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXlCdW5kbGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID0gU2lnbmVkUHVibGljS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVLZXkgPSBTaWduZWRQdWJsaWNLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IGlzU2V0KG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVLZXk6IGlzU2V0KG9iamVjdC5wcmVLZXkpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LnByZUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaWRlbnRpdHlLZXkgPSBtZXNzYWdlLmlkZW50aXR5S2V5XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnByZUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnByZUtleSA9IG1lc3NhZ2UucHJlS2V5XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UucHJlS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFB1YmxpY0tleUJ1bmRsZSgpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wcmVLZXkgPVxuICAgICAgICAgICAgb2JqZWN0LnByZUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wcmVLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QucHJlS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZXN0YW1wOiBMb25nLlVaRVJPLFxuICAgICAgICBzaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBQdWJsaWNLZXkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVzdGFtcC5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmVuY29kZShtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiBpc1NldChvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5mcm9tSlNPTihvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gKG1lc3NhZ2UudGltZXN0YW1wIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpZ25hdHVyZSA9IG1lc3NhZ2Uuc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2Uuc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZWNwMjU2azFVbmNvbXByZXNzZWQgPSBtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC50b0pTT04obWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVibGljS2V5KCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID1cbiAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCA9XG4gICAgICAgICAgICBvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmZyb21QYXJ0aWFsKG9iamVjdC5zZWNwMjU2azFVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQoKSB7XG4gICAgcmV0dXJuIHsgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQoKTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IChfYSA9IG9iamVjdC5ieXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHVibGljS2V5QnVuZGxlKCkge1xuICAgIHJldHVybiB7IGlkZW50aXR5S2V5OiB1bmRlZmluZWQsIHByZUtleTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUHVibGljS2V5QnVuZGxlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFB1YmxpY0tleS5lbmNvZGUobWVzc2FnZS5pZGVudGl0eUtleSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5LmVuY29kZShtZXNzYWdlLnByZUtleSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleUJ1bmRsZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSBQdWJsaWNLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZUtleSA9IFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZGVudGl0eUtleTogaXNTZXQob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LmZyb21KU09OKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZUtleTogaXNTZXQob2JqZWN0LnByZUtleSlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QucHJlS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZGVudGl0eUtleSA9IG1lc3NhZ2UuaWRlbnRpdHlLZXlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS50b0pTT04obWVzc2FnZS5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucHJlS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJlS2V5ID0gbWVzc2FnZS5wcmVLZXlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS50b0pTT04obWVzc2FnZS5wcmVLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVibGljS2V5QnVuZGxlKCk7XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPVxuICAgICAgICAgICAgb2JqZWN0LmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlkZW50aXR5S2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkuZnJvbVBhcnRpYWwob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnByZUtleSA9XG4gICAgICAgICAgICBvYmplY3QucHJlS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnByZUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5wcmVLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2tleS5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   Signature_ECDSACompact: () => (/* binding */ Signature_ECDSACompact),\n/* harmony export */   Signature_WalletECDSACompact: () => (/* binding */ Signature_WalletECDSACompact),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignature() {\n    return { ecdsaCompact: undefined, walletEcdsaCompact: undefined };\n}\nconst Signature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.ecdsaCompact !== undefined) {\n            Signature_ECDSACompact.encode(message.ecdsaCompact, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.walletEcdsaCompact !== undefined) {\n            Signature_WalletECDSACompact.encode(message.walletEcdsaCompact, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ecdsaCompact = Signature_ECDSACompact.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.walletEcdsaCompact = Signature_WalletECDSACompact.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ecdsaCompact: isSet(object.ecdsaCompact)\n                ? Signature_ECDSACompact.fromJSON(object.ecdsaCompact)\n                : undefined,\n            walletEcdsaCompact: isSet(object.walletEcdsaCompact)\n                ? Signature_WalletECDSACompact.fromJSON(object.walletEcdsaCompact)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ecdsaCompact !== undefined &&\n            (obj.ecdsaCompact = message.ecdsaCompact\n                ? Signature_ECDSACompact.toJSON(message.ecdsaCompact)\n                : undefined);\n        message.walletEcdsaCompact !== undefined &&\n            (obj.walletEcdsaCompact = message.walletEcdsaCompact\n                ? Signature_WalletECDSACompact.toJSON(message.walletEcdsaCompact)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignature();\n        message.ecdsaCompact =\n            object.ecdsaCompact !== undefined && object.ecdsaCompact !== null\n                ? Signature_ECDSACompact.fromPartial(object.ecdsaCompact)\n                : undefined;\n        message.walletEcdsaCompact =\n            object.walletEcdsaCompact !== undefined &&\n                object.walletEcdsaCompact !== null\n                ? Signature_WalletECDSACompact.fromPartial(object.walletEcdsaCompact)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignature_ECDSACompact() {\n    return { bytes: new Uint8Array(), recovery: 0 };\n}\nconst Signature_ECDSACompact = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        if (message.recovery !== 0) {\n            writer.uint32(16).uint32(message.recovery);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature_ECDSACompact();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                case 2:\n                    message.recovery = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            recovery: isSet(object.recovery) ? Number(object.recovery) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.recovery !== undefined &&\n            (obj.recovery = Math.round(message.recovery));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignature_ECDSACompact();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseSignature_WalletECDSACompact() {\n    return { bytes: new Uint8Array(), recovery: 0 };\n}\nconst Signature_WalletECDSACompact = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        if (message.recovery !== 0) {\n            writer.uint32(16).uint32(message.recovery);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature_WalletECDSACompact();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                case 2:\n                    message.recovery = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            recovery: isSet(object.recovery) ? Number(object.recovery) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.recovery !== undefined &&\n            (obj.recovery = Math.round(message.recovery));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignature_WalletECDSACompact();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signature.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvc2lnbmF0dXJlLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNhO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvc2lnbmF0dXJlLnBiLmpzPzljNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4geyBlY2RzYUNvbXBhY3Q6IHVuZGVmaW5lZCwgd2FsbGV0RWNkc2FDb21wYWN0OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduYXR1cmUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZWNkc2FDb21wYWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QuZW5jb2RlKG1lc3NhZ2UuZWNkc2FDb21wYWN0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0LmVuY29kZShtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWNkc2FDb21wYWN0ID0gU2lnbmF0dXJlX0VDRFNBQ29tcGFjdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2FsbGV0RWNkc2FDb21wYWN0ID0gU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlY2RzYUNvbXBhY3Q6IGlzU2V0KG9iamVjdC5lY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmVfRUNEU0FDb21wYWN0LmZyb21KU09OKG9iamVjdC5lY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3YWxsZXRFY2RzYUNvbXBhY3Q6IGlzU2V0KG9iamVjdC53YWxsZXRFY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0LmZyb21KU09OKG9iamVjdC53YWxsZXRFY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lY2RzYUNvbXBhY3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lY2RzYUNvbXBhY3QgPSBtZXNzYWdlLmVjZHNhQ29tcGFjdFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlX0VDRFNBQ29tcGFjdC50b0pTT04obWVzc2FnZS5lY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLndhbGxldEVjZHNhQ29tcGFjdCA9IG1lc3NhZ2Uud2FsbGV0RWNkc2FDb21wYWN0XG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0LnRvSlNPTihtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmUoKTtcbiAgICAgICAgbWVzc2FnZS5lY2RzYUNvbXBhY3QgPVxuICAgICAgICAgICAgb2JqZWN0LmVjZHNhQ29tcGFjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lY2RzYUNvbXBhY3QgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QuZnJvbVBhcnRpYWwob2JqZWN0LmVjZHNhQ29tcGFjdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRFY2RzYUNvbXBhY3QgPVxuICAgICAgICAgICAgb2JqZWN0LndhbGxldEVjZHNhQ29tcGFjdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LndhbGxldEVjZHNhQ29tcGFjdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdC5mcm9tUGFydGlhbChvYmplY3Qud2FsbGV0RWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduYXR1cmVfRUNEU0FDb21wYWN0KCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLCByZWNvdmVyeTogMCB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNvdmVyeSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDMyKG1lc3NhZ2UucmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlX0VDRFNBQ29tcGFjdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY292ZXJ5ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICByZWNvdmVyeTogaXNTZXQob2JqZWN0LnJlY292ZXJ5KSA/IE51bWJlcihvYmplY3QucmVjb3ZlcnkpIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlY292ZXJ5ID0gTWF0aC5yb3VuZChtZXNzYWdlLnJlY292ZXJ5KSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVfRUNEU0FDb21wYWN0KCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucmVjb3ZlcnkgPSAoX2IgPSBvYmplY3QucmVjb3ZlcnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZV9XYWxsZXRFQ0RTQUNvbXBhY3QoKSB7XG4gICAgcmV0dXJuIHsgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCksIHJlY292ZXJ5OiAwIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJlY292ZXJ5ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50MzIobWVzc2FnZS5yZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjb3ZlcnkgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBpc1NldChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHJlY292ZXJ5OiBpc1NldChvYmplY3QucmVjb3ZlcnkpID8gTnVtYmVyKG9iamVjdC5yZWNvdmVyeSkgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ieXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnJlY292ZXJ5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjb3ZlcnkgPSBNYXRoLnJvdW5kKG1lc3NhZ2UucmVjb3ZlcnkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZV9XYWxsZXRFQ0RTQUNvbXBhY3QoKTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IChfYSA9IG9iamVjdC5ieXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeSA9IChfYiA9IG9iamVjdC5yZWNvdmVyeSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignedPayload: () => (/* binding */ SignedPayload),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignedPayload() {\n    return { payload: new Uint8Array(), signature: undefined };\n}\nconst SignedPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPayload();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signed_payload.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvc2lnbmVkX3BheWxvYWQucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDbUI7QUFDTjtBQUM5QjtBQUNQO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFTO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0RBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9zaWduZWRfcGF5bG9hZC5wYi5qcz9jZjBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZFBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHsgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRQYXlsb2FkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2Uuc2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUGF5bG9hZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnBheWxvYWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQYXlsb2FkKCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYSA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3Quc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmVkX3BheWxvYWQucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/node.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/node.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authn: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.authn),\n/* harmony export */   ciphertext: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ciphertext),\n/* harmony export */   composite: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.composite),\n/* harmony export */   contact: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.contact),\n/* harmony export */   content: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.content),\n/* harmony export */   conversationReference: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.conversationReference),\n/* harmony export */   ecies: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ecies),\n/* harmony export */   fetcher: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.fetcher),\n/* harmony export */   frames: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.frames),\n/* harmony export */   invitation: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.invitation),\n/* harmony export */   keystore: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.keystore),\n/* harmony export */   message: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.message),\n/* harmony export */   messageApi: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.messageApi),\n/* harmony export */   privateKey: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.privateKey),\n/* harmony export */   privatePreferences: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.privatePreferences),\n/* harmony export */   publicKey: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.publicKey),\n/* harmony export */   signature: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.signature),\n/* harmony export */   signedPayload: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.signedPayload)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/index.js\");\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    return undefined;\n}\nconst ctx = getGlobal();\nif (typeof ctx.fetch === \"undefined\") {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { fetch, Request, Response, Headers } = __webpack_require__(/*! undici */ \"undici\");\n    ctx.fetch = fetch;\n    ctx.Request = Request;\n    ctx.Response = Response;\n    ctx.Headers = Headers;\n}\nconst streamClasses = [\n    \"TextDecoderStream\",\n    \"TextEncoderStream\",\n    \"TransformStream\",\n    \"ReadableStream\",\n    \"WritableStream\",\n    \"ByteLengthQueuingStrategy\",\n    \"CountQueuingStrategy\",\n];\nfor (const clsName of streamClasses) {\n    if (typeof ctx[clsName] === \"undefined\") {\n        ctx[clsName] = __webpack_require__(/*! stream/web */ \"stream/web\")[clsName];\n    }\n}\n\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL25vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDhCQUFZO0FBQzNDO0FBQ0E7QUFDd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb25zZW50LXByb29mLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbm9kZS5qcz9lODE0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IGN0eCA9IGdldEdsb2JhbCgpO1xuaWYgKHR5cGVvZiBjdHguZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IHsgZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlLCBIZWFkZXJzIH0gPSByZXF1aXJlKFwidW5kaWNpXCIpO1xuICAgIGN0eC5mZXRjaCA9IGZldGNoO1xuICAgIGN0eC5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBjdHguUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICBjdHguSGVhZGVycyA9IEhlYWRlcnM7XG59XG5jb25zdCBzdHJlYW1DbGFzc2VzID0gW1xuICAgIFwiVGV4dERlY29kZXJTdHJlYW1cIixcbiAgICBcIlRleHRFbmNvZGVyU3RyZWFtXCIsXG4gICAgXCJUcmFuc2Zvcm1TdHJlYW1cIixcbiAgICBcIlJlYWRhYmxlU3RyZWFtXCIsXG4gICAgXCJXcml0YWJsZVN0cmVhbVwiLFxuICAgIFwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiLFxuICAgIFwiQ291bnRRdWV1aW5nU3RyYXRlZ3lcIixcbl07XG5mb3IgKGNvbnN0IGNsc05hbWUgb2Ygc3RyZWFtQ2xhc3Nlcykge1xuICAgIGlmICh0eXBlb2YgY3R4W2Nsc05hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGN0eFtjbHNOYW1lXSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpW2Nsc05hbWVdO1xuICAgIH1cbn1cbmV4cG9ydCAqIGZyb20gXCIuL2luZGV4XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js":
/*!**********************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b64Decode: () => (/* binding */ b64Decode),\n/* harmony export */   b64Encode: () => (/* binding */ b64Encode),\n/* harmony export */   fetchReq: () => (/* binding */ fetchReq),\n/* harmony export */   fetchStreamingRequest: () => (/* binding */ fetchStreamingRequest),\n/* harmony export */   renderURLSearchParams: () => (/* binding */ renderURLSearchParams),\n/* harmony export */   replacer: () => (/* binding */ replacer)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\n/*\n* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY\n*/\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * base64 encoder and decoder\n * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js\n */\n// Base64 encoding table\nconst b64 = new Array(64);\n// Base64 decoding table\nconst s64 = new Array(123);\n// 65..90, 97..122, 48..57, 43, 47\nfor (let i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\nfunction b64Encode(buffer, start, end) {\n    let parts = null;\n    const chunk = [];\n    let i = 0, // output index\n    j = 0, // goto index\n    t; // temporary\n    while (start < end) {\n        const b = buffer[start++];\n        switch (j) {\n            case 0:\n                chunk[i++] = b64[b >> 2];\n                t = (b & 3) << 4;\n                j = 1;\n                break;\n            case 1:\n                chunk[i++] = b64[t | b >> 4];\n                t = (b & 15) << 2;\n                j = 2;\n                break;\n            case 2:\n                chunk[i++] = b64[t | b >> 6];\n                chunk[i++] = b64[b & 63];\n                j = 0;\n                break;\n        }\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (j) {\n        chunk[i++] = b64[t];\n        chunk[i++] = 61;\n        if (j === 1)\n            chunk[i++] = 61;\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\nconst invalidEncoding = \"invalid encoding\";\nfunction b64Decode(s) {\n    const buffer = [];\n    let offset = 0;\n    let j = 0, // goto index\n    t; // temporary\n    for (let i = 0; i < s.length;) {\n        let c = s.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error(invalidEncoding);\n        switch (j) {\n            case 0:\n                t = c;\n                j = 1;\n                break;\n            case 1:\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            case 2:\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            case 3:\n                buffer[offset++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n        }\n    }\n    if (j === 1)\n        throw Error(invalidEncoding);\n    return new Uint8Array(buffer);\n}\nfunction b64Test(s) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);\n}\nfunction replacer(key, value) {\n    if (value && value.constructor === Uint8Array) {\n        return b64Encode(value, 0, value.length);\n    }\n    return value;\n}\nfunction fetchReq(path, init) {\n    const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [\"pathPrefix\"]);\n    const url = pathPrefix ? `${pathPrefix}${path}` : path;\n    return fetch(url, req).then(r => r.json().then((body) => {\n        if (!r.ok) {\n            throw body;\n        }\n        return body;\n    }));\n}\n/**\n * fetchStreamingRequest is able to handle grpc-gateway server side streaming call\n * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call\n * all entities will be returned as an array after the call finishes.\n **/\nfunction fetchStreamingRequest(path, callback, init) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [\"pathPrefix\"]);\n        const url = pathPrefix ? `${pathPrefix}${path}` : path;\n        const result = yield fetch(url, req);\n        // needs to use the .ok to check the status of HTTP status code\n        // http other than 200 will not throw an error, instead the .ok will become false.\n        // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#\n        if (!result.ok) {\n            const resp = yield result.json();\n            const errMsg = resp.error && resp.error.message ? resp.error.message : \"\";\n            throw new Error(errMsg);\n        }\n        if (!result.body) {\n            throw new Error(\"response doesnt have a body\");\n        }\n        yield result.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(getNewLineDelimitedJSONDecodingStream())\n            .pipeTo(getNotifyEntityArrivalSink((e) => {\n            if (callback) {\n                callback(e);\n            }\n        }));\n        // wait for the streaming to finish and return the success respond\n        return;\n    });\n}\n/**\n * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities\n */\nfunction getNewLineDelimitedJSONDecodingStream() {\n    return new TransformStream({\n        start(controller) {\n            controller.buf = '';\n            controller.pos = 0;\n        },\n        transform(chunk, controller) {\n            if (controller.buf === undefined) {\n                controller.buf = '';\n            }\n            if (controller.pos === undefined) {\n                controller.pos = 0;\n            }\n            controller.buf += chunk;\n            while (controller.pos < controller.buf.length) {\n                if (controller.buf[controller.pos] === '\\n') {\n                    const line = controller.buf.substring(0, controller.pos);\n                    const response = JSON.parse(line);\n                    controller.enqueue(response.result);\n                    controller.buf = controller.buf.substring(controller.pos + 1);\n                    controller.pos = 0;\n                }\n                else {\n                    ++controller.pos;\n                }\n            }\n        }\n    });\n}\n/**\n * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return\n * a sink that will call the callback on entity arrival\n * @param notifyCallback\n */\nfunction getNotifyEntityArrivalSink(notifyCallback) {\n    return new WritableStream({\n        write(entity) {\n            notifyCallback(entity);\n        }\n    });\n}\n/**\n * Checks if given value is a plain object\n * Logic copied and adapted from below source:\n * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n    const isObject = Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n    const isObjLike = value !== null && isObject;\n    if (!isObjLike || !isObject) {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    const hasObjectConstructor = typeof proto === \"object\" &&\n        proto.constructor === Object.prototype.constructor;\n    return hasObjectConstructor;\n}\n/**\n * Checks if given value is of a primitive type\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPrimitive(value) {\n    return [\"string\", \"number\", \"boolean\"].some(t => typeof value === t);\n}\n/**\n * Checks if given primitive is zero-value\n * @param  {Primitive} value\n * @return {boolean}\n */\nfunction isZeroValuePrimitive(value) {\n    return value === false || value === 0 || value === \"\";\n}\n/**\n * Flattens a deeply nested request payload and returns an object\n * with only primitive values and non-empty array of primitive values\n * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto\n * @param  {RequestPayload} requestPayload\n * @param  {String} path\n * @return {FlattenedRequestPayload>}\n */\nfunction flattenRequestPayload(requestPayload, path = \"\") {\n    return Object.keys(requestPayload).reduce((acc, key) => {\n        const value = requestPayload[key];\n        const newPath = path ? [path, key].join(\".\") : key;\n        const isNonEmptyPrimitiveArray = Array.isArray(value) &&\n            value.every(v => isPrimitive(v)) &&\n            value.length > 0;\n        const isNonZeroValuePrimitive = isPrimitive(value) && !isZeroValuePrimitive(value);\n        let objectToMerge = {};\n        if (isPlainObject(value)) {\n            objectToMerge = flattenRequestPayload(value, newPath);\n        }\n        else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {\n            objectToMerge = { [newPath]: value };\n        }\n        return Object.assign(Object.assign({}, acc), objectToMerge);\n    }, {});\n}\n/**\n * Renders a deeply nested request payload into a string of URL search\n * parameters by first flattening the request payload and then removing keys\n * which are already present in the URL path.\n * @param  {RequestPayload} requestPayload\n * @param  {string[]} urlPathParams\n * @return {string}\n */\nfunction renderURLSearchParams(requestPayload, urlPathParams = []) {\n    const flattenedRequestPayload = flattenRequestPayload(requestPayload);\n    const urlSearchParams = Object.keys(flattenedRequestPayload).reduce((acc, key) => {\n        // key should not be present in the url path as a parameter\n        const value = flattenedRequestPayload[key];\n        if (urlPathParams.find(f => f === key)) {\n            return acc;\n        }\n        return Array.isArray(value)\n            ? [...acc, ...value.map(m => [key, m.toString()])]\n            : (acc = [...acc, [key, value.toString()]]);\n    }, []);\n    return new URLSearchParams(urlSearchParams).toString();\n}\n//# sourceMappingURL=fetch.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vZmV0Y2gucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFO0FBQ3hFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUIsSUFBSSxhQUFhO0FBQzFDLGdDQUFnQyxXQUFXLEVBQUUsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2QkFBNkIsSUFBSSxhQUFhO0FBQzlDLG9DQUFvQyxXQUFXLEVBQUUsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2Q0FBNkM7QUFDN0MsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksVUFBVTtBQUN0QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2ZldGNoLnBiLmpzPzlhMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vKlxuKiBUaGlzIGZpbGUgaXMgYSBnZW5lcmF0ZWQgVHlwZXNjcmlwdCBmaWxlIGZvciBHUlBDIEdhdGV3YXksIERPIE5PVCBNT0RJRllcbiovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbi8qKlxuICogYmFzZTY0IGVuY29kZXIgYW5kIGRlY29kZXJcbiAqIENvcGllZCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2J1ZmpzL3Byb3RvYnVmLmpzL2Jsb2IvbWFzdGVyL2xpYi9iYXNlNjQvaW5kZXguanNcbiAqL1xuLy8gQmFzZTY0IGVuY29kaW5nIHRhYmxlXG5jb25zdCBiNjQgPSBuZXcgQXJyYXkoNjQpO1xuLy8gQmFzZTY0IGRlY29kaW5nIHRhYmxlXG5jb25zdCBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcbi8vIDY1Li45MCwgOTcuLjEyMiwgNDguLjU3LCA0MywgNDdcbmZvciAobGV0IGkgPSAwOyBpIDwgNjQ7KVxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcbmV4cG9ydCBmdW5jdGlvbiBiNjRFbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHBhcnRzID0gbnVsbDtcbiAgICBjb25zdCBjaHVuayA9IFtdO1xuICAgIGxldCBpID0gMCwgLy8gb3V0cHV0IGluZGV4XG4gICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcbiAgICB0OyAvLyB0ZW1wb3JhcnlcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgYiA9IGJ1ZmZlcltzdGFydCsrXTtcbiAgICAgICAgc3dpdGNoIChqKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICAgICAgaiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDZdO1xuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaikge1xuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xuICAgICAgICBjaHVua1tpKytdID0gNjE7XG4gICAgICAgIGlmIChqID09PSAxKVxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xuICAgIH1cbiAgICBpZiAocGFydHMpIHtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XG59XG5jb25zdCBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcbmV4cG9ydCBmdW5jdGlvbiBiNjREZWNvZGUocykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBqID0gMCwgLy8gZ290byBpbmRleFxuICAgIHQ7IC8vIHRlbXBvcmFyeVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBjID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcbiAgICAgICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XG4gICAgICAgICAgICAgICAgdCA9IGM7XG4gICAgICAgICAgICAgICAgaiA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGogPT09IDEpXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG59XG5mdW5jdGlvbiBiNjRUZXN0KHMpIHtcbiAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qocyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gYjY0RW5jb2RlKHZhbHVlLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hSZXEocGF0aCwgaW5pdCkge1xuICAgIGNvbnN0IF9hID0gaW5pdCB8fCB7fSwgeyBwYXRoUHJlZml4IH0gPSBfYSwgcmVxID0gX19yZXN0KF9hLCBbXCJwYXRoUHJlZml4XCJdKTtcbiAgICBjb25zdCB1cmwgPSBwYXRoUHJlZml4ID8gYCR7cGF0aFByZWZpeH0ke3BhdGh9YCA6IHBhdGg7XG4gICAgcmV0dXJuIGZldGNoKHVybCwgcmVxKS50aGVuKHIgPT4gci5qc29uKCkudGhlbigoYm9keSkgPT4ge1xuICAgICAgICBpZiAoIXIub2spIHtcbiAgICAgICAgICAgIHRocm93IGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSkpO1xufVxuLyoqXG4gKiBmZXRjaFN0cmVhbWluZ1JlcXVlc3QgaXMgYWJsZSB0byBoYW5kbGUgZ3JwYy1nYXRld2F5IHNlcnZlciBzaWRlIHN0cmVhbWluZyBjYWxsXG4gKiBpdCB0YWtlcyBOb3RpZnlTdHJlYW1FbnRpdHlBcnJpdmFsIHRoYXQgbGV0cyB1c2VycyByZXNwb25kIHRvIGVudGl0eSBhcnJpdmFsIGR1cmluZyB0aGUgY2FsbFxuICogYWxsIGVudGl0aWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkgYWZ0ZXIgdGhlIGNhbGwgZmluaXNoZXMuXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hTdHJlYW1pbmdSZXF1ZXN0KHBhdGgsIGNhbGxiYWNrLCBpbml0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgX2EgPSBpbml0IHx8IHt9LCB7IHBhdGhQcmVmaXggfSA9IF9hLCByZXEgPSBfX3Jlc3QoX2EsIFtcInBhdGhQcmVmaXhcIl0pO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXRoUHJlZml4ID8gYCR7cGF0aFByZWZpeH0ke3BhdGh9YCA6IHBhdGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGZldGNoKHVybCwgcmVxKTtcbiAgICAgICAgLy8gbmVlZHMgdG8gdXNlIHRoZSAub2sgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiBIVFRQIHN0YXR1cyBjb2RlXG4gICAgICAgIC8vIGh0dHAgb3RoZXIgdGhhbiAyMDAgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IsIGluc3RlYWQgdGhlIC5vayB3aWxsIGJlY29tZSBmYWxzZS5cbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2gjXG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwID0geWllbGQgcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IHJlc3AuZXJyb3IgJiYgcmVzcC5lcnJvci5tZXNzYWdlID8gcmVzcC5lcnJvci5tZXNzYWdlIDogXCJcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LmJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc3BvbnNlIGRvZXNudCBoYXZlIGEgYm9keVwiKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCByZXN1bHQuYm9keVxuICAgICAgICAgICAgLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKVxuICAgICAgICAgICAgLnBpcGVUaHJvdWdoKGdldE5ld0xpbmVEZWxpbWl0ZWRKU09ORGVjb2RpbmdTdHJlYW0oKSlcbiAgICAgICAgICAgIC5waXBlVG8oZ2V0Tm90aWZ5RW50aXR5QXJyaXZhbFNpbmsoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBzdHJlYW1pbmcgdG8gZmluaXNoIGFuZCByZXR1cm4gdGhlIHN1Y2Nlc3MgcmVzcG9uZFxuICAgICAgICByZXR1cm47XG4gICAgfSk7XG59XG4vKipcbiAqIGdldE5ld0xpbmVEZWxpbWl0ZWRKU09ORGVjb2RpbmdTdHJlYW0gcmV0dXJucyBhIFRyYW5zZm9ybVN0cmVhbSB0aGF0J3MgYWJsZSB0byBoYW5kbGUgbmV3IGxpbmUgZGVsaW1pdGVkIGpzb24gc3RyZWFtIGNvbnRlbnQgaW50byBwYXJzZWQgZW50aXRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmV3TGluZURlbGltaXRlZEpTT05EZWNvZGluZ1N0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYnVmID0gJyc7XG4gICAgICAgICAgICBjb250cm9sbGVyLnBvcyA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuYnVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmJ1ZiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIucG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmJ1ZiArPSBjaHVuaztcbiAgICAgICAgICAgIHdoaWxlIChjb250cm9sbGVyLnBvcyA8IGNvbnRyb2xsZXIuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmJ1Zltjb250cm9sbGVyLnBvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBjb250cm9sbGVyLmJ1Zi5zdWJzdHJpbmcoMCwgY29udHJvbGxlci5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmJ1ZiA9IGNvbnRyb2xsZXIuYnVmLnN1YnN0cmluZyhjb250cm9sbGVyLnBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnBvcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2NvbnRyb2xsZXIucG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBnZXROb3RpZnlFbnRpdHlBcnJpdmFsU2luayB0YWtlcyB0aGUgTm90aWZ5U3RyZWFtRW50aXR5QXJyaXZhbCBjYWxsYmFjayBhbmQgcmV0dXJuXG4gKiBhIHNpbmsgdGhhdCB3aWxsIGNhbGwgdGhlIGNhbGxiYWNrIG9uIGVudGl0eSBhcnJpdmFsXG4gKiBAcGFyYW0gbm90aWZ5Q2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0Tm90aWZ5RW50aXR5QXJyaXZhbFNpbmsobm90aWZ5Q2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgd3JpdGUoZW50aXR5KSB7XG4gICAgICAgICAgICBub3RpZnlDYWxsYmFjayhlbnRpdHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdFxuICogTG9naWMgY29waWVkIGFuZCBhZGFwdGVkIGZyb20gYmVsb3cgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXIwbi9yYW1kYS1hZGp1bmN0L2Jsb2IvbWFzdGVyL3NyYy9pc1BsYWluT2JqLmpzXG4gKiBAcGFyYW0gIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgPT09IFwiT2JqZWN0XCI7XG4gICAgY29uc3QgaXNPYmpMaWtlID0gdmFsdWUgIT09IG51bGwgJiYgaXNPYmplY3Q7XG4gICAgaWYgKCFpc09iakxpa2UgfHwgIWlzT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIGNvbnN0IGhhc09iamVjdENvbnN0cnVjdG9yID0gdHlwZW9mIHByb3RvID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb3RvLmNvbnN0cnVjdG9yID09PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBoYXNPYmplY3RDb25zdHJ1Y3Rvcjtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGdpdmVuIHZhbHVlIGlzIG9mIGEgcHJpbWl0aXZlIHR5cGVcbiAqIEBwYXJhbSAge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLnNvbWUodCA9PiB0eXBlb2YgdmFsdWUgPT09IHQpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgZ2l2ZW4gcHJpbWl0aXZlIGlzIHplcm8tdmFsdWVcbiAqIEBwYXJhbSAge1ByaW1pdGl2ZX0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzWmVyb1ZhbHVlUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbi8qKlxuICogRmxhdHRlbnMgYSBkZWVwbHkgbmVzdGVkIHJlcXVlc3QgcGF5bG9hZCBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqIHdpdGggb25seSBwcmltaXRpdmUgdmFsdWVzIGFuZCBub24tZW1wdHkgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuICogYXMgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZWFwaXMvYmxvYi9tYXN0ZXIvZ29vZ2xlL2FwaS9odHRwLnByb3RvXG4gKiBAcGFyYW0gIHtSZXF1ZXN0UGF5bG9hZH0gcmVxdWVzdFBheWxvYWRcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7RmxhdHRlbmVkUmVxdWVzdFBheWxvYWQ+fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuUmVxdWVzdFBheWxvYWQocmVxdWVzdFBheWxvYWQsIHBhdGggPSBcIlwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlcXVlc3RQYXlsb2FkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVxdWVzdFBheWxvYWRba2V5XTtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IHBhdGggPyBbcGF0aCwga2V5XS5qb2luKFwiLlwiKSA6IGtleTtcbiAgICAgICAgY29uc3QgaXNOb25FbXB0eVByaW1pdGl2ZUFycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIHZhbHVlLmV2ZXJ5KHYgPT4gaXNQcmltaXRpdmUodikpICYmXG4gICAgICAgICAgICB2YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBpc05vblplcm9WYWx1ZVByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlKHZhbHVlKSAmJiAhaXNaZXJvVmFsdWVQcmltaXRpdmUodmFsdWUpO1xuICAgICAgICBsZXQgb2JqZWN0VG9NZXJnZSA9IHt9O1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG9iamVjdFRvTWVyZ2UgPSBmbGF0dGVuUmVxdWVzdFBheWxvYWQodmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTm9uWmVyb1ZhbHVlUHJpbWl0aXZlIHx8IGlzTm9uRW1wdHlQcmltaXRpdmVBcnJheSkge1xuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IHsgW25ld1BhdGhdOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIG9iamVjdFRvTWVyZ2UpO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogUmVuZGVycyBhIGRlZXBseSBuZXN0ZWQgcmVxdWVzdCBwYXlsb2FkIGludG8gYSBzdHJpbmcgb2YgVVJMIHNlYXJjaFxuICogcGFyYW1ldGVycyBieSBmaXJzdCBmbGF0dGVuaW5nIHRoZSByZXF1ZXN0IHBheWxvYWQgYW5kIHRoZW4gcmVtb3Zpbmcga2V5c1xuICogd2hpY2ggYXJlIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgVVJMIHBhdGguXG4gKiBAcGFyYW0gIHtSZXF1ZXN0UGF5bG9hZH0gcmVxdWVzdFBheWxvYWRcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSB1cmxQYXRoUGFyYW1zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJVUkxTZWFyY2hQYXJhbXMocmVxdWVzdFBheWxvYWQsIHVybFBhdGhQYXJhbXMgPSBbXSkge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFJlcXVlc3RQYXlsb2FkID0gZmxhdHRlblJlcXVlc3RQYXlsb2FkKHJlcXVlc3RQYXlsb2FkKTtcbiAgICBjb25zdCB1cmxTZWFyY2hQYXJhbXMgPSBPYmplY3Qua2V5cyhmbGF0dGVuZWRSZXF1ZXN0UGF5bG9hZCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAvLyBrZXkgc2hvdWxkIG5vdCBiZSBwcmVzZW50IGluIHRoZSB1cmwgcGF0aCBhcyBhIHBhcmFtZXRlclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGZsYXR0ZW5lZFJlcXVlc3RQYXlsb2FkW2tleV07XG4gICAgICAgIGlmICh1cmxQYXRoUGFyYW1zLmZpbmQoZiA9PiBmID09PSBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyBbLi4uYWNjLCAuLi52YWx1ZS5tYXAobSA9PiBba2V5LCBtLnRvU3RyaW5nKCldKV1cbiAgICAgICAgICAgIDogKGFjYyA9IFsuLi5hY2MsIFtrZXksIHZhbHVlLnRvU3RyaW5nKCldXSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybFNlYXJjaFBhcmFtcykudG9TdHJpbmcoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/google/protobuf/empty.pb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/google/protobuf/empty.pb.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"google.protobuf\";\nfunction createBaseEmpty() {\n    return {};\n}\nconst Empty = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEmpty();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseEmpty();\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\n//# sourceMappingURL=empty.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vZ29vZ2xlL3Byb3RvYnVmL2VtcHR5LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDYTtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLGdFQUFVO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi9lbXB0eS5wYi5qcz80ZTVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJnb29nbGUucHJvdG9idWZcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbXB0eSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnQgY29uc3QgRW1wdHkgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbXB0eSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbXB0eSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/google/protobuf/empty.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/api/v1/identity.pb.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/identity/api/v1/identity.pb.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetIdentityUpdatesRequest: () => (/* binding */ GetIdentityUpdatesRequest),\n/* harmony export */   GetIdentityUpdatesRequest_Request: () => (/* binding */ GetIdentityUpdatesRequest_Request),\n/* harmony export */   GetIdentityUpdatesResponse: () => (/* binding */ GetIdentityUpdatesResponse),\n/* harmony export */   GetIdentityUpdatesResponse_IdentityUpdateLog: () => (/* binding */ GetIdentityUpdatesResponse_IdentityUpdateLog),\n/* harmony export */   GetIdentityUpdatesResponse_Response: () => (/* binding */ GetIdentityUpdatesResponse_Response),\n/* harmony export */   GetInboxIdsRequest: () => (/* binding */ GetInboxIdsRequest),\n/* harmony export */   GetInboxIdsRequest_Request: () => (/* binding */ GetInboxIdsRequest_Request),\n/* harmony export */   GetInboxIdsResponse: () => (/* binding */ GetInboxIdsResponse),\n/* harmony export */   GetInboxIdsResponse_Response: () => (/* binding */ GetInboxIdsResponse_Response),\n/* harmony export */   IdentityApiClientImpl: () => (/* binding */ IdentityApiClientImpl),\n/* harmony export */   PublishIdentityUpdateRequest: () => (/* binding */ PublishIdentityUpdateRequest),\n/* harmony export */   PublishIdentityUpdateResponse: () => (/* binding */ PublishIdentityUpdateResponse),\n/* harmony export */   UnverifiedSmartContractWalletSignature: () => (/* binding */ UnverifiedSmartContractWalletSignature),\n/* harmony export */   VerifySmartContractWalletSignaturesRequest: () => (/* binding */ VerifySmartContractWalletSignaturesRequest),\n/* harmony export */   VerifySmartContractWalletSignaturesResponse: () => (/* binding */ VerifySmartContractWalletSignaturesResponse),\n/* harmony export */   VerifySmartContractWalletSignaturesResponse_ValidationResponse: () => (/* binding */ VerifySmartContractWalletSignaturesResponse_ValidationResponse),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../associations/signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/signature.pb.js\");\n/* harmony import */ var _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../associations/association.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/association.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.identity.api.v1\";\nfunction createBaseVerifySmartContractWalletSignaturesRequest() {\n    return { signatures: [] };\n}\nconst VerifySmartContractWalletSignaturesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.signatures) {\n            UnverifiedSmartContractWalletSignature.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVerifySmartContractWalletSignaturesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(UnverifiedSmartContractWalletSignature.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => UnverifiedSmartContractWalletSignature.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => e ? UnverifiedSmartContractWalletSignature.toJSON(e) : undefined);\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseVerifySmartContractWalletSignaturesRequest();\n        message.signatures =\n            ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => UnverifiedSmartContractWalletSignature.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseUnverifiedSmartContractWalletSignature() {\n    return { scwSignature: undefined, hash: new Uint8Array() };\n}\nconst UnverifiedSmartContractWalletSignature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.scwSignature !== undefined) {\n            _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__.SmartContractWalletSignature.encode(message.scwSignature, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.hash.length !== 0) {\n            writer.uint32(42).bytes(message.hash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnverifiedSmartContractWalletSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.scwSignature = _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__.SmartContractWalletSignature.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.hash = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            scwSignature: isSet(object.scwSignature)\n                ? _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__.SmartContractWalletSignature.fromJSON(object.scwSignature)\n                : undefined,\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.scwSignature !== undefined &&\n            (obj.scwSignature = message.scwSignature\n                ? _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__.SmartContractWalletSignature.toJSON(message.scwSignature)\n                : undefined);\n        message.hash !== undefined &&\n            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUnverifiedSmartContractWalletSignature();\n        message.scwSignature =\n            object.scwSignature !== undefined && object.scwSignature !== null\n                ? _associations_signature_pb__WEBPACK_IMPORTED_MODULE_1__.SmartContractWalletSignature.fromPartial(object.scwSignature)\n                : undefined;\n        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseVerifySmartContractWalletSignaturesResponse() {\n    return { responses: [] };\n}\nconst VerifySmartContractWalletSignaturesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.responses) {\n            VerifySmartContractWalletSignaturesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVerifySmartContractWalletSignaturesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(VerifySmartContractWalletSignaturesResponse_ValidationResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e\n                ? VerifySmartContractWalletSignaturesResponse_ValidationResponse.toJSON(e)\n                : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseVerifySmartContractWalletSignaturesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse() {\n    return { isValid: false, error: undefined };\n}\nconst VerifySmartContractWalletSignaturesResponse_ValidationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.isValid === true) {\n            writer.uint32(8).bool(message.isValid);\n        }\n        if (message.error !== undefined) {\n            writer.uint32(18).string(message.error);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isValid = reader.bool();\n                    break;\n                case 2:\n                    message.error = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,\n            error: isSet(object.error) ? String(object.error) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isValid !== undefined && (obj.isValid = message.isValid);\n        message.error !== undefined && (obj.error = message.error);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();\n        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;\n        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : undefined;\n        return message;\n    },\n};\nfunction createBasePublishIdentityUpdateRequest() {\n    return { identityUpdate: undefined };\n}\nconst PublishIdentityUpdateRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityUpdate !== undefined) {\n            _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.encode(message.identityUpdate, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublishIdentityUpdateRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityUpdate = _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityUpdate: isSet(object.identityUpdate)\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromJSON(object.identityUpdate)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityUpdate !== undefined &&\n            (obj.identityUpdate = message.identityUpdate\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.toJSON(message.identityUpdate)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePublishIdentityUpdateRequest();\n        message.identityUpdate =\n            object.identityUpdate !== undefined && object.identityUpdate !== null\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromPartial(object.identityUpdate)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePublishIdentityUpdateResponse() {\n    return {};\n}\nconst PublishIdentityUpdateResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublishIdentityUpdateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBasePublishIdentityUpdateResponse();\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesRequest() {\n    return { requests: [] };\n}\nconst GetIdentityUpdatesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.requests) {\n            GetIdentityUpdatesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(GetIdentityUpdatesRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => GetIdentityUpdatesRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? GetIdentityUpdatesRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => GetIdentityUpdatesRequest_Request.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesRequest_Request() {\n    return { inboxId: \"\", sequenceId: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst GetIdentityUpdatesRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        if (!message.sequenceId.isZero()) {\n            writer.uint32(16).uint64(message.sequenceId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                case 2:\n                    message.sequenceId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n            sequenceId: isSet(object.sequenceId)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sequenceId)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        message.sequenceId !== undefined &&\n            (obj.sequenceId = (message.sequenceId || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesRequest_Request();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        message.sequenceId =\n            object.sequenceId !== undefined && object.sequenceId !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sequenceId)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse() {\n    return { responses: [] };\n}\nconst GetIdentityUpdatesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.responses) {\n            GetIdentityUpdatesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(GetIdentityUpdatesResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => GetIdentityUpdatesResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? GetIdentityUpdatesResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => GetIdentityUpdatesResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_IdentityUpdateLog() {\n    return {\n        sequenceId: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        serverTimestampNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        update: undefined,\n    };\n}\nconst GetIdentityUpdatesResponse_IdentityUpdateLog = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.sequenceId.isZero()) {\n            writer.uint32(8).uint64(message.sequenceId);\n        }\n        if (!message.serverTimestampNs.isZero()) {\n            writer.uint32(16).uint64(message.serverTimestampNs);\n        }\n        if (message.update !== undefined) {\n            _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.encode(message.update, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sequenceId = reader.uint64();\n                    break;\n                case 2:\n                    message.serverTimestampNs = reader.uint64();\n                    break;\n                case 3:\n                    message.update = _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sequenceId: isSet(object.sequenceId)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sequenceId)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            serverTimestampNs: isSet(object.serverTimestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.serverTimestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            update: isSet(object.update)\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromJSON(object.update)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sequenceId !== undefined &&\n            (obj.sequenceId = (message.sequenceId || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.serverTimestampNs !== undefined &&\n            (obj.serverTimestampNs = (message.serverTimestampNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.update !== undefined &&\n            (obj.update = message.update\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.toJSON(message.update)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();\n        message.sequenceId =\n            object.sequenceId !== undefined && object.sequenceId !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sequenceId)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.serverTimestampNs =\n            object.serverTimestampNs !== undefined &&\n                object.serverTimestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.serverTimestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.update =\n            object.update !== undefined && object.update !== null\n                ? _associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromPartial(object.update)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_Response() {\n    return { inboxId: \"\", updates: [] };\n}\nconst GetIdentityUpdatesResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        for (const v of message.updates) {\n            GetIdentityUpdatesResponse_IdentityUpdateLog.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                case 2:\n                    message.updates.push(GetIdentityUpdatesResponse_IdentityUpdateLog.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates)\n                ? object.updates.map((e) => GetIdentityUpdatesResponse_IdentityUpdateLog.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        if (message.updates) {\n            obj.updates = message.updates.map((e) => e ? GetIdentityUpdatesResponse_IdentityUpdateLog.toJSON(e) : undefined);\n        }\n        else {\n            obj.updates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetIdentityUpdatesResponse_Response();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        message.updates =\n            ((_b = object.updates) === null || _b === void 0 ? void 0 : _b.map((e) => GetIdentityUpdatesResponse_IdentityUpdateLog.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetInboxIdsRequest() {\n    return { requests: [] };\n}\nconst GetInboxIdsRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.requests) {\n            GetInboxIdsRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetInboxIdsRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(GetInboxIdsRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => GetInboxIdsRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? GetInboxIdsRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetInboxIdsRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => GetInboxIdsRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseGetInboxIdsRequest_Request() {\n    return { address: \"\" };\n}\nconst GetInboxIdsRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetInboxIdsRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetInboxIdsRequest_Request();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetInboxIdsResponse() {\n    return { responses: [] };\n}\nconst GetInboxIdsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.responses) {\n            GetInboxIdsResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetInboxIdsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(GetInboxIdsResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => GetInboxIdsResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? GetInboxIdsResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetInboxIdsResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => GetInboxIdsResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetInboxIdsResponse_Response() {\n    return { address: \"\", inboxId: undefined };\n}\nconst GetInboxIdsResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        if (message.inboxId !== undefined) {\n            writer.uint32(18).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetInboxIdsResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : \"\",\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetInboxIdsResponse_Response();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : \"\";\n        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : undefined;\n        return message;\n    },\n};\nclass IdentityApiClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n        this.PublishIdentityUpdate = this.PublishIdentityUpdate.bind(this);\n        this.GetIdentityUpdates = this.GetIdentityUpdates.bind(this);\n        this.GetInboxIds = this.GetInboxIds.bind(this);\n        this.VerifySmartContractWalletSignatures =\n            this.VerifySmartContractWalletSignatures.bind(this);\n    }\n    PublishIdentityUpdate(request) {\n        const data = PublishIdentityUpdateRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.identity.api.v1.IdentityApi\", \"PublishIdentityUpdate\", data);\n        return promise.then((data) => PublishIdentityUpdateResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    GetIdentityUpdates(request) {\n        const data = GetIdentityUpdatesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.identity.api.v1.IdentityApi\", \"GetIdentityUpdates\", data);\n        return promise.then((data) => GetIdentityUpdatesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    GetInboxIds(request) {\n        const data = GetInboxIdsRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.identity.api.v1.IdentityApi\", \"GetInboxIds\", data);\n        return promise.then((data) => GetInboxIdsResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    VerifySmartContractWalletSignatures(request) {\n        const data = VerifySmartContractWalletSignaturesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.identity.api.v1.IdentityApi\", \"VerifySmartContractWalletSignatures\", data);\n        return promise.then((data) => VerifySmartContractWalletSignaturesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n}\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=identity.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvYXBpL3YxL2lkZW50aXR5LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUN1RDtBQUNaO0FBQzlCO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSxvRkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvRkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9GQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9GQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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ZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvYXBpL3YxL2lkZW50aXR5LnBiLmpzPzY3NzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlIH0gZnJvbSBcIi4uLy4uL2Fzc29jaWF0aW9ucy9zaWduYXR1cmUucGJcIjtcbmltcG9ydCB7IElkZW50aXR5VXBkYXRlIH0gZnJvbSBcIi4uLy4uL2Fzc29jaWF0aW9ucy9hc3NvY2lhdGlvbi5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLmlkZW50aXR5LmFwaS52MVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBzaWduYXR1cmVzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBVbnZlcmlmaWVkU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcy5wdXNoKFVudmVyaWZpZWRTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmVzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5zaWduYXR1cmVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnNpZ25hdHVyZXMubWFwKChlKSA9PiBVbnZlcmlmaWVkU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gbWVzc2FnZS5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZSA/IFVudmVyaWZpZWRTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBVbnZlcmlmaWVkU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VVbnZlcmlmaWVkU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4geyBzY3dTaWduYXR1cmU6IHVuZGVmaW5lZCwgaGFzaDogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IFVudmVyaWZpZWRTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNjd1NpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNjd1NpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MikuYnl0ZXMobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVudmVyaWZpZWRTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zY3dTaWduYXR1cmUgPSBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjd1NpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNjd1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNjd1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhhc2g6IGlzU2V0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNjd1NpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNjd1NpZ25hdHVyZSA9IG1lc3NhZ2Uuc2N3U2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNjd1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmhhc2ggOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVudmVyaWZpZWRTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2N3U2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5zY3dTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2N3U2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5zY3dTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCA9IChfYSA9IG9iamVjdC5oYXNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBtZXNzYWdlLnJlc3BvbnNlcy5tYXAoKGUpID0+IGVcbiAgICAgICAgICAgICAgICA/IFZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLnRvSlNPTihlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlzVmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuYm9vbChtZXNzYWdlLmlzVmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc1ZhbGlkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBpc1NldChvYmplY3QuaXNWYWxpZCkgPyBCb29sZWFuKG9iamVjdC5pc1ZhbGlkKSA6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGlzU2V0KG9iamVjdC5lcnJvcikgPyBTdHJpbmcob2JqZWN0LmVycm9yKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlzVmFsaWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlzVmFsaWQgPSBtZXNzYWdlLmlzVmFsaWQpO1xuICAgICAgICBtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQgJiYgKG9iai5lcnJvciA9IG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5pc1ZhbGlkID0gKF9hID0gb2JqZWN0LmlzVmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmVycm9yID0gKF9iID0gb2JqZWN0LmVycm9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1Ymxpc2hJZGVudGl0eVVwZGF0ZVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgaWRlbnRpdHlVcGRhdGU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFB1Ymxpc2hJZGVudGl0eVVwZGF0ZVJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpdHlVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSWRlbnRpdHlVcGRhdGUuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlVcGRhdGUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaXNoSWRlbnRpdHlVcGRhdGVSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eVVwZGF0ZSA9IElkZW50aXR5VXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW50aXR5VXBkYXRlOiBpc1NldChvYmplY3QuaWRlbnRpdHlVcGRhdGUpXG4gICAgICAgICAgICAgICAgPyBJZGVudGl0eVVwZGF0ZS5mcm9tSlNPTihvYmplY3QuaWRlbnRpdHlVcGRhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eVVwZGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW50aXR5VXBkYXRlID0gbWVzc2FnZS5pZGVudGl0eVVwZGF0ZVxuICAgICAgICAgICAgICAgID8gSWRlbnRpdHlVcGRhdGUudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlVcGRhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVibGlzaElkZW50aXR5VXBkYXRlUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5VXBkYXRlID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eVVwZGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eVVwZGF0ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSWRlbnRpdHlVcGRhdGUuZnJvbVBhcnRpYWwob2JqZWN0LmlkZW50aXR5VXBkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdWJsaXNoSWRlbnRpdHlVcGRhdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnQgY29uc3QgUHVibGlzaElkZW50aXR5VXBkYXRlUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaXNoSWRlbnRpdHlVcGRhdGVSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaXNoSWRlbnRpdHlVcGRhdGVSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1JlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGluYm94SWQ6IFwiXCIsIHNlcXVlbmNlSWQ6IExvbmcuVVpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0X1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5ib3hJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLnNlcXVlbmNlSWQuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnNlcXVlbmNlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmJveElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2VJZCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5ib3hJZDogaXNTZXQob2JqZWN0LmluYm94SWQpID8gU3RyaW5nKG9iamVjdC5pbmJveElkKSA6IFwiXCIsXG4gICAgICAgICAgICBzZXF1ZW5jZUlkOiBpc1NldChvYmplY3Quc2VxdWVuY2VJZClcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5zZXF1ZW5jZUlkKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmluYm94SWQgPSBtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICBtZXNzYWdlLnNlcXVlbmNlSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZXF1ZW5jZUlkID0gKG1lc3NhZ2Uuc2VxdWVuY2VJZCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IChfYSA9IG9iamVjdC5pbmJveElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNlcXVlbmNlSWQgPVxuICAgICAgICAgICAgb2JqZWN0LnNlcXVlbmNlSWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VxdWVuY2VJZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnNlcXVlbmNlSWQpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXNwb25zZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfUmVzcG9uc2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBtZXNzYWdlLnJlc3BvbnNlcy5tYXAoKGUpID0+IGUgPyBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9JZGVudGl0eVVwZGF0ZUxvZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXF1ZW5jZUlkOiBMb25nLlVaRVJPLFxuICAgICAgICBzZXJ2ZXJUaW1lc3RhbXBOczogTG9uZy5VWkVSTyxcbiAgICAgICAgdXBkYXRlOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9JZGVudGl0eVVwZGF0ZUxvZyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2Uuc2VxdWVuY2VJZC5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5zZXF1ZW5jZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2Uuc2VydmVyVGltZXN0YW1wTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnNlcnZlclRpbWVzdGFtcE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSWRlbnRpdHlVcGRhdGUuZW5jb2RlKG1lc3NhZ2UudXBkYXRlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfSWRlbnRpdHlVcGRhdGVMb2coKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlcXVlbmNlSWQgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXJ2ZXJUaW1lc3RhbXBOcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZSA9IElkZW50aXR5VXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlcXVlbmNlSWQ6IGlzU2V0KG9iamVjdC5zZXF1ZW5jZUlkKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnNlcXVlbmNlSWQpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgc2VydmVyVGltZXN0YW1wTnM6IGlzU2V0KG9iamVjdC5zZXJ2ZXJUaW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5zZXJ2ZXJUaW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICB1cGRhdGU6IGlzU2V0KG9iamVjdC51cGRhdGUpXG4gICAgICAgICAgICAgICAgPyBJZGVudGl0eVVwZGF0ZS5mcm9tSlNPTihvYmplY3QudXBkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2VJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlcXVlbmNlSWQgPSAobWVzc2FnZS5zZXF1ZW5jZUlkIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNlcnZlclRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VydmVyVGltZXN0YW1wTnMgPSAobWVzc2FnZS5zZXJ2ZXJUaW1lc3RhbXBOcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51cGRhdGUgPSBtZXNzYWdlLnVwZGF0ZVxuICAgICAgICAgICAgICAgID8gSWRlbnRpdHlVcGRhdGUudG9KU09OKG1lc3NhZ2UudXBkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX0lkZW50aXR5VXBkYXRlTG9nKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2VJZCA9XG4gICAgICAgICAgICBvYmplY3Quc2VxdWVuY2VJZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZXF1ZW5jZUlkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3Quc2VxdWVuY2VJZClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uuc2VydmVyVGltZXN0YW1wTnMgPVxuICAgICAgICAgICAgb2JqZWN0LnNlcnZlclRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VydmVyVGltZXN0YW1wTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5zZXJ2ZXJUaW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlID1cbiAgICAgICAgICAgIG9iamVjdC51cGRhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudXBkYXRlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBJZGVudGl0eVVwZGF0ZS5mcm9tUGFydGlhbChvYmplY3QudXBkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBpbmJveElkOiBcIlwiLCB1cGRhdGVzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluYm94SWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX0lkZW50aXR5VXBkYXRlTG9nLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluYm94SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVzLnB1c2goR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfSWRlbnRpdHlVcGRhdGVMb2cuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluYm94SWQ6IGlzU2V0KG9iamVjdC5pbmJveElkKSA/IFN0cmluZyhvYmplY3QuaW5ib3hJZCkgOiBcIlwiLFxuICAgICAgICAgICAgdXBkYXRlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QudXBkYXRlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC51cGRhdGVzLm1hcCgoZSkgPT4gR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfSWRlbnRpdHlVcGRhdGVMb2cuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmluYm94SWQgPSBtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGVzKSB7XG4gICAgICAgICAgICBvYmoudXBkYXRlcyA9IG1lc3NhZ2UudXBkYXRlcy5tYXAoKGUpID0+IGUgPyBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9JZGVudGl0eVVwZGF0ZUxvZy50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkID0gKF9hID0gb2JqZWN0LmluYm94SWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9iID0gb2JqZWN0LnVwZGF0ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXAoKGUpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX0lkZW50aXR5VXBkYXRlTG9nLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldEluYm94SWRzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJbmJveElkc1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIEdldEluYm94SWRzUmVxdWVzdF9SZXF1ZXN0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SW5ib3hJZHNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKEdldEluYm94SWRzUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBHZXRJbmJveElkc1JlcXVlc3RfUmVxdWVzdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBtZXNzYWdlLnJlcXVlc3RzLm1hcCgoZSkgPT4gZSA/IEdldEluYm94SWRzUmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJbmJveElkc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBHZXRJbmJveElkc1JlcXVlc3RfUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldEluYm94SWRzUmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGFkZHJlc3M6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJbmJveElkc1JlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEluYm94SWRzUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBpc1NldChvYmplY3QuYWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LmFkZHJlc3MpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFkZHJlc3MgPSBtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJbmJveElkc1JlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSAoX2EgPSBvYmplY3QuYWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SW5ib3hJZHNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgR2V0SW5ib3hJZHNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIEdldEluYm94SWRzUmVzcG9uc2VfUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJbmJveElkc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChHZXRJbmJveElkc1Jlc3BvbnNlX1Jlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBHZXRJbmJveElkc1Jlc3BvbnNlX1Jlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gR2V0SW5ib3hJZHNSZXNwb25zZV9SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEluYm94SWRzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXNwb25zZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEdldEluYm94SWRzUmVzcG9uc2VfUmVzcG9uc2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SW5ib3hJZHNSZXNwb25zZV9SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBhZGRyZXNzOiBcIlwiLCBpbmJveElkOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJbmJveElkc1Jlc3BvbnNlX1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJbmJveElkc1Jlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5hZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgICAgICBpbmJveElkOiBpc1NldChvYmplY3QuaW5ib3hJZCkgPyBTdHJpbmcob2JqZWN0LmluYm94SWQpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWRkcmVzcyA9IG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5ib3hJZCA9IG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJbmJveElkc1Jlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IChfYSA9IG9iamVjdC5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgPSAoX2IgPSBvYmplY3QuaW5ib3hJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmV4cG9ydCBjbGFzcyBJZGVudGl0eUFwaUNsaWVudEltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJwYykge1xuICAgICAgICB0aGlzLnJwYyA9IHJwYztcbiAgICAgICAgdGhpcy5QdWJsaXNoSWRlbnRpdHlVcGRhdGUgPSB0aGlzLlB1Ymxpc2hJZGVudGl0eVVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLkdldElkZW50aXR5VXBkYXRlcyA9IHRoaXMuR2V0SWRlbnRpdHlVcGRhdGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuR2V0SW5ib3hJZHMgPSB0aGlzLkdldEluYm94SWRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXMgPVxuICAgICAgICAgICAgdGhpcy5WZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlcy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBQdWJsaXNoSWRlbnRpdHlVcGRhdGUocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gUHVibGlzaElkZW50aXR5VXBkYXRlUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5pZGVudGl0eS5hcGkudjEuSWRlbnRpdHlBcGlcIiwgXCJQdWJsaXNoSWRlbnRpdHlVcGRhdGVcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IFB1Ymxpc2hJZGVudGl0eVVwZGF0ZVJlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBHZXRJZGVudGl0eVVwZGF0ZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5pZGVudGl0eS5hcGkudjEuSWRlbnRpdHlBcGlcIiwgXCJHZXRJZGVudGl0eVVwZGF0ZXNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBHZXRJbmJveElkcyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBHZXRJbmJveElkc1JlcXVlc3QuZW5jb2RlKHJlcXVlc3QpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ycGMucmVxdWVzdChcInhtdHAuaWRlbnRpdHkuYXBpLnYxLklkZW50aXR5QXBpXCIsIFwiR2V0SW5ib3hJZHNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IEdldEluYm94SWRzUmVzcG9uc2UuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIFZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5pZGVudGl0eS5hcGkudjEuSWRlbnRpdHlBcGlcIiwgXCJWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXNwb25zZS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKTtcbiAgICB9XG59XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGVudGl0eS5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/api/v1/identity.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/association.pb.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/association.pb.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddAssociation: () => (/* binding */ AddAssociation),\n/* harmony export */   AssociationState: () => (/* binding */ AssociationState),\n/* harmony export */   AssociationStateDiff: () => (/* binding */ AssociationStateDiff),\n/* harmony export */   ChangeRecoveryAddress: () => (/* binding */ ChangeRecoveryAddress),\n/* harmony export */   CreateInbox: () => (/* binding */ CreateInbox),\n/* harmony export */   IdentityAction: () => (/* binding */ IdentityAction),\n/* harmony export */   IdentityUpdate: () => (/* binding */ IdentityUpdate),\n/* harmony export */   Member: () => (/* binding */ Member),\n/* harmony export */   MemberIdentifier: () => (/* binding */ MemberIdentifier),\n/* harmony export */   MemberMap: () => (/* binding */ MemberMap),\n/* harmony export */   RevokeAssociation: () => (/* binding */ RevokeAssociation),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.identity.associations\";\nfunction createBaseMemberIdentifier() {\n    return { address: undefined, installationPublicKey: undefined };\n}\nconst MemberIdentifier = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.address !== undefined) {\n            writer.uint32(10).string(message.address);\n        }\n        if (message.installationPublicKey !== undefined) {\n            writer.uint32(18).bytes(message.installationPublicKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMemberIdentifier();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.installationPublicKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : undefined,\n            installationPublicKey: isSet(object.installationPublicKey)\n                ? bytesFromBase64(object.installationPublicKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        message.installationPublicKey !== undefined &&\n            (obj.installationPublicKey =\n                message.installationPublicKey !== undefined\n                    ? base64FromBytes(message.installationPublicKey)\n                    : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMemberIdentifier();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : undefined;\n        message.installationPublicKey = (_b = object.installationPublicKey) !== null && _b !== void 0 ? _b : undefined;\n        return message;\n    },\n};\nfunction createBaseMember() {\n    return {\n        identifier: undefined,\n        addedByEntity: undefined,\n        clientTimestampNs: undefined,\n    };\n}\nconst Member = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.identifier !== undefined) {\n            MemberIdentifier.encode(message.identifier, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.addedByEntity !== undefined) {\n            MemberIdentifier.encode(message.addedByEntity, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.clientTimestampNs !== undefined) {\n            writer.uint32(24).uint64(message.clientTimestampNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMember();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identifier = MemberIdentifier.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.addedByEntity = MemberIdentifier.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.clientTimestampNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identifier: isSet(object.identifier)\n                ? MemberIdentifier.fromJSON(object.identifier)\n                : undefined,\n            addedByEntity: isSet(object.addedByEntity)\n                ? MemberIdentifier.fromJSON(object.addedByEntity)\n                : undefined,\n            clientTimestampNs: isSet(object.clientTimestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.clientTimestampNs)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identifier !== undefined &&\n            (obj.identifier = message.identifier\n                ? MemberIdentifier.toJSON(message.identifier)\n                : undefined);\n        message.addedByEntity !== undefined &&\n            (obj.addedByEntity = message.addedByEntity\n                ? MemberIdentifier.toJSON(message.addedByEntity)\n                : undefined);\n        message.clientTimestampNs !== undefined &&\n            (obj.clientTimestampNs = (message.clientTimestampNs || undefined).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMember();\n        message.identifier =\n            object.identifier !== undefined && object.identifier !== null\n                ? MemberIdentifier.fromPartial(object.identifier)\n                : undefined;\n        message.addedByEntity =\n            object.addedByEntity !== undefined && object.addedByEntity !== null\n                ? MemberIdentifier.fromPartial(object.addedByEntity)\n                : undefined;\n        message.clientTimestampNs =\n            object.clientTimestampNs !== undefined &&\n                object.clientTimestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.clientTimestampNs)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateInbox() {\n    return {\n        initialAddress: \"\",\n        nonce: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        initialAddressSignature: undefined,\n    };\n}\nconst CreateInbox = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.initialAddress !== \"\") {\n            writer.uint32(10).string(message.initialAddress);\n        }\n        if (!message.nonce.isZero()) {\n            writer.uint32(16).uint64(message.nonce);\n        }\n        if (message.initialAddressSignature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.initialAddressSignature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateInbox();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.initialAddress = reader.string();\n                    break;\n                case 2:\n                    message.nonce = reader.uint64();\n                    break;\n                case 3:\n                    message.initialAddressSignature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            initialAddress: isSet(object.initialAddress)\n                ? String(object.initialAddress)\n                : \"\",\n            nonce: isSet(object.nonce) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.nonce) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            initialAddressSignature: isSet(object.initialAddressSignature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.initialAddressSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.initialAddress !== undefined &&\n            (obj.initialAddress = message.initialAddress);\n        message.nonce !== undefined &&\n            (obj.nonce = (message.nonce || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.initialAddressSignature !== undefined &&\n            (obj.initialAddressSignature = message.initialAddressSignature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.initialAddressSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseCreateInbox();\n        message.initialAddress = (_a = object.initialAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.nonce =\n            object.nonce !== undefined && object.nonce !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.nonce)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.initialAddressSignature =\n            object.initialAddressSignature !== undefined &&\n                object.initialAddressSignature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.initialAddressSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAddAssociation() {\n    return {\n        newMemberIdentifier: undefined,\n        existingMemberSignature: undefined,\n        newMemberSignature: undefined,\n    };\n}\nconst AddAssociation = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.newMemberIdentifier !== undefined) {\n            MemberIdentifier.encode(message.newMemberIdentifier, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.existingMemberSignature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.existingMemberSignature, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.newMemberSignature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.newMemberSignature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAddAssociation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.newMemberIdentifier = MemberIdentifier.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.existingMemberSignature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.newMemberSignature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            newMemberIdentifier: isSet(object.newMemberIdentifier)\n                ? MemberIdentifier.fromJSON(object.newMemberIdentifier)\n                : undefined,\n            existingMemberSignature: isSet(object.existingMemberSignature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.existingMemberSignature)\n                : undefined,\n            newMemberSignature: isSet(object.newMemberSignature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.newMemberSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.newMemberIdentifier !== undefined &&\n            (obj.newMemberIdentifier = message.newMemberIdentifier\n                ? MemberIdentifier.toJSON(message.newMemberIdentifier)\n                : undefined);\n        message.existingMemberSignature !== undefined &&\n            (obj.existingMemberSignature = message.existingMemberSignature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.existingMemberSignature)\n                : undefined);\n        message.newMemberSignature !== undefined &&\n            (obj.newMemberSignature = message.newMemberSignature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.newMemberSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAddAssociation();\n        message.newMemberIdentifier =\n            object.newMemberIdentifier !== undefined &&\n                object.newMemberIdentifier !== null\n                ? MemberIdentifier.fromPartial(object.newMemberIdentifier)\n                : undefined;\n        message.existingMemberSignature =\n            object.existingMemberSignature !== undefined &&\n                object.existingMemberSignature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.existingMemberSignature)\n                : undefined;\n        message.newMemberSignature =\n            object.newMemberSignature !== undefined &&\n                object.newMemberSignature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.newMemberSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseRevokeAssociation() {\n    return { memberToRevoke: undefined, recoveryAddressSignature: undefined };\n}\nconst RevokeAssociation = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.memberToRevoke !== undefined) {\n            MemberIdentifier.encode(message.memberToRevoke, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recoveryAddressSignature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.recoveryAddressSignature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRevokeAssociation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.memberToRevoke = MemberIdentifier.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recoveryAddressSignature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            memberToRevoke: isSet(object.memberToRevoke)\n                ? MemberIdentifier.fromJSON(object.memberToRevoke)\n                : undefined,\n            recoveryAddressSignature: isSet(object.recoveryAddressSignature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.recoveryAddressSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.memberToRevoke !== undefined &&\n            (obj.memberToRevoke = message.memberToRevoke\n                ? MemberIdentifier.toJSON(message.memberToRevoke)\n                : undefined);\n        message.recoveryAddressSignature !== undefined &&\n            (obj.recoveryAddressSignature = message.recoveryAddressSignature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.recoveryAddressSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseRevokeAssociation();\n        message.memberToRevoke =\n            object.memberToRevoke !== undefined && object.memberToRevoke !== null\n                ? MemberIdentifier.fromPartial(object.memberToRevoke)\n                : undefined;\n        message.recoveryAddressSignature =\n            object.recoveryAddressSignature !== undefined &&\n                object.recoveryAddressSignature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.recoveryAddressSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseChangeRecoveryAddress() {\n    return {\n        newRecoveryAddress: \"\",\n        existingRecoveryAddressSignature: undefined,\n    };\n}\nconst ChangeRecoveryAddress = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.newRecoveryAddress !== \"\") {\n            writer.uint32(10).string(message.newRecoveryAddress);\n        }\n        if (message.existingRecoveryAddressSignature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.existingRecoveryAddressSignature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseChangeRecoveryAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.newRecoveryAddress = reader.string();\n                    break;\n                case 2:\n                    message.existingRecoveryAddressSignature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            newRecoveryAddress: isSet(object.newRecoveryAddress)\n                ? String(object.newRecoveryAddress)\n                : \"\",\n            existingRecoveryAddressSignature: isSet(object.existingRecoveryAddressSignature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.existingRecoveryAddressSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.newRecoveryAddress !== undefined &&\n            (obj.newRecoveryAddress = message.newRecoveryAddress);\n        message.existingRecoveryAddressSignature !== undefined &&\n            (obj.existingRecoveryAddressSignature =\n                message.existingRecoveryAddressSignature\n                    ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.existingRecoveryAddressSignature)\n                    : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseChangeRecoveryAddress();\n        message.newRecoveryAddress = (_a = object.newRecoveryAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.existingRecoveryAddressSignature =\n            object.existingRecoveryAddressSignature !== undefined &&\n                object.existingRecoveryAddressSignature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.existingRecoveryAddressSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseIdentityAction() {\n    return {\n        createInbox: undefined,\n        add: undefined,\n        revoke: undefined,\n        changeRecoveryAddress: undefined,\n    };\n}\nconst IdentityAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.createInbox !== undefined) {\n            CreateInbox.encode(message.createInbox, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.add !== undefined) {\n            AddAssociation.encode(message.add, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.revoke !== undefined) {\n            RevokeAssociation.encode(message.revoke, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.changeRecoveryAddress !== undefined) {\n            ChangeRecoveryAddress.encode(message.changeRecoveryAddress, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIdentityAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createInbox = CreateInbox.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.add = AddAssociation.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.revoke = RevokeAssociation.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.changeRecoveryAddress = ChangeRecoveryAddress.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createInbox: isSet(object.createInbox)\n                ? CreateInbox.fromJSON(object.createInbox)\n                : undefined,\n            add: isSet(object.add) ? AddAssociation.fromJSON(object.add) : undefined,\n            revoke: isSet(object.revoke)\n                ? RevokeAssociation.fromJSON(object.revoke)\n                : undefined,\n            changeRecoveryAddress: isSet(object.changeRecoveryAddress)\n                ? ChangeRecoveryAddress.fromJSON(object.changeRecoveryAddress)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createInbox !== undefined &&\n            (obj.createInbox = message.createInbox\n                ? CreateInbox.toJSON(message.createInbox)\n                : undefined);\n        message.add !== undefined &&\n            (obj.add = message.add ? AddAssociation.toJSON(message.add) : undefined);\n        message.revoke !== undefined &&\n            (obj.revoke = message.revoke\n                ? RevokeAssociation.toJSON(message.revoke)\n                : undefined);\n        message.changeRecoveryAddress !== undefined &&\n            (obj.changeRecoveryAddress = message.changeRecoveryAddress\n                ? ChangeRecoveryAddress.toJSON(message.changeRecoveryAddress)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseIdentityAction();\n        message.createInbox =\n            object.createInbox !== undefined && object.createInbox !== null\n                ? CreateInbox.fromPartial(object.createInbox)\n                : undefined;\n        message.add =\n            object.add !== undefined && object.add !== null\n                ? AddAssociation.fromPartial(object.add)\n                : undefined;\n        message.revoke =\n            object.revoke !== undefined && object.revoke !== null\n                ? RevokeAssociation.fromPartial(object.revoke)\n                : undefined;\n        message.changeRecoveryAddress =\n            object.changeRecoveryAddress !== undefined &&\n                object.changeRecoveryAddress !== null\n                ? ChangeRecoveryAddress.fromPartial(object.changeRecoveryAddress)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseIdentityUpdate() {\n    return { actions: [], clientTimestampNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, inboxId: \"\" };\n}\nconst IdentityUpdate = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.actions) {\n            IdentityAction.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (!message.clientTimestampNs.isZero()) {\n            writer.uint32(16).uint64(message.clientTimestampNs);\n        }\n        if (message.inboxId !== \"\") {\n            writer.uint32(26).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIdentityUpdate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.actions.push(IdentityAction.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.clientTimestampNs = reader.uint64();\n                    break;\n                case 3:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            actions: Array.isArray(object === null || object === void 0 ? void 0 : object.actions)\n                ? object.actions.map((e) => IdentityAction.fromJSON(e))\n                : [],\n            clientTimestampNs: isSet(object.clientTimestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.clientTimestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.actions) {\n            obj.actions = message.actions.map((e) => e ? IdentityAction.toJSON(e) : undefined);\n        }\n        else {\n            obj.actions = [];\n        }\n        message.clientTimestampNs !== undefined &&\n            (obj.clientTimestampNs = (message.clientTimestampNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseIdentityUpdate();\n        message.actions =\n            ((_a = object.actions) === null || _a === void 0 ? void 0 : _a.map((e) => IdentityAction.fromPartial(e))) || [];\n        message.clientTimestampNs =\n            object.clientTimestampNs !== undefined &&\n                object.clientTimestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.clientTimestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMemberMap() {\n    return { key: undefined, value: undefined };\n}\nconst MemberMap = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.key !== undefined) {\n            MemberIdentifier.encode(message.key, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.value !== undefined) {\n            Member.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMemberMap();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = MemberIdentifier.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.value = Member.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key)\n                ? MemberIdentifier.fromJSON(object.key)\n                : undefined,\n            value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = message.key\n                ? MemberIdentifier.toJSON(message.key)\n                : undefined);\n        message.value !== undefined &&\n            (obj.value = message.value ? Member.toJSON(message.value) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMemberMap();\n        message.key =\n            object.key !== undefined && object.key !== null\n                ? MemberIdentifier.fromPartial(object.key)\n                : undefined;\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? Member.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAssociationState() {\n    return { inboxId: \"\", members: [], recoveryAddress: \"\", seenSignatures: [] };\n}\nconst AssociationState = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        for (const v of message.members) {\n            MemberMap.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.recoveryAddress !== \"\") {\n            writer.uint32(26).string(message.recoveryAddress);\n        }\n        for (const v of message.seenSignatures) {\n            writer.uint32(34).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAssociationState();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                case 2:\n                    message.members.push(MemberMap.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.recoveryAddress = reader.string();\n                    break;\n                case 4:\n                    message.seenSignatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n            members: Array.isArray(object === null || object === void 0 ? void 0 : object.members)\n                ? object.members.map((e) => MemberMap.fromJSON(e))\n                : [],\n            recoveryAddress: isSet(object.recoveryAddress)\n                ? String(object.recoveryAddress)\n                : \"\",\n            seenSignatures: Array.isArray(object === null || object === void 0 ? void 0 : object.seenSignatures)\n                ? object.seenSignatures.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        if (message.members) {\n            obj.members = message.members.map((e) => e ? MemberMap.toJSON(e) : undefined);\n        }\n        else {\n            obj.members = [];\n        }\n        message.recoveryAddress !== undefined &&\n            (obj.recoveryAddress = message.recoveryAddress);\n        if (message.seenSignatures) {\n            obj.seenSignatures = message.seenSignatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.seenSignatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseAssociationState();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        message.members =\n            ((_b = object.members) === null || _b === void 0 ? void 0 : _b.map((e) => MemberMap.fromPartial(e))) || [];\n        message.recoveryAddress = (_c = object.recoveryAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.seenSignatures = ((_d = object.seenSignatures) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseAssociationStateDiff() {\n    return { newMembers: [], removedMembers: [] };\n}\nconst AssociationStateDiff = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.newMembers) {\n            MemberIdentifier.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.removedMembers) {\n            MemberIdentifier.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAssociationStateDiff();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.newMembers.push(MemberIdentifier.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.removedMembers.push(MemberIdentifier.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            newMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.newMembers)\n                ? object.newMembers.map((e) => MemberIdentifier.fromJSON(e))\n                : [],\n            removedMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.removedMembers)\n                ? object.removedMembers.map((e) => MemberIdentifier.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.newMembers) {\n            obj.newMembers = message.newMembers.map((e) => e ? MemberIdentifier.toJSON(e) : undefined);\n        }\n        else {\n            obj.newMembers = [];\n        }\n        if (message.removedMembers) {\n            obj.removedMembers = message.removedMembers.map((e) => e ? MemberIdentifier.toJSON(e) : undefined);\n        }\n        else {\n            obj.removedMembers = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseAssociationStateDiff();\n        message.newMembers =\n            ((_a = object.newMembers) === null || _a === void 0 ? void 0 : _a.map((e) => MemberIdentifier.fromPartial(e))) || [];\n        message.removedMembers =\n            ((_b = object.removedMembers) === null || _b === void 0 ? void 0 : _b.map((e) => MemberIdentifier.fromPartial(e))) || [];\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=association.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvYXNzb2NpYXRpb25zL2Fzc29jaWF0aW9uLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNtQjtBQUNOO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvYXNzb2NpYXRpb25zL2Fzc29jaWF0aW9uLnBiLmpzP2MwZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5pZGVudGl0eS5hc3NvY2lhdGlvbnNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZW1iZXJJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB7IGFkZHJlc3M6IHVuZGVmaW5lZCwgaW5zdGFsbGF0aW9uUHVibGljS2V5OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBNZW1iZXJJZGVudGlmaWVyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lbWJlcklkZW50aWZpZXIoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5hZGRyZXNzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGluc3RhbGxhdGlvblB1YmxpY0tleTogaXNTZXQob2JqZWN0Lmluc3RhbGxhdGlvblB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaW5zdGFsbGF0aW9uUHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWRkcmVzcyA9IG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaW5zdGFsbGF0aW9uUHVibGljS2V5ID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvblB1YmxpY0tleSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZW1iZXJJZGVudGlmaWVyKCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IChfYSA9IG9iamVjdC5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ID0gKF9iID0gb2JqZWN0Lmluc3RhbGxhdGlvblB1YmxpY0tleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZW1iZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogdW5kZWZpbmVkLFxuICAgICAgICBhZGRlZEJ5RW50aXR5OiB1bmRlZmluZWQsXG4gICAgICAgIGNsaWVudFRpbWVzdGFtcE5zOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBNZW1iZXIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpZmllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZW1iZXJJZGVudGlmaWVyLmVuY29kZShtZXNzYWdlLmlkZW50aWZpZXIsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkZWRCeUVudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZW1iZXJJZGVudGlmaWVyLmVuY29kZShtZXNzYWdlLmFkZGVkQnlFbnRpdHksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2xpZW50VGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2UuY2xpZW50VGltZXN0YW1wTnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVtYmVyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGlmaWVyID0gTWVtYmVySWRlbnRpZmllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkZWRCeUVudGl0eSA9IE1lbWJlcklkZW50aWZpZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsaWVudFRpbWVzdGFtcE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiBpc1NldChvYmplY3QuaWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbUpTT04ob2JqZWN0LmlkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhZGRlZEJ5RW50aXR5OiBpc1NldChvYmplY3QuYWRkZWRCeUVudGl0eSlcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbUpTT04ob2JqZWN0LmFkZGVkQnlFbnRpdHkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjbGllbnRUaW1lc3RhbXBOczogaXNTZXQob2JqZWN0LmNsaWVudFRpbWVzdGFtcE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNsaWVudFRpbWVzdGFtcE5zKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpZmllciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW50aWZpZXIgPSBtZXNzYWdlLmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIudG9KU09OKG1lc3NhZ2UuaWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkZWRCeUVudGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFkZGVkQnlFbnRpdHkgPSBtZXNzYWdlLmFkZGVkQnlFbnRpdHlcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIudG9KU09OKG1lc3NhZ2UuYWRkZWRCeUVudGl0eSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY2xpZW50VGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jbGllbnRUaW1lc3RhbXBOcyA9IChtZXNzYWdlLmNsaWVudFRpbWVzdGFtcE5zIHx8IHVuZGVmaW5lZCkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZW1iZXIoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGlmaWVyID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGlmaWVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlkZW50aWZpZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbVBhcnRpYWwob2JqZWN0LmlkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYWRkZWRCeUVudGl0eSA9XG4gICAgICAgICAgICBvYmplY3QuYWRkZWRCeUVudGl0eSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hZGRlZEJ5RW50aXR5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBNZW1iZXJJZGVudGlmaWVyLmZyb21QYXJ0aWFsKG9iamVjdC5hZGRlZEJ5RW50aXR5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNsaWVudFRpbWVzdGFtcE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jbGllbnRUaW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmNsaWVudFRpbWVzdGFtcE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY2xpZW50VGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNyZWF0ZUluYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluaXRpYWxBZGRyZXNzOiBcIlwiLFxuICAgICAgICBub25jZTogTG9uZy5VWkVSTyxcbiAgICAgICAgaW5pdGlhbEFkZHJlc3NTaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IENyZWF0ZUluYm94ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5pbml0aWFsQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLm5vbmNlLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS5ub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbEFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLmluaXRpYWxBZGRyZXNzU2lnbmF0dXJlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlSW5ib3goKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uY2UgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsQWRkcmVzc1NpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWFsQWRkcmVzczogaXNTZXQob2JqZWN0LmluaXRpYWxBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5pbml0aWFsQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBub25jZTogaXNTZXQob2JqZWN0Lm5vbmNlKSA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5ub25jZSkgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgaW5pdGlhbEFkZHJlc3NTaWduYXR1cmU6IGlzU2V0KG9iamVjdC5pbml0aWFsQWRkcmVzc1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3QuaW5pdGlhbEFkZHJlc3NTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbml0aWFsQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluaXRpYWxBZGRyZXNzID0gbWVzc2FnZS5pbml0aWFsQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2Uubm9uY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ub25jZSA9IChtZXNzYWdlLm5vbmNlIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxBZGRyZXNzU2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaW5pdGlhbEFkZHJlc3NTaWduYXR1cmUgPSBtZXNzYWdlLmluaXRpYWxBZGRyZXNzU2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2UuaW5pdGlhbEFkZHJlc3NTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDcmVhdGVJbmJveCgpO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxBZGRyZXNzID0gKF9hID0gb2JqZWN0LmluaXRpYWxBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm5vbmNlID1cbiAgICAgICAgICAgIG9iamVjdC5ub25jZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ub25jZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0Lm5vbmNlKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5pbml0aWFsQWRkcmVzc1NpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3QuaW5pdGlhbEFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsQWRkcmVzc1NpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5pbml0aWFsQWRkcmVzc1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQWRkQXNzb2NpYXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV3TWVtYmVySWRlbnRpZmllcjogdW5kZWZpbmVkLFxuICAgICAgICBleGlzdGluZ01lbWJlclNpZ25hdHVyZTogdW5kZWZpbmVkLFxuICAgICAgICBuZXdNZW1iZXJTaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IEFkZEFzc29jaWF0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm5ld01lbWJlcklkZW50aWZpZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWVtYmVySWRlbnRpZmllci5lbmNvZGUobWVzc2FnZS5uZXdNZW1iZXJJZGVudGlmaWVyLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmV4aXN0aW5nTWVtYmVyU2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5leGlzdGluZ01lbWJlclNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uZXdNZW1iZXJTaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLm5ld01lbWJlclNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZEFzc29jaWF0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uZXdNZW1iZXJJZGVudGlmaWVyID0gTWVtYmVySWRlbnRpZmllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3RpbmdNZW1iZXJTaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5ld01lbWJlclNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXdNZW1iZXJJZGVudGlmaWVyOiBpc1NldChvYmplY3QubmV3TWVtYmVySWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbUpTT04ob2JqZWN0Lm5ld01lbWJlcklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBleGlzdGluZ01lbWJlclNpZ25hdHVyZTogaXNTZXQob2JqZWN0LmV4aXN0aW5nTWVtYmVyU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5leGlzdGluZ01lbWJlclNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5ld01lbWJlclNpZ25hdHVyZTogaXNTZXQob2JqZWN0Lm5ld01lbWJlclNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3QubmV3TWVtYmVyU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubmV3TWVtYmVySWRlbnRpZmllciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm5ld01lbWJlcklkZW50aWZpZXIgPSBtZXNzYWdlLm5ld01lbWJlcklkZW50aWZpZXJcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIudG9KU09OKG1lc3NhZ2UubmV3TWVtYmVySWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZXhpc3RpbmdNZW1iZXJTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5leGlzdGluZ01lbWJlclNpZ25hdHVyZSA9IG1lc3NhZ2UuZXhpc3RpbmdNZW1iZXJTaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5leGlzdGluZ01lbWJlclNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubmV3TWVtYmVyU2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubmV3TWVtYmVyU2lnbmF0dXJlID0gbWVzc2FnZS5uZXdNZW1iZXJTaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5uZXdNZW1iZXJTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQWRkQXNzb2NpYXRpb24oKTtcbiAgICAgICAgbWVzc2FnZS5uZXdNZW1iZXJJZGVudGlmaWVyID1cbiAgICAgICAgICAgIG9iamVjdC5uZXdNZW1iZXJJZGVudGlmaWVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QubmV3TWVtYmVySWRlbnRpZmllciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTWVtYmVySWRlbnRpZmllci5mcm9tUGFydGlhbChvYmplY3QubmV3TWVtYmVySWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5leGlzdGluZ01lbWJlclNpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3QuZXhpc3RpbmdNZW1iZXJTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5leGlzdGluZ01lbWJlclNpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5leGlzdGluZ01lbWJlclNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5uZXdNZW1iZXJTaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0Lm5ld01lbWJlclNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5ld01lbWJlclNpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5uZXdNZW1iZXJTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJldm9rZUFzc29jaWF0aW9uKCkge1xuICAgIHJldHVybiB7IG1lbWJlclRvUmV2b2tlOiB1bmRlZmluZWQsIHJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUmV2b2tlQXNzb2NpYXRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVtYmVyVG9SZXZva2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWVtYmVySWRlbnRpZmllci5lbmNvZGUobWVzc2FnZS5tZW1iZXJUb1Jldm9rZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJldm9rZUFzc29jaWF0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZW1iZXJUb1Jldm9rZSA9IE1lbWJlcklkZW50aWZpZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZW1iZXJUb1Jldm9rZTogaXNTZXQob2JqZWN0Lm1lbWJlclRvUmV2b2tlKVxuICAgICAgICAgICAgICAgID8gTWVtYmVySWRlbnRpZmllci5mcm9tSlNPTihvYmplY3QubWVtYmVyVG9SZXZva2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWNvdmVyeUFkZHJlc3NTaWduYXR1cmU6IGlzU2V0KG9iamVjdC5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm1lbWJlclRvUmV2b2tlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWVtYmVyVG9SZXZva2UgPSBtZXNzYWdlLm1lbWJlclRvUmV2b2tlXG4gICAgICAgICAgICAgICAgPyBNZW1iZXJJZGVudGlmaWVyLnRvSlNPTihtZXNzYWdlLm1lbWJlclRvUmV2b2tlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgPSBtZXNzYWdlLnJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnJlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZXZva2VBc3NvY2lhdGlvbigpO1xuICAgICAgICBtZXNzYWdlLm1lbWJlclRvUmV2b2tlID1cbiAgICAgICAgICAgIG9iamVjdC5tZW1iZXJUb1Jldm9rZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tZW1iZXJUb1Jldm9rZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTWVtYmVySWRlbnRpZmllci5mcm9tUGFydGlhbChvYmplY3QubWVtYmVyVG9SZXZva2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5yZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3QucmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDaGFuZ2VSZWNvdmVyeUFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV3UmVjb3ZlcnlBZGRyZXNzOiBcIlwiLFxuICAgICAgICBleGlzdGluZ1JlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgQ2hhbmdlUmVjb3ZlcnlBZGRyZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm5ld1JlY292ZXJ5QWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UubmV3UmVjb3ZlcnlBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5leGlzdGluZ1JlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmUuZW5jb2RlKG1lc3NhZ2UuZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDaGFuZ2VSZWNvdmVyeUFkZHJlc3MoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5ld1JlY292ZXJ5QWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0aW5nUmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlID0gU2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5ld1JlY292ZXJ5QWRkcmVzczogaXNTZXQob2JqZWN0Lm5ld1JlY292ZXJ5QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QubmV3UmVjb3ZlcnlBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGV4aXN0aW5nUmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlOiBpc1NldChvYmplY3QuZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LmV4aXN0aW5nUmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubmV3UmVjb3ZlcnlBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubmV3UmVjb3ZlcnlBZGRyZXNzID0gbWVzc2FnZS5uZXdSZWNvdmVyeUFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmV4aXN0aW5nUmVjb3ZlcnlBZGRyZXNzU2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgPVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2UuZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2hhbmdlUmVjb3ZlcnlBZGRyZXNzKCk7XG4gICAgICAgIG1lc3NhZ2UubmV3UmVjb3ZlcnlBZGRyZXNzID0gKF9hID0gb2JqZWN0Lm5ld1JlY292ZXJ5QWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5leGlzdGluZ1JlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSA9XG4gICAgICAgICAgICBvYmplY3QuZXhpc3RpbmdSZWNvdmVyeUFkZHJlc3NTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5leGlzdGluZ1JlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5leGlzdGluZ1JlY292ZXJ5QWRkcmVzc1NpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSWRlbnRpdHlBY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlSW5ib3g6IHVuZGVmaW5lZCxcbiAgICAgICAgYWRkOiB1bmRlZmluZWQsXG4gICAgICAgIHJldm9rZTogdW5kZWZpbmVkLFxuICAgICAgICBjaGFuZ2VSZWNvdmVyeUFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IElkZW50aXR5QWN0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNyZWF0ZUluYm94ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENyZWF0ZUluYm94LmVuY29kZShtZXNzYWdlLmNyZWF0ZUluYm94LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBBZGRBc3NvY2lhdGlvbi5lbmNvZGUobWVzc2FnZS5hZGQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmV2b2tlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFJldm9rZUFzc29jaWF0aW9uLmVuY29kZShtZXNzYWdlLnJldm9rZSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jaGFuZ2VSZWNvdmVyeUFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2hhbmdlUmVjb3ZlcnlBZGRyZXNzLmVuY29kZShtZXNzYWdlLmNoYW5nZVJlY292ZXJ5QWRkcmVzcywgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUlkZW50aXR5QWN0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVJbmJveCA9IENyZWF0ZUluYm94LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGQgPSBBZGRBc3NvY2lhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmV2b2tlID0gUmV2b2tlQXNzb2NpYXRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYW5nZVJlY292ZXJ5QWRkcmVzcyA9IENoYW5nZVJlY292ZXJ5QWRkcmVzcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVJbmJveDogaXNTZXQob2JqZWN0LmNyZWF0ZUluYm94KVxuICAgICAgICAgICAgICAgID8gQ3JlYXRlSW5ib3guZnJvbUpTT04ob2JqZWN0LmNyZWF0ZUluYm94KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWRkOiBpc1NldChvYmplY3QuYWRkKSA/IEFkZEFzc29jaWF0aW9uLmZyb21KU09OKG9iamVjdC5hZGQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV2b2tlOiBpc1NldChvYmplY3QucmV2b2tlKVxuICAgICAgICAgICAgICAgID8gUmV2b2tlQXNzb2NpYXRpb24uZnJvbUpTT04ob2JqZWN0LnJldm9rZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYW5nZVJlY292ZXJ5QWRkcmVzczogaXNTZXQob2JqZWN0LmNoYW5nZVJlY292ZXJ5QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IENoYW5nZVJlY292ZXJ5QWRkcmVzcy5mcm9tSlNPTihvYmplY3QuY2hhbmdlUmVjb3ZlcnlBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlSW5ib3ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVJbmJveCA9IG1lc3NhZ2UuY3JlYXRlSW5ib3hcbiAgICAgICAgICAgICAgICA/IENyZWF0ZUluYm94LnRvSlNPTihtZXNzYWdlLmNyZWF0ZUluYm94KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5hZGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZGQgPSBtZXNzYWdlLmFkZCA/IEFkZEFzc29jaWF0aW9uLnRvSlNPTihtZXNzYWdlLmFkZCkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnJldm9rZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJldm9rZSA9IG1lc3NhZ2UucmV2b2tlXG4gICAgICAgICAgICAgICAgPyBSZXZva2VBc3NvY2lhdGlvbi50b0pTT04obWVzc2FnZS5yZXZva2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNoYW5nZVJlY292ZXJ5QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNoYW5nZVJlY292ZXJ5QWRkcmVzcyA9IG1lc3NhZ2UuY2hhbmdlUmVjb3ZlcnlBZGRyZXNzXG4gICAgICAgICAgICAgICAgPyBDaGFuZ2VSZWNvdmVyeUFkZHJlc3MudG9KU09OKG1lc3NhZ2UuY2hhbmdlUmVjb3ZlcnlBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUlkZW50aXR5QWN0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlSW5ib3ggPVxuICAgICAgICAgICAgb2JqZWN0LmNyZWF0ZUluYm94ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZUluYm94ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDcmVhdGVJbmJveC5mcm9tUGFydGlhbChvYmplY3QuY3JlYXRlSW5ib3gpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYWRkID1cbiAgICAgICAgICAgIG9iamVjdC5hZGQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYWRkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBBZGRBc3NvY2lhdGlvbi5mcm9tUGFydGlhbChvYmplY3QuYWRkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnJldm9rZSA9XG4gICAgICAgICAgICBvYmplY3QucmV2b2tlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJldm9rZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUmV2b2tlQXNzb2NpYXRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnJldm9rZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jaGFuZ2VSZWNvdmVyeUFkZHJlc3MgPVxuICAgICAgICAgICAgb2JqZWN0LmNoYW5nZVJlY292ZXJ5QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmNoYW5nZVJlY292ZXJ5QWRkcmVzcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ2hhbmdlUmVjb3ZlcnlBZGRyZXNzLmZyb21QYXJ0aWFsKG9iamVjdC5jaGFuZ2VSZWNvdmVyeUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUlkZW50aXR5VXBkYXRlKCkge1xuICAgIHJldHVybiB7IGFjdGlvbnM6IFtdLCBjbGllbnRUaW1lc3RhbXBOczogTG9uZy5VWkVSTywgaW5ib3hJZDogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IElkZW50aXR5VXBkYXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmFjdGlvbnMpIHtcbiAgICAgICAgICAgIElkZW50aXR5QWN0aW9uLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS5jbGllbnRUaW1lc3RhbXBOcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UuY2xpZW50VGltZXN0YW1wTnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluYm94SWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSWRlbnRpdHlVcGRhdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjdGlvbnMucHVzaChJZGVudGl0eUFjdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsaWVudFRpbWVzdGFtcE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aW9uczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuYWN0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hY3Rpb25zLm1hcCgoZSkgPT4gSWRlbnRpdHlBY3Rpb24uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGNsaWVudFRpbWVzdGFtcE5zOiBpc1NldChvYmplY3QuY2xpZW50VGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY2xpZW50VGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgaW5ib3hJZDogaXNTZXQob2JqZWN0LmluYm94SWQpID8gU3RyaW5nKG9iamVjdC5pbmJveElkKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aW9ucykge1xuICAgICAgICAgICAgb2JqLmFjdGlvbnMgPSBtZXNzYWdlLmFjdGlvbnMubWFwKChlKSA9PiBlID8gSWRlbnRpdHlBY3Rpb24udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hY3Rpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5jbGllbnRUaW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNsaWVudFRpbWVzdGFtcE5zID0gKG1lc3NhZ2UuY2xpZW50VGltZXN0YW1wTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5ib3hJZCA9IG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJZGVudGl0eVVwZGF0ZSgpO1xuICAgICAgICBtZXNzYWdlLmFjdGlvbnMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBJZGVudGl0eUFjdGlvbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmNsaWVudFRpbWVzdGFtcE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jbGllbnRUaW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmNsaWVudFRpbWVzdGFtcE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY2xpZW50VGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgPSAoX2IgPSBvYmplY3QuaW5ib3hJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTWVtYmVyTWFwKCkge1xuICAgIHJldHVybiB7IGtleTogdW5kZWZpbmVkLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgTWVtYmVyTWFwID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZW1iZXJJZGVudGlmaWVyLmVuY29kZShtZXNzYWdlLmtleSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZW1iZXIuZW5jb2RlKG1lc3NhZ2UudmFsdWUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZW1iZXJNYXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IE1lbWJlcklkZW50aWZpZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gTWVtYmVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSlcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbUpTT04ob2JqZWN0LmtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiBpc1NldChvYmplY3QudmFsdWUpID8gTWVtYmVyLmZyb21KU09OKG9iamVjdC52YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXkgPSBtZXNzYWdlLmtleVxuICAgICAgICAgICAgICAgID8gTWVtYmVySWRlbnRpZmllci50b0pTT04obWVzc2FnZS5rZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsdWUgPSBtZXNzYWdlLnZhbHVlID8gTWVtYmVyLnRvSlNPTihtZXNzYWdlLnZhbHVlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZW1iZXJNYXAoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPVxuICAgICAgICAgICAgb2JqZWN0LmtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5rZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lbWJlcklkZW50aWZpZXIuZnJvbVBhcnRpYWwob2JqZWN0LmtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lbWJlci5mcm9tUGFydGlhbChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUFzc29jaWF0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHsgaW5ib3hJZDogXCJcIiwgbWVtYmVyczogW10sIHJlY292ZXJ5QWRkcmVzczogXCJcIiwgc2VlblNpZ25hdHVyZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgQXNzb2NpYXRpb25TdGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pbmJveElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5pbmJveElkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tZW1iZXJzKSB7XG4gICAgICAgICAgICBNZW1iZXJNYXAuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjb3ZlcnlBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5yZWNvdmVyeUFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNlZW5TaWduYXR1cmVzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFzc29jaWF0aW9uU3RhdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluYm94SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZW1iZXJzLnB1c2goTWVtYmVyTWFwLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjb3ZlcnlBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VlblNpZ25hdHVyZXMucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluYm94SWQ6IGlzU2V0KG9iamVjdC5pbmJveElkKSA/IFN0cmluZyhvYmplY3QuaW5ib3hJZCkgOiBcIlwiLFxuICAgICAgICAgICAgbWVtYmVyczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QubWVtYmVycylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5tZW1iZXJzLm1hcCgoZSkgPT4gTWVtYmVyTWFwLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICByZWNvdmVyeUFkZHJlc3M6IGlzU2V0KG9iamVjdC5yZWNvdmVyeUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnJlY292ZXJ5QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBzZWVuU2lnbmF0dXJlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Quc2VlblNpZ25hdHVyZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Quc2VlblNpZ25hdHVyZXMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmluYm94SWQgPSBtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICBpZiAobWVzc2FnZS5tZW1iZXJzKSB7XG4gICAgICAgICAgICBvYmoubWVtYmVycyA9IG1lc3NhZ2UubWVtYmVycy5tYXAoKGUpID0+IGUgPyBNZW1iZXJNYXAudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5tZW1iZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeUFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZWNvdmVyeUFkZHJlc3MgPSBtZXNzYWdlLnJlY292ZXJ5QWRkcmVzcyk7XG4gICAgICAgIGlmIChtZXNzYWdlLnNlZW5TaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBvYmouc2VlblNpZ25hdHVyZXMgPSBtZXNzYWdlLnNlZW5TaWduYXR1cmVzLm1hcCgoZSkgPT4gYmFzZTY0RnJvbUJ5dGVzKGUgIT09IHVuZGVmaW5lZCA/IGUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2VlblNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBc3NvY2lhdGlvblN0YXRlKCk7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IChfYSA9IG9iamVjdC5pbmJveElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm1lbWJlcnMgPVxuICAgICAgICAgICAgKChfYiA9IG9iamVjdC5tZW1iZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBNZW1iZXJNYXAuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeUFkZHJlc3MgPSAoX2MgPSBvYmplY3QucmVjb3ZlcnlBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNlZW5TaWduYXR1cmVzID0gKChfZCA9IG9iamVjdC5zZWVuU2lnbmF0dXJlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VBc3NvY2lhdGlvblN0YXRlRGlmZigpIHtcbiAgICByZXR1cm4geyBuZXdNZW1iZXJzOiBbXSwgcmVtb3ZlZE1lbWJlcnM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgQXNzb2NpYXRpb25TdGF0ZURpZmYgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubmV3TWVtYmVycykge1xuICAgICAgICAgICAgTWVtYmVySWRlbnRpZmllci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZW1vdmVkTWVtYmVycykge1xuICAgICAgICAgICAgTWVtYmVySWRlbnRpZmllci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFzc29jaWF0aW9uU3RhdGVEaWZmKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uZXdNZW1iZXJzLnB1c2goTWVtYmVySWRlbnRpZmllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlbW92ZWRNZW1iZXJzLnB1c2goTWVtYmVySWRlbnRpZmllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV3TWVtYmVyczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QubmV3TWVtYmVycylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5uZXdNZW1iZXJzLm1hcCgoZSkgPT4gTWVtYmVySWRlbnRpZmllci5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgcmVtb3ZlZE1lbWJlcnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlbW92ZWRNZW1iZXJzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlbW92ZWRNZW1iZXJzLm1hcCgoZSkgPT4gTWVtYmVySWRlbnRpZmllci5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm5ld01lbWJlcnMpIHtcbiAgICAgICAgICAgIG9iai5uZXdNZW1iZXJzID0gbWVzc2FnZS5uZXdNZW1iZXJzLm1hcCgoZSkgPT4gZSA/IE1lbWJlcklkZW50aWZpZXIudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5uZXdNZW1iZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVtb3ZlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgIG9iai5yZW1vdmVkTWVtYmVycyA9IG1lc3NhZ2UucmVtb3ZlZE1lbWJlcnMubWFwKChlKSA9PiBlID8gTWVtYmVySWRlbnRpZmllci50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlbW92ZWRNZW1iZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFzc29jaWF0aW9uU3RhdGVEaWZmKCk7XG4gICAgICAgIG1lc3NhZ2UubmV3TWVtYmVycyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0Lm5ld01lbWJlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IE1lbWJlcklkZW50aWZpZXIuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5yZW1vdmVkTWVtYmVycyA9XG4gICAgICAgICAgICAoKF9iID0gb2JqZWN0LnJlbW92ZWRNZW1iZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBNZW1iZXJJZGVudGlmaWVyLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzb2NpYXRpb24ucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/association.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/signature.pb.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/signature.pb.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LegacyDelegatedSignature: () => (/* binding */ LegacyDelegatedSignature),\n/* harmony export */   RecoverableEcdsaSignature: () => (/* binding */ RecoverableEcdsaSignature),\n/* harmony export */   RecoverableEd25519Signature: () => (/* binding */ RecoverableEd25519Signature),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SmartContractWalletSignature: () => (/* binding */ SmartContractWalletSignature),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.identity.associations\";\nfunction createBaseRecoverableEcdsaSignature() {\n    return { bytes: new Uint8Array() };\n}\nconst RecoverableEcdsaSignature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRecoverableEcdsaSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRecoverableEcdsaSignature();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseRecoverableEd25519Signature() {\n    return { bytes: new Uint8Array(), publicKey: new Uint8Array() };\n}\nconst RecoverableEd25519Signature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        if (message.publicKey.length !== 0) {\n            writer.uint32(18).bytes(message.publicKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRecoverableEd25519Signature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                case 2:\n                    message.publicKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            publicKey: isSet(object.publicKey)\n                ? bytesFromBase64(object.publicKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.publicKey !== undefined &&\n            (obj.publicKey = base64FromBytes(message.publicKey !== undefined ? message.publicKey : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseRecoverableEd25519Signature();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.publicKey = (_b = object.publicKey) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSmartContractWalletSignature() {\n    return {\n        accountId: \"\",\n        blockNumber: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        signature: new Uint8Array(),\n    };\n}\nconst SmartContractWalletSignature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.accountId !== \"\") {\n            writer.uint32(10).string(message.accountId);\n        }\n        if (!message.blockNumber.isZero()) {\n            writer.uint32(16).uint64(message.blockNumber);\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(26).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSmartContractWalletSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.string();\n                    break;\n                case 2:\n                    message.blockNumber = reader.uint64();\n                    break;\n                case 3:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            accountId: isSet(object.accountId) ? String(object.accountId) : \"\",\n            blockNumber: isSet(object.blockNumber)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.blockNumber)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            signature: isSet(object.signature)\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.accountId !== undefined && (obj.accountId = message.accountId);\n        message.blockNumber !== undefined &&\n            (obj.blockNumber = (message.blockNumber || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSmartContractWalletSignature();\n        message.accountId = (_a = object.accountId) !== null && _a !== void 0 ? _a : \"\";\n        message.blockNumber =\n            object.blockNumber !== undefined && object.blockNumber !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.blockNumber)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseLegacyDelegatedSignature() {\n    return { delegatedKey: undefined, signature: undefined };\n}\nconst LegacyDelegatedSignature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.delegatedKey !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.encode(message.delegatedKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.signature !== undefined) {\n            RecoverableEcdsaSignature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLegacyDelegatedSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatedKey = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signature = RecoverableEcdsaSignature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatedKey: isSet(object.delegatedKey)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromJSON(object.delegatedKey)\n                : undefined,\n            signature: isSet(object.signature)\n                ? RecoverableEcdsaSignature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatedKey !== undefined &&\n            (obj.delegatedKey = message.delegatedKey\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.toJSON(message.delegatedKey)\n                : undefined);\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? RecoverableEcdsaSignature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseLegacyDelegatedSignature();\n        message.delegatedKey =\n            object.delegatedKey !== undefined && object.delegatedKey !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromPartial(object.delegatedKey)\n                : undefined;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? RecoverableEcdsaSignature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignature() {\n    return {\n        erc191: undefined,\n        erc6492: undefined,\n        installationKey: undefined,\n        delegatedErc191: undefined,\n    };\n}\nconst Signature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.erc191 !== undefined) {\n            RecoverableEcdsaSignature.encode(message.erc191, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.erc6492 !== undefined) {\n            SmartContractWalletSignature.encode(message.erc6492, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.installationKey !== undefined) {\n            RecoverableEd25519Signature.encode(message.installationKey, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.delegatedErc191 !== undefined) {\n            LegacyDelegatedSignature.encode(message.delegatedErc191, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.erc191 = RecoverableEcdsaSignature.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.erc6492 = SmartContractWalletSignature.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.installationKey = RecoverableEd25519Signature.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.delegatedErc191 = LegacyDelegatedSignature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            erc191: isSet(object.erc191)\n                ? RecoverableEcdsaSignature.fromJSON(object.erc191)\n                : undefined,\n            erc6492: isSet(object.erc6492)\n                ? SmartContractWalletSignature.fromJSON(object.erc6492)\n                : undefined,\n            installationKey: isSet(object.installationKey)\n                ? RecoverableEd25519Signature.fromJSON(object.installationKey)\n                : undefined,\n            delegatedErc191: isSet(object.delegatedErc191)\n                ? LegacyDelegatedSignature.fromJSON(object.delegatedErc191)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.erc191 !== undefined &&\n            (obj.erc191 = message.erc191\n                ? RecoverableEcdsaSignature.toJSON(message.erc191)\n                : undefined);\n        message.erc6492 !== undefined &&\n            (obj.erc6492 = message.erc6492\n                ? SmartContractWalletSignature.toJSON(message.erc6492)\n                : undefined);\n        message.installationKey !== undefined &&\n            (obj.installationKey = message.installationKey\n                ? RecoverableEd25519Signature.toJSON(message.installationKey)\n                : undefined);\n        message.delegatedErc191 !== undefined &&\n            (obj.delegatedErc191 = message.delegatedErc191\n                ? LegacyDelegatedSignature.toJSON(message.delegatedErc191)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignature();\n        message.erc191 =\n            object.erc191 !== undefined && object.erc191 !== null\n                ? RecoverableEcdsaSignature.fromPartial(object.erc191)\n                : undefined;\n        message.erc6492 =\n            object.erc6492 !== undefined && object.erc6492 !== null\n                ? SmartContractWalletSignature.fromPartial(object.erc6492)\n                : undefined;\n        message.installationKey =\n            object.installationKey !== undefined && object.installationKey !== null\n                ? RecoverableEd25519Signature.fromPartial(object.installationKey)\n                : undefined;\n        message.delegatedErc191 =\n            object.delegatedErc191 !== undefined && object.delegatedErc191 !== null\n                ? LegacyDelegatedSignature.fromPartial(object.delegatedErc191)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signature.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvYXNzb2NpYXRpb25zL3NpZ25hdHVyZS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDK0M7QUFDbEM7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtB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QWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL2lkZW50aXR5L2Fzc29jaWF0aW9ucy9zaWduYXR1cmUucGIuanM/YTlmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFNpZ25lZFB1YmxpY0tleSB9IGZyb20gXCIuLi8uLi9tZXNzYWdlX2NvbnRlbnRzL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5pZGVudGl0eS5hc3NvY2lhdGlvbnNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VSZWNvdmVyYWJsZUVjZHNhU2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXM6IGlzU2V0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ieXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZWNvdmVyYWJsZUVjZHNhU2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJlY292ZXJhYmxlRWQyNTUxOVNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4geyBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSwgcHVibGljS2V5OiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgUmVjb3ZlcmFibGVFZDI1NTE5U2lnbmF0dXJlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGljS2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5wdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVjb3ZlcmFibGVFZDI1NTE5U2lnbmF0dXJlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBpc1NldChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogaXNTZXQob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wdWJsaWNLZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucHVibGljS2V5IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVjb3ZlcmFibGVFZDI1NTE5U2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID0gKF9iID0gb2JqZWN0LnB1YmxpY0tleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50SWQ6IFwiXCIsXG4gICAgICAgIGJsb2NrTnVtYmVyOiBMb25nLlVaRVJPLFxuICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjY291bnRJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYWNjb3VudElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuYmxvY2tOdW1iZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLmJsb2NrTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY2NvdW50SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja051bWJlciA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50SWQ6IGlzU2V0KG9iamVjdC5hY2NvdW50SWQpID8gU3RyaW5nKG9iamVjdC5hY2NvdW50SWQpIDogXCJcIixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBpc1NldChvYmplY3QuYmxvY2tOdW1iZXIpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuYmxvY2tOdW1iZXIpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWNjb3VudElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5hY2NvdW50SWQgPSBtZXNzYWdlLmFjY291bnRJZCk7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tOdW1iZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ibG9ja051bWJlciA9IChtZXNzYWdlLmJsb2NrTnVtYmVyIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpZ25hdHVyZSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5zaWduYXR1cmUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuYWNjb3VudElkID0gKF9hID0gb2JqZWN0LmFjY291bnRJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ibG9ja051bWJlciA9XG4gICAgICAgICAgICBvYmplY3QuYmxvY2tOdW1iZXIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYmxvY2tOdW1iZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5ibG9ja051bWJlcilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gKF9iID0gb2JqZWN0LnNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTGVnYWN5RGVsZWdhdGVkU2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB7IGRlbGVnYXRlZEtleTogdW5kZWZpbmVkLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IExlZ2FjeURlbGVnYXRlZFNpZ25hdHVyZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZWxlZ2F0ZWRLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5LmVuY29kZShtZXNzYWdlLmRlbGVnYXRlZEtleSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5zaWduYXR1cmUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VMZWdhY3lEZWxlZ2F0ZWRTaWduYXR1cmUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRlZEtleSA9IFNpZ25lZFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0ZWRLZXk6IGlzU2V0KG9iamVjdC5kZWxlZ2F0ZWRLZXkpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LmRlbGVnYXRlZEtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFJlY292ZXJhYmxlRWNkc2FTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRlZEtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlbGVnYXRlZEtleSA9IG1lc3NhZ2UuZGVsZWdhdGVkS2V5XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UuZGVsZWdhdGVkS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTGVnYWN5RGVsZWdhdGVkU2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdGVkS2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5kZWxlZ2F0ZWRLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGVsZWdhdGVkS2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbVBhcnRpYWwob2JqZWN0LmRlbGVnYXRlZEtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFJlY292ZXJhYmxlRWNkc2FTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVyYzE5MTogdW5kZWZpbmVkLFxuICAgICAgICBlcmM2NDkyOiB1bmRlZmluZWQsXG4gICAgICAgIGluc3RhbGxhdGlvbktleTogdW5kZWZpbmVkLFxuICAgICAgICBkZWxlZ2F0ZWRFcmMxOTE6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25hdHVyZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5lcmMxOTEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUmVjb3ZlcmFibGVFY2RzYVNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5lcmMxOTEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJjNjQ5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLmVyYzY0OTIsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFJlY292ZXJhYmxlRWQyNTUxOVNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5pbnN0YWxsYXRpb25LZXksIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdGVkRXJjMTkxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExlZ2FjeURlbGVnYXRlZFNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5kZWxlZ2F0ZWRFcmMxOTEsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVyYzE5MSA9IFJlY292ZXJhYmxlRWNkc2FTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVyYzY0OTIgPSBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgPSBSZWNvdmVyYWJsZUVkMjU1MTlTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRlZEVyYzE5MSA9IExlZ2FjeURlbGVnYXRlZFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcmMxOTE6IGlzU2V0KG9iamVjdC5lcmMxOTEpXG4gICAgICAgICAgICAgICAgPyBSZWNvdmVyYWJsZUVjZHNhU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5lcmMxOTEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcmM2NDkyOiBpc1NldChvYmplY3QuZXJjNjQ5MilcbiAgICAgICAgICAgICAgICA/IFNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LmVyYzY0OTIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBSZWNvdmVyYWJsZUVkMjU1MTlTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlbGVnYXRlZEVyYzE5MTogaXNTZXQob2JqZWN0LmRlbGVnYXRlZEVyYzE5MSlcbiAgICAgICAgICAgICAgICA/IExlZ2FjeURlbGVnYXRlZFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3QuZGVsZWdhdGVkRXJjMTkxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZXJjMTkxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJjMTkxID0gbWVzc2FnZS5lcmMxOTFcbiAgICAgICAgICAgICAgICA/IFJlY292ZXJhYmxlRWNkc2FTaWduYXR1cmUudG9KU09OKG1lc3NhZ2UuZXJjMTkxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5lcmM2NDkyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJjNjQ5MiA9IG1lc3NhZ2UuZXJjNjQ5MlxuICAgICAgICAgICAgICAgID8gU21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5lcmM2NDkyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBtZXNzYWdlLmluc3RhbGxhdGlvbktleVxuICAgICAgICAgICAgICAgID8gUmVjb3ZlcmFibGVFZDI1NTE5U2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdGVkRXJjMTkxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdGVkRXJjMTkxID0gbWVzc2FnZS5kZWxlZ2F0ZWRFcmMxOTFcbiAgICAgICAgICAgICAgICA/IExlZ2FjeURlbGVnYXRlZFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5kZWxlZ2F0ZWRFcmMxOTEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuZXJjMTkxID1cbiAgICAgICAgICAgIG9iamVjdC5lcmMxOTEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJjMTkxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBSZWNvdmVyYWJsZUVjZHNhU2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5lcmMxOTEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZXJjNjQ5MiA9XG4gICAgICAgICAgICBvYmplY3QuZXJjNjQ5MiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lcmM2NDkyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5lcmM2NDkyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9XG4gICAgICAgICAgICBvYmplY3QuaW5zdGFsbGF0aW9uS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmluc3RhbGxhdGlvbktleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUmVjb3ZlcmFibGVFZDI1NTE5U2lnbmF0dXJlLmZyb21QYXJ0aWFsKG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdGVkRXJjMTkxID1cbiAgICAgICAgICAgIG9iamVjdC5kZWxlZ2F0ZWRFcmMxOTEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGVsZWdhdGVkRXJjMTkxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMZWdhY3lEZWxlZ2F0ZWRTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LmRlbGVnYXRlZEVyYzE5MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/signature.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/credential.pb.js":
/*!************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/identity/credential.pb.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MlsCredential: () => (/* binding */ MlsCredential),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.identity\";\nfunction createBaseMlsCredential() {\n    return { inboxId: \"\" };\n}\nconst MlsCredential = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMlsCredential();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMlsCredential();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=credential.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaWRlbnRpdHkvY3JlZGVudGlhbC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2E7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9pZGVudGl0eS9jcmVkZW50aWFsLnBiLmpzPzBlNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAuaWRlbnRpdHlcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNbHNDcmVkZW50aWFsKCkge1xuICAgIHJldHVybiB7IGluYm94SWQ6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBNbHNDcmVkZW50aWFsID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluYm94SWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWxzQ3JlZGVudGlhbCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5ib3hJZDogaXNTZXQob2JqZWN0LmluYm94SWQpID8gU3RyaW5nKG9iamVjdC5pbmJveElkKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbmJveElkID0gbWVzc2FnZS5pbmJveElkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWxzQ3JlZGVudGlhbCgpO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgPSAoX2EgPSBvYmplY3QuaW5ib3hJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVkZW50aWFsLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/credential.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authn: () => (/* reexport module object */ _message_api_v1_authn_pb__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   ciphertext: () => (/* reexport module object */ _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   composite: () => (/* reexport module object */ _message_contents_composite_pb__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   contact: () => (/* reexport module object */ _message_contents_contact_pb__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   content: () => (/* reexport module object */ _message_contents_content_pb__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   conversationReference: () => (/* reexport module object */ _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   ecies: () => (/* reexport module object */ _message_contents_ecies_pb__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   fetcher: () => (/* reexport module object */ _fetch_pb__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   frames: () => (/* reexport module object */ _message_contents_frames_pb__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   invitation: () => (/* reexport module object */ _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   keystore: () => (/* reexport module object */ _keystore_api_v1_keystore_pb__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   message: () => (/* reexport module object */ _message_contents_message_pb__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   messageApi: () => (/* reexport module object */ _message_api_v1_message_api_pb__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   mlsApi: () => (/* reexport module object */ _mls_api_v1_mls_pb__WEBPACK_IMPORTED_MODULE_18__),\n/* harmony export */   mlsContent: () => (/* reexport module object */ _mls_message_contents_content_pb__WEBPACK_IMPORTED_MODULE_20__),\n/* harmony export */   mlsDatabaseIntent: () => (/* reexport module object */ _mls_database_intents_pb__WEBPACK_IMPORTED_MODULE_19__),\n/* harmony export */   mlsGroupMembership: () => (/* reexport module object */ _mls_message_contents_group_membership_pb__WEBPACK_IMPORTED_MODULE_21__),\n/* harmony export */   mlsGroupMetadata: () => (/* reexport module object */ _mls_message_contents_group_metadata_pb__WEBPACK_IMPORTED_MODULE_22__),\n/* harmony export */   mlsGroupMutableMetadata: () => (/* reexport module object */ _mls_message_contents_group_mutable_metadata_pb__WEBPACK_IMPORTED_MODULE_23__),\n/* harmony export */   mlsTranscriptMessages: () => (/* reexport module object */ _mls_message_contents_transcript_messages_pb__WEBPACK_IMPORTED_MODULE_24__),\n/* harmony export */   mlsValidationService: () => (/* reexport module object */ _mls_validation_v1_service_pb__WEBPACK_IMPORTED_MODULE_25__),\n/* harmony export */   privateKey: () => (/* reexport module object */ _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   privatePreferences: () => (/* reexport module object */ _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   publicKey: () => (/* reexport module object */ _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   signature: () => (/* reexport module object */ _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   signedPayload: () => (/* reexport module object */ _message_contents_signed_payload_pb__WEBPACK_IMPORTED_MODULE_16__)\n/* harmony export */ });\n/* harmony import */ var _message_api_v1_message_api_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message_api/v1/message_api.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js\");\n/* harmony import */ var _fetch_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\");\n/* harmony import */ var _message_api_v1_authn_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message_api/v1/authn.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js\");\n/* harmony import */ var _message_contents_message_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message_contents/message.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js\");\n/* harmony import */ var _message_contents_content_pb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./message_contents/content.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\");\n/* harmony import */ var _message_contents_frames_pb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message_contents/frames.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js\");\n/* harmony import */ var _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./message_contents/conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var _message_contents_composite_pb__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./message_contents/composite.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js\");\n/* harmony import */ var _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./message_contents/private_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./message_contents/signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./message_contents/ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _message_contents_contact_pb__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./message_contents/contact.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js\");\n/* harmony import */ var _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./message_contents/invitation.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var _keystore_api_v1_keystore_pb__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./keystore_api/v1/keystore.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js\");\n/* harmony import */ var _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./message_contents/private_preferences.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js\");\n/* harmony import */ var _message_contents_signed_payload_pb__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./message_contents/signed_payload.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js\");\n/* harmony import */ var _message_contents_ecies_pb__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./message_contents/ecies.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js\");\n/* harmony import */ var _mls_api_v1_mls_pb__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./mls/api/v1/mls.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/api/v1/mls.pb.js\");\n/* harmony import */ var _mls_database_intents_pb__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./mls/database/intents.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/database/intents.pb.js\");\n/* harmony import */ var _mls_message_contents_content_pb__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./mls/message_contents/content.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/content.pb.js\");\n/* harmony import */ var _mls_message_contents_group_membership_pb__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./mls/message_contents/group_membership.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_membership.pb.js\");\n/* harmony import */ var _mls_message_contents_group_metadata_pb__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./mls/message_contents/group_metadata.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_metadata.pb.js\");\n/* harmony import */ var _mls_message_contents_group_mutable_metadata_pb__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mls/message_contents/group_mutable_metadata.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_mutable_metadata.pb.js\");\n/* harmony import */ var _mls_message_contents_transcript_messages_pb__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./mls/message_contents/transcript_messages.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/transcript_messages.pb.js\");\n/* harmony import */ var _mls_validation_v1_service_pb__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./mls_validation/v1/service.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls_validation/v1/service.pb.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUN4QjtBQUNhO0FBQ007QUFDQTtBQUNGO0FBQytCO0FBQ3pCO0FBQ0c7QUFDRjtBQUNEO0FBQ0U7QUFDTjtBQUNNO0FBQ0w7QUFDc0I7QUFDVjtBQUNqQjtBQUNQO0FBQ2lCO0FBQ0M7QUFDaUI7QUFDSjtBQUNlO0FBQ0w7QUFDaEI7QUFDdkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9pbmRleC5qcz9jODA3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGFzIG1lc3NhZ2VBcGkgZnJvbSBcIi4vbWVzc2FnZV9hcGkvdjEvbWVzc2FnZV9hcGkucGJcIjtcbmV4cG9ydCAqIGFzIGZldGNoZXIgZnJvbSBcIi4vZmV0Y2gucGJcIjtcbmV4cG9ydCAqIGFzIGF1dGhuIGZyb20gXCIuL21lc3NhZ2VfYXBpL3YxL2F1dGhuLnBiXCI7XG5leHBvcnQgKiBhcyBtZXNzYWdlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvbWVzc2FnZS5wYlwiO1xuZXhwb3J0ICogYXMgY29udGVudCBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2NvbnRlbnQucGJcIjtcbmV4cG9ydCAqIGFzIGZyYW1lcyBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2ZyYW1lcy5wYlwiO1xuZXhwb3J0ICogYXMgY29udmVyc2F0aW9uUmVmZXJlbmNlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvY29udmVyc2F0aW9uX3JlZmVyZW5jZS5wYlwiO1xuZXhwb3J0ICogYXMgY29tcG9zaXRlIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvY29tcG9zaXRlLnBiXCI7XG5leHBvcnQgKiBhcyBwcml2YXRlS2V5IGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvcHJpdmF0ZV9rZXkucGJcIjtcbmV4cG9ydCAqIGFzIHB1YmxpY0tleSBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL3B1YmxpY19rZXkucGJcIjtcbmV4cG9ydCAqIGFzIHNpZ25hdHVyZSBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL3NpZ25hdHVyZS5wYlwiO1xuZXhwb3J0ICogYXMgY2lwaGVydGV4dCBmcm9tIFwiLi9tZXNzYWdlX2NvbnRlbnRzL2NpcGhlcnRleHQucGJcIjtcbmV4cG9ydCAqIGFzIGNvbnRhY3QgZnJvbSBcIi4vbWVzc2FnZV9jb250ZW50cy9jb250YWN0LnBiXCI7XG5leHBvcnQgKiBhcyBpbnZpdGF0aW9uIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvaW52aXRhdGlvbi5wYlwiO1xuZXhwb3J0ICogYXMga2V5c3RvcmUgZnJvbSBcIi4va2V5c3RvcmVfYXBpL3YxL2tleXN0b3JlLnBiXCI7XG5leHBvcnQgKiBhcyBwcml2YXRlUHJlZmVyZW5jZXMgZnJvbSBcIi4vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX3ByZWZlcmVuY2VzLnBiXCI7XG5leHBvcnQgKiBhcyBzaWduZWRQYXlsb2FkIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvc2lnbmVkX3BheWxvYWQucGJcIjtcbmV4cG9ydCAqIGFzIGVjaWVzIGZyb20gXCIuL21lc3NhZ2VfY29udGVudHMvZWNpZXMucGJcIjtcbmV4cG9ydCAqIGFzIG1sc0FwaSBmcm9tIFwiLi9tbHMvYXBpL3YxL21scy5wYlwiO1xuZXhwb3J0ICogYXMgbWxzRGF0YWJhc2VJbnRlbnQgZnJvbSBcIi4vbWxzL2RhdGFiYXNlL2ludGVudHMucGJcIjtcbmV4cG9ydCAqIGFzIG1sc0NvbnRlbnQgZnJvbSBcIi4vbWxzL21lc3NhZ2VfY29udGVudHMvY29udGVudC5wYlwiO1xuZXhwb3J0ICogYXMgbWxzR3JvdXBNZW1iZXJzaGlwIGZyb20gXCIuL21scy9tZXNzYWdlX2NvbnRlbnRzL2dyb3VwX21lbWJlcnNoaXAucGJcIjtcbmV4cG9ydCAqIGFzIG1sc0dyb3VwTWV0YWRhdGEgZnJvbSBcIi4vbWxzL21lc3NhZ2VfY29udGVudHMvZ3JvdXBfbWV0YWRhdGEucGJcIjtcbmV4cG9ydCAqIGFzIG1sc0dyb3VwTXV0YWJsZU1ldGFkYXRhIGZyb20gXCIuL21scy9tZXNzYWdlX2NvbnRlbnRzL2dyb3VwX211dGFibGVfbWV0YWRhdGEucGJcIjtcbmV4cG9ydCAqIGFzIG1sc1RyYW5zY3JpcHRNZXNzYWdlcyBmcm9tIFwiLi9tbHMvbWVzc2FnZV9jb250ZW50cy90cmFuc2NyaXB0X21lc3NhZ2VzLnBiXCI7XG5leHBvcnQgKiBhcyBtbHNWYWxpZGF0aW9uU2VydmljZSBmcm9tIFwiLi9tbHNfdmFsaWRhdGlvbi92MS9zZXJ2aWNlLnBiXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateAuthTokenRequest: () => (/* binding */ CreateAuthTokenRequest),\n/* harmony export */   CreateInviteRequest: () => (/* binding */ CreateInviteRequest),\n/* harmony export */   CreateInviteResponse: () => (/* binding */ CreateInviteResponse),\n/* harmony export */   DecryptResponse: () => (/* binding */ DecryptResponse),\n/* harmony export */   DecryptResponse_Response: () => (/* binding */ DecryptResponse_Response),\n/* harmony export */   DecryptResponse_Response_Success: () => (/* binding */ DecryptResponse_Response_Success),\n/* harmony export */   DecryptV1Request: () => (/* binding */ DecryptV1Request),\n/* harmony export */   DecryptV1Request_Request: () => (/* binding */ DecryptV1Request_Request),\n/* harmony export */   DecryptV2Request: () => (/* binding */ DecryptV2Request),\n/* harmony export */   DecryptV2Request_Request: () => (/* binding */ DecryptV2Request_Request),\n/* harmony export */   EncryptResponse: () => (/* binding */ EncryptResponse),\n/* harmony export */   EncryptResponse_Response: () => (/* binding */ EncryptResponse_Response),\n/* harmony export */   EncryptResponse_Response_Success: () => (/* binding */ EncryptResponse_Response_Success),\n/* harmony export */   EncryptV1Request: () => (/* binding */ EncryptV1Request),\n/* harmony export */   EncryptV1Request_Request: () => (/* binding */ EncryptV1Request_Request),\n/* harmony export */   EncryptV2Request: () => (/* binding */ EncryptV2Request),\n/* harmony export */   EncryptV2Request_Request: () => (/* binding */ EncryptV2Request_Request),\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   GetConversationHmacKeysRequest: () => (/* binding */ GetConversationHmacKeysRequest),\n/* harmony export */   GetConversationHmacKeysResponse: () => (/* binding */ GetConversationHmacKeysResponse),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeyData: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeyData),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeys: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeys),\n/* harmony export */   GetConversationHmacKeysResponse_HmacKeysEntry: () => (/* binding */ GetConversationHmacKeysResponse_HmacKeysEntry),\n/* harmony export */   GetConversationsResponse: () => (/* binding */ GetConversationsResponse),\n/* harmony export */   GetKeystoreStatusRequest: () => (/* binding */ GetKeystoreStatusRequest),\n/* harmony export */   GetKeystoreStatusResponse: () => (/* binding */ GetKeystoreStatusResponse),\n/* harmony export */   GetKeystoreStatusResponse_KeystoreStatus: () => (/* binding */ GetKeystoreStatusResponse_KeystoreStatus),\n/* harmony export */   GetPrivatePreferencesTopicIdentifierResponse: () => (/* binding */ GetPrivatePreferencesTopicIdentifierResponse),\n/* harmony export */   GetRefreshJobRequest: () => (/* binding */ GetRefreshJobRequest),\n/* harmony export */   GetRefreshJobResponse: () => (/* binding */ GetRefreshJobResponse),\n/* harmony export */   InitKeystoreRequest: () => (/* binding */ InitKeystoreRequest),\n/* harmony export */   InitKeystoreResponse: () => (/* binding */ InitKeystoreResponse),\n/* harmony export */   JobType: () => (/* binding */ JobType),\n/* harmony export */   KeystoreError: () => (/* binding */ KeystoreError),\n/* harmony export */   PrivatePreferencesActionMap: () => (/* binding */ PrivatePreferencesActionMap),\n/* harmony export */   PrivatePreferencesActionMap_ActionsEntry: () => (/* binding */ PrivatePreferencesActionMap_ActionsEntry),\n/* harmony export */   SaveInvitesRequest: () => (/* binding */ SaveInvitesRequest),\n/* harmony export */   SaveInvitesRequest_Request: () => (/* binding */ SaveInvitesRequest_Request),\n/* harmony export */   SaveInvitesResponse: () => (/* binding */ SaveInvitesResponse),\n/* harmony export */   SaveInvitesResponse_Response: () => (/* binding */ SaveInvitesResponse_Response),\n/* harmony export */   SaveInvitesResponse_Response_Success: () => (/* binding */ SaveInvitesResponse_Response_Success),\n/* harmony export */   SaveV1ConversationsRequest: () => (/* binding */ SaveV1ConversationsRequest),\n/* harmony export */   SaveV1ConversationsResponse: () => (/* binding */ SaveV1ConversationsResponse),\n/* harmony export */   SelfDecryptRequest: () => (/* binding */ SelfDecryptRequest),\n/* harmony export */   SelfDecryptRequest_Request: () => (/* binding */ SelfDecryptRequest_Request),\n/* harmony export */   SelfEncryptRequest: () => (/* binding */ SelfEncryptRequest),\n/* harmony export */   SelfEncryptRequest_Request: () => (/* binding */ SelfEncryptRequest_Request),\n/* harmony export */   SelfEncryptResponse: () => (/* binding */ SelfEncryptResponse),\n/* harmony export */   SelfEncryptResponse_Response: () => (/* binding */ SelfEncryptResponse_Response),\n/* harmony export */   SelfEncryptResponse_Response_Success: () => (/* binding */ SelfEncryptResponse_Response_Success),\n/* harmony export */   SetRefeshJobRequest: () => (/* binding */ SetRefeshJobRequest),\n/* harmony export */   SetRefreshJobResponse: () => (/* binding */ SetRefreshJobResponse),\n/* harmony export */   SignDigestRequest: () => (/* binding */ SignDigestRequest),\n/* harmony export */   TopicMap: () => (/* binding */ TopicMap),\n/* harmony export */   TopicMap_TopicData: () => (/* binding */ TopicMap_TopicData),\n/* harmony export */   TopicMap_TopicsEntry: () => (/* binding */ TopicMap_TopicsEntry),\n/* harmony export */   errorCodeFromJSON: () => (/* binding */ errorCodeFromJSON),\n/* harmony export */   errorCodeToJSON: () => (/* binding */ errorCodeToJSON),\n/* harmony export */   getKeystoreStatusResponse_KeystoreStatusFromJSON: () => (/* binding */ getKeystoreStatusResponse_KeystoreStatusFromJSON),\n/* harmony export */   getKeystoreStatusResponse_KeystoreStatusToJSON: () => (/* binding */ getKeystoreStatusResponse_KeystoreStatusToJSON),\n/* harmony export */   jobTypeFromJSON: () => (/* binding */ jobTypeFromJSON),\n/* harmony export */   jobTypeToJSON: () => (/* binding */ jobTypeToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../message_contents/ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../message_contents/invitation.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../message_contents/conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../message_contents/private_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\");\n/* harmony import */ var _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../message_contents/private_preferences.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7__);\n/* eslint-disable */\n\n\n\n\n\n\n\n\nconst protobufPackage = \"xmtp.keystore_api.v1\";\n/** Message content encoding structures */\n/** Application-specific error codes for the Keystore API. */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"ERROR_CODE_UNSPECIFIED\"] = 0] = \"ERROR_CODE_UNSPECIFIED\";\n    ErrorCode[ErrorCode[\"ERROR_CODE_INVALID_INPUT\"] = 1] = \"ERROR_CODE_INVALID_INPUT\";\n    ErrorCode[ErrorCode[\"ERROR_CODE_NO_MATCHING_PREKEY\"] = 2] = \"ERROR_CODE_NO_MATCHING_PREKEY\";\n    ErrorCode[ErrorCode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ErrorCode || (ErrorCode = {}));\nfunction errorCodeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"ERROR_CODE_UNSPECIFIED\":\n            return ErrorCode.ERROR_CODE_UNSPECIFIED;\n        case 1:\n        case \"ERROR_CODE_INVALID_INPUT\":\n            return ErrorCode.ERROR_CODE_INVALID_INPUT;\n        case 2:\n        case \"ERROR_CODE_NO_MATCHING_PREKEY\":\n            return ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ErrorCode.UNRECOGNIZED;\n    }\n}\nfunction errorCodeToJSON(object) {\n    switch (object) {\n        case ErrorCode.ERROR_CODE_UNSPECIFIED:\n            return \"ERROR_CODE_UNSPECIFIED\";\n        case ErrorCode.ERROR_CODE_INVALID_INPUT:\n            return \"ERROR_CODE_INVALID_INPUT\";\n        case ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY:\n            return \"ERROR_CODE_NO_MATCHING_PREKEY\";\n        case ErrorCode.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** JobType is used to specify the type of job the caller would like info on */\nvar JobType;\n(function (JobType) {\n    JobType[JobType[\"JOB_TYPE_UNSPECIFIED\"] = 0] = \"JOB_TYPE_UNSPECIFIED\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_V1\"] = 1] = \"JOB_TYPE_REFRESH_V1\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_V2\"] = 2] = \"JOB_TYPE_REFRESH_V2\";\n    JobType[JobType[\"JOB_TYPE_REFRESH_PPPP\"] = 3] = \"JOB_TYPE_REFRESH_PPPP\";\n    JobType[JobType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(JobType || (JobType = {}));\nfunction jobTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"JOB_TYPE_UNSPECIFIED\":\n            return JobType.JOB_TYPE_UNSPECIFIED;\n        case 1:\n        case \"JOB_TYPE_REFRESH_V1\":\n            return JobType.JOB_TYPE_REFRESH_V1;\n        case 2:\n        case \"JOB_TYPE_REFRESH_V2\":\n            return JobType.JOB_TYPE_REFRESH_V2;\n        case 3:\n        case \"JOB_TYPE_REFRESH_PPPP\":\n            return JobType.JOB_TYPE_REFRESH_PPPP;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return JobType.UNRECOGNIZED;\n    }\n}\nfunction jobTypeToJSON(object) {\n    switch (object) {\n        case JobType.JOB_TYPE_UNSPECIFIED:\n            return \"JOB_TYPE_UNSPECIFIED\";\n        case JobType.JOB_TYPE_REFRESH_V1:\n            return \"JOB_TYPE_REFRESH_V1\";\n        case JobType.JOB_TYPE_REFRESH_V2:\n            return \"JOB_TYPE_REFRESH_V2\";\n        case JobType.JOB_TYPE_REFRESH_PPPP:\n            return \"JOB_TYPE_REFRESH_PPPP\";\n        case JobType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** Status of the Keystore for the specified wallet address */\nvar GetKeystoreStatusResponse_KeystoreStatus;\n(function (GetKeystoreStatusResponse_KeystoreStatus) {\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_UNSPECIFIED\"] = 0] = \"KEYSTORE_STATUS_UNSPECIFIED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_UNINITIALIZED\"] = 1] = \"KEYSTORE_STATUS_UNINITIALIZED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"KEYSTORE_STATUS_INITIALIZED\"] = 2] = \"KEYSTORE_STATUS_INITIALIZED\";\n    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(GetKeystoreStatusResponse_KeystoreStatus || (GetKeystoreStatusResponse_KeystoreStatus = {}));\nfunction getKeystoreStatusResponse_KeystoreStatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"KEYSTORE_STATUS_UNSPECIFIED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED;\n        case 1:\n        case \"KEYSTORE_STATUS_UNINITIALIZED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED;\n        case 2:\n        case \"KEYSTORE_STATUS_INITIALIZED\":\n            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED;\n    }\n}\nfunction getKeystoreStatusResponse_KeystoreStatusToJSON(object) {\n    switch (object) {\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED:\n            return \"KEYSTORE_STATUS_UNSPECIFIED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED:\n            return \"KEYSTORE_STATUS_UNINITIALIZED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED:\n            return \"KEYSTORE_STATUS_INITIALIZED\";\n        case GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseKeystoreError() {\n    return { message: \"\", code: 0 };\n}\nconst KeystoreError = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.message !== \"\") {\n            writer.uint32(10).string(message.message);\n        }\n        if (message.code !== 0) {\n            writer.uint32(16).int32(message.code);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseKeystoreError();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    message.code = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            message: isSet(object.message) ? String(object.message) : \"\",\n            code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.message !== undefined && (obj.message = message.message);\n        message.code !== undefined && (obj.code = errorCodeToJSON(message.code));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseKeystoreError();\n        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : \"\";\n        message.code = (_b = object.code) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseDecryptV1Request() {\n    return { requests: [] };\n}\nconst DecryptV1Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            DecryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV1Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(DecryptV1Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => DecryptV1Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? DecryptV1Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptV1Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptV1Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptV1Request_Request() {\n    return {\n        payload: undefined,\n        peerKeys: undefined,\n        headerBytes: new Uint8Array(),\n        isSender: false,\n    };\n}\nconst DecryptV1Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.payload !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.payload, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.peerKeys !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.encode(message.peerKeys, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(26).bytes(message.headerBytes);\n        }\n        if (message.isSender === true) {\n            writer.uint32(32).bool(message.isSender);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV1Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.peerKeys = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 4:\n                    message.isSender = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.payload)\n                : undefined,\n            peerKeys: isSet(object.peerKeys)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromJSON(object.peerKeys)\n                : undefined,\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            isSender: isSet(object.isSender) ? Boolean(object.isSender) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = message.payload\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.payload)\n                : undefined);\n        message.peerKeys !== undefined &&\n            (obj.peerKeys = message.peerKeys\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.toJSON(message.peerKeys)\n                : undefined);\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.isSender !== undefined && (obj.isSender = message.isSender);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDecryptV1Request_Request();\n        message.payload =\n            object.payload !== undefined && object.payload !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.payload)\n                : undefined;\n        message.peerKeys =\n            object.peerKeys !== undefined && object.peerKeys !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromPartial(object.peerKeys)\n                : undefined;\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.isSender = (_b = object.isSender) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseDecryptResponse() {\n    return { responses: [] };\n}\nconst DecryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.responses) {\n            DecryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(DecryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => DecryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? DecryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptResponse_Response.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst DecryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.result !== undefined) {\n            DecryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = DecryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? DecryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? DecryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDecryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? DecryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseDecryptResponse_Response_Success() {\n    return { decrypted: new Uint8Array() };\n}\nconst DecryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.decrypted.length !== 0) {\n            writer.uint32(10).bytes(message.decrypted);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.decrypted = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            decrypted: isSet(object.decrypted)\n                ? bytesFromBase64(object.decrypted)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.decrypted !== undefined &&\n            (obj.decrypted = base64FromBytes(message.decrypted !== undefined ? message.decrypted : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptResponse_Response_Success();\n        message.decrypted = (_a = object.decrypted) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseDecryptV2Request() {\n    return { requests: [] };\n}\nconst DecryptV2Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            DecryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV2Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(DecryptV2Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => DecryptV2Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? DecryptV2Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecryptV2Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => DecryptV2Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseDecryptV2Request_Request() {\n    return {\n        payload: undefined,\n        headerBytes: new Uint8Array(),\n        contentTopic: \"\",\n    };\n}\nconst DecryptV2Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.payload !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.payload, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(18).bytes(message.headerBytes);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(26).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecryptV2Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.payload)\n                : undefined,\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = message.payload\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.payload)\n                : undefined);\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDecryptV2Request_Request();\n        message.payload =\n            object.payload !== undefined && object.payload !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.payload)\n                : undefined;\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.contentTopic = (_b = object.contentTopic) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseEncryptV1Request() {\n    return { requests: [] };\n}\nconst EncryptV1Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            EncryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV1Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(EncryptV1Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => EncryptV1Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? EncryptV1Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptV1Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptV1Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptV1Request_Request() {\n    return {\n        recipient: undefined,\n        payload: new Uint8Array(),\n        headerBytes: new Uint8Array(),\n    };\n}\nconst EncryptV1Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.recipient !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.encode(message.recipient, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(18).bytes(message.payload);\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(26).bytes(message.headerBytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV1Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.recipient = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.payload = reader.bytes();\n                    break;\n                case 3:\n                    message.headerBytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            recipient: isSet(object.recipient)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEncryptV1Request_Request();\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.PublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncryptResponse() {\n    return { responses: [] };\n}\nconst EncryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.responses) {\n            EncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(EncryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => EncryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? EncryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptResponse_Response.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst EncryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.result !== undefined) {\n            EncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = EncryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? EncryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? EncryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseEncryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? EncryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptResponse_Response_Success() {\n    return { encrypted: undefined, senderHmac: new Uint8Array() };\n}\nconst EncryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.encrypted !== undefined) {\n            _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.encrypted, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.senderHmac.length !== 0) {\n            writer.uint32(18).bytes(message.senderHmac);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.encrypted = _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.senderHmac = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            encrypted: isSet(object.encrypted)\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.encrypted)\n                : undefined,\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.encrypted !== undefined &&\n            (obj.encrypted = message.encrypted\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.encrypted)\n                : undefined);\n        message.senderHmac !== undefined &&\n            (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptResponse_Response_Success();\n        message.encrypted =\n            object.encrypted !== undefined && object.encrypted !== null\n                ? _message_contents_ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.encrypted)\n                : undefined;\n        message.senderHmac = (_a = object.senderHmac) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncryptV2Request() {\n    return { requests: [] };\n}\nconst EncryptV2Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            EncryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV2Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(EncryptV2Request_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => EncryptV2Request_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? EncryptV2Request_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptV2Request();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => EncryptV2Request_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseEncryptV2Request_Request() {\n    return {\n        payload: new Uint8Array(),\n        headerBytes: new Uint8Array(),\n        contentTopic: \"\",\n    };\n}\nconst EncryptV2Request_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(18).bytes(message.headerBytes);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(26).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptV2Request_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseEncryptV2Request_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.contentTopic = (_c = object.contentTopic) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseSelfEncryptRequest() {\n    return { requests: [] };\n}\nconst SelfEncryptRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            SelfEncryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SelfEncryptRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SelfEncryptRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SelfEncryptRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SelfEncryptRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSelfEncryptRequest_Request() {\n    return { payload: new Uint8Array() };\n}\nconst SelfEncryptRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptRequest_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse() {\n    return { responses: [] };\n}\nconst SelfEncryptResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.responses) {\n            SelfEncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(SelfEncryptResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => SelfEncryptResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? SelfEncryptResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => SelfEncryptResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst SelfEncryptResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.result !== undefined) {\n            SelfEncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = SelfEncryptResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? SelfEncryptResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? SelfEncryptResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSelfEncryptResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? SelfEncryptResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSelfEncryptResponse_Response_Success() {\n    return { encrypted: new Uint8Array() };\n}\nconst SelfEncryptResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.encrypted.length !== 0) {\n            writer.uint32(10).bytes(message.encrypted);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfEncryptResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.encrypted = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            encrypted: isSet(object.encrypted)\n                ? bytesFromBase64(object.encrypted)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.encrypted !== undefined &&\n            (obj.encrypted = base64FromBytes(message.encrypted !== undefined ? message.encrypted : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfEncryptResponse_Response_Success();\n        message.encrypted = (_a = object.encrypted) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSelfDecryptRequest() {\n    return { requests: [] };\n}\nconst SelfDecryptRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            SelfDecryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfDecryptRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SelfDecryptRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SelfDecryptRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SelfDecryptRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfDecryptRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SelfDecryptRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSelfDecryptRequest_Request() {\n    return { payload: new Uint8Array() };\n}\nconst SelfDecryptRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSelfDecryptRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSelfDecryptRequest_Request();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetPrivatePreferencesTopicIdentifierResponse() {\n    return { identifier: \"\" };\n}\nconst GetPrivatePreferencesTopicIdentifierResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.identifier !== \"\") {\n            writer.uint32(10).string(message.identifier);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identifier = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identifier: isSet(object.identifier) ? String(object.identifier) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identifier !== undefined && (obj.identifier = message.identifier);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();\n        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseCreateInviteRequest() {\n    return {\n        context: undefined,\n        recipient: undefined,\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        consentProof: undefined,\n    };\n}\nconst CreateInviteRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.context !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.encode(message.context, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        if (message.consentProof !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.encode(message.consentProof, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateInviteRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.context = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 4:\n                    message.consentProof = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            context: isSet(object.context)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            consentProof: isSet(object.consentProof)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.fromJSON(object.consentProof)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.consentProof !== undefined &&\n            (obj.consentProof = message.consentProof\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.toJSON(message.consentProof)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCreateInviteRequest();\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.consentProof =\n            object.consentProof !== undefined && object.consentProof !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.ConsentProofPayload.fromPartial(object.consentProof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateInviteResponse() {\n    return { conversation: undefined, payload: new Uint8Array() };\n}\nconst CreateInviteResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.conversation !== undefined) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(message.conversation, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(18).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateInviteResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversation = _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversation: isSet(object.conversation)\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseCreateInviteResponse();\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSaveInvitesRequest() {\n    return { requests: [] };\n}\nconst SaveInvitesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.requests) {\n            SaveInvitesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(SaveInvitesRequest_Request.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => SaveInvitesRequest_Request.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? SaveInvitesRequest_Request.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveInvitesRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => SaveInvitesRequest_Request.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSaveInvitesRequest_Request() {\n    return {\n        contentTopic: \"\",\n        timestampNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        payload: new Uint8Array(),\n    };\n}\nconst SaveInvitesRequest_Request = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.contentTopic !== \"\") {\n            writer.uint32(10).string(message.contentTopic);\n        }\n        if (!message.timestampNs.isZero()) {\n            writer.uint32(16).uint64(message.timestampNs);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(26).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesRequest_Request();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.contentTopic = reader.string();\n                    break;\n                case 2:\n                    message.timestampNs = reader.uint64();\n                    break;\n                case 3:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n            timestampNs: isSet(object.timestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.timestampNs !== undefined &&\n            (obj.timestampNs = (message.timestampNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSaveInvitesRequest_Request();\n        message.contentTopic = (_a = object.contentTopic) !== null && _a !== void 0 ? _a : \"\";\n        message.timestampNs =\n            object.timestampNs !== undefined && object.timestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse() {\n    return { responses: [] };\n}\nconst SaveInvitesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.responses) {\n            SaveInvitesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(SaveInvitesResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => SaveInvitesResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? SaveInvitesResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveInvitesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => SaveInvitesResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse_Response() {\n    return { result: undefined, error: undefined };\n}\nconst SaveInvitesResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.result !== undefined) {\n            SaveInvitesResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.result = SaveInvitesResponse_Response_Success.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            result: isSet(object.result)\n                ? SaveInvitesResponse_Response_Success.fromJSON(object.result)\n                : undefined,\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.result !== undefined &&\n            (obj.result = message.result\n                ? SaveInvitesResponse_Response_Success.toJSON(message.result)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSaveInvitesResponse_Response();\n        message.result =\n            object.result !== undefined && object.result !== null\n                ? SaveInvitesResponse_Response_Success.fromPartial(object.result)\n                : undefined;\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSaveInvitesResponse_Response_Success() {\n    return { conversation: undefined };\n}\nconst SaveInvitesResponse_Response_Success = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.conversation !== undefined) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(message.conversation, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveInvitesResponse_Response_Success();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversation = _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversation: isSet(object.conversation)\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSaveInvitesResponse_Response_Success();\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateAuthTokenRequest() {\n    return { timestampNs: undefined };\n}\nconst CreateAuthTokenRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.timestampNs !== undefined) {\n            writer.uint32(8).uint64(message.timestampNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateAuthTokenRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestampNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestampNs: isSet(object.timestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestampNs !== undefined &&\n            (obj.timestampNs = (message.timestampNs || undefined).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCreateAuthTokenRequest();\n        message.timestampNs =\n            object.timestampNs !== undefined && object.timestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSaveV1ConversationsRequest() {\n    return { conversations: [] };\n}\nconst SaveV1ConversationsRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.conversations) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveV1ConversationsRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversations.push(_message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations)\n                ? object.conversations.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.conversations) {\n            obj.conversations = message.conversations.map((e) => e ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(e) : undefined);\n        }\n        else {\n            obj.conversations = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSaveV1ConversationsRequest();\n        message.conversations =\n            ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseSaveV1ConversationsResponse() {\n    return {};\n}\nconst SaveV1ConversationsResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSaveV1ConversationsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSaveV1ConversationsResponse();\n        return message;\n    },\n};\nfunction createBaseGetConversationsResponse() {\n    return { conversations: [] };\n}\nconst GetConversationsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.conversations) {\n            _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversations.push(_message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations)\n                ? object.conversations.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.conversations) {\n            obj.conversations = message.conversations.map((e) => e ? _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.toJSON(e) : undefined);\n        }\n        else {\n            obj.conversations = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationsResponse();\n        message.conversations =\n            ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e) => _message_contents_conversation_reference_pb__WEBPACK_IMPORTED_MODULE_4__.ConversationReference.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBaseGetKeystoreStatusRequest() {\n    return { walletAddress: \"\" };\n}\nconst GetKeystoreStatusRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.walletAddress !== \"\") {\n            writer.uint32(10).string(message.walletAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetKeystoreStatusRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddress: isSet(object.walletAddress)\n                ? String(object.walletAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletAddress !== undefined &&\n            (obj.walletAddress = message.walletAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetKeystoreStatusRequest();\n        message.walletAddress = (_a = object.walletAddress) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetKeystoreStatusResponse() {\n    return { status: 0 };\n}\nconst GetKeystoreStatusResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.status !== 0) {\n            writer.uint32(8).int32(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetKeystoreStatusResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            status: isSet(object.status)\n                ? getKeystoreStatusResponse_KeystoreStatusFromJSON(object.status)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.status !== undefined &&\n            (obj.status = getKeystoreStatusResponse_KeystoreStatusToJSON(message.status));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetKeystoreStatusResponse();\n        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseInitKeystoreRequest() {\n    return { v1: undefined };\n}\nconst InitKeystoreRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitKeystoreRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseInitKeystoreRequest();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? _message_contents_private_key_pb__WEBPACK_IMPORTED_MODULE_5__.PrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseInitKeystoreResponse() {\n    return { error: undefined };\n}\nconst InitKeystoreResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.error !== undefined) {\n            KeystoreError.encode(message.error, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitKeystoreResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.error = KeystoreError.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            error: isSet(object.error)\n                ? KeystoreError.fromJSON(object.error)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.error !== undefined &&\n            (obj.error = message.error\n                ? KeystoreError.toJSON(message.error)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseInitKeystoreResponse();\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? KeystoreError.fromPartial(object.error)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignDigestRequest() {\n    return {\n        digest: new Uint8Array(),\n        identityKey: undefined,\n        prekeyIndex: undefined,\n    };\n}\nconst SignDigestRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.digest.length !== 0) {\n            writer.uint32(10).bytes(message.digest);\n        }\n        if (message.identityKey !== undefined) {\n            writer.uint32(16).bool(message.identityKey);\n        }\n        if (message.prekeyIndex !== undefined) {\n            writer.uint32(24).uint32(message.prekeyIndex);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignDigestRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.digest = reader.bytes();\n                    break;\n                case 2:\n                    message.identityKey = reader.bool();\n                    break;\n                case 3:\n                    message.prekeyIndex = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            digest: isSet(object.digest)\n                ? bytesFromBase64(object.digest)\n                : new Uint8Array(),\n            identityKey: isSet(object.identityKey)\n                ? Boolean(object.identityKey)\n                : undefined,\n            prekeyIndex: isSet(object.prekeyIndex)\n                ? Number(object.prekeyIndex)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.digest !== undefined &&\n            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey);\n        message.prekeyIndex !== undefined &&\n            (obj.prekeyIndex = Math.round(message.prekeyIndex));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseSignDigestRequest();\n        message.digest = (_a = object.digest) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.identityKey = (_b = object.identityKey) !== null && _b !== void 0 ? _b : undefined;\n        message.prekeyIndex = (_c = object.prekeyIndex) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBaseGetRefreshJobRequest() {\n    return { jobType: 0 };\n}\nconst GetRefreshJobRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.jobType !== 0) {\n            writer.uint32(8).int32(message.jobType);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetRefreshJobRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jobType = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jobType !== undefined &&\n            (obj.jobType = jobTypeToJSON(message.jobType));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetRefreshJobRequest();\n        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseGetRefreshJobResponse() {\n    return { lastRunNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO };\n}\nconst GetRefreshJobResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (!message.lastRunNs.isZero()) {\n            writer.uint32(8).int64(message.lastRunNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetRefreshJobResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.lastRunNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            lastRunNs: isSet(object.lastRunNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.lastRunNs !== undefined &&\n            (obj.lastRunNs = (message.lastRunNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetRefreshJobResponse();\n        message.lastRunNs =\n            object.lastRunNs !== undefined && object.lastRunNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO;\n        return message;\n    },\n};\nfunction createBaseSetRefeshJobRequest() {\n    return { jobType: 0, lastRunNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO };\n}\nconst SetRefeshJobRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.jobType !== 0) {\n            writer.uint32(8).int32(message.jobType);\n        }\n        if (!message.lastRunNs.isZero()) {\n            writer.uint32(16).int64(message.lastRunNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSetRefeshJobRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jobType = reader.int32();\n                    break;\n                case 2:\n                    message.lastRunNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,\n            lastRunNs: isSet(object.lastRunNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jobType !== undefined &&\n            (obj.jobType = jobTypeToJSON(message.jobType));\n        message.lastRunNs !== undefined &&\n            (obj.lastRunNs = (message.lastRunNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSetRefeshJobRequest();\n        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;\n        message.lastRunNs =\n            object.lastRunNs !== undefined && object.lastRunNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.lastRunNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZERO;\n        return message;\n    },\n};\nfunction createBaseSetRefreshJobResponse() {\n    return {};\n}\nconst SetRefreshJobResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSetRefreshJobResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSetRefreshJobResponse();\n        return message;\n    },\n};\nfunction createBaseTopicMap() {\n    return { topics: {} };\n}\nconst TopicMap = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        Object.entries(message.topics).forEach(([key, value]) => {\n            TopicMap_TopicsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = TopicMap_TopicsEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.topics[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topics: isObject(object.topics)\n                ? Object.entries(object.topics).reduce((acc, [key, value]) => {\n                    acc[key] = TopicMap_TopicData.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.topics = {};\n        if (message.topics) {\n            Object.entries(message.topics).forEach(([k, v]) => {\n                obj.topics[k] = TopicMap_TopicData.toJSON(v);\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap();\n        message.topics = Object.entries((_a = object.topics) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = TopicMap_TopicData.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseTopicMap_TopicData() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, peerAddress: \"\", invitation: undefined };\n}\nconst TopicMap_TopicData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.peerAddress !== \"\") {\n            writer.uint32(18).string(message.peerAddress);\n        }\n        if (message.invitation !== undefined) {\n            _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.encode(message.invitation, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap_TopicData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.peerAddress = reader.string();\n                    break;\n                case 3:\n                    message.invitation = _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : \"\",\n            invitation: isSet(object.invitation)\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.fromJSON(object.invitation)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.peerAddress !== undefined &&\n            (obj.peerAddress = message.peerAddress);\n        message.invitation !== undefined &&\n            (obj.invitation = message.invitation\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.toJSON(message.invitation)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap_TopicData();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.peerAddress = (_a = object.peerAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.invitation =\n            object.invitation !== undefined && object.invitation !== null\n                ? _message_contents_invitation_pb__WEBPACK_IMPORTED_MODULE_3__.InvitationV1.fromPartial(object.invitation)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseTopicMap_TopicsEntry() {\n    return { key: \"\", value: undefined };\n}\nconst TopicMap_TopicsEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            TopicMap_TopicData.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTopicMap_TopicsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = TopicMap_TopicData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value)\n                ? TopicMap_TopicData.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = message.value\n                ? TopicMap_TopicData.toJSON(message.value)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTopicMap_TopicsEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? TopicMap_TopicData.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysRequest() {\n    return { topics: [] };\n}\nconst GetConversationHmacKeysRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.topics) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topics.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topics: Array.isArray(object === null || object === void 0 ? void 0 : object.topics)\n                ? object.topics.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.topics) {\n            obj.topics = message.topics.map((e) => e);\n        }\n        else {\n            obj.topics = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysRequest();\n        message.topics = ((_a = object.topics) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse() {\n    return { hmacKeys: {} };\n}\nconst GetConversationHmacKeysResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        Object.entries(message.hmacKeys).forEach(([key, value]) => {\n            GetConversationHmacKeysResponse_HmacKeysEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = GetConversationHmacKeysResponse_HmacKeysEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.hmacKeys[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hmacKeys: isObject(object.hmacKeys)\n                ? Object.entries(object.hmacKeys).reduce((acc, [key, value]) => {\n                    acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.hmacKeys = {};\n        if (message.hmacKeys) {\n            Object.entries(message.hmacKeys).forEach(([k, v]) => {\n                obj.hmacKeys[k] = GetConversationHmacKeysResponse_HmacKeys.toJSON(v);\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse();\n        message.hmacKeys = Object.entries((_a = object.hmacKeys) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeyData() {\n    return { thirtyDayPeriodsSinceEpoch: 0, hmacKey: new Uint8Array() };\n}\nconst GetConversationHmacKeysResponse_HmacKeyData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.thirtyDayPeriodsSinceEpoch !== 0) {\n            writer.uint32(8).int32(message.thirtyDayPeriodsSinceEpoch);\n        }\n        if (message.hmacKey.length !== 0) {\n            writer.uint32(18).bytes(message.hmacKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.thirtyDayPeriodsSinceEpoch = reader.int32();\n                    break;\n                case 2:\n                    message.hmacKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            thirtyDayPeriodsSinceEpoch: isSet(object.thirtyDayPeriodsSinceEpoch)\n                ? Number(object.thirtyDayPeriodsSinceEpoch)\n                : 0,\n            hmacKey: isSet(object.hmacKey)\n                ? bytesFromBase64(object.hmacKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.thirtyDayPeriodsSinceEpoch !== undefined &&\n            (obj.thirtyDayPeriodsSinceEpoch = Math.round(message.thirtyDayPeriodsSinceEpoch));\n        message.hmacKey !== undefined &&\n            (obj.hmacKey = base64FromBytes(message.hmacKey !== undefined ? message.hmacKey : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();\n        message.thirtyDayPeriodsSinceEpoch = (_a = object.thirtyDayPeriodsSinceEpoch) !== null && _a !== void 0 ? _a : 0;\n        message.hmacKey = (_b = object.hmacKey) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeys() {\n    return { values: [] };\n}\nconst GetConversationHmacKeysResponse_HmacKeys = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        for (const v of message.values) {\n            GetConversationHmacKeysResponse_HmacKeyData.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.values.push(GetConversationHmacKeysResponse_HmacKeyData.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            values: Array.isArray(object === null || object === void 0 ? void 0 : object.values)\n                ? object.values.map((e) => GetConversationHmacKeysResponse_HmacKeyData.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.values) {\n            obj.values = message.values.map((e) => e ? GetConversationHmacKeysResponse_HmacKeyData.toJSON(e) : undefined);\n        }\n        else {\n            obj.values = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();\n        message.values =\n            ((_a = object.values) === null || _a === void 0 ? void 0 : _a.map((e) => GetConversationHmacKeysResponse_HmacKeyData.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetConversationHmacKeysResponse_HmacKeysEntry() {\n    return { key: \"\", value: undefined };\n}\nconst GetConversationHmacKeysResponse_HmacKeysEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            GetConversationHmacKeysResponse_HmacKeys.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = GetConversationHmacKeysResponse_HmacKeys.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value)\n                ? GetConversationHmacKeysResponse_HmacKeys.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = message.value\n                ? GetConversationHmacKeysResponse_HmacKeys.toJSON(message.value)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? GetConversationHmacKeysResponse_HmacKeys.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesActionMap() {\n    return { actions: {} };\n}\nconst PrivatePreferencesActionMap = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        Object.entries(message.actions).forEach(([key, value]) => {\n            PrivatePreferencesActionMap_ActionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesActionMap();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = PrivatePreferencesActionMap_ActionsEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.actions[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            actions: isObject(object.actions)\n                ? Object.entries(object.actions).reduce((acc, [key, value]) => {\n                    acc[key] = _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.actions = {};\n        if (message.actions) {\n            Object.entries(message.actions).forEach(([k, v]) => {\n                obj.actions[k] = _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.toJSON(v);\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesActionMap();\n        message.actions = Object.entries((_a = object.actions) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesActionMap_ActionsEntry() {\n    return { key: \"\", value: undefined };\n}\nconst PrivatePreferencesActionMap_ActionsEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesActionMap_ActionsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value)\n                ? _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = message.value\n                ? _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.toJSON(message.value)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesActionMap_ActionsEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? _message_contents_private_preferences_pb__WEBPACK_IMPORTED_MODULE_6__.PrivatePreferencesAction.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_7___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=keystore.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20va2V5c3RvcmVfYXBpL3YxL2tleXN0b3JlLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQzBDO0FBQzZCO0FBQ2lCO0FBQ3ZCO0FBQ2Q7QUFDYztBQUNwRDtBQUM5QjtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUN4QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDcEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0RkFBNEY7QUFDdEY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLHVFQUFVO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLDRFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUVBQVU7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QTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEZBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEZBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEZBQXdCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9rZXlzdG9yZV9hcGkvdjEva2V5c3RvcmUucGIuanM/MmY2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IENpcGhlcnRleHQgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9jaXBoZXJ0ZXh0LnBiXCI7XG5pbXBvcnQgeyBQdWJsaWNLZXlCdW5kbGUsIFNpZ25lZFB1YmxpY0tleUJ1bmRsZSwgfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9wdWJsaWNfa2V5LnBiXCI7XG5pbXBvcnQgeyBJbnZpdGF0aW9uVjFfQ29udGV4dCwgQ29uc2VudFByb29mUGF5bG9hZCwgSW52aXRhdGlvblYxLCB9IGZyb20gXCIuLi8uLi9tZXNzYWdlX2NvbnRlbnRzL2ludml0YXRpb24ucGJcIjtcbmltcG9ydCB7IENvbnZlcnNhdGlvblJlZmVyZW5jZSB9IGZyb20gXCIuLi8uLi9tZXNzYWdlX2NvbnRlbnRzL2NvbnZlcnNhdGlvbl9yZWZlcmVuY2UucGJcIjtcbmltcG9ydCB7IFByaXZhdGVLZXlCdW5kbGVWMSB9IGZyb20gXCIuLi8uLi9tZXNzYWdlX2NvbnRlbnRzL3ByaXZhdGVfa2V5LnBiXCI7XG5pbXBvcnQgeyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24gfSBmcm9tIFwiLi4vLi4vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX3ByZWZlcmVuY2VzLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAua2V5c3RvcmVfYXBpLnYxXCI7XG4vKiogTWVzc2FnZSBjb250ZW50IGVuY29kaW5nIHN0cnVjdHVyZXMgKi9cbi8qKiBBcHBsaWNhdGlvbi1zcGVjaWZpYyBlcnJvciBjb2RlcyBmb3IgdGhlIEtleXN0b3JlIEFQSS4gKi9cbmV4cG9ydCB2YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJST1JfQ09ERV9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJFUlJPUl9DT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVFwiXSA9IDFdID0gXCJFUlJPUl9DT0RFX0lOVkFMSURfSU5QVVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJST1JfQ09ERV9OT19NQVRDSElOR19QUkVLRVlcIl0gPSAyXSA9IFwiRVJST1JfQ09ERV9OT19NQVRDSElOR19QUkVLRVlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvZGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJFUlJPUl9DT0RFX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JDb2RlLkVSUk9SX0NPREVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVFwiOlxuICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQ7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZXCI6XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JDb2RlLkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JDb2RlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JDb2RlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLkVSUk9SX0NPREVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJFUlJPUl9DT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVDpcbiAgICAgICAgICAgIHJldHVybiBcIkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVFwiO1xuICAgICAgICBjYXNlIEVycm9yQ29kZS5FUlJPUl9DT0RFX05PX01BVENISU5HX1BSRUtFWTpcbiAgICAgICAgICAgIHJldHVybiBcIkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZXCI7XG4gICAgICAgIGNhc2UgRXJyb3JDb2RlLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOUkVDT0dOSVpFRFwiO1xuICAgIH1cbn1cbi8qKiBKb2JUeXBlIGlzIHVzZWQgdG8gc3BlY2lmeSB0aGUgdHlwZSBvZiBqb2IgdGhlIGNhbGxlciB3b3VsZCBsaWtlIGluZm8gb24gKi9cbmV4cG9ydCB2YXIgSm9iVHlwZTtcbihmdW5jdGlvbiAoSm9iVHlwZSkge1xuICAgIEpvYlR5cGVbSm9iVHlwZVtcIkpPQl9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkpPQl9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgSm9iVHlwZVtKb2JUeXBlW1wiSk9CX1RZUEVfUkVGUkVTSF9WMVwiXSA9IDFdID0gXCJKT0JfVFlQRV9SRUZSRVNIX1YxXCI7XG4gICAgSm9iVHlwZVtKb2JUeXBlW1wiSk9CX1RZUEVfUkVGUkVTSF9WMlwiXSA9IDJdID0gXCJKT0JfVFlQRV9SRUZSRVNIX1YyXCI7XG4gICAgSm9iVHlwZVtKb2JUeXBlW1wiSk9CX1RZUEVfUkVGUkVTSF9QUFBQXCJdID0gM10gPSBcIkpPQl9UWVBFX1JFRlJFU0hfUFBQUFwiO1xuICAgIEpvYlR5cGVbSm9iVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShKb2JUeXBlIHx8IChKb2JUeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBqb2JUeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiSk9CX1RZUEVfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBKb2JUeXBlLkpPQl9UWVBFX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJKT0JfVFlQRV9SRUZSRVNIX1YxXCI6XG4gICAgICAgICAgICByZXR1cm4gSm9iVHlwZS5KT0JfVFlQRV9SRUZSRVNIX1YxO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJKT0JfVFlQRV9SRUZSRVNIX1YyXCI6XG4gICAgICAgICAgICByZXR1cm4gSm9iVHlwZS5KT0JfVFlQRV9SRUZSRVNIX1YyO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJKT0JfVFlQRV9SRUZSRVNIX1BQUFBcIjpcbiAgICAgICAgICAgIHJldHVybiBKb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfUFBQUDtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEpvYlR5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2JUeXBlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgSm9iVHlwZS5KT0JfVFlQRV9VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkpPQl9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgSm9iVHlwZS5KT0JfVFlQRV9SRUZSRVNIX1YxOlxuICAgICAgICAgICAgcmV0dXJuIFwiSk9CX1RZUEVfUkVGUkVTSF9WMVwiO1xuICAgICAgICBjYXNlIEpvYlR5cGUuSk9CX1RZUEVfUkVGUkVTSF9WMjpcbiAgICAgICAgICAgIHJldHVybiBcIkpPQl9UWVBFX1JFRlJFU0hfVjJcIjtcbiAgICAgICAgY2FzZSBKb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfUFBQUDpcbiAgICAgICAgICAgIHJldHVybiBcIkpPQl9UWVBFX1JFRlJFU0hfUFBQUFwiO1xuICAgICAgICBjYXNlIEpvYlR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuLyoqIFN0YXR1cyBvZiB0aGUgS2V5c3RvcmUgZm9yIHRoZSBzcGVjaWZpZWQgd2FsbGV0IGFkZHJlc3MgKi9cbmV4cG9ydCB2YXIgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cztcbihmdW5jdGlvbiAoR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cykge1xuICAgIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c1tcIktFWVNUT1JFX1NUQVRVU19VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJLRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW0dldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbXCJLRVlTVE9SRV9TVEFUVVNfVU5JTklUSUFMSVpFRFwiXSA9IDFdID0gXCJLRVlTVE9SRV9TVEFUVVNfVU5JTklUSUFMSVpFRFwiO1xuICAgIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c1tcIktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRFwiXSA9IDJdID0gXCJLRVlTVE9SRV9TVEFUVVNfSU5JVElBTElaRURcIjtcbiAgICBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzW0dldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cyB8fCAoR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cyA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1c0Zyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIktFWVNUT1JFX1NUQVRVU19VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuS0VZU1RPUkVfU1RBVFVTX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJLRVlTVE9SRV9TVEFUVVNfVU5JTklUSUFMSVpFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRUQ7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuS0VZU1RPUkVfU1RBVFVTX0lOSVRJQUxJWkVEO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cy5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXNUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIktFWVNUT1JFX1NUQVRVU19VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuS0VZU1RPUkVfU1RBVFVTX1VOSU5JVElBTElaRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJLRVlTVE9SRV9TVEFUVVNfVU5JTklUSUFMSVpFRFwiO1xuICAgICAgICBjYXNlIEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2VfS2V5c3RvcmVTdGF0dXMuS0VZU1RPUkVfU1RBVFVTX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiS0VZU1RPUkVfU1RBVFVTX0lOSVRJQUxJWkVEXCI7XG4gICAgICAgIGNhc2UgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1cy5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTlJFQ09HTklaRURcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlS2V5c3RvcmVFcnJvcigpIHtcbiAgICByZXR1cm4geyBtZXNzYWdlOiBcIlwiLCBjb2RlOiAwIH07XG59XG5leHBvcnQgY29uc3QgS2V5c3RvcmVFcnJvciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb2RlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQzMihtZXNzYWdlLmNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlS2V5c3RvcmVFcnJvcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogaXNTZXQob2JqZWN0Lm1lc3NhZ2UpID8gU3RyaW5nKG9iamVjdC5tZXNzYWdlKSA6IFwiXCIsXG4gICAgICAgICAgICBjb2RlOiBpc1NldChvYmplY3QuY29kZSkgPyBlcnJvckNvZGVGcm9tSlNPTihvYmplY3QuY29kZSkgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubWVzc2FnZSA9IG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG1lc3NhZ2UuY29kZSAhPT0gdW5kZWZpbmVkICYmIChvYmouY29kZSA9IGVycm9yQ29kZVRvSlNPTihtZXNzYWdlLmNvZGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUtleXN0b3JlRXJyb3IoKTtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gKF9hID0gb2JqZWN0Lm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29kZSA9IChfYiA9IG9iamVjdC5jb2RlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNyeXB0VjFSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IERlY3J5cHRWMVJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIERlY3J5cHRWMVJlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMVJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMVJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICBwZWVyS2V5czogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaXNTZW5kZXI6IGZhbHNlLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5wYXlsb2FkLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJLZXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFB1YmxpY0tleUJ1bmRsZS5lbmNvZGUobWVzc2FnZS5wZWVyS2V5cywgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzU2VuZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5ib29sKG1lc3NhZ2UuaXNTZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFYxUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gQ2lwaGVydGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlcktleXMgPSBQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc1NlbmRlciA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tSlNPTihvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBlZXJLZXlzOiBpc1NldChvYmplY3QucGVlcktleXMpXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LnBlZXJLZXlzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaXNTZW5kZXI6IGlzU2V0KG9iamVjdC5pc1NlbmRlcikgPyBCb29sZWFuKG9iamVjdC5pc1NlbmRlcikgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LnRvSlNPTihtZXNzYWdlLnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnBlZXJLZXlzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGVlcktleXMgPSBtZXNzYWdlLnBlZXJLZXlzXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2UucGVlcktleXMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVhZGVyQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmhlYWRlckJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaXNTZW5kZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlzU2VuZGVyID0gbWVzc2FnZS5pc1NlbmRlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID1cbiAgICAgICAgICAgIG9iamVjdC5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBheWxvYWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucGVlcktleXMgPVxuICAgICAgICAgICAgb2JqZWN0LnBlZXJLZXlzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBlZXJLZXlzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnBlZXJLZXlzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gKF9hID0gb2JqZWN0LmhlYWRlckJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmlzU2VuZGVyID0gKF9iID0gb2JqZWN0LmlzU2VuZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBEZWNyeXB0UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0UmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcy5wdXNoKERlY3J5cHRSZXNwb25zZV9SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB1bmRlZmluZWQsIGVycm9yOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIERlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmVuY29kZShtZXNzYWdlLnJlc3VsdCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBLZXlzdG9yZUVycm9yLmVuY29kZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSBEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBLZXlzdG9yZUVycm9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogaXNTZXQob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA/IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21KU09OKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tSlNPTihvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXN1bHQgPSBtZXNzYWdlLnJlc3VsdFxuICAgICAgICAgICAgICAgID8gRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MudG9KU09OKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci50b0pTT04obWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgPVxuICAgICAgICAgICAgb2JqZWN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXN1bHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IERlY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmZyb21QYXJ0aWFsKG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmVycm9yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVycm9yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21QYXJ0aWFsKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHsgZGVjcnlwdGVkOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVjcnlwdGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5kZWNyeXB0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlY3J5cHRlZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNyeXB0ZWQ6IGlzU2V0KG9iamVjdC5kZWNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRlY3J5cHRlZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWNyeXB0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWNyeXB0ZWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5kZWNyeXB0ZWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGVjcnlwdGVkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICBtZXNzYWdlLmRlY3J5cHRlZCA9IChfYSA9IG9iamVjdC5kZWNyeXB0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURlY3J5cHRWMlJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgcmVxdWVzdHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgRGVjcnlwdFYyUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgRGVjcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFYyUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdHMucHVzaChEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXF1ZXN0cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXF1ZXN0cy5tYXAoKGUpID0+IERlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBtZXNzYWdlLnJlcXVlc3RzLm1hcCgoZSkgPT4gZSA/IERlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVjcnlwdFYyUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVxdWVzdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IERlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXlsb2FkOiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlckJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjb250ZW50VG9waWM6IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLnBheWxvYWQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50VG9waWMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSBDaXBoZXJ0ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWFkZXJCeXRlczogaXNTZXQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBjb250ZW50VG9waWM6IGlzU2V0KG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlckJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5oZWFkZXJCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY3J5cHRWMlJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPVxuICAgICAgICAgICAgb2JqZWN0LnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGF5bG9hZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tUGFydGlhbChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYSA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAoX2IgPSBvYmplY3QuY29udGVudFRvcGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRWMVJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIEVuY3J5cHRWMVJlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMVJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMVJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVjaXBpZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGhlYWRlckJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRW5jcnlwdFYxUmVxdWVzdF9SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2UucmVjaXBpZW50LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlYWRlckJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0VjFSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9IFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVjaXBpZW50OiBpc1NldChvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBoZWFkZXJCeXRlczogaXNTZXQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZWNpcGllbnQgPSBtZXNzYWdlLnJlY2lwaWVudFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnBheWxvYWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oZWFkZXJCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaGVhZGVyQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMVJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9XG4gICAgICAgICAgICBvYmplY3QucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlY2lwaWVudCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYSA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gKF9iID0gb2JqZWN0LmhlYWRlckJ5dGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzcG9uc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzLnB1c2goRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBtZXNzYWdlLnJlc3BvbnNlcy5tYXAoKGUpID0+IGUgPyBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXNwb25zZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVuY3J5cHRSZXNwb25zZV9SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXN1bHQ6IHVuZGVmaW5lZCwgZXJyb3I6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZW5jb2RlKG1lc3NhZ2UucmVzdWx0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEtleXN0b3JlRXJyb3IuZW5jb2RlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3VsdCA9IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEtleXN0b3JlRXJyb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBpc1NldChvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgID8gRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbUpTT04ob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlc3VsdCA9IG1lc3NhZ2UucmVzdWx0XG4gICAgICAgICAgICAgICAgPyBFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy50b0pTT04obWVzc2FnZS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJyb3IgPSBtZXNzYWdlLmVycm9yXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLnRvSlNPTihtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRSZXNwb25zZV9SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3VsdCA9XG4gICAgICAgICAgICBvYmplY3QucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlc3VsdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbVBhcnRpYWwob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5lcnJvciA9XG4gICAgICAgICAgICBvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IuZnJvbVBhcnRpYWwob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpIHtcbiAgICByZXR1cm4geyBlbmNyeXB0ZWQ6IHVuZGVmaW5lZCwgc2VuZGVySG1hYzogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVuY3J5cHRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLmVuY3J5cHRlZCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXJIbWFjLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5zZW5kZXJIbWFjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmNyeXB0ZWQgPSBDaXBoZXJ0ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXJIbWFjID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRlZDogaXNTZXQob2JqZWN0LmVuY3J5cHRlZClcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbUpTT04ob2JqZWN0LmVuY3J5cHRlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbmRlckhtYWM6IGlzU2V0KG9iamVjdC5zZW5kZXJIbWFjKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zZW5kZXJIbWFjKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmVuY3J5cHRlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVuY3J5cHRlZCA9IG1lc3NhZ2UuZW5jcnlwdGVkXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LnRvSlNPTihtZXNzYWdlLmVuY3J5cHRlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbmRlckhtYWMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zZW5kZXJIbWFjICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnNlbmRlckhtYWMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIG1lc3NhZ2UuZW5jcnlwdGVkID1cbiAgICAgICAgICAgIG9iamVjdC5lbmNyeXB0ZWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZW5jcnlwdGVkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5lbmNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyA9IChfYSA9IG9iamVjdC5zZW5kZXJIbWFjKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0VjJSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRWMlJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIEVuY3J5cHRWMlJlcXVlc3RfUmVxdWVzdC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMlJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMlJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QuZnJvbVBhcnRpYWwoZSkpKSB8fFxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0VjJSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaGVhZGVyQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGNvbnRlbnRUb3BpYzogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRWMlJlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRWMlJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnBheWxvYWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oZWFkZXJCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaGVhZGVyQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW5jcnlwdFYyUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYSA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gKF9iID0gb2JqZWN0LmhlYWRlckJ5dGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IChfYyA9IG9iamVjdC5jb250ZW50VG9waWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRW5jcnlwdFJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIFNlbGZFbmNyeXB0UmVxdWVzdF9SZXF1ZXN0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cy5wdXNoKFNlbGZFbmNyeXB0UmVxdWVzdF9SZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVxdWVzdHMubWFwKChlKSA9PiBTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBtZXNzYWdlLnJlcXVlc3RzLm1hcCgoZSkgPT4gZSA/IFNlbGZFbmNyeXB0UmVxdWVzdF9SZXF1ZXN0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVxdWVzdF9SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlcXVlc3RfUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgU2VsZkVuY3J5cHRSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRW5jcnlwdFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXNwb25zZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXN1bHQ6IHVuZGVmaW5lZCwgZXJyb3I6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5lbmNvZGUobWVzc2FnZS5yZXN1bHQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgS2V5c3RvcmVFcnJvci5lbmNvZGUobWVzc2FnZS5lcnJvciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3VsdCA9IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBLZXlzdG9yZUVycm9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogaXNTZXQob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA/IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5mcm9tSlNPTihvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXJyb3I6IGlzU2V0KG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IuZnJvbUpTT04ob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVzdWx0ID0gbWVzc2FnZS5yZXN1bHRcbiAgICAgICAgICAgICAgICA/IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy50b0pTT04obWVzc2FnZS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJyb3IgPSBtZXNzYWdlLmVycm9yXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLnRvSlNPTihtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgPVxuICAgICAgICAgICAgb2JqZWN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXN1bHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2Vzcy5mcm9tUGFydGlhbChvYmplY3QucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmVycm9yID1cbiAgICAgICAgICAgIG9iamVjdC5lcnJvciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5lcnJvciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci5mcm9tUGFydGlhbChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbGZFbmNyeXB0UmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpIHtcbiAgICByZXR1cm4geyBlbmNyeXB0ZWQ6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWxmRW5jcnlwdFJlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5jcnlwdGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5lbmNyeXB0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmNyeXB0ZWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5jcnlwdGVkOiBpc1NldChvYmplY3QuZW5jcnlwdGVkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5lbmNyeXB0ZWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZW5jcnlwdGVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZW5jcnlwdGVkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZW5jcnlwdGVkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmVuY3J5cHRlZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkVuY3J5cHRSZXNwb25zZV9SZXNwb25zZV9TdWNjZXNzKCk7XG4gICAgICAgIG1lc3NhZ2UuZW5jcnlwdGVkID0gKF9hID0gb2JqZWN0LmVuY3J5cHRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VsZkRlY3J5cHRSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbGZEZWNyeXB0UmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgU2VsZkRlY3J5cHRSZXF1ZXN0X1JlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWxmRGVjcnlwdFJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goU2VsZkRlY3J5cHRSZXF1ZXN0X1JlcXVlc3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXF1ZXN0cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXF1ZXN0cy5tYXAoKGUpID0+IFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IG1lc3NhZ2UucmVxdWVzdHMubWFwKChlKSA9PiBlID8gU2VsZkRlY3J5cHRSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZEZWNyeXB0UmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVxdWVzdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0LmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VsZkRlY3J5cHRSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VsZkRlY3J5cHRSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnBheWxvYWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbGZEZWNyeXB0UmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYSA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRQcml2YXRlUHJlZmVyZW5jZXNUb3BpY0lkZW50aWZpZXJSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBpZGVudGlmaWVyOiBcIlwiIH07XG59XG5leHBvcnQgY29uc3QgR2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpZmllciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRQcml2YXRlUHJlZmVyZW5jZXNUb3BpY0lkZW50aWZpZXJSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpZmllciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogaXNTZXQob2JqZWN0LmlkZW50aWZpZXIpID8gU3RyaW5nKG9iamVjdC5pZGVudGlmaWVyKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGlmaWVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5pZGVudGlmaWVyID0gbWVzc2FnZS5pZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGlmaWVyID0gKF9hID0gb2JqZWN0LmlkZW50aWZpZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNyZWF0ZUludml0ZVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICByZWNpcGllbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY3JlYXRlZE5zOiBMb25nLlVaRVJPLFxuICAgICAgICBjb25zZW50UHJvb2Y6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IENyZWF0ZUludml0ZVJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBJbnZpdGF0aW9uVjFfQ29udGV4dC5lbmNvZGUobWVzc2FnZS5jb250ZXh0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2UucmVjaXBpZW50LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS5jcmVhdGVkTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLmNyZWF0ZWROcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29uc2VudFByb29mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnNlbnRQcm9vZlBheWxvYWQuZW5jb2RlKG1lc3NhZ2UuY29uc2VudFByb29mLCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlSW52aXRlUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGV4dCA9IEludml0YXRpb25WMV9Db250ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgPSBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZiA9IENvbnNlbnRQcm9vZlBheWxvYWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dDogaXNTZXQob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC5mcm9tSlNPTihvYmplY3QuY29udGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlY2lwaWVudDogaXNTZXQob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3JlYXRlZE5zOiBpc1NldChvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBjb25zZW50UHJvb2Y6IGlzU2V0KG9iamVjdC5jb25zZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgPyBDb25zZW50UHJvb2ZQYXlsb2FkLmZyb21KU09OKG9iamVjdC5jb25zZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGV4dCA9IG1lc3NhZ2UuY29udGV4dFxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0NvbnRleHQudG9KU09OKG1lc3NhZ2UuY29udGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjaXBpZW50ID0gbWVzc2FnZS5yZWNpcGllbnRcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2YgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb25zZW50UHJvb2YgPSBtZXNzYWdlLmNvbnNlbnRQcm9vZlxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC50b0pTT04obWVzc2FnZS5jb25zZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlSW52aXRlUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmNvbnRleHQgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udGV4dCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0NvbnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ID1cbiAgICAgICAgICAgIG9iamVjdC5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjaXBpZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPVxuICAgICAgICAgICAgb2JqZWN0LmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVhdGVkTnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZiA9XG4gICAgICAgICAgICBvYmplY3QuY29uc2VudFByb29mICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnNlbnRQcm9vZiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC5mcm9tUGFydGlhbChvYmplY3QuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDcmVhdGVJbnZpdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBjb252ZXJzYXRpb246IHVuZGVmaW5lZCwgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IENyZWF0ZUludml0ZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb252ZXJzYXRpb25SZWZlcmVuY2UuZW5jb2RlKG1lc3NhZ2UuY29udmVyc2F0aW9uLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlSW52aXRlUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9IENvbnZlcnNhdGlvblJlZmVyZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb246IGlzU2V0KG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbUpTT04ob2JqZWN0LmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnZlcnNhdGlvbiA9IG1lc3NhZ2UuY29udmVyc2F0aW9uXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UudG9KU09OKG1lc3NhZ2UuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlSW52aXRlUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb252ZXJzYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tUGFydGlhbChvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJlcXVlc3RzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNhdmVJbnZpdGVzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgU2F2ZUludml0ZXNSZXF1ZXN0X1JlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RzLnB1c2goU2F2ZUludml0ZXNSZXF1ZXN0X1JlcXVlc3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXF1ZXN0cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXF1ZXN0cy5tYXAoKGUpID0+IFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdHMpIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IG1lc3NhZ2UucmVxdWVzdHMubWFwKChlKSA9PiBlID8gU2F2ZUludml0ZXNSZXF1ZXN0X1JlcXVlc3QudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVxdWVzdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0LmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXF1ZXN0X1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudFRvcGljOiBcIlwiLFxuICAgICAgICB0aW1lc3RhbXBOczogTG9uZy5VWkVSTyxcbiAgICAgICAgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UudGltZXN0YW1wTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnRpbWVzdGFtcE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVxdWVzdF9SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgdGltZXN0YW1wTnM6IGlzU2V0KG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50aW1lc3RhbXBOcyA9IChtZXNzYWdlLnRpbWVzdGFtcE5zIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXF1ZXN0X1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAoX2EgPSBvYmplY3QuY29udGVudFRvcGljKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE5zID1cbiAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXBOcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gKF9iID0gb2JqZWN0LnBheWxvYWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzcG9uc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNhdmVJbnZpdGVzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZUludml0ZXNSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzLnB1c2goU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXNwb25zZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmVzcG9uc2VzLm1hcCgoZSkgPT4gU2F2ZUludml0ZXNSZXNwb25zZV9SZXNwb25zZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IG1lc3NhZ2UucmVzcG9uc2VzLm1hcCgoZSkgPT4gZSA/IFNhdmVJbnZpdGVzUmVzcG9uc2VfUmVzcG9uc2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QucmVzcG9uc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVzcG9uc2VfUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiB1bmRlZmluZWQsIGVycm9yOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZW5jb2RlKG1lc3NhZ2UucmVzdWx0LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEtleXN0b3JlRXJyb3IuZW5jb2RlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gS2V5c3RvcmVFcnJvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGlzU2V0KG9iamVjdC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgPyBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbUpTT04ob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlc3VsdCA9IG1lc3NhZ2UucmVzdWx0XG4gICAgICAgICAgICAgICAgPyBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MudG9KU09OKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgID8gS2V5c3RvcmVFcnJvci50b0pTT04obWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0ID1cbiAgICAgICAgICAgIG9iamVjdC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzdWx0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MuZnJvbVBhcnRpYWwob2JqZWN0LnJlc3VsdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5lcnJvciA9XG4gICAgICAgICAgICBvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEtleXN0b3JlRXJyb3IuZnJvbVBhcnRpYWwob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHsgY29udmVyc2F0aW9uOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udmVyc2F0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnZlcnNhdGlvblJlZmVyZW5jZS5lbmNvZGUobWVzc2FnZS5jb252ZXJzYXRpb24sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlSW52aXRlc1Jlc3BvbnNlX1Jlc3BvbnNlX1N1Y2Nlc3MoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9IENvbnZlcnNhdGlvblJlZmVyZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb246IGlzU2V0KG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbUpTT04ob2JqZWN0LmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnZlcnNhdGlvbiA9IG1lc3NhZ2UuY29udmVyc2F0aW9uXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UudG9KU09OKG1lc3NhZ2UuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVJbnZpdGVzUmVzcG9uc2VfUmVzcG9uc2VfU3VjY2VzcygpO1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QuY29udmVyc2F0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnZlcnNhdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21QYXJ0aWFsKG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNyZWF0ZUF1dGhUb2tlblJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgdGltZXN0YW1wTnM6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IENyZWF0ZUF1dGhUb2tlblJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wTnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXBOcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDcmVhdGVBdXRoVG9rZW5SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXN0YW1wTnM6IGlzU2V0KG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBOcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wTnMgPSAobWVzc2FnZS50aW1lc3RhbXBOcyB8fCB1bmRlZmluZWQpLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ3JlYXRlQXV0aFRva2VuUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE5zID1cbiAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXBOcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcE5zKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTYXZlVjFDb252ZXJzYXRpb25zUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBjb252ZXJzYXRpb25zOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNhdmVWMUNvbnZlcnNhdGlvbnNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmNvbnZlcnNhdGlvbnMpIHtcbiAgICAgICAgICAgIENvbnZlcnNhdGlvblJlZmVyZW5jZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNhdmVWMUNvbnZlcnNhdGlvbnNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25zLnB1c2goQ29udmVyc2F0aW9uUmVmZXJlbmNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb25zOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5jb252ZXJzYXRpb25zKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmNvbnZlcnNhdGlvbnMubWFwKChlKSA9PiBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICBvYmouY29udmVyc2F0aW9ucyA9IG1lc3NhZ2UuY29udmVyc2F0aW9ucy5tYXAoKGUpID0+IGUgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5jb252ZXJzYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZVYxQ29udmVyc2F0aW9uc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25zID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuY29udmVyc2F0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2F2ZVYxQ29udmVyc2F0aW9uc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydCBjb25zdCBTYXZlVjFDb252ZXJzYXRpb25zUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTYXZlVjFDb252ZXJzYXRpb25zUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2F2ZVYxQ29udmVyc2F0aW9uc1Jlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbnNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBjb252ZXJzYXRpb25zOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldENvbnZlcnNhdGlvbnNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICBDb252ZXJzYXRpb25SZWZlcmVuY2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25zUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbnMucHVzaChDb252ZXJzYXRpb25SZWZlcmVuY2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmNvbnZlcnNhdGlvbnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuY29udmVyc2F0aW9ucy5tYXAoKGUpID0+IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbnMpIHtcbiAgICAgICAgICAgIG9iai5jb252ZXJzYXRpb25zID0gbWVzc2FnZS5jb252ZXJzYXRpb25zLm1hcCgoZSkgPT4gZSA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmNvbnZlcnNhdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25zUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25zID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuY29udmVyc2F0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHdhbGxldEFkZHJlc3M6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRLZXlzdG9yZVN0YXR1c1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uud2FsbGV0QWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uud2FsbGV0QWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRLZXlzdG9yZVN0YXR1c1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldEFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdhbGxldEFkZHJlc3M6IGlzU2V0KG9iamVjdC53YWxsZXRBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC53YWxsZXRBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLndhbGxldEFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai53YWxsZXRBZGRyZXNzID0gbWVzc2FnZS53YWxsZXRBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkcmVzcyA9IChfYSA9IG9iamVjdC53YWxsZXRBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHN0YXR1czogMCB9O1xufVxuZXhwb3J0IGNvbnN0IEdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0YXR1cyA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IGlzU2V0KG9iamVjdC5zdGF0dXMpXG4gICAgICAgICAgICAgICAgPyBnZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzRnJvbUpTT04ob2JqZWN0LnN0YXR1cylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zdGF0dXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdGF0dXMgPSBnZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzVG9KU09OKG1lc3NhZ2Uuc3RhdHVzKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5zdGF0dXMgPSAoX2EgPSBvYmplY3Quc3RhdHVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VJbml0S2V5c3RvcmVSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBJbml0S2V5c3RvcmVSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFByaXZhdGVLZXlCdW5kbGVWMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluaXRLZXlzdG9yZVJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gUHJpdmF0ZUtleUJ1bmRsZVYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gUHJpdmF0ZUtleUJ1bmRsZVYxLmZyb21KU09OKG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MSA/IFByaXZhdGVLZXlCdW5kbGVWMS50b0pTT04obWVzc2FnZS52MSkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5pdEtleXN0b3JlUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleUJ1bmRsZVYxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW5pdEtleXN0b3JlUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEluaXRLZXlzdG9yZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEtleXN0b3JlRXJyb3IuZW5jb2RlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbml0S2V5c3RvcmVSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBLZXlzdG9yZUVycm9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJyb3IgPSBtZXNzYWdlLmVycm9yXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLnRvSlNPTihtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluaXRLZXlzdG9yZVJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmVycm9yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVycm9yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBLZXlzdG9yZUVycm9yLmZyb21QYXJ0aWFsKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbkRpZ2VzdFJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlnZXN0OiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBpZGVudGl0eUtleTogdW5kZWZpbmVkLFxuICAgICAgICBwcmVrZXlJbmRleDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgU2lnbkRpZ2VzdFJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGlnZXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5kaWdlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmJvb2wobWVzc2FnZS5pZGVudGl0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJla2V5SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDMyKG1lc3NhZ2UucHJla2V5SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbkRpZ2VzdFJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpZ2VzdCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJla2V5SW5kZXggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZ2VzdDogaXNTZXQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGlnZXN0KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBpc1NldChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgPyBCb29sZWFuKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZWtleUluZGV4OiBpc1NldChvYmplY3QucHJla2V5SW5kZXgpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnByZWtleUluZGV4KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGlnZXN0ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRpZ2VzdCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW50aXR5S2V5ID0gbWVzc2FnZS5pZGVudGl0eUtleSk7XG4gICAgICAgIG1lc3NhZ2UucHJla2V5SW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wcmVrZXlJbmRleCA9IE1hdGgucm91bmQobWVzc2FnZS5wcmVrZXlJbmRleCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25EaWdlc3RSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gKF9hID0gb2JqZWN0LmRpZ2VzdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9IChfYiA9IG9iamVjdC5pZGVudGl0eUtleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnByZWtleUluZGV4ID0gKF9jID0gb2JqZWN0LnByZWtleUluZGV4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldFJlZnJlc2hKb2JSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGpvYlR5cGU6IDAgfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRSZWZyZXNoSm9iUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5qb2JUeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2Uuam9iVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRSZWZyZXNoSm9iUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuam9iVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqb2JUeXBlOiBpc1NldChvYmplY3Quam9iVHlwZSkgPyBqb2JUeXBlRnJvbUpTT04ob2JqZWN0LmpvYlR5cGUpIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmpvYlR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5qb2JUeXBlID0gam9iVHlwZVRvSlNPTihtZXNzYWdlLmpvYlR5cGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0UmVmcmVzaEpvYlJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5qb2JUeXBlID0gKF9hID0gb2JqZWN0LmpvYlR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldFJlZnJlc2hKb2JSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBsYXN0UnVuTnM6IExvbmcuWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IEdldFJlZnJlc2hKb2JSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UubGFzdFJ1bk5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDY0KG1lc3NhZ2UubGFzdFJ1bk5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldFJlZnJlc2hKb2JSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFzdFJ1bk5zID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhc3RSdW5OczogaXNTZXQob2JqZWN0Lmxhc3RSdW5OcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5sYXN0UnVuTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5sYXN0UnVuTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5sYXN0UnVuTnMgPSAobWVzc2FnZS5sYXN0UnVuTnMgfHwgTG9uZy5aRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldFJlZnJlc2hKb2JSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmxhc3RSdW5OcyA9XG4gICAgICAgICAgICBvYmplY3QubGFzdFJ1bk5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmxhc3RSdW5OcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0Lmxhc3RSdW5OcylcbiAgICAgICAgICAgICAgICA6IExvbmcuWkVSTztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2V0UmVmZXNoSm9iUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBqb2JUeXBlOiAwLCBsYXN0UnVuTnM6IExvbmcuWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IFNldFJlZmVzaEpvYlJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuam9iVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLmpvYlR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS5sYXN0UnVuTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDY0KG1lc3NhZ2UubGFzdFJ1bk5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNldFJlZmVzaEpvYlJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmpvYlR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxhc3RSdW5OcyA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqb2JUeXBlOiBpc1NldChvYmplY3Quam9iVHlwZSkgPyBqb2JUeXBlRnJvbUpTT04ob2JqZWN0LmpvYlR5cGUpIDogMCxcbiAgICAgICAgICAgIGxhc3RSdW5OczogaXNTZXQob2JqZWN0Lmxhc3RSdW5OcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5sYXN0UnVuTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5qb2JUeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouam9iVHlwZSA9IGpvYlR5cGVUb0pTT04obWVzc2FnZS5qb2JUeXBlKSk7XG4gICAgICAgIG1lc3NhZ2UubGFzdFJ1bk5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubGFzdFJ1bk5zID0gKG1lc3NhZ2UubGFzdFJ1bk5zIHx8IExvbmcuWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNldFJlZmVzaEpvYlJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5qb2JUeXBlID0gKF9hID0gb2JqZWN0LmpvYlR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UubGFzdFJ1bk5zID1cbiAgICAgICAgICAgIG9iamVjdC5sYXN0UnVuTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubGFzdFJ1bk5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QubGFzdFJ1bk5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5aRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZXRSZWZyZXNoSm9iUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0IGNvbnN0IFNldFJlZnJlc2hKb2JSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNldFJlZnJlc2hKb2JSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZXRSZWZyZXNoSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVG9waWNNYXAoKSB7XG4gICAgcmV0dXJuIHsgdG9waWNzOiB7fSB9O1xufVxuZXhwb3J0IGNvbnN0IFRvcGljTWFwID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UudG9waWNzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIFRvcGljTWFwX1RvcGljc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb3BpY01hcCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MSA9IFRvcGljTWFwX1RvcGljc0VudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeTEudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3BpY3NbZW50cnkxLmtleV0gPSBlbnRyeTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9waWNzOiBpc09iamVjdChvYmplY3QudG9waWNzKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqZWN0LnRvcGljcykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFRvcGljTWFwX1RvcGljRGF0YS5mcm9tSlNPTih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBvYmoudG9waWNzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljcykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS50b3BpY3MpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIG9iai50b3BpY3Nba10gPSBUb3BpY01hcF9Ub3BpY0RhdGEudG9KU09OKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9waWNNYXAoKTtcbiAgICAgICAgbWVzc2FnZS50b3BpY3MgPSBPYmplY3QuZW50cmllcygoX2EgPSBvYmplY3QudG9waWNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFRvcGljTWFwX1RvcGljRGF0YS5mcm9tUGFydGlhbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljRGF0YSgpIHtcbiAgICByZXR1cm4geyBjcmVhdGVkTnM6IExvbmcuVVpFUk8sIHBlZXJBZGRyZXNzOiBcIlwiLCBpbnZpdGF0aW9uOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBUb3BpY01hcF9Ub3BpY0RhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmNyZWF0ZWROcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5wZWVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW52aXRhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBJbnZpdGF0aW9uVjEuZW5jb2RlKG1lc3NhZ2UuaW52aXRhdGlvbiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljRGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnZpdGF0aW9uID0gSW52aXRhdGlvblYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgcGVlckFkZHJlc3M6IGlzU2V0KG9iamVjdC5wZWVyQWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LnBlZXJBZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgICAgICBpbnZpdGF0aW9uOiBpc1NldChvYmplY3QuaW52aXRhdGlvbilcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMS5mcm9tSlNPTihvYmplY3QuaW52aXRhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5wZWVyQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBlZXJBZGRyZXNzID0gbWVzc2FnZS5wZWVyQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UuaW52aXRhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmludml0YXRpb24gPSBtZXNzYWdlLmludml0YXRpb25cbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMS50b0pTT04obWVzc2FnZS5pbnZpdGF0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9waWNNYXBfVG9waWNEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5wZWVyQWRkcmVzcyA9IChfYSA9IG9iamVjdC5wZWVyQWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pbnZpdGF0aW9uID1cbiAgICAgICAgICAgIG9iamVjdC5pbnZpdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmludml0YXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMS5mcm9tUGFydGlhbChvYmplY3QuaW52aXRhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVG9waWNNYXBfVG9waWNzRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgVG9waWNNYXBfVG9waWNzRW50cnkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFRvcGljTWFwX1RvcGljRGF0YS5lbmNvZGUobWVzc2FnZS52YWx1ZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IFRvcGljTWFwX1RvcGljRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGlzU2V0KG9iamVjdC5rZXkpID8gU3RyaW5nKG9iamVjdC5rZXkpIDogXCJcIixcbiAgICAgICAgICAgIHZhbHVlOiBpc1NldChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgPyBUb3BpY01hcF9Ub3BpY0RhdGEuZnJvbUpTT04ob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgJiYgKG9iai5rZXkgPSBtZXNzYWdlLmtleSk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWVcbiAgICAgICAgICAgICAgICA/IFRvcGljTWFwX1RvcGljRGF0YS50b0pTT04obWVzc2FnZS52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRvcGljTWFwX1RvcGljc0VudHJ5KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gKF9hID0gb2JqZWN0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFRvcGljTWFwX1RvcGljRGF0YS5mcm9tUGFydGlhbChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyB0b3BpY3M6IFtdIH07XG59XG5leHBvcnQgY29uc3QgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnRvcGljcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3BpY3MucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3BpY3M6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnRvcGljcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC50b3BpY3MubWFwKChlKSA9PiBTdHJpbmcoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50b3BpY3MpIHtcbiAgICAgICAgICAgIG9iai50b3BpY3MgPSBtZXNzYWdlLnRvcGljcy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnRvcGljcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLnRvcGljcyA9ICgoX2EgPSBvYmplY3QudG9waWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgaG1hY0tleXM6IHt9IH07XG59XG5leHBvcnQgY29uc3QgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLmhtYWNLZXlzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXNFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MSA9IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkxLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaG1hY0tleXNbZW50cnkxLmtleV0gPSBlbnRyeTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG1hY0tleXM6IGlzT2JqZWN0KG9iamVjdC5obWFjS2V5cylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5obWFjS2V5cykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMuZnJvbUpTT04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLmhtYWNLZXlzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmhtYWNLZXlzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLmhtYWNLZXlzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBvYmouaG1hY0tleXNba10gPSBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLnRvSlNPTih2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5obWFjS2V5cyA9IE9iamVjdC5lbnRyaWVzKChfYSA9IG9iamVjdC5obWFjS2V5cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLmZyb21QYXJ0aWFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YSgpIHtcbiAgICByZXR1cm4geyB0aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaDogMCwgaG1hY0tleTogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2ggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaG1hY0tleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaG1hY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaG1hY0tleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaDogaXNTZXQob2JqZWN0LnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKG9iamVjdC50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBobWFjS2V5OiBpc1NldChvYmplY3QuaG1hY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaG1hY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoID0gTWF0aC5yb3VuZChtZXNzYWdlLnRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoKSk7XG4gICAgICAgIG1lc3NhZ2UuaG1hY0tleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhtYWNLZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5obWFjS2V5ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmhtYWNLZXkgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2ggPSAoX2EgPSBvYmplY3QudGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaG1hY0tleSA9IChfYiA9IG9iamVjdC5obWFjS2V5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzKCkge1xuICAgIHJldHVybiB7IHZhbHVlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnZhbHVlcykge1xuICAgICAgICAgICAgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcy5wdXNoKEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QudmFsdWVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnZhbHVlcy5tYXAoKGUpID0+IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleURhdGEuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMpIHtcbiAgICAgICAgICAgIG9iai52YWx1ZXMgPSBtZXNzYWdlLnZhbHVlcy5tYXAoKGUpID0+IGUgPyBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlEYXRhLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cygpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5RGF0YS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5c0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLmVuY29kZShtZXNzYWdlLnZhbHVlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5c0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IEdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IFN0cmluZyhvYmplY3Qua2V5KSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy5mcm9tSlNPTihvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmtleSA9IG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbHVlID0gbWVzc2FnZS52YWx1ZVxuICAgICAgICAgICAgICAgID8gR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZV9IbWFjS2V5cy50b0pTT04obWVzc2FnZS52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldENvbnZlcnNhdGlvbkhtYWNLZXlzUmVzcG9uc2VfSG1hY0tleXNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBHZXRDb252ZXJzYXRpb25IbWFjS2V5c1Jlc3BvbnNlX0htYWNLZXlzLmZyb21QYXJ0aWFsKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uTWFwKCkge1xuICAgIHJldHVybiB7IGFjdGlvbnM6IHt9IH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uTWFwID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UuYWN0aW9ucykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXBfQWN0aW9uc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeTEgPSBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXBfQWN0aW9uc0VudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeTEudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb25zW2VudHJ5MS5rZXldID0gZW50cnkxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGlvbnM6IGlzT2JqZWN0KG9iamVjdC5hY3Rpb25zKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqZWN0LmFjdGlvbnMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24uZnJvbUpTT04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLmFjdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aW9ucykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5hY3Rpb25zKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBvYmouYWN0aW9uc1trXSA9IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbi50b0pTT04odik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXAoKTtcbiAgICAgICAgbWVzc2FnZS5hY3Rpb25zID0gT2JqZWN0LmVudHJpZXMoKF9hID0gb2JqZWN0LmFjdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uLmZyb21QYXJ0aWFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uTWFwX0FjdGlvbnNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6IFwiXCIsIHZhbHVlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXBfQWN0aW9uc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24uZW5jb2RlKG1lc3NhZ2UudmFsdWUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXBfQWN0aW9uc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGlzU2V0KG9iamVjdC5rZXkpID8gU3RyaW5nKG9iamVjdC5rZXkpIDogXCJcIixcbiAgICAgICAgICAgIHZhbHVlOiBpc1NldChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24uZnJvbUpTT04ob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5ICE9PSB1bmRlZmluZWQgJiYgKG9iai5rZXkgPSBtZXNzYWdlLmtleSk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWVcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbi50b0pTT04obWVzc2FnZS52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbk1hcF9BY3Rpb25zRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2EgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID1cbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52YWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlzdG9yZS5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/keystore_api/v1/keystore.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthData: () => (/* binding */ AuthData),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../message_contents/public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../message_contents/signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_api.v1\";\nfunction createBaseToken() {\n    return {\n        identityKey: undefined,\n        authDataBytes: new Uint8Array(),\n        authDataSignature: undefined,\n    };\n}\nconst Token = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.authDataBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authDataBytes);\n        }\n        if (message.authDataSignature !== undefined) {\n            _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.encode(message.authDataSignature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseToken();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.authDataBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.authDataSignature = _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromJSON(object.identityKey)\n                : undefined,\n            authDataBytes: isSet(object.authDataBytes)\n                ? bytesFromBase64(object.authDataBytes)\n                : new Uint8Array(),\n            authDataSignature: isSet(object.authDataSignature)\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromJSON(object.authDataSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.authDataBytes !== undefined &&\n            (obj.authDataBytes = base64FromBytes(message.authDataBytes !== undefined\n                ? message.authDataBytes\n                : new Uint8Array()));\n        message.authDataSignature !== undefined &&\n            (obj.authDataSignature = message.authDataSignature\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.toJSON(message.authDataSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseToken();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? _message_contents_public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.authDataBytes = (_a = object.authDataBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authDataSignature =\n            object.authDataSignature !== undefined &&\n                object.authDataSignature !== null\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromPartial(object.authDataSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAuthData() {\n    return { walletAddr: \"\", createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst AuthData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.walletAddr !== \"\") {\n            writer.uint32(10).string(message.walletAddr);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(16).uint64(message.createdNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAuthData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddr = reader.string();\n                    break;\n                case 2:\n                    message.createdNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddr: isSet(object.walletAddr) ? String(object.walletAddr) : \"\",\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletAddr !== undefined && (obj.walletAddr = message.walletAddr);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAuthData();\n        message.walletAddr = (_a = object.walletAddr) !== null && _a !== void 0 ? _a : \"\";\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=authn.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9hcGkvdjEvYXV0aG4ucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUN5QztBQUNEO0FBQzNCO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBLFlBQVksc0VBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQVM7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzRUFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFFQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFTO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNFQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSwyQkFBMkIsNENBQUk7QUFDNUM7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2FwaS92MS9hdXRobi5wYi5qcz9jM2I0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSBcIi4uLy4uL21lc3NhZ2VfY29udGVudHMvcHVibGljX2tleS5wYlwiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uLy4uL21lc3NhZ2VfY29udGVudHMvc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9hcGkudjFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUb2tlbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGl0eUtleTogdW5kZWZpbmVkLFxuICAgICAgICBhdXRoRGF0YUJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBhdXRoRGF0YVNpZ25hdHVyZTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgVG9rZW4gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5LmVuY29kZShtZXNzYWdlLmlkZW50aXR5S2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhEYXRhQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmF1dGhEYXRhQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5hdXRoRGF0YVNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRva2VuKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9IFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aERhdGFCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aERhdGFTaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IGlzU2V0KG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhdXRoRGF0YUJ5dGVzOiBpc1NldChvYmplY3QuYXV0aERhdGFCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYXV0aERhdGFCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBhdXRoRGF0YVNpZ25hdHVyZTogaXNTZXQob2JqZWN0LmF1dGhEYXRhU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5hdXRoRGF0YVNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaWRlbnRpdHlLZXkgPSBtZXNzYWdlLmlkZW50aXR5S2V5XG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmF1dGhEYXRhQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hdXRoRGF0YUJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYXV0aERhdGFCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmF1dGhEYXRhQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5hdXRoRGF0YVNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmF1dGhEYXRhU2lnbmF0dXJlID0gbWVzc2FnZS5hdXRoRGF0YVNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9rZW4oKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9XG4gICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWRlbnRpdHlLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYXV0aERhdGFCeXRlcyA9IChfYSA9IG9iamVjdC5hdXRoRGF0YUJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhEYXRhU2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5hdXRoRGF0YVNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmF1dGhEYXRhU2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LmF1dGhEYXRhU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VBdXRoRGF0YSgpIHtcbiAgICByZXR1cm4geyB3YWxsZXRBZGRyOiBcIlwiLCBjcmVhdGVkTnM6IExvbmcuVVpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBBdXRoRGF0YSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS53YWxsZXRBZGRyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS53YWxsZXRBZGRyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQXV0aERhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldEFkZHIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdhbGxldEFkZHI6IGlzU2V0KG9iamVjdC53YWxsZXRBZGRyKSA/IFN0cmluZyhvYmplY3Qud2FsbGV0QWRkcikgOiBcIlwiLFxuICAgICAgICAgICAgY3JlYXRlZE5zOiBpc1NldChvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyICE9PSB1bmRlZmluZWQgJiYgKG9iai53YWxsZXRBZGRyID0gbWVzc2FnZS53YWxsZXRBZGRyKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUF1dGhEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkciA9IChfYSA9IG9iamVjdC53YWxsZXRBZGRyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZWROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG4ucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/authn.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageApi: () => (/* binding */ MessageApi),\n/* harmony export */   SortDirection: () => (/* binding */ SortDirection)\n/* harmony export */ });\n/* harmony import */ var _fetch_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../fetch.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/fetch.pb.js\");\n/* eslint-disable */\n// @ts-nocheck\n/*\n* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY\n*/\n\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection[\"SORT_DIRECTION_UNSPECIFIED\"] = \"SORT_DIRECTION_UNSPECIFIED\";\n    SortDirection[\"SORT_DIRECTION_ASCENDING\"] = \"SORT_DIRECTION_ASCENDING\";\n    SortDirection[\"SORT_DIRECTION_DESCENDING\"] = \"SORT_DIRECTION_DESCENDING\";\n})(SortDirection || (SortDirection = {}));\nclass MessageApi {\n    static Publish(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/publish`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static Subscribe(req, entityNotifier, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchStreamingRequest(`/message/v1/subscribe`, entityNotifier, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static SubscribeAll(req, entityNotifier, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchStreamingRequest(`/message/v1/subscribe-all`, entityNotifier, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static Query(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/query`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n    static BatchQuery(req, initReq) {\n        return _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.fetchReq(`/message/v1/batch-query`, Object.assign(Object.assign({}, initReq), { method: \"POST\", body: JSON.stringify(req, _fetch_pb__WEBPACK_IMPORTED_MODULE_0__.replacer) }));\n    }\n}\n//# sourceMappingURL=message_api.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9hcGkvdjEvbWVzc2FnZV9hcGkucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBLGVBQWUsK0NBQVcsc0RBQXNELGNBQWMsMENBQTBDLCtDQUFXLEdBQUc7QUFDdEo7QUFDQTtBQUNBLGVBQWUsNERBQXdCLHdFQUF3RSxjQUFjLDBDQUEwQywrQ0FBVyxHQUFHO0FBQ3JMO0FBQ0E7QUFDQSxlQUFlLDREQUF3Qiw0RUFBNEUsY0FBYywwQ0FBMEMsK0NBQVcsR0FBRztBQUN6TDtBQUNBO0FBQ0EsZUFBZSwrQ0FBVyxvREFBb0QsY0FBYywwQ0FBMEMsK0NBQVcsR0FBRztBQUNwSjtBQUNBO0FBQ0EsZUFBZSwrQ0FBVywwREFBMEQsY0FBYywwQ0FBMEMsK0NBQVcsR0FBRztBQUMxSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2FwaS92MS9tZXNzYWdlX2FwaS5wYi5qcz9iYzgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuLypcbiogVGhpcyBmaWxlIGlzIGEgZ2VuZXJhdGVkIFR5cGVzY3JpcHQgZmlsZSBmb3IgR1JQQyBHYXRld2F5LCBETyBOT1QgTU9ESUZZXG4qL1xuaW1wb3J0ICogYXMgZm0gZnJvbSBcIi4uLy4uL2ZldGNoLnBiXCI7XG5leHBvcnQgdmFyIFNvcnREaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNvcnREaXJlY3Rpb24pIHtcbiAgICBTb3J0RGlyZWN0aW9uW1wiU09SVF9ESVJFQ1RJT05fVU5TUEVDSUZJRURcIl0gPSBcIlNPUlRfRElSRUNUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgU29ydERpcmVjdGlvbltcIlNPUlRfRElSRUNUSU9OX0FTQ0VORElOR1wiXSA9IFwiU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HXCI7XG4gICAgU29ydERpcmVjdGlvbltcIlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkdcIl0gPSBcIlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkdcIjtcbn0pKFNvcnREaXJlY3Rpb24gfHwgKFNvcnREaXJlY3Rpb24gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIE1lc3NhZ2VBcGkge1xuICAgIHN0YXRpYyBQdWJsaXNoKHJlcSwgaW5pdFJlcSkge1xuICAgICAgICByZXR1cm4gZm0uZmV0Y2hSZXEoYC9tZXNzYWdlL3YxL3B1Ymxpc2hgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRSZXEpLCB7IG1ldGhvZDogXCJQT1NUXCIsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcSwgZm0ucmVwbGFjZXIpIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIFN1YnNjcmliZShyZXEsIGVudGl0eU5vdGlmaWVyLCBpbml0UmVxKSB7XG4gICAgICAgIHJldHVybiBmbS5mZXRjaFN0cmVhbWluZ1JlcXVlc3QoYC9tZXNzYWdlL3YxL3N1YnNjcmliZWAsIGVudGl0eU5vdGlmaWVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRSZXEpLCB7IG1ldGhvZDogXCJQT1NUXCIsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcSwgZm0ucmVwbGFjZXIpIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIFN1YnNjcmliZUFsbChyZXEsIGVudGl0eU5vdGlmaWVyLCBpbml0UmVxKSB7XG4gICAgICAgIHJldHVybiBmbS5mZXRjaFN0cmVhbWluZ1JlcXVlc3QoYC9tZXNzYWdlL3YxL3N1YnNjcmliZS1hbGxgLCBlbnRpdHlOb3RpZmllciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0UmVxKSwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBKU09OLnN0cmluZ2lmeShyZXEsIGZtLnJlcGxhY2VyKSB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBRdWVyeShyZXEsIGluaXRSZXEpIHtcbiAgICAgICAgcmV0dXJuIGZtLmZldGNoUmVxKGAvbWVzc2FnZS92MS9xdWVyeWAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFJlcSksIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxLCBmbS5yZXBsYWNlcikgfSkpO1xuICAgIH1cbiAgICBzdGF0aWMgQmF0Y2hRdWVyeShyZXEsIGluaXRSZXEpIHtcbiAgICAgICAgcmV0dXJuIGZtLmZldGNoUmVxKGAvbWVzc2FnZS92MS9iYXRjaC1xdWVyeWAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFJlcSksIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxLCBmbS5yZXBsYWNlcikgfSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VfYXBpLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_api/v1/message_api.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ciphertext: () => (/* binding */ Ciphertext),\n/* harmony export */   Ciphertext_Aes256gcmHkdfsha256: () => (/* binding */ Ciphertext_Aes256gcmHkdfsha256),\n/* harmony export */   SignedEciesCiphertext: () => (/* binding */ SignedEciesCiphertext),\n/* harmony export */   SignedEciesCiphertext_Ecies: () => (/* binding */ SignedEciesCiphertext_Ecies),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseCiphertext() {\n    return { aes256GcmHkdfSha256: undefined };\n}\nconst Ciphertext = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.aes256GcmHkdfSha256 !== undefined) {\n            Ciphertext_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCiphertext();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.aes256GcmHkdfSha256 = Ciphertext_Aes256gcmHkdfsha256.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256)\n                ? Ciphertext_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.aes256GcmHkdfSha256 !== undefined &&\n            (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256\n                ? Ciphertext_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseCiphertext();\n        message.aes256GcmHkdfSha256 =\n            object.aes256GcmHkdfSha256 !== undefined &&\n                object.aes256GcmHkdfSha256 !== null\n                ? Ciphertext_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCiphertext_Aes256gcmHkdfsha256() {\n    return {\n        hkdfSalt: new Uint8Array(),\n        gcmNonce: new Uint8Array(),\n        payload: new Uint8Array(),\n    };\n}\nconst Ciphertext_Aes256gcmHkdfsha256 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.hkdfSalt.length !== 0) {\n            writer.uint32(10).bytes(message.hkdfSalt);\n        }\n        if (message.gcmNonce.length !== 0) {\n            writer.uint32(18).bytes(message.gcmNonce);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(26).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCiphertext_Aes256gcmHkdfsha256();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hkdfSalt = reader.bytes();\n                    break;\n                case 2:\n                    message.gcmNonce = reader.bytes();\n                    break;\n                case 3:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hkdfSalt: isSet(object.hkdfSalt)\n                ? bytesFromBase64(object.hkdfSalt)\n                : new Uint8Array(),\n            gcmNonce: isSet(object.gcmNonce)\n                ? bytesFromBase64(object.gcmNonce)\n                : new Uint8Array(),\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hkdfSalt !== undefined &&\n            (obj.hkdfSalt = base64FromBytes(message.hkdfSalt !== undefined ? message.hkdfSalt : new Uint8Array()));\n        message.gcmNonce !== undefined &&\n            (obj.gcmNonce = base64FromBytes(message.gcmNonce !== undefined ? message.gcmNonce : new Uint8Array()));\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseCiphertext_Aes256gcmHkdfsha256();\n        message.hkdfSalt = (_a = object.hkdfSalt) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.gcmNonce = (_b = object.gcmNonce) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.payload = (_c = object.payload) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignedEciesCiphertext() {\n    return { eciesBytes: new Uint8Array(), signature: undefined };\n}\nconst SignedEciesCiphertext = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.eciesBytes.length !== 0) {\n            writer.uint32(10).bytes(message.eciesBytes);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedEciesCiphertext();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eciesBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            eciesBytes: isSet(object.eciesBytes)\n                ? bytesFromBase64(object.eciesBytes)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.eciesBytes !== undefined &&\n            (obj.eciesBytes = base64FromBytes(message.eciesBytes !== undefined ? message.eciesBytes : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedEciesCiphertext();\n        message.eciesBytes = (_a = object.eciesBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedEciesCiphertext_Ecies() {\n    return {\n        ephemeralPublicKey: new Uint8Array(),\n        iv: new Uint8Array(),\n        mac: new Uint8Array(),\n        ciphertext: new Uint8Array(),\n    };\n}\nconst SignedEciesCiphertext_Ecies = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.ephemeralPublicKey.length !== 0) {\n            writer.uint32(10).bytes(message.ephemeralPublicKey);\n        }\n        if (message.iv.length !== 0) {\n            writer.uint32(18).bytes(message.iv);\n        }\n        if (message.mac.length !== 0) {\n            writer.uint32(26).bytes(message.mac);\n        }\n        if (message.ciphertext.length !== 0) {\n            writer.uint32(34).bytes(message.ciphertext);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedEciesCiphertext_Ecies();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ephemeralPublicKey = reader.bytes();\n                    break;\n                case 2:\n                    message.iv = reader.bytes();\n                    break;\n                case 3:\n                    message.mac = reader.bytes();\n                    break;\n                case 4:\n                    message.ciphertext = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ephemeralPublicKey: isSet(object.ephemeralPublicKey)\n                ? bytesFromBase64(object.ephemeralPublicKey)\n                : new Uint8Array(),\n            iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(),\n            mac: isSet(object.mac) ? bytesFromBase64(object.mac) : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? bytesFromBase64(object.ciphertext)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ephemeralPublicKey !== undefined &&\n            (obj.ephemeralPublicKey = base64FromBytes(message.ephemeralPublicKey !== undefined\n                ? message.ephemeralPublicKey\n                : new Uint8Array()));\n        message.iv !== undefined &&\n            (obj.iv = base64FromBytes(message.iv !== undefined ? message.iv : new Uint8Array()));\n        message.mac !== undefined &&\n            (obj.mac = base64FromBytes(message.mac !== undefined ? message.mac : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = base64FromBytes(message.ciphertext !== undefined ? message.ciphertext : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseSignedEciesCiphertext_Ecies();\n        message.ephemeralPublicKey = (_a = object.ephemeralPublicKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.iv = (_b = object.iv) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.mac = (_c = object.mac) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.ciphertext = (_d = object.ciphertext) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=ciphertext.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jaXBoZXJ0ZXh0LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ21CO0FBQ047QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBUztBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL2NpcGhlcnRleHQucGIuanM/ZTkwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuL3NpZ25hdHVyZS5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDaXBoZXJ0ZXh0KCkge1xuICAgIHJldHVybiB7IGFlczI1NkdjbUhrZGZTaGEyNTY6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IENpcGhlcnRleHQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYuZW5jb2RlKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1Niwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNpcGhlcnRleHQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgPSBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWVzMjU2R2NtSGtkZlNoYTI1NjogaXNTZXQob2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYuZnJvbUpTT04ob2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWVzMjU2R2NtSGtkZlNoYTI1NiA9IG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NlxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dF9BZXMyNTZnY21Ia2Rmc2hhMjU2LnRvSlNPTihtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2lwaGVydGV4dCgpO1xuICAgICAgICBtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgPVxuICAgICAgICAgICAgb2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYuZnJvbVBhcnRpYWwob2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNpcGhlcnRleHRfQWVzMjU2Z2NtSGtkZnNoYTI1NigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoa2RmU2FsdDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZ2NtTm9uY2U6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGtkZlNhbHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmhrZGZTYWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5nY21Ob25jZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuZ2NtTm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2lwaGVydGV4dF9BZXMyNTZnY21Ia2Rmc2hhMjU2KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oa2RmU2FsdCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2NtTm9uY2UgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGtkZlNhbHQ6IGlzU2V0KG9iamVjdC5oa2RmU2FsdClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGtkZlNhbHQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZ2NtTm9uY2U6IGlzU2V0KG9iamVjdC5nY21Ob25jZSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZ2NtTm9uY2UpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgcGF5bG9hZDogaXNTZXQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGtkZlNhbHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oa2RmU2FsdCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhrZGZTYWx0ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmhrZGZTYWx0IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmdjbU5vbmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZ2NtTm9uY2UgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5nY21Ob25jZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5nY21Ob25jZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDaXBoZXJ0ZXh0X0FlczI1NmdjbUhrZGZzaGEyNTYoKTtcbiAgICAgICAgbWVzc2FnZS5oa2RmU2FsdCA9IChfYSA9IG9iamVjdC5oa2RmU2FsdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5nY21Ob25jZSA9IChfYiA9IG9iamVjdC5nY21Ob25jZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gKF9jID0gb2JqZWN0LnBheWxvYWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZEVjaWVzQ2lwaGVydGV4dCgpIHtcbiAgICByZXR1cm4geyBlY2llc0J5dGVzOiBuZXcgVWludDhBcnJheSgpLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25lZEVjaWVzQ2lwaGVydGV4dCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5lY2llc0J5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5lY2llc0J5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEVjaWVzQ2lwaGVydGV4dCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWNpZXNCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVjaWVzQnl0ZXM6IGlzU2V0KG9iamVjdC5lY2llc0J5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5lY2llc0J5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaXNTZXQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tSlNPTihvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZWNpZXNCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVjaWVzQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5lY2llc0J5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmVjaWVzQnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRFY2llc0NpcGhlcnRleHQoKTtcbiAgICAgICAgbWVzc2FnZS5lY2llc0J5dGVzID0gKF9hID0gb2JqZWN0LmVjaWVzQnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0X0VjaWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVwaGVtZXJhbFB1YmxpY0tleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaXY6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIG1hYzogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgY2lwaGVydGV4dDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25lZEVjaWVzQ2lwaGVydGV4dF9FY2llcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5lcGhlbWVyYWxQdWJsaWNLZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmVwaGVtZXJhbFB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXYubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLml2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tYWMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLm1hYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2lwaGVydGV4dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLmJ5dGVzKG1lc3NhZ2UuY2lwaGVydGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRFY2llc0NpcGhlcnRleHRfRWNpZXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVwaGVtZXJhbFB1YmxpY0tleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXYgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1hYyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcGhlbWVyYWxQdWJsaWNLZXk6IGlzU2V0KG9iamVjdC5lcGhlbWVyYWxQdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmVwaGVtZXJhbFB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBpdjogaXNTZXQob2JqZWN0Lml2KSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaXYpIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIG1hYzogaXNTZXQob2JqZWN0Lm1hYykgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm1hYykgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaXNTZXQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXBoZW1lcmFsUHVibGljS2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuZXBoZW1lcmFsUHVibGljS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaXYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pdiA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLml2ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLml2IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLm1hYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm1hYyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLm1hYyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5tYWMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNpcGhlcnRleHQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmNpcGhlcnRleHQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEVjaWVzQ2lwaGVydGV4dF9FY2llcygpO1xuICAgICAgICBtZXNzYWdlLmVwaGVtZXJhbFB1YmxpY0tleSA9IChfYSA9IG9iamVjdC5lcGhlbWVyYWxQdWJsaWNLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaXYgPSAoX2IgPSBvYmplY3QuaXYpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UubWFjID0gKF9jID0gb2JqZWN0Lm1hYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID0gKF9kID0gb2JqZWN0LmNpcGhlcnRleHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2lwaGVydGV4dC5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   Composite_Part: () => (/* binding */ Composite_Part),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _content_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseComposite() {\n    return { parts: [] };\n}\nconst Composite = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.parts) {\n            Composite_Part.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComposite();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.parts.push(Composite_Part.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            parts: Array.isArray(object === null || object === void 0 ? void 0 : object.parts)\n                ? object.parts.map((e) => Composite_Part.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.parts) {\n            obj.parts = message.parts.map((e) => e ? Composite_Part.toJSON(e) : undefined);\n        }\n        else {\n            obj.parts = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseComposite();\n        message.parts =\n            ((_a = object.parts) === null || _a === void 0 ? void 0 : _a.map((e) => Composite_Part.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseComposite_Part() {\n    return { part: undefined, composite: undefined };\n}\nconst Composite_Part = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.part !== undefined) {\n            _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.encode(message.part, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.composite !== undefined) {\n            Composite.encode(message.composite, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComposite_Part();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.part = _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.composite = Composite.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            part: isSet(object.part)\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.fromJSON(object.part)\n                : undefined,\n            composite: isSet(object.composite)\n                ? Composite.fromJSON(object.composite)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.part !== undefined &&\n            (obj.part = message.part\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.toJSON(message.part)\n                : undefined);\n        message.composite !== undefined &&\n            (obj.composite = message.composite\n                ? Composite.toJSON(message.composite)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseComposite_Part();\n        message.part =\n            object.part !== undefined && object.part !== null\n                ? _content_pb__WEBPACK_IMPORTED_MODULE_1__.EncodedContent.fromPartial(object.part)\n                : undefined;\n        message.composite =\n            object.composite !== undefined && object.composite !== null\n                ? Composite.fromPartial(object.composite)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=composite.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb21wb3NpdGUucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ3NCO0FBQ1Q7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLHVEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb21wb3NpdGUucGIuanM/MTkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IEVuY29kZWRDb250ZW50IH0gZnJvbSBcIi4vY29udGVudC5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb21wb3NpdGUoKSB7XG4gICAgcmV0dXJuIHsgcGFydHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgQ29tcG9zaXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnBhcnRzKSB7XG4gICAgICAgICAgICBDb21wb3NpdGVfUGFydC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbXBvc2l0ZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydHMucHVzaChDb21wb3NpdGVfUGFydC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnBhcnRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnBhcnRzLm1hcCgoZSkgPT4gQ29tcG9zaXRlX1BhcnQuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0cykge1xuICAgICAgICAgICAgb2JqLnBhcnRzID0gbWVzc2FnZS5wYXJ0cy5tYXAoKGUpID0+IGUgPyBDb21wb3NpdGVfUGFydC50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcG9zaXRlKCk7XG4gICAgICAgIG1lc3NhZ2UucGFydHMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5wYXJ0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gQ29tcG9zaXRlX1BhcnQuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29tcG9zaXRlX1BhcnQoKSB7XG4gICAgcmV0dXJuIHsgcGFydDogdW5kZWZpbmVkLCBjb21wb3NpdGU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IENvbXBvc2l0ZV9QYXJ0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRW5jb2RlZENvbnRlbnQuZW5jb2RlKG1lc3NhZ2UucGFydCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21wb3NpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLmVuY29kZShtZXNzYWdlLmNvbXBvc2l0ZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbXBvc2l0ZV9QYXJ0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0ID0gRW5jb2RlZENvbnRlbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXBvc2l0ZSA9IENvbXBvc2l0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0OiBpc1NldChvYmplY3QucGFydClcbiAgICAgICAgICAgICAgICA/IEVuY29kZWRDb250ZW50LmZyb21KU09OKG9iamVjdC5wYXJ0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29tcG9zaXRlOiBpc1NldChvYmplY3QuY29tcG9zaXRlKVxuICAgICAgICAgICAgICAgID8gQ29tcG9zaXRlLmZyb21KU09OKG9iamVjdC5jb21wb3NpdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFydCA9IG1lc3NhZ2UucGFydFxuICAgICAgICAgICAgICAgID8gRW5jb2RlZENvbnRlbnQudG9KU09OKG1lc3NhZ2UucGFydClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29tcG9zaXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29tcG9zaXRlID0gbWVzc2FnZS5jb21wb3NpdGVcbiAgICAgICAgICAgICAgICA/IENvbXBvc2l0ZS50b0pTT04obWVzc2FnZS5jb21wb3NpdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcG9zaXRlX1BhcnQoKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0ID1cbiAgICAgICAgICAgIG9iamVjdC5wYXJ0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhcnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEVuY29kZWRDb250ZW50LmZyb21QYXJ0aWFsKG9iamVjdC5wYXJ0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNvbXBvc2l0ZSA9XG4gICAgICAgICAgICBvYmplY3QuY29tcG9zaXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbXBvc2l0ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29tcG9zaXRlLmZyb21QYXJ0aWFsKG9iamVjdC5jb21wb3NpdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9zaXRlLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/composite.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactBundle: () => (/* binding */ ContactBundle),\n/* harmony export */   ContactBundleV1: () => (/* binding */ ContactBundleV1),\n/* harmony export */   ContactBundleV2: () => (/* binding */ ContactBundleV2),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseContactBundleV1() {\n    return { keyBundle: undefined };\n}\nconst ContactBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.keyBundle, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBundle: isSet(object.keyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.keyBundle)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBundle !== undefined &&\n            (obj.keyBundle = message.keyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.keyBundle)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundleV1();\n        message.keyBundle =\n            object.keyBundle !== undefined && object.keyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.keyBundle)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContactBundleV2() {\n    return { keyBundle: undefined };\n}\nconst ContactBundleV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.keyBundle, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundleV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBundle: isSet(object.keyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.keyBundle)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBundle !== undefined &&\n            (obj.keyBundle = message.keyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.keyBundle)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundleV2();\n        message.keyBundle =\n            object.keyBundle !== undefined && object.keyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.keyBundle)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContactBundle() {\n    return { v1: undefined, v2: undefined };\n}\nconst ContactBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            ContactBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            ContactBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContactBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = ContactBundleV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = ContactBundleV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? ContactBundleV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? ContactBundleV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? ContactBundleV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? ContactBundleV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseContactBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? ContactBundleV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? ContactBundleV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=contact.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb250YWN0LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDaUQ7QUFDcEM7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSwyREFBZTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSxZQUFZLGlFQUFxQjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlFQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29udGFjdC5wYi5qcz8xNzdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgUHVibGljS2V5QnVuZGxlLCBTaWduZWRQdWJsaWNLZXlCdW5kbGUgfSBmcm9tIFwiLi9wdWJsaWNfa2V5LnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGVWMSgpIHtcbiAgICByZXR1cm4geyBrZXlCdW5kbGU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IENvbnRhY3RCdW5kbGVWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlCdW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLmtleUJ1bmRsZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRhY3RCdW5kbGVWMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5QnVuZGxlID0gUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleUJ1bmRsZTogaXNTZXQob2JqZWN0LmtleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3Qua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5QnVuZGxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5QnVuZGxlID0gbWVzc2FnZS5rZXlCdW5kbGVcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5rZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGFjdEJ1bmRsZVYxKCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5QnVuZGxlID1cbiAgICAgICAgICAgIG9iamVjdC5rZXlCdW5kbGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qua2V5QnVuZGxlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LmtleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29udGFjdEJ1bmRsZVYyKCkge1xuICAgIHJldHVybiB7IGtleUJ1bmRsZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgQ29udGFjdEJ1bmRsZVYyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZW5jb2RlKG1lc3NhZ2Uua2V5QnVuZGxlLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGFjdEJ1bmRsZVYyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgPSBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5QnVuZGxlOiBpc1NldChvYmplY3Qua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5rZXlCdW5kbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXlCdW5kbGUgPSBtZXNzYWdlLmtleUJ1bmRsZVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLmtleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlVjIoKTtcbiAgICAgICAgbWVzc2FnZS5rZXlCdW5kbGUgPVxuICAgICAgICAgICAgb2JqZWN0LmtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5rZXlCdW5kbGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3Qua2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQsIHYyOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBDb250YWN0QnVuZGxlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENvbnRhY3RCdW5kbGVWMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb250YWN0QnVuZGxlVjIuZW5jb2RlKG1lc3NhZ2UudjIsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IENvbnRhY3RCdW5kbGVWMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjIgPSBDb250YWN0QnVuZGxlVjIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSkgPyBDb250YWN0QnVuZGxlVjEuZnJvbUpTT04ob2JqZWN0LnYxKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHYyOiBpc1NldChvYmplY3QudjIpID8gQ29udGFjdEJ1bmRsZVYyLmZyb21KU09OKG9iamVjdC52MikgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MSA/IENvbnRhY3RCdW5kbGVWMS50b0pTT04obWVzc2FnZS52MSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnYyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjIgPSBtZXNzYWdlLnYyID8gQ29udGFjdEJ1bmRsZVYyLnRvSlNPTihtZXNzYWdlLnYyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250YWN0QnVuZGxlKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb250YWN0QnVuZGxlVjEuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnYyID1cbiAgICAgICAgICAgIG9iamVjdC52MiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29udGFjdEJ1bmRsZVYyLmZyb21QYXJ0aWFsKG9iamVjdC52MilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWN0LnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/contact.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compression: () => (/* binding */ Compression),\n/* harmony export */   ContentTypeId: () => (/* binding */ ContentTypeId),\n/* harmony export */   EncodedContent: () => (/* binding */ EncodedContent),\n/* harmony export */   EncodedContent_ParametersEntry: () => (/* binding */ EncodedContent_ParametersEntry),\n/* harmony export */   SignedContent: () => (/* binding */ SignedContent),\n/* harmony export */   compressionFromJSON: () => (/* binding */ compressionFromJSON),\n/* harmony export */   compressionToJSON: () => (/* binding */ compressionToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\n/** Message content encoding structures */\n/**\n * Recognized compression algorithms\n * protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH\n */\nvar Compression;\n(function (Compression) {\n    Compression[Compression[\"COMPRESSION_DEFLATE\"] = 0] = \"COMPRESSION_DEFLATE\";\n    Compression[Compression[\"COMPRESSION_GZIP\"] = 1] = \"COMPRESSION_GZIP\";\n    Compression[Compression[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Compression || (Compression = {}));\nfunction compressionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"COMPRESSION_DEFLATE\":\n            return Compression.COMPRESSION_DEFLATE;\n        case 1:\n        case \"COMPRESSION_GZIP\":\n            return Compression.COMPRESSION_GZIP;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Compression.UNRECOGNIZED;\n    }\n}\nfunction compressionToJSON(object) {\n    switch (object) {\n        case Compression.COMPRESSION_DEFLATE:\n            return \"COMPRESSION_DEFLATE\";\n        case Compression.COMPRESSION_GZIP:\n            return \"COMPRESSION_GZIP\";\n        case Compression.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseContentTypeId() {\n    return { authorityId: \"\", typeId: \"\", versionMajor: 0, versionMinor: 0 };\n}\nconst ContentTypeId = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.authorityId !== \"\") {\n            writer.uint32(10).string(message.authorityId);\n        }\n        if (message.typeId !== \"\") {\n            writer.uint32(18).string(message.typeId);\n        }\n        if (message.versionMajor !== 0) {\n            writer.uint32(24).uint32(message.versionMajor);\n        }\n        if (message.versionMinor !== 0) {\n            writer.uint32(32).uint32(message.versionMinor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContentTypeId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authorityId = reader.string();\n                    break;\n                case 2:\n                    message.typeId = reader.string();\n                    break;\n                case 3:\n                    message.versionMajor = reader.uint32();\n                    break;\n                case 4:\n                    message.versionMinor = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            authorityId: isSet(object.authorityId) ? String(object.authorityId) : \"\",\n            typeId: isSet(object.typeId) ? String(object.typeId) : \"\",\n            versionMajor: isSet(object.versionMajor)\n                ? Number(object.versionMajor)\n                : 0,\n            versionMinor: isSet(object.versionMinor)\n                ? Number(object.versionMinor)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authorityId !== undefined &&\n            (obj.authorityId = message.authorityId);\n        message.typeId !== undefined && (obj.typeId = message.typeId);\n        message.versionMajor !== undefined &&\n            (obj.versionMajor = Math.round(message.versionMajor));\n        message.versionMinor !== undefined &&\n            (obj.versionMinor = Math.round(message.versionMinor));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseContentTypeId();\n        message.authorityId = (_a = object.authorityId) !== null && _a !== void 0 ? _a : \"\";\n        message.typeId = (_b = object.typeId) !== null && _b !== void 0 ? _b : \"\";\n        message.versionMajor = (_c = object.versionMajor) !== null && _c !== void 0 ? _c : 0;\n        message.versionMinor = (_d = object.versionMinor) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBaseEncodedContent() {\n    return {\n        type: undefined,\n        parameters: {},\n        fallback: undefined,\n        compression: undefined,\n        content: new Uint8Array(),\n    };\n}\nconst EncodedContent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.type !== undefined) {\n            ContentTypeId.encode(message.type, writer.uint32(10).fork()).ldelim();\n        }\n        Object.entries(message.parameters).forEach(([key, value]) => {\n            EncodedContent_ParametersEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\n        });\n        if (message.fallback !== undefined) {\n            writer.uint32(26).string(message.fallback);\n        }\n        if (message.compression !== undefined) {\n            writer.uint32(40).int32(message.compression);\n        }\n        if (message.content.length !== 0) {\n            writer.uint32(34).bytes(message.content);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = ContentTypeId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    const entry2 = EncodedContent_ParametersEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.parameters[entry2.key] = entry2.value;\n                    }\n                    break;\n                case 3:\n                    message.fallback = reader.string();\n                    break;\n                case 5:\n                    message.compression = reader.int32();\n                    break;\n                case 4:\n                    message.content = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type)\n                ? ContentTypeId.fromJSON(object.type)\n                : undefined,\n            parameters: isObject(object.parameters)\n                ? Object.entries(object.parameters).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n            fallback: isSet(object.fallback) ? String(object.fallback) : undefined,\n            compression: isSet(object.compression)\n                ? compressionFromJSON(object.compression)\n                : undefined,\n            content: isSet(object.content)\n                ? bytesFromBase64(object.content)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined &&\n            (obj.type = message.type\n                ? ContentTypeId.toJSON(message.type)\n                : undefined);\n        obj.parameters = {};\n        if (message.parameters) {\n            Object.entries(message.parameters).forEach(([k, v]) => {\n                obj.parameters[k] = v;\n            });\n        }\n        message.fallback !== undefined && (obj.fallback = message.fallback);\n        message.compression !== undefined &&\n            (obj.compression =\n                message.compression !== undefined\n                    ? compressionToJSON(message.compression)\n                    : undefined);\n        message.content !== undefined &&\n            (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseEncodedContent();\n        message.type =\n            object.type !== undefined && object.type !== null\n                ? ContentTypeId.fromPartial(object.type)\n                : undefined;\n        message.parameters = Object.entries((_a = object.parameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        message.fallback = (_b = object.fallback) !== null && _b !== void 0 ? _b : undefined;\n        message.compression = (_c = object.compression) !== null && _c !== void 0 ? _c : undefined;\n        message.content = (_d = object.content) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncodedContent_ParametersEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst EncodedContent_ParametersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent_ParametersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEncodedContent_ParametersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSignedContent() {\n    return { payload: new Uint8Array(), sender: undefined, signature: undefined };\n}\nconst SignedContent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.sender, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.encode(message.signature, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedContent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedContent();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_2__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=content.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb250ZW50LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNnQztBQUNiO0FBQ047QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQzVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FB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O0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvY29udGVudC5wYi5qcz9lYTg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmVkUHVibGljS2V5QnVuZGxlIH0gZnJvbSBcIi4vcHVibGljX2tleS5wYlwiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuLyoqIE1lc3NhZ2UgY29udGVudCBlbmNvZGluZyBzdHJ1Y3R1cmVzICovXG4vKipcbiAqIFJlY29nbml6ZWQgY29tcHJlc3Npb24gYWxnb3JpdGhtc1xuICogcHJvdG9saW50OmRpc2FibGUgRU5VTV9GSUVMRF9OQU1FU19aRVJPX1ZBTFVFX0VORF9XSVRIXG4gKi9cbmV4cG9ydCB2YXIgQ29tcHJlc3Npb247XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uKSB7XG4gICAgQ29tcHJlc3Npb25bQ29tcHJlc3Npb25bXCJDT01QUkVTU0lPTl9ERUZMQVRFXCJdID0gMF0gPSBcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIjtcbiAgICBDb21wcmVzc2lvbltDb21wcmVzc2lvbltcIkNPTVBSRVNTSU9OX0daSVBcIl0gPSAxXSA9IFwiQ09NUFJFU1NJT05fR1pJUFwiO1xuICAgIENvbXByZXNzaW9uW0NvbXByZXNzaW9uW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKENvbXByZXNzaW9uIHx8IChDb21wcmVzc2lvbiA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Npb25Gcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJDT01QUkVTU0lPTl9ERUZMQVRFXCI6XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fREVGTEFURTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiQ09NUFJFU1NJT05fR1pJUFwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbXByZXNzaW9uLkNPTVBSRVNTSU9OX0daSVA7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2lvbi5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzaW9uVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fREVGTEFURTpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIjtcbiAgICAgICAgY2FzZSBDb21wcmVzc2lvbi5DT01QUkVTU0lPTl9HWklQOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ09NUFJFU1NJT05fR1pJUFwiO1xuICAgICAgICBjYXNlIENvbXByZXNzaW9uLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOUkVDT0dOSVpFRFwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250ZW50VHlwZUlkKCkge1xuICAgIHJldHVybiB7IGF1dGhvcml0eUlkOiBcIlwiLCB0eXBlSWQ6IFwiXCIsIHZlcnNpb25NYWpvcjogMCwgdmVyc2lvbk1pbm9yOiAwIH07XG59XG5leHBvcnQgY29uc3QgQ29udGVudFR5cGVJZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hdXRob3JpdHlJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYXV0aG9yaXR5SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGVJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudHlwZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uTWFqb3IgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQzMihtZXNzYWdlLnZlcnNpb25NYWpvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbk1pbm9yICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS51aW50MzIobWVzc2FnZS52ZXJzaW9uTWlub3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGVudFR5cGVJZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aG9yaXR5SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWFqb3IgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWlub3IgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhvcml0eUlkOiBpc1NldChvYmplY3QuYXV0aG9yaXR5SWQpID8gU3RyaW5nKG9iamVjdC5hdXRob3JpdHlJZCkgOiBcIlwiLFxuICAgICAgICAgICAgdHlwZUlkOiBpc1NldChvYmplY3QudHlwZUlkKSA/IFN0cmluZyhvYmplY3QudHlwZUlkKSA6IFwiXCIsXG4gICAgICAgICAgICB2ZXJzaW9uTWFqb3I6IGlzU2V0KG9iamVjdC52ZXJzaW9uTWFqb3IpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnZlcnNpb25NYWpvcilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICB2ZXJzaW9uTWlub3I6IGlzU2V0KG9iamVjdC52ZXJzaW9uTWlub3IpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnZlcnNpb25NaW5vcilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hdXRob3JpdHlJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmF1dGhvcml0eUlkID0gbWVzc2FnZS5hdXRob3JpdHlJZCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZUlkICE9PSB1bmRlZmluZWQgJiYgKG9iai50eXBlSWQgPSBtZXNzYWdlLnR5cGVJZCk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbk1ham9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmVyc2lvbk1ham9yID0gTWF0aC5yb3VuZChtZXNzYWdlLnZlcnNpb25NYWpvcikpO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb25NaW5vciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZlcnNpb25NaW5vciA9IE1hdGgucm91bmQobWVzc2FnZS52ZXJzaW9uTWlub3IpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGVudFR5cGVJZCgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml0eUlkID0gKF9hID0gb2JqZWN0LmF1dGhvcml0eUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnR5cGVJZCA9IChfYiA9IG9iamVjdC50eXBlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbk1ham9yID0gKF9jID0gb2JqZWN0LnZlcnNpb25NYWpvcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWlub3IgPSAoX2QgPSBvYmplY3QudmVyc2lvbk1pbm9yKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBmYWxsYmFjazogdW5kZWZpbmVkLFxuICAgICAgICBjb21wcmVzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZW50OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRW5jb2RlZENvbnRlbnQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb250ZW50VHlwZUlkLmVuY29kZShtZXNzYWdlLnR5cGUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5wYXJhbWV0ZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS5pbnQzMihtZXNzYWdlLmNvbXByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gQ29udGVudFR5cGVJZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MiA9IEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkyLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFyYW1ldGVyc1tlbnRyeTIua2V5XSA9IGVudHJ5Mi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmFsbGJhY2sgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2lvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBpc1NldChvYmplY3QudHlwZSlcbiAgICAgICAgICAgICAgICA/IENvbnRlbnRUeXBlSWQuZnJvbUpTT04ob2JqZWN0LnR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBpc09iamVjdChvYmplY3QucGFyYW1ldGVycylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wYXJhbWV0ZXJzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgZmFsbGJhY2s6IGlzU2V0KG9iamVjdC5mYWxsYmFjaykgPyBTdHJpbmcob2JqZWN0LmZhbGxiYWNrKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBpc1NldChvYmplY3QuY29tcHJlc3Npb24pXG4gICAgICAgICAgICAgICAgPyBjb21wcmVzc2lvbkZyb21KU09OKG9iamVjdC5jb21wcmVzc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGlzU2V0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50eXBlID0gbWVzc2FnZS50eXBlXG4gICAgICAgICAgICAgICAgPyBDb250ZW50VHlwZUlkLnRvSlNPTihtZXNzYWdlLnR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBvYmoucGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBhcmFtZXRlcnMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIG9iai5wYXJhbWV0ZXJzW2tdID0gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiAob2JqLmZhbGxiYWNrID0gbWVzc2FnZS5mYWxsYmFjayk7XG4gICAgICAgIG1lc3NhZ2UuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wcmVzc2lvbiA9XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gY29tcHJlc3Npb25Ub0pTT04obWVzc2FnZS5jb21wcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuY29udGVudCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5jb250ZW50IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudCgpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPVxuICAgICAgICAgICAgb2JqZWN0LnR5cGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHlwZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29udGVudFR5cGVJZC5mcm9tUGFydGlhbChvYmplY3QudHlwZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wYXJhbWV0ZXJzID0gT2JqZWN0LmVudHJpZXMoKF9hID0gb2JqZWN0LnBhcmFtZXRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbWVzc2FnZS5mYWxsYmFjayA9IChfYiA9IG9iamVjdC5mYWxsYmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNvbXByZXNzaW9uID0gKF9jID0gb2JqZWN0LmNvbXByZXNzaW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudCA9IChfZCA9IG9iamVjdC5jb250ZW50KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudF9QYXJhbWV0ZXJzRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBTdHJpbmcob2JqZWN0LnZhbHVlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmtleSA9IG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudmFsdWUgPSBtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPSAoX2IgPSBvYmplY3QudmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHsgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoKSwgc2VuZGVyOiB1bmRlZmluZWQsIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkQ29udGVudCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnNlbmRlciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZENvbnRlbnQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlciA9IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHNlbmRlcjogaXNTZXQob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3Quc2VuZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGF5bG9hZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucGF5bG9hZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXIgPSBtZXNzYWdlLnNlbmRlclxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRDb250ZW50KCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IChfYSA9IG9iamVjdC5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciA9XG4gICAgICAgICAgICBvYmplY3Quc2VuZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRlciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZW50LnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/content.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConversationReference: () => (/* binding */ ConversationReference),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _invitation_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invitation.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseConversationReference() {\n    return {\n        topic: \"\",\n        peerAddress: \"\",\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        context: undefined,\n        consentProofPayload: undefined,\n    };\n}\nconst ConversationReference = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.topic !== \"\") {\n            writer.uint32(10).string(message.topic);\n        }\n        if (message.peerAddress !== \"\") {\n            writer.uint32(18).string(message.peerAddress);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        if (message.context !== undefined) {\n            _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.encode(message.context, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.consentProofPayload !== undefined) {\n            _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.encode(message.consentProofPayload, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConversationReference();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topic = reader.string();\n                    break;\n                case 2:\n                    message.peerAddress = reader.string();\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 4:\n                    message.context = _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.consentProofPayload = _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : \"\",\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            context: isSet(object.context)\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            consentProofPayload: isSet(object.consentProofPayload)\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.fromJSON(object.consentProofPayload)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.topic !== undefined && (obj.topic = message.topic);\n        message.peerAddress !== undefined &&\n            (obj.peerAddress = message.peerAddress);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.consentProofPayload !== undefined &&\n            (obj.consentProofPayload = message.consentProofPayload\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.toJSON(message.consentProofPayload)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConversationReference();\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        message.peerAddress = (_b = object.peerAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.consentProofPayload =\n            object.consentProofPayload !== undefined &&\n                object.consentProofPayload !== null\n                ? _invitation_pb__WEBPACK_IMPORTED_MODULE_1__.ConsentProofPayload.fromPartial(object.consentProofPayload)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=conversation_reference.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb252ZXJzYXRpb25fcmVmZXJlbmNlLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ29EO0FBQ3ZDO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxZQUFZLCtEQUFtQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdFQUFvQjtBQUMxRDtBQUNBO0FBQ0Esa0RBQWtELCtEQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBLGtCQUFrQixnRUFBb0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQiwrREFBbUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNENBQUk7QUFDdkQ7QUFDQTtBQUNBLGtCQUFrQixnRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFtQjtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBbUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9jb252ZXJzYXRpb25fcmVmZXJlbmNlLnBiLmpzPzFiOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBJbnZpdGF0aW9uVjFfQ29udGV4dCwgQ29uc2VudFByb29mUGF5bG9hZCB9IGZyb20gXCIuL2ludml0YXRpb24ucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29udmVyc2F0aW9uUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcGljOiBcIlwiLFxuICAgICAgICBwZWVyQWRkcmVzczogXCJcIixcbiAgICAgICAgY3JlYXRlZE5zOiBMb25nLlVaRVJPLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnNlbnRQcm9vZlBheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IENvbnZlcnNhdGlvblJlZmVyZW5jZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50b3BpYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UudG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5wZWVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLmNyZWF0ZWROcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEludml0YXRpb25WMV9Db250ZXh0LmVuY29kZShtZXNzYWdlLmNvbnRleHQsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29uc2VudFByb29mUGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb25zZW50UHJvb2ZQYXlsb2FkLmVuY29kZShtZXNzYWdlLmNvbnNlbnRQcm9vZlBheWxvYWQsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb252ZXJzYXRpb25SZWZlcmVuY2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZXh0ID0gSW52aXRhdGlvblYxX0NvbnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZlBheWxvYWQgPSBDb25zZW50UHJvb2ZQYXlsb2FkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcGljOiBpc1NldChvYmplY3QudG9waWMpID8gU3RyaW5nKG9iamVjdC50b3BpYykgOiBcIlwiLFxuICAgICAgICAgICAgcGVlckFkZHJlc3M6IGlzU2V0KG9iamVjdC5wZWVyQWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LnBlZXJBZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgICAgICBjcmVhdGVkTnM6IGlzU2V0KG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGlzU2V0KG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0NvbnRleHQuZnJvbUpTT04ob2JqZWN0LmNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25zZW50UHJvb2ZQYXlsb2FkOiBpc1NldChvYmplY3QuY29uc2VudFByb29mUGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQuZnJvbUpTT04ob2JqZWN0LmNvbnNlbnRQcm9vZlBheWxvYWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50b3BpYyAhPT0gdW5kZWZpbmVkICYmIChvYmoudG9waWMgPSBtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgbWVzc2FnZS5wZWVyQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBlZXJBZGRyZXNzID0gbWVzc2FnZS5wZWVyQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY3JlYXRlZE5zID0gKG1lc3NhZ2UuY3JlYXRlZE5zIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZXh0ID0gbWVzc2FnZS5jb250ZXh0XG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC50b0pTT04obWVzc2FnZS5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2ZQYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29uc2VudFByb29mUGF5bG9hZCA9IG1lc3NhZ2UuY29uc2VudFByb29mUGF5bG9hZFxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC50b0pTT04obWVzc2FnZS5jb25zZW50UHJvb2ZQYXlsb2FkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnZlcnNhdGlvblJlZmVyZW5jZSgpO1xuICAgICAgICBtZXNzYWdlLnRvcGljID0gKF9hID0gb2JqZWN0LnRvcGljKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnBlZXJBZGRyZXNzID0gKF9iID0gb2JqZWN0LnBlZXJBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZWROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UuY29udGV4dCA9XG4gICAgICAgICAgICBvYmplY3QuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb250ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC5mcm9tUGFydGlhbChvYmplY3QuY29udGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb25zZW50UHJvb2ZQYXlsb2FkID1cbiAgICAgICAgICAgIG9iamVjdC5jb25zZW50UHJvb2ZQYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuY29uc2VudFByb29mUGF5bG9hZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29uc2VudFByb29mUGF5bG9hZC5mcm9tUGFydGlhbChvYmplY3QuY29uc2VudFByb29mUGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJzYXRpb25fcmVmZXJlbmNlLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EciesMessage: () => (/* binding */ EciesMessage),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseEciesMessage() {\n    return { v1: undefined };\n}\nconst EciesMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            writer.uint32(10).bytes(message.v1);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEciesMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? bytesFromBase64(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 =\n                message.v1 !== undefined ? base64FromBytes(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEciesMessage();\n        message.v1 = (_a = object.v1) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=ecies.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9lY2llcy5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2E7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvZWNpZXMucGIuanM/ZTU1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlRWNpZXNNZXNzYWdlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBFY2llc01lc3NhZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS52MSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFY2llc01lc3NhZ2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgPyBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS52MSkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFY2llc01lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9IChfYSA9IG9iamVjdC52MSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjaWVzLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ecies.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FrameAction: () => (/* binding */ FrameAction),\n/* harmony export */   FrameActionBody: () => (/* binding */ FrameActionBody),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseFrameActionBody() {\n    return {\n        frameUrl: \"\",\n        buttonIndex: 0,\n        timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        opaqueConversationIdentifier: \"\",\n        unixTimestamp: 0,\n        inputText: \"\",\n        state: \"\",\n        address: \"\",\n        transactionId: \"\",\n    };\n}\nconst FrameActionBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.frameUrl !== \"\") {\n            writer.uint32(10).string(message.frameUrl);\n        }\n        if (message.buttonIndex !== 0) {\n            writer.uint32(16).int32(message.buttonIndex);\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(24).uint64(message.timestamp);\n        }\n        if (message.opaqueConversationIdentifier !== \"\") {\n            writer.uint32(34).string(message.opaqueConversationIdentifier);\n        }\n        if (message.unixTimestamp !== 0) {\n            writer.uint32(40).uint32(message.unixTimestamp);\n        }\n        if (message.inputText !== \"\") {\n            writer.uint32(50).string(message.inputText);\n        }\n        if (message.state !== \"\") {\n            writer.uint32(58).string(message.state);\n        }\n        if (message.address !== \"\") {\n            writer.uint32(66).string(message.address);\n        }\n        if (message.transactionId !== \"\") {\n            writer.uint32(74).string(message.transactionId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFrameActionBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.frameUrl = reader.string();\n                    break;\n                case 2:\n                    message.buttonIndex = reader.int32();\n                    break;\n                case 3:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 4:\n                    message.opaqueConversationIdentifier = reader.string();\n                    break;\n                case 5:\n                    message.unixTimestamp = reader.uint32();\n                    break;\n                case 6:\n                    message.inputText = reader.string();\n                    break;\n                case 7:\n                    message.state = reader.string();\n                    break;\n                case 8:\n                    message.address = reader.string();\n                    break;\n                case 9:\n                    message.transactionId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            frameUrl: isSet(object.frameUrl) ? String(object.frameUrl) : \"\",\n            buttonIndex: isSet(object.buttonIndex) ? Number(object.buttonIndex) : 0,\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            opaqueConversationIdentifier: isSet(object.opaqueConversationIdentifier)\n                ? String(object.opaqueConversationIdentifier)\n                : \"\",\n            unixTimestamp: isSet(object.unixTimestamp)\n                ? Number(object.unixTimestamp)\n                : 0,\n            inputText: isSet(object.inputText) ? String(object.inputText) : \"\",\n            state: isSet(object.state) ? String(object.state) : \"\",\n            address: isSet(object.address) ? String(object.address) : \"\",\n            transactionId: isSet(object.transactionId)\n                ? String(object.transactionId)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.frameUrl !== undefined && (obj.frameUrl = message.frameUrl);\n        message.buttonIndex !== undefined &&\n            (obj.buttonIndex = Math.round(message.buttonIndex));\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.opaqueConversationIdentifier !== undefined &&\n            (obj.opaqueConversationIdentifier = message.opaqueConversationIdentifier);\n        message.unixTimestamp !== undefined &&\n            (obj.unixTimestamp = Math.round(message.unixTimestamp));\n        message.inputText !== undefined && (obj.inputText = message.inputText);\n        message.state !== undefined && (obj.state = message.state);\n        message.address !== undefined && (obj.address = message.address);\n        message.transactionId !== undefined &&\n            (obj.transactionId = message.transactionId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const message = createBaseFrameActionBody();\n        message.frameUrl = (_a = object.frameUrl) !== null && _a !== void 0 ? _a : \"\";\n        message.buttonIndex = (_b = object.buttonIndex) !== null && _b !== void 0 ? _b : 0;\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.opaqueConversationIdentifier =\n            (_c = object.opaqueConversationIdentifier) !== null && _c !== void 0 ? _c : \"\";\n        message.unixTimestamp = (_d = object.unixTimestamp) !== null && _d !== void 0 ? _d : 0;\n        message.inputText = (_e = object.inputText) !== null && _e !== void 0 ? _e : \"\";\n        message.state = (_f = object.state) !== null && _f !== void 0 ? _f : \"\";\n        message.address = (_g = object.address) !== null && _g !== void 0 ? _g : \"\";\n        message.transactionId = (_h = object.transactionId) !== null && _h !== void 0 ? _h : \"\";\n        return message;\n    },\n};\nfunction createBaseFrameAction() {\n    return {\n        signature: undefined,\n        signedPublicKeyBundle: undefined,\n        actionBody: new Uint8Array(),\n    };\n}\nconst FrameAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.signedPublicKeyBundle !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.encode(message.signedPublicKeyBundle, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.actionBody.length !== 0) {\n            writer.uint32(26).bytes(message.actionBody);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFrameAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signedPublicKeyBundle = _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.actionBody = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n            signedPublicKeyBundle: isSet(object.signedPublicKeyBundle)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromJSON(object.signedPublicKeyBundle)\n                : undefined,\n            actionBody: isSet(object.actionBody)\n                ? bytesFromBase64(object.actionBody)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        message.signedPublicKeyBundle !== undefined &&\n            (obj.signedPublicKeyBundle = message.signedPublicKeyBundle\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.toJSON(message.signedPublicKeyBundle)\n                : undefined);\n        message.actionBody !== undefined &&\n            (obj.actionBody = base64FromBytes(message.actionBody !== undefined ? message.actionBody : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseFrameAction();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        message.signedPublicKeyBundle =\n            object.signedPublicKeyBundle !== undefined &&\n                object.signedPublicKeyBundle !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_2__.SignedPublicKeyBundle.fromPartial(object.signedPublicKeyBundle)\n                : undefined;\n        message.actionBody = (_a = object.actionBody) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=frames.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9mcmFtZXMucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNtQjtBQUNhO0FBQ25CO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNENBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSxvREFBUztBQUNyQjtBQUNBO0FBQ0EsWUFBWSxpRUFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUztBQUNqRDtBQUNBO0FBQ0Esb0RBQW9ELGlFQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLGtCQUFrQixpRUFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvZnJhbWVzLnBiLmpzPzBmM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUucGJcIjtcbmltcG9ydCB7IFNpZ25lZFB1YmxpY0tleUJ1bmRsZSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlRnJhbWVBY3Rpb25Cb2R5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyYW1lVXJsOiBcIlwiLFxuICAgICAgICBidXR0b25JbmRleDogMCxcbiAgICAgICAgdGltZXN0YW1wOiBMb25nLlVaRVJPLFxuICAgICAgICBvcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyOiBcIlwiLFxuICAgICAgICB1bml4VGltZXN0YW1wOiAwLFxuICAgICAgICBpbnB1dFRleHQ6IFwiXCIsXG4gICAgICAgIHN0YXRlOiBcIlwiLFxuICAgICAgICBhZGRyZXNzOiBcIlwiLFxuICAgICAgICB0cmFuc2FjdGlvbklkOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRnJhbWVBY3Rpb25Cb2R5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmZyYW1lVXJsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5mcmFtZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnV0dG9uSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UuYnV0dG9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXAuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudW5peFRpbWVzdGFtcCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDMyKG1lc3NhZ2UudW5peFRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXRUZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5zdHJpbmcobWVzc2FnZS5pbnB1dFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXRlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU4KS5zdHJpbmcobWVzc2FnZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig2Nikuc3RyaW5nKG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhbnNhY3Rpb25JZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3NCkuc3RyaW5nKG1lc3NhZ2UudHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGcmFtZUFjdGlvbkJvZHkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZyYW1lVXJsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnV0dG9uSW5kZXggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wYXF1ZUNvbnZlcnNhdGlvbklkZW50aWZpZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51bml4VGltZXN0YW1wID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXRUZXh0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhbnNhY3Rpb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJhbWVVcmw6IGlzU2V0KG9iamVjdC5mcmFtZVVybCkgPyBTdHJpbmcob2JqZWN0LmZyYW1lVXJsKSA6IFwiXCIsXG4gICAgICAgICAgICBidXR0b25JbmRleDogaXNTZXQob2JqZWN0LmJ1dHRvbkluZGV4KSA/IE51bWJlcihvYmplY3QuYnV0dG9uSW5kZXgpIDogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgb3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcjogaXNTZXQob2JqZWN0Lm9wYXF1ZUNvbnZlcnNhdGlvbklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0Lm9wYXF1ZUNvbnZlcnNhdGlvbklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgdW5peFRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnVuaXhUaW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnVuaXhUaW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaW5wdXRUZXh0OiBpc1NldChvYmplY3QuaW5wdXRUZXh0KSA/IFN0cmluZyhvYmplY3QuaW5wdXRUZXh0KSA6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogaXNTZXQob2JqZWN0LnN0YXRlKSA/IFN0cmluZyhvYmplY3Quc3RhdGUpIDogXCJcIixcbiAgICAgICAgICAgIGFkZHJlc3M6IGlzU2V0KG9iamVjdC5hZGRyZXNzKSA/IFN0cmluZyhvYmplY3QuYWRkcmVzcykgOiBcIlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogaXNTZXQob2JqZWN0LnRyYW5zYWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnRyYW5zYWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZnJhbWVVcmwgIT09IHVuZGVmaW5lZCAmJiAob2JqLmZyYW1lVXJsID0gbWVzc2FnZS5mcmFtZVVybCk7XG4gICAgICAgIG1lc3NhZ2UuYnV0dG9uSW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5idXR0b25JbmRleCA9IE1hdGgucm91bmQobWVzc2FnZS5idXR0b25JbmRleCkpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5vcGFxdWVDb252ZXJzYXRpb25JZGVudGlmaWVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllciA9IG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcik7XG4gICAgICAgIG1lc3NhZ2UudW5peFRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnVuaXhUaW1lc3RhbXAgPSBNYXRoLnJvdW5kKG1lc3NhZ2UudW5peFRpbWVzdGFtcCkpO1xuICAgICAgICBtZXNzYWdlLmlucHV0VGV4dCAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5wdXRUZXh0ID0gbWVzc2FnZS5pbnB1dFRleHQpO1xuICAgICAgICBtZXNzYWdlLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgKG9iai5zdGF0ZSA9IG1lc3NhZ2Uuc3RhdGUpO1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFkZHJlc3MgPSBtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLnRyYW5zYWN0aW9uSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50cmFuc2FjdGlvbklkID0gbWVzc2FnZS50cmFuc2FjdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZyYW1lQWN0aW9uQm9keSgpO1xuICAgICAgICBtZXNzYWdlLmZyYW1lVXJsID0gKF9hID0gb2JqZWN0LmZyYW1lVXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmJ1dHRvbkluZGV4ID0gKF9iID0gb2JqZWN0LmJ1dHRvbkluZGV4KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRpbWVzdGFtcCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllciA9XG4gICAgICAgICAgICAoX2MgPSBvYmplY3Qub3BhcXVlQ29udmVyc2F0aW9uSWRlbnRpZmllcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS51bml4VGltZXN0YW1wID0gKF9kID0gb2JqZWN0LnVuaXhUaW1lc3RhbXApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaW5wdXRUZXh0ID0gKF9lID0gb2JqZWN0LmlucHV0VGV4dCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdGF0ZSA9IChfZiA9IG9iamVjdC5zdGF0ZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKF9nID0gb2JqZWN0LmFkZHJlc3MpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudHJhbnNhY3Rpb25JZCA9IChfaCA9IG9iamVjdC50cmFuc2FjdGlvbklkKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGcmFtZUFjdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmVkUHVibGljS2V5QnVuZGxlOiB1bmRlZmluZWQsXG4gICAgICAgIGFjdGlvbkJvZHk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBGcmFtZUFjdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduZWRQdWJsaWNLZXlCdW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hY3Rpb25Cb2R5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5hY3Rpb25Cb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZyYW1lQWN0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSA9IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWN0aW9uQm9keSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpZ25lZFB1YmxpY0tleUJ1bmRsZTogaXNTZXQob2JqZWN0LnNpZ25lZFB1YmxpY0tleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3Quc2lnbmVkUHVibGljS2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWN0aW9uQm9keTogaXNTZXQob2JqZWN0LmFjdGlvbkJvZHkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmFjdGlvbkJvZHkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSA9IG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2Uuc2lnbmVkUHVibGljS2V5QnVuZGxlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5hY3Rpb25Cb2R5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWN0aW9uQm9keSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmFjdGlvbkJvZHkgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYWN0aW9uQm9keSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRnJhbWVBY3Rpb24oKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNpZ25lZFB1YmxpY0tleUJ1bmRsZSA9XG4gICAgICAgICAgICBvYmplY3Quc2lnbmVkUHVibGljS2V5QnVuZGxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3Quc2lnbmVkUHVibGljS2V5QnVuZGxlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25lZFB1YmxpY0tleUJ1bmRsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5hY3Rpb25Cb2R5ID0gKF9hID0gb2JqZWN0LmFjdGlvbkJvZHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhbWVzLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/frames.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsentProofPayload: () => (/* binding */ ConsentProofPayload),\n/* harmony export */   ConsentProofPayloadVersion: () => (/* binding */ ConsentProofPayloadVersion),\n/* harmony export */   InvitationV1: () => (/* binding */ InvitationV1),\n/* harmony export */   InvitationV1_Aes256gcmHkdfsha256: () => (/* binding */ InvitationV1_Aes256gcmHkdfsha256),\n/* harmony export */   InvitationV1_Context: () => (/* binding */ InvitationV1_Context),\n/* harmony export */   InvitationV1_Context_MetadataEntry: () => (/* binding */ InvitationV1_Context_MetadataEntry),\n/* harmony export */   SealedInvitation: () => (/* binding */ SealedInvitation),\n/* harmony export */   SealedInvitationHeaderV1: () => (/* binding */ SealedInvitationHeaderV1),\n/* harmony export */   SealedInvitationV1: () => (/* binding */ SealedInvitationV1),\n/* harmony export */   consentProofPayloadVersionFromJSON: () => (/* binding */ consentProofPayloadVersionFromJSON),\n/* harmony export */   consentProofPayloadVersionToJSON: () => (/* binding */ consentProofPayloadVersionToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\n/**\n * Invitation is used by an initiator to invite participants\n * into a new conversation. Invitation carries the chosen topic name\n * and encryption scheme and key material to be used for message encryption.\n */\n/** Version of consent proof payload */\nvar ConsentProofPayloadVersion;\n(function (ConsentProofPayloadVersion) {\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\"] = 0] = \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\";\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"CONSENT_PROOF_PAYLOAD_VERSION_1\"] = 1] = \"CONSENT_PROOF_PAYLOAD_VERSION_1\";\n    ConsentProofPayloadVersion[ConsentProofPayloadVersion[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ConsentProofPayloadVersion || (ConsentProofPayloadVersion = {}));\nfunction consentProofPayloadVersionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\":\n            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED;\n        case 1:\n        case \"CONSENT_PROOF_PAYLOAD_VERSION_1\":\n            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ConsentProofPayloadVersion.UNRECOGNIZED;\n    }\n}\nfunction consentProofPayloadVersionToJSON(object) {\n    switch (object) {\n        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED:\n            return \"CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED\";\n        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1:\n            return \"CONSENT_PROOF_PAYLOAD_VERSION_1\";\n        case ConsentProofPayloadVersion.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseInvitationV1() {\n    return {\n        topic: \"\",\n        context: undefined,\n        aes256GcmHkdfSha256: undefined,\n        consentProof: undefined,\n    };\n}\nconst InvitationV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.topic !== \"\") {\n            writer.uint32(10).string(message.topic);\n        }\n        if (message.context !== undefined) {\n            InvitationV1_Context.encode(message.context, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.aes256GcmHkdfSha256 !== undefined) {\n            InvitationV1_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.consentProof !== undefined) {\n            ConsentProofPayload.encode(message.consentProof, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.topic = reader.string();\n                    break;\n                case 2:\n                    message.context = InvitationV1_Context.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.aes256GcmHkdfSha256 = InvitationV1_Aes256gcmHkdfsha256.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.consentProof = ConsentProofPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n            context: isSet(object.context)\n                ? InvitationV1_Context.fromJSON(object.context)\n                : undefined,\n            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256)\n                ? InvitationV1_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256)\n                : undefined,\n            consentProof: isSet(object.consentProof)\n                ? ConsentProofPayload.fromJSON(object.consentProof)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.topic !== undefined && (obj.topic = message.topic);\n        message.context !== undefined &&\n            (obj.context = message.context\n                ? InvitationV1_Context.toJSON(message.context)\n                : undefined);\n        message.aes256GcmHkdfSha256 !== undefined &&\n            (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256\n                ? InvitationV1_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256)\n                : undefined);\n        message.consentProof !== undefined &&\n            (obj.consentProof = message.consentProof\n                ? ConsentProofPayload.toJSON(message.consentProof)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInvitationV1();\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        message.context =\n            object.context !== undefined && object.context !== null\n                ? InvitationV1_Context.fromPartial(object.context)\n                : undefined;\n        message.aes256GcmHkdfSha256 =\n            object.aes256GcmHkdfSha256 !== undefined &&\n                object.aes256GcmHkdfSha256 !== null\n                ? InvitationV1_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256)\n                : undefined;\n        message.consentProof =\n            object.consentProof !== undefined && object.consentProof !== null\n                ? ConsentProofPayload.fromPartial(object.consentProof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Aes256gcmHkdfsha256() {\n    return { keyMaterial: new Uint8Array() };\n}\nconst InvitationV1_Aes256gcmHkdfsha256 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyMaterial.length !== 0) {\n            writer.uint32(10).bytes(message.keyMaterial);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyMaterial = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyMaterial: isSet(object.keyMaterial)\n                ? bytesFromBase64(object.keyMaterial)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyMaterial !== undefined &&\n            (obj.keyMaterial = base64FromBytes(message.keyMaterial !== undefined\n                ? message.keyMaterial\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();\n        message.keyMaterial = (_a = object.keyMaterial) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Context() {\n    return { conversationId: \"\", metadata: {} };\n}\nconst InvitationV1_Context = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.conversationId !== \"\") {\n            writer.uint32(10).string(message.conversationId);\n        }\n        Object.entries(message.metadata).forEach(([key, value]) => {\n            InvitationV1_Context_MetadataEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Context();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversationId = reader.string();\n                    break;\n                case 2:\n                    const entry2 = InvitationV1_Context_MetadataEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.metadata[entry2.key] = entry2.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversationId: isSet(object.conversationId)\n                ? String(object.conversationId)\n                : \"\",\n            metadata: isObject(object.metadata)\n                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversationId !== undefined &&\n            (obj.conversationId = message.conversationId);\n        obj.metadata = {};\n        if (message.metadata) {\n            Object.entries(message.metadata).forEach(([k, v]) => {\n                obj.metadata[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseInvitationV1_Context();\n        message.conversationId = (_a = object.conversationId) !== null && _a !== void 0 ? _a : \"\";\n        message.metadata = Object.entries((_b = object.metadata) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseInvitationV1_Context_MetadataEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst InvitationV1_Context_MetadataEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInvitationV1_Context_MetadataEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseInvitationV1_Context_MetadataEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSealedInvitationHeaderV1() {\n    return { sender: undefined, recipient: undefined, createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst SealedInvitationHeaderV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.sender, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(24).uint64(message.createdNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitationHeaderV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.createdNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSealedInvitationHeaderV1();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseSealedInvitationV1() {\n    return { headerBytes: new Uint8Array(), ciphertext: undefined };\n}\nconst SealedInvitationV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitationV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSealedInvitationV1();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSealedInvitation() {\n    return { v1: undefined };\n}\nconst SealedInvitation = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            SealedInvitationV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSealedInvitation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = SealedInvitationV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? SealedInvitationV1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? SealedInvitationV1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSealedInvitation();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? SealedInvitationV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseConsentProofPayload() {\n    return { signature: \"\", timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, payloadVersion: 0 };\n}\nconst ConsentProofPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.signature !== \"\") {\n            writer.uint32(10).string(message.signature);\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(16).uint64(message.timestamp);\n        }\n        if (message.payloadVersion !== 0) {\n            writer.uint32(24).int32(message.payloadVersion);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConsentProofPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signature = reader.string();\n                    break;\n                case 2:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 3:\n                    message.payloadVersion = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signature: isSet(object.signature) ? String(object.signature) : \"\",\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            payloadVersion: isSet(object.payloadVersion)\n                ? consentProofPayloadVersionFromJSON(object.payloadVersion)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.signature !== undefined && (obj.signature = message.signature);\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.payloadVersion !== undefined &&\n            (obj.payloadVersion = consentProofPayloadVersionToJSON(message.payloadVersion));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConsentProofPayload();\n        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : \"\";\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.payloadVersion = (_b = object.payloadVersion) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=invitation.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9pbnZpdGF0aW9uLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDZ0M7QUFDWDtBQUNSO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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M0M7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL2ludml0YXRpb24ucGIuanM/ZGI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFNpZ25lZFB1YmxpY0tleUJ1bmRsZSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCB7IENpcGhlcnRleHQgfSBmcm9tIFwiLi9jaXBoZXJ0ZXh0LnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuLyoqXG4gKiBJbnZpdGF0aW9uIGlzIHVzZWQgYnkgYW4gaW5pdGlhdG9yIHRvIGludml0ZSBwYXJ0aWNpcGFudHNcbiAqIGludG8gYSBuZXcgY29udmVyc2F0aW9uLiBJbnZpdGF0aW9uIGNhcnJpZXMgdGhlIGNob3NlbiB0b3BpYyBuYW1lXG4gKiBhbmQgZW5jcnlwdGlvbiBzY2hlbWUgYW5kIGtleSBtYXRlcmlhbCB0byBiZSB1c2VkIGZvciBtZXNzYWdlIGVuY3J5cHRpb24uXG4gKi9cbi8qKiBWZXJzaW9uIG9mIGNvbnNlbnQgcHJvb2YgcGF5bG9hZCAqL1xuZXhwb3J0IHZhciBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbjtcbihmdW5jdGlvbiAoQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24pIHtcbiAgICBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb25bQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb25bXCJDT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl8xXCJdID0gMV0gPSBcIkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OXzFcIjtcbiAgICBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbltcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbiB8fCAoQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24gPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbi5DT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl9VTlNQRUNJRklFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fMVwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uLkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OXzE7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbi5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24uQ09OU0VOVF9QUk9PRl9QQVlMT0FEX1ZFUlNJT05fVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJDT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIENvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uLkNPTlNFTlRfUFJPT0ZfUEFZTE9BRF9WRVJTSU9OXzE6XG4gICAgICAgICAgICByZXR1cm4gXCJDT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl8xXCI7XG4gICAgICAgIGNhc2UgQ29uc2VudFByb29mUGF5bG9hZFZlcnNpb24uVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmFzZUludml0YXRpb25WMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3BpYzogXCJcIixcbiAgICAgICAgY29udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBhZXMyNTZHY21Ia2RmU2hhMjU2OiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnNlbnRQcm9vZjogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgSW52aXRhdGlvblYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50b3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBJbnZpdGF0aW9uVjFfQ29udGV4dC5lbmNvZGUobWVzc2FnZS5jb250ZXh0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFlczI1NkdjbUhrZGZTaGEyNTYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYuZW5jb2RlKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1Niwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb25zZW50UHJvb2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ29uc2VudFByb29mUGF5bG9hZC5lbmNvZGUobWVzc2FnZS5jb25zZW50UHJvb2YsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGV4dCA9IEludml0YXRpb25WMV9Db250ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2ID0gSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnRQcm9vZiA9IENvbnNlbnRQcm9vZlBheWxvYWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9waWM6IGlzU2V0KG9iamVjdC50b3BpYykgPyBTdHJpbmcob2JqZWN0LnRvcGljKSA6IFwiXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBpc1NldChvYmplY3QuY29udGV4dClcbiAgICAgICAgICAgICAgICA/IEludml0YXRpb25WMV9Db250ZXh0LmZyb21KU09OKG9iamVjdC5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWVzMjU2R2NtSGtkZlNoYTI1NjogaXNTZXQob2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1Ni5mcm9tSlNPTihvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnNlbnRQcm9vZjogaXNTZXQob2JqZWN0LmNvbnNlbnRQcm9vZilcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQuZnJvbUpTT04ob2JqZWN0LmNvbnNlbnRQcm9vZilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRvcGljICE9PSB1bmRlZmluZWQgJiYgKG9iai50b3BpYyA9IG1lc3NhZ2UudG9waWMpO1xuICAgICAgICBtZXNzYWdlLmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZXh0ID0gbWVzc2FnZS5jb250ZXh0XG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC50b0pTT04obWVzc2FnZS5jb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWVzMjU2R2NtSGtkZlNoYTI1NiA9IG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NlxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYudG9KU09OKG1lc3NhZ2UuYWVzMjU2R2NtSGtkZlNoYTI1NilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29uc2VudFByb29mICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29uc2VudFByb29mID0gbWVzc2FnZS5jb25zZW50UHJvb2ZcbiAgICAgICAgICAgICAgICA/IENvbnNlbnRQcm9vZlBheWxvYWQudG9KU09OKG1lc3NhZ2UuY29uc2VudFByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxKCk7XG4gICAgICAgIG1lc3NhZ2UudG9waWMgPSAoX2EgPSBvYmplY3QudG9waWMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29udGV4dCA9XG4gICAgICAgICAgICBvYmplY3QuY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb250ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBJbnZpdGF0aW9uVjFfQ29udGV4dC5mcm9tUGFydGlhbChvYmplY3QuY29udGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5hZXMyNTZHY21Ia2RmU2hhMjU2ID1cbiAgICAgICAgICAgIG9iamVjdC5hZXMyNTZHY21Ia2RmU2hhMjU2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuYWVzMjU2R2NtSGtkZlNoYTI1NiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYuZnJvbVBhcnRpYWwob2JqZWN0LmFlczI1NkdjbUhrZGZTaGEyNTYpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29uc2VudFByb29mID1cbiAgICAgICAgICAgIG9iamVjdC5jb25zZW50UHJvb2YgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29uc2VudFByb29mICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDb25zZW50UHJvb2ZQYXlsb2FkLmZyb21QYXJ0aWFsKG9iamVjdC5jb25zZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUludml0YXRpb25WMV9BZXMyNTZnY21Ia2Rmc2hhMjU2KCkge1xuICAgIHJldHVybiB7IGtleU1hdGVyaWFsOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgSW52aXRhdGlvblYxX0FlczI1NmdjbUhrZGZzaGEyNTYgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5TWF0ZXJpYWwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmtleU1hdGVyaWFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludml0YXRpb25WMV9BZXMyNTZnY21Ia2Rmc2hhMjU2KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlNYXRlcmlhbCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlNYXRlcmlhbDogaXNTZXQob2JqZWN0LmtleU1hdGVyaWFsKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5rZXlNYXRlcmlhbClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlNYXRlcmlhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleU1hdGVyaWFsID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uua2V5TWF0ZXJpYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5rZXlNYXRlcmlhbFxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjFfQWVzMjU2Z2NtSGtkZnNoYTI1NigpO1xuICAgICAgICBtZXNzYWdlLmtleU1hdGVyaWFsID0gKF9hID0gb2JqZWN0LmtleU1hdGVyaWFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjFfQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyBjb252ZXJzYXRpb25JZDogXCJcIiwgbWV0YWRhdGE6IHt9IH07XG59XG5leHBvcnQgY29uc3QgSW52aXRhdGlvblYxX0NvbnRleHQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udmVyc2F0aW9uSWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmNvbnZlcnNhdGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLm1ldGFkYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIEludml0YXRpb25WMV9Db250ZXh0X01ldGFkYXRhRW50cnkuZW5jb2RlKHsga2V5OiBrZXksIHZhbHVlIH0sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludml0YXRpb25WMV9Db250ZXh0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeTIgPSBJbnZpdGF0aW9uVjFfQ29udGV4dF9NZXRhZGF0YUVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeTIudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVtlbnRyeTIua2V5XSA9IGVudHJ5Mi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb25JZDogaXNTZXQob2JqZWN0LmNvbnZlcnNhdGlvbklkKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5jb252ZXJzYXRpb25JZClcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBtZXRhZGF0YTogaXNPYmplY3Qob2JqZWN0Lm1ldGFkYXRhKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqZWN0Lm1ldGFkYXRhKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb252ZXJzYXRpb25JZCA9IG1lc3NhZ2UuY29udmVyc2F0aW9uSWQpO1xuICAgICAgICBvYmoubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UubWV0YWRhdGEpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIG9iai5tZXRhZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0NvbnRleHQoKTtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb25JZCA9IChfYSA9IG9iamVjdC5jb252ZXJzYXRpb25JZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5tZXRhZGF0YSA9IE9iamVjdC5lbnRyaWVzKChfYiA9IG9iamVjdC5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VJbnZpdGF0aW9uVjFfQ29udGV4dF9NZXRhZGF0YUVudHJ5KCkge1xuICAgIHJldHVybiB7IGtleTogXCJcIiwgdmFsdWU6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBJbnZpdGF0aW9uVjFfQ29udGV4dF9NZXRhZGF0YUVudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW52aXRhdGlvblYxX0NvbnRleHRfTWV0YWRhdGFFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBTdHJpbmcob2JqZWN0LnZhbHVlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmtleSA9IG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudmFsdWUgPSBtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludml0YXRpb25WMV9Db250ZXh0X01ldGFkYXRhRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2EgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID0gKF9iID0gb2JqZWN0LnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTZWFsZWRJbnZpdGF0aW9uSGVhZGVyVjEoKSB7XG4gICAgcmV0dXJuIHsgc2VuZGVyOiB1bmRlZmluZWQsIHJlY2lwaWVudDogdW5kZWZpbmVkLCBjcmVhdGVkTnM6IExvbmcuVVpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBTZWFsZWRJbnZpdGF0aW9uSGVhZGVyVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5lbmNvZGUobWVzc2FnZS5zZW5kZXIsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjaXBpZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5lbmNvZGUobWVzc2FnZS5yZWNpcGllbnQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLmNyZWF0ZWROcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb25IZWFkZXJWMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gU2lnbmVkUHVibGljS2V5QnVuZGxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNpcGllbnQgPSBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZGVyOiBpc1NldChvYmplY3Quc2VuZGVyKVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21KU09OKG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWNpcGllbnQ6IGlzU2V0KG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VuZGVyID0gbWVzc2FnZS5zZW5kZXJcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlY2lwaWVudCA9IG1lc3NhZ2UucmVjaXBpZW50XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXlCdW5kbGUudG9KU09OKG1lc3NhZ2UucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWFsZWRJbnZpdGF0aW9uSGVhZGVyVjEoKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgPVxuICAgICAgICAgICAgb2JqZWN0LnNlbmRlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZW5kZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleUJ1bmRsZS5mcm9tUGFydGlhbChvYmplY3Quc2VuZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9XG4gICAgICAgICAgICBvYmplY3QucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlY2lwaWVudCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvblYxKCkge1xuICAgIHJldHVybiB7IGhlYWRlckJ5dGVzOiBuZXcgVWludDhBcnJheSgpLCBjaXBoZXJ0ZXh0OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTZWFsZWRJbnZpdGF0aW9uVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIENpcGhlcnRleHQuZW5jb2RlKG1lc3NhZ2UuY2lwaGVydGV4dCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb25WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgPSBDaXBoZXJ0ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzOiBpc1NldChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmhlYWRlckJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IGlzU2V0KG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tSlNPTihvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVhZGVyQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmhlYWRlckJ5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNpcGhlcnRleHQgPSBtZXNzYWdlLmNpcGhlcnRleHRcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQudG9KU09OKG1lc3NhZ2UuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb25WMSgpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlckJ5dGVzID0gKF9hID0gb2JqZWN0LmhlYWRlckJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgPVxuICAgICAgICAgICAgb2JqZWN0LmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY2lwaGVydGV4dCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC5mcm9tUGFydGlhbChvYmplY3QuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VhbGVkSW52aXRhdGlvbigpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2VhbGVkSW52aXRhdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTZWFsZWRJbnZpdGF0aW9uVjEuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZWFsZWRJbnZpdGF0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFNlYWxlZEludml0YXRpb25WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IFNlYWxlZEludml0YXRpb25WMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBTZWFsZWRJbnZpdGF0aW9uVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlYWxlZEludml0YXRpb24oKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNlYWxlZEludml0YXRpb25WMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbnNlbnRQcm9vZlBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlOiBcIlwiLCB0aW1lc3RhbXA6IExvbmcuVVpFUk8sIHBheWxvYWRWZXJzaW9uOiAwIH07XG59XG5leHBvcnQgY29uc3QgQ29uc2VudFByb29mUGF5bG9hZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLnRpbWVzdGFtcC5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UudGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkVmVyc2lvbiAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5wYXlsb2FkVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb25zZW50UHJvb2ZQYXlsb2FkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXlsb2FkVmVyc2lvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpID8gU3RyaW5nKG9iamVjdC5zaWduYXR1cmUpIDogXCJcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgcGF5bG9hZFZlcnNpb246IGlzU2V0KG9iamVjdC5wYXlsb2FkVmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IGNvbnNlbnRQcm9vZlBheWxvYWRWZXJzaW9uRnJvbUpTT04ob2JqZWN0LnBheWxvYWRWZXJzaW9uKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmUpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkVmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBheWxvYWRWZXJzaW9uID0gY29uc2VudFByb29mUGF5bG9hZFZlcnNpb25Ub0pTT04obWVzc2FnZS5wYXlsb2FkVmVyc2lvbikpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29uc2VudFByb29mUGF5bG9hZCgpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IChfYSA9IG9iamVjdC5zaWduYXR1cmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID1cbiAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkVmVyc2lvbiA9IChfYiA9IG9iamVjdC5wYXlsb2FkVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZpdGF0aW9uLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/invitation.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodedMessage: () => (/* binding */ DecodedMessage),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageHeaderV1: () => (/* binding */ MessageHeaderV1),\n/* harmony export */   MessageHeaderV2: () => (/* binding */ MessageHeaderV2),\n/* harmony export */   MessageV1: () => (/* binding */ MessageV1),\n/* harmony export */   MessageV2: () => (/* binding */ MessageV2),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./conversation_reference.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/conversation_reference.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__);\n/* eslint-disable */\n\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseMessageHeaderV1() {\n    return { sender: undefined, recipient: undefined, timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst MessageHeaderV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.sender !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.sender, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.timestamp.isZero()) {\n            writer.uint32(24).uint64(message.timestamp);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHeaderV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.timestamp = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.sender)\n                : undefined,\n            recipient: isSet(object.recipient)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromJSON(object.recipient)\n                : undefined,\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined &&\n            (obj.sender = message.sender\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.sender)\n                : undefined);\n        message.recipient !== undefined &&\n            (obj.recipient = message.recipient\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.toJSON(message.recipient)\n                : undefined);\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMessageHeaderV1();\n        message.sender =\n            object.sender !== undefined && object.sender !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.sender)\n                : undefined;\n        message.recipient =\n            object.recipient !== undefined && object.recipient !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKeyBundle.fromPartial(object.recipient)\n                : undefined;\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseMessageV1() {\n    return { headerBytes: new Uint8Array(), ciphertext: undefined };\n}\nconst MessageV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageV1();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMessageHeaderV2() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, topic: \"\" };\n}\nconst MessageHeaderV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.topic !== \"\") {\n            writer.uint32(18).string(message.topic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHeaderV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.topic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            topic: isSet(object.topic) ? String(object.topic) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.topic !== undefined && (obj.topic = message.topic);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageHeaderV2();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseMessageV2() {\n    return {\n        headerBytes: new Uint8Array(),\n        ciphertext: undefined,\n        senderHmac: undefined,\n        shouldPush: undefined,\n    };\n}\nconst MessageV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.headerBytes.length !== 0) {\n            writer.uint32(10).bytes(message.headerBytes);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.senderHmac !== undefined) {\n            writer.uint32(26).bytes(message.senderHmac);\n        }\n        if (message.shouldPush !== undefined) {\n            writer.uint32(32).bool(message.shouldPush);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.headerBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.senderHmac = reader.bytes();\n                    break;\n                case 4:\n                    message.shouldPush = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headerBytes: isSet(object.headerBytes)\n                ? bytesFromBase64(object.headerBytes)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : undefined,\n            shouldPush: isSet(object.shouldPush)\n                ? Boolean(object.shouldPush)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.headerBytes !== undefined &&\n            (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined\n                ? message.headerBytes\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        message.senderHmac !== undefined &&\n            (obj.senderHmac =\n                message.senderHmac !== undefined\n                    ? base64FromBytes(message.senderHmac)\n                    : undefined);\n        message.shouldPush !== undefined && (obj.shouldPush = message.shouldPush);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMessageV2();\n        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        message.senderHmac = (_b = object.senderHmac) !== null && _b !== void 0 ? _b : undefined;\n        message.shouldPush = (_c = object.shouldPush) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBaseMessage() {\n    return { v1: undefined, v2: undefined };\n}\nconst Message = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            MessageV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            MessageV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = MessageV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = MessageV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? MessageV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? MessageV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? MessageV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? MessageV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMessage();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? MessageV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? MessageV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseDecodedMessage() {\n    return {\n        id: \"\",\n        messageVersion: \"\",\n        senderAddress: \"\",\n        recipientAddress: undefined,\n        sentNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        contentTopic: \"\",\n        conversation: undefined,\n        contentBytes: new Uint8Array(),\n    };\n}\nconst DecodedMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.messageVersion !== \"\") {\n            writer.uint32(18).string(message.messageVersion);\n        }\n        if (message.senderAddress !== \"\") {\n            writer.uint32(26).string(message.senderAddress);\n        }\n        if (message.recipientAddress !== undefined) {\n            writer.uint32(34).string(message.recipientAddress);\n        }\n        if (!message.sentNs.isZero()) {\n            writer.uint32(40).uint64(message.sentNs);\n        }\n        if (message.contentTopic !== \"\") {\n            writer.uint32(50).string(message.contentTopic);\n        }\n        if (message.conversation !== undefined) {\n            _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.encode(message.conversation, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.contentBytes.length !== 0) {\n            writer.uint32(66).bytes(message.contentBytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecodedMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.messageVersion = reader.string();\n                    break;\n                case 3:\n                    message.senderAddress = reader.string();\n                    break;\n                case 4:\n                    message.recipientAddress = reader.string();\n                    break;\n                case 5:\n                    message.sentNs = reader.uint64();\n                    break;\n                case 6:\n                    message.contentTopic = reader.string();\n                    break;\n                case 7:\n                    message.conversation = _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.contentBytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            messageVersion: isSet(object.messageVersion)\n                ? String(object.messageVersion)\n                : \"\",\n            senderAddress: isSet(object.senderAddress)\n                ? String(object.senderAddress)\n                : \"\",\n            recipientAddress: isSet(object.recipientAddress)\n                ? String(object.recipientAddress)\n                : undefined,\n            sentNs: isSet(object.sentNs) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sentNs) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            contentTopic: isSet(object.contentTopic)\n                ? String(object.contentTopic)\n                : \"\",\n            conversation: isSet(object.conversation)\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.fromJSON(object.conversation)\n                : undefined,\n            contentBytes: isSet(object.contentBytes)\n                ? bytesFromBase64(object.contentBytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.messageVersion !== undefined &&\n            (obj.messageVersion = message.messageVersion);\n        message.senderAddress !== undefined &&\n            (obj.senderAddress = message.senderAddress);\n        message.recipientAddress !== undefined &&\n            (obj.recipientAddress = message.recipientAddress);\n        message.sentNs !== undefined &&\n            (obj.sentNs = (message.sentNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.conversation !== undefined &&\n            (obj.conversation = message.conversation\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.toJSON(message.conversation)\n                : undefined);\n        message.contentBytes !== undefined &&\n            (obj.contentBytes = base64FromBytes(message.contentBytes !== undefined\n                ? message.contentBytes\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseDecodedMessage();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.messageVersion = (_b = object.messageVersion) !== null && _b !== void 0 ? _b : \"\";\n        message.senderAddress = (_c = object.senderAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.recipientAddress = (_d = object.recipientAddress) !== null && _d !== void 0 ? _d : undefined;\n        message.sentNs =\n            object.sentNs !== undefined && object.sentNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.sentNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.contentTopic = (_e = object.contentTopic) !== null && _e !== void 0 ? _e : \"\";\n        message.conversation =\n            object.conversation !== undefined && object.conversation !== null\n                ? _conversation_reference_pb__WEBPACK_IMPORTED_MODULE_3__.ConversationReference.fromPartial(object.conversation)\n                : undefined;\n        message.contentBytes = (_f = object.contentBytes) !== null && _f !== void 0 ? _f : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=message.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9tZXNzYWdlLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUMwQjtBQUNMO0FBQ3VCO0FBQy9CO0FBQzlCO0FBQ1A7QUFDQSxhQUFhLG9EQUFvRCw0Q0FBSTtBQUNyRTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSwyREFBZTtBQUMzQjtBQUNBO0FBQ0EsWUFBWSwyREFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFlO0FBQ3BEO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxtREFBbUQsNENBQUk7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1As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O0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZFQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL21lc3NhZ2UucGIuanM/MzE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFB1YmxpY0tleUJ1bmRsZSB9IGZyb20gXCIuL3B1YmxpY19rZXkucGJcIjtcbmltcG9ydCB7IENpcGhlcnRleHQgfSBmcm9tIFwiLi9jaXBoZXJ0ZXh0LnBiXCI7XG5pbXBvcnQgeyBDb252ZXJzYXRpb25SZWZlcmVuY2UgfSBmcm9tIFwiLi9jb252ZXJzYXRpb25fcmVmZXJlbmNlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2VIZWFkZXJWMSgpIHtcbiAgICByZXR1cm4geyBzZW5kZXI6IHVuZGVmaW5lZCwgcmVjaXBpZW50OiB1bmRlZmluZWQsIHRpbWVzdGFtcDogTG9uZy5VWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VIZWFkZXJWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnNlbmRlciwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5QnVuZGxlLmVuY29kZShtZXNzYWdlLnJlY2lwaWVudCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UudGltZXN0YW1wLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhlYWRlclYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSBQdWJsaWNLZXlCdW5kbGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY2lwaWVudCA9IFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kZXI6IGlzU2V0KG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbUpTT04ob2JqZWN0LnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlY2lwaWVudDogaXNTZXQob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS5mcm9tSlNPTihvYmplY3QucmVjaXBpZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXIgPSBtZXNzYWdlLnNlbmRlclxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLnRvSlNPTihtZXNzYWdlLnNlbmRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVjaXBpZW50ID0gbWVzc2FnZS5yZWNpcGllbnRcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleUJ1bmRsZS50b0pTT04obWVzc2FnZS5yZWNpcGllbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VIZWFkZXJWMSgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciA9XG4gICAgICAgICAgICBvYmplY3Quc2VuZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRlciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5QnVuZGxlLmZyb21QYXJ0aWFsKG9iamVjdC5zZW5kZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50ID1cbiAgICAgICAgICAgIG9iamVjdC5yZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjaXBpZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXlCdW5kbGUuZnJvbVBhcnRpYWwob2JqZWN0LnJlY2lwaWVudClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPVxuICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXAgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXNzYWdlVjEoKSB7XG4gICAgcmV0dXJuIHsgaGVhZGVyQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksIGNpcGhlcnRleHQ6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5jaXBoZXJ0ZXh0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZVYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaXNTZXQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oZWFkZXJCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhlYWRlckJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaGVhZGVyQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2lwaGVydGV4dCA9IG1lc3NhZ2UuY2lwaGVydGV4dFxuICAgICAgICAgICAgICAgID8gQ2lwaGVydGV4dC50b0pTT04obWVzc2FnZS5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZVYxKCk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSAoX2EgPSBvYmplY3QuaGVhZGVyQnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9XG4gICAgICAgICAgICBvYmplY3QuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXNzYWdlSGVhZGVyVjIoKSB7XG4gICAgcmV0dXJuIHsgY3JlYXRlZE5zOiBMb25nLlVaRVJPLCB0b3BpYzogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VIZWFkZXJWMiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLmNyZWF0ZWROcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9waWMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VIZWFkZXJWMigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgdG9waWM6IGlzU2V0KG9iamVjdC50b3BpYykgPyBTdHJpbmcob2JqZWN0LnRvcGljKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UudG9waWMgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvcGljID0gbWVzc2FnZS50b3BpYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VIZWFkZXJWMigpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZWROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UudG9waWMgPSAoX2EgPSBvYmplY3QudG9waWMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2VWMigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgY2lwaGVydGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBzZW5kZXJIbWFjOiB1bmRlZmluZWQsXG4gICAgICAgIHNob3VsZFB1c2g6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VWMiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXJCeXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ2lwaGVydGV4dC5lbmNvZGUobWVzc2FnZS5jaXBoZXJ0ZXh0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5zZW5kZXJIbWFjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaG91bGRQdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLmJvb2wobWVzc2FnZS5zaG91bGRQdXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VWMigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgPSBDaXBoZXJ0ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXJIbWFjID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaG91bGRQdXNoID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IGlzU2V0KG9iamVjdC5oZWFkZXJCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGVhZGVyQnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaXNTZXQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VuZGVySG1hYzogaXNTZXQob2JqZWN0LnNlbmRlckhtYWMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnNlbmRlckhtYWMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaG91bGRQdXNoOiBpc1NldChvYmplY3Quc2hvdWxkUHVzaClcbiAgICAgICAgICAgICAgICA/IEJvb2xlYW4ob2JqZWN0LnNob3VsZFB1c2gpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlckJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGVhZGVyQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5oZWFkZXJCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jaXBoZXJ0ZXh0ID0gbWVzc2FnZS5jaXBoZXJ0ZXh0XG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LnRvSlNPTihtZXNzYWdlLmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZW5kZXJIbWFjID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnNlbmRlckhtYWMpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zaG91bGRQdXNoICE9PSB1bmRlZmluZWQgJiYgKG9iai5zaG91bGRQdXNoID0gbWVzc2FnZS5zaG91bGRQdXNoKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlVjIoKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJCeXRlcyA9IChfYSA9IG9iamVjdC5oZWFkZXJCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jaXBoZXJ0ZXh0ID1cbiAgICAgICAgICAgIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNpcGhlcnRleHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQuZnJvbVBhcnRpYWwob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyA9IChfYiA9IG9iamVjdC5zZW5kZXJIbWFjKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2hvdWxkUHVzaCA9IChfYyA9IG9iamVjdC5zaG91bGRQdXNoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCwgdjI6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWVzc2FnZVYxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VWMi5lbmNvZGUobWVzc2FnZS52Miwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gTWVzc2FnZVYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MiA9IE1lc3NhZ2VWMi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IE1lc3NhZ2VWMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdjI6IGlzU2V0KG9iamVjdC52MikgPyBNZXNzYWdlVjIuZnJvbUpTT04ob2JqZWN0LnYyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxID8gTWVzc2FnZVYxLnRvSlNPTihtZXNzYWdlLnYxKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudjIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MiA9IG1lc3NhZ2UudjIgPyBNZXNzYWdlVjIudG9KU09OKG1lc3NhZ2UudjIpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VWMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudjIgPVxuICAgICAgICAgICAgb2JqZWN0LnYyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBNZXNzYWdlVjIuZnJvbVBhcnRpYWwob2JqZWN0LnYyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNvZGVkTWVzc2FnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogXCJcIixcbiAgICAgICAgbWVzc2FnZVZlcnNpb246IFwiXCIsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IFwiXCIsXG4gICAgICAgIHJlY2lwaWVudEFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VudE5zOiBMb25nLlVaRVJPLFxuICAgICAgICBjb250ZW50VG9waWM6IFwiXCIsXG4gICAgICAgIGNvbnZlcnNhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZW50Qnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBEZWNvZGVkTWVzc2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VWZXJzaW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5tZXNzYWdlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVyQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2Uuc2VuZGVyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjaXBpZW50QWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5yZWNpcGllbnRBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2Uuc2VudE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS51aW50NjQobWVzc2FnZS5zZW50TnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig1MCkuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQ29udmVyc2F0aW9uUmVmZXJlbmNlLmVuY29kZShtZXNzYWdlLmNvbnZlcnNhdGlvbiwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50Qnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDY2KS5ieXRlcyhtZXNzYWdlLmNvbnRlbnRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNvZGVkTWVzc2FnZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNpcGllbnRBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VudE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uID0gQ29udmVyc2F0aW9uUmVmZXJlbmNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50Qnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlzU2V0KG9iamVjdC5pZCkgPyBTdHJpbmcob2JqZWN0LmlkKSA6IFwiXCIsXG4gICAgICAgICAgICBtZXNzYWdlVmVyc2lvbjogaXNTZXQob2JqZWN0Lm1lc3NhZ2VWZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5tZXNzYWdlVmVyc2lvbilcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBzZW5kZXJBZGRyZXNzOiBpc1NldChvYmplY3Quc2VuZGVyQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Quc2VuZGVyQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICByZWNpcGllbnRBZGRyZXNzOiBpc1NldChvYmplY3QucmVjaXBpZW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QucmVjaXBpZW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbnROczogaXNTZXQob2JqZWN0LnNlbnROcykgPyBMb25nLmZyb21WYWx1ZShvYmplY3Quc2VudE5zKSA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBjb250ZW50VG9waWM6IGlzU2V0KG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBjb252ZXJzYXRpb246IGlzU2V0KG9iamVjdC5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgPyBDb252ZXJzYXRpb25SZWZlcmVuY2UuZnJvbUpTT04ob2JqZWN0LmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnRlbnRCeXRlczogaXNTZXQob2JqZWN0LmNvbnRlbnRCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY29udGVudEJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlkICE9PSB1bmRlZmluZWQgJiYgKG9iai5pZCA9IG1lc3NhZ2UuaWQpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2VWZXJzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWVzc2FnZVZlcnNpb24gPSBtZXNzYWdlLm1lc3NhZ2VWZXJzaW9uKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXJBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VuZGVyQWRkcmVzcyA9IG1lc3NhZ2Uuc2VuZGVyQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UucmVjaXBpZW50QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlY2lwaWVudEFkZHJlc3MgPSBtZXNzYWdlLnJlY2lwaWVudEFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLnNlbnROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbnROcyA9IChtZXNzYWdlLnNlbnROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udmVyc2F0aW9uID0gbWVzc2FnZS5jb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS50b0pTT04obWVzc2FnZS5jb252ZXJzYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnRCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRlbnRCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNvbnRlbnRCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmNvbnRlbnRCeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY29kZWRNZXNzYWdlKCk7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSAoX2EgPSBvYmplY3QuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZVZlcnNpb24gPSAoX2IgPSBvYmplY3QubWVzc2FnZVZlcnNpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyQWRkcmVzcyA9IChfYyA9IG9iamVjdC5zZW5kZXJBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnJlY2lwaWVudEFkZHJlc3MgPSAoX2QgPSBvYmplY3QucmVjaXBpZW50QWRkcmVzcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNlbnROcyA9XG4gICAgICAgICAgICBvYmplY3Quc2VudE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbnROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnNlbnROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gKF9lID0gb2JqZWN0LmNvbnRlbnRUb3BpYykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb252ZXJzYXRpb24gPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnZlcnNhdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb252ZXJzYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IENvbnZlcnNhdGlvblJlZmVyZW5jZS5mcm9tUGFydGlhbChvYmplY3QuY29udmVyc2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnRCeXRlcyA9IChfZiA9IG9iamVjdC5jb250ZW50Qnl0ZXMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/message.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptedPrivateKeyBundle: () => (/* binding */ EncryptedPrivateKeyBundle),\n/* harmony export */   EncryptedPrivateKeyBundleV1: () => (/* binding */ EncryptedPrivateKeyBundleV1),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyBundle: () => (/* binding */ PrivateKeyBundle),\n/* harmony export */   PrivateKeyBundleV1: () => (/* binding */ PrivateKeyBundleV1),\n/* harmony export */   PrivateKeyBundleV2: () => (/* binding */ PrivateKeyBundleV2),\n/* harmony export */   PrivateKey_Secp256k1: () => (/* binding */ PrivateKey_Secp256k1),\n/* harmony export */   SignedPrivateKey: () => (/* binding */ SignedPrivateKey),\n/* harmony export */   SignedPrivateKey_Secp256k1: () => (/* binding */ SignedPrivateKey_Secp256k1),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _public_key_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./public_key.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignedPrivateKey() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1: undefined, publicKey: undefined };\n}\nconst SignedPrivateKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.secp256k1 !== undefined) {\n            SignedPrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.publicKey !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.encode(message.publicKey, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPrivateKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 2:\n                    message.secp256k1 = SignedPrivateKey_Secp256k1.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.publicKey = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1: isSet(object.secp256k1)\n                ? SignedPrivateKey_Secp256k1.fromJSON(object.secp256k1)\n                : undefined,\n            publicKey: isSet(object.publicKey)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromJSON(object.publicKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1 !== undefined &&\n            (obj.secp256k1 = message.secp256k1\n                ? SignedPrivateKey_Secp256k1.toJSON(message.secp256k1)\n                : undefined);\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.toJSON(message.publicKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignedPrivateKey();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1 =\n            object.secp256k1 !== undefined && object.secp256k1 !== null\n                ? SignedPrivateKey_Secp256k1.fromPartial(object.secp256k1)\n                : undefined;\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.SignedPublicKey.fromPartial(object.publicKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedPrivateKey_Secp256k1() {\n    return { bytes: new Uint8Array() };\n}\nconst SignedPrivateKey_Secp256k1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPrivateKey_Secp256k1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPrivateKey_Secp256k1();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundleV2() {\n    return { identityKey: undefined, preKeys: [] };\n}\nconst PrivateKeyBundleV2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            SignedPrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.preKeys) {\n            SignedPrivateKey.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundleV2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = SignedPrivateKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKeys.push(SignedPrivateKey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? SignedPrivateKey.fromJSON(object.identityKey)\n                : undefined,\n            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys)\n                ? object.preKeys.map((e) => SignedPrivateKey.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? SignedPrivateKey.toJSON(message.identityKey)\n                : undefined);\n        if (message.preKeys) {\n            obj.preKeys = message.preKeys.map((e) => e ? SignedPrivateKey.toJSON(e) : undefined);\n        }\n        else {\n            obj.preKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKeyBundleV2();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? SignedPrivateKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKeys =\n            ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e) => SignedPrivateKey.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePrivateKey() {\n    return { timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1: undefined, publicKey: undefined };\n}\nconst PrivateKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.timestamp.isZero()) {\n            writer.uint32(8).uint64(message.timestamp);\n        }\n        if (message.secp256k1 !== undefined) {\n            PrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.publicKey !== undefined) {\n            _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.encode(message.publicKey, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 2:\n                    message.secp256k1 = PrivateKey_Secp256k1.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.publicKey = _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1: isSet(object.secp256k1)\n                ? PrivateKey_Secp256k1.fromJSON(object.secp256k1)\n                : undefined,\n            publicKey: isSet(object.publicKey)\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromJSON(object.publicKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1 !== undefined &&\n            (obj.secp256k1 = message.secp256k1\n                ? PrivateKey_Secp256k1.toJSON(message.secp256k1)\n                : undefined);\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.toJSON(message.publicKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivateKey();\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1 =\n            object.secp256k1 !== undefined && object.secp256k1 !== null\n                ? PrivateKey_Secp256k1.fromPartial(object.secp256k1)\n                : undefined;\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? _public_key_pb__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromPartial(object.publicKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePrivateKey_Secp256k1() {\n    return { bytes: new Uint8Array() };\n}\nconst PrivateKey_Secp256k1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKey_Secp256k1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKey_Secp256k1();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundleV1() {\n    return { identityKey: undefined, preKeys: [] };\n}\nconst PrivateKeyBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            PrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.preKeys) {\n            PrivateKey.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = PrivateKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKeys.push(PrivateKey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? PrivateKey.fromJSON(object.identityKey)\n                : undefined,\n            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys)\n                ? object.preKeys.map((e) => PrivateKey.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? PrivateKey.toJSON(message.identityKey)\n                : undefined);\n        if (message.preKeys) {\n            obj.preKeys = message.preKeys.map((e) => e ? PrivateKey.toJSON(e) : undefined);\n        }\n        else {\n            obj.preKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivateKeyBundleV1();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? PrivateKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKeys =\n            ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e) => PrivateKey.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePrivateKeyBundle() {\n    return { v1: undefined, v2: undefined };\n}\nconst PrivateKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            PrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            PrivateKeyBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivateKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = PrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = PrivateKeyBundleV2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? PrivateKeyBundleV1.fromJSON(object.v1) : undefined,\n            v2: isSet(object.v2) ? PrivateKeyBundleV2.fromJSON(object.v2) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? PrivateKeyBundleV1.toJSON(message.v1) : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2 ? PrivateKeyBundleV2.toJSON(message.v2) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivateKeyBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? PrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? PrivateKeyBundleV2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptedPrivateKeyBundleV1() {\n    return { walletPreKey: new Uint8Array(), ciphertext: undefined };\n}\nconst EncryptedPrivateKeyBundleV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.walletPreKey.length !== 0) {\n            writer.uint32(10).bytes(message.walletPreKey);\n        }\n        if (message.ciphertext !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.encode(message.ciphertext, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptedPrivateKeyBundleV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletPreKey = reader.bytes();\n                    break;\n                case 2:\n                    message.ciphertext = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletPreKey: isSet(object.walletPreKey)\n                ? bytesFromBase64(object.walletPreKey)\n                : new Uint8Array(),\n            ciphertext: isSet(object.ciphertext)\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromJSON(object.ciphertext)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.walletPreKey !== undefined &&\n            (obj.walletPreKey = base64FromBytes(message.walletPreKey !== undefined\n                ? message.walletPreKey\n                : new Uint8Array()));\n        message.ciphertext !== undefined &&\n            (obj.ciphertext = message.ciphertext\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.toJSON(message.ciphertext)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEncryptedPrivateKeyBundleV1();\n        message.walletPreKey = (_a = object.walletPreKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.ciphertext =\n            object.ciphertext !== undefined && object.ciphertext !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_2__.Ciphertext.fromPartial(object.ciphertext)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEncryptedPrivateKeyBundle() {\n    return { v1: undefined };\n}\nconst EncryptedPrivateKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            EncryptedPrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncryptedPrivateKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = EncryptedPrivateKeyBundleV1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? EncryptedPrivateKeyBundleV1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? EncryptedPrivateKeyBundleV1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseEncryptedPrivateKeyBundle();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? EncryptedPrivateKeyBundleV1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=private_key.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX2tleS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNxQztBQUNoQjtBQUNSO0FBQzlCO0FBQ1A7QUFDQSxhQUFhLFdBQVcsNENBQUk7QUFDNUI7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQWU7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyREFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFlO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBZTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFJO0FBQ3RCLGtCQUFrQiw0Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWU7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFB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QUFrQixzREFBVTtBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVTtBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX2tleS5wYi5qcz8zOTQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmVkUHVibGljS2V5LCBQdWJsaWNLZXkgfSBmcm9tIFwiLi9wdWJsaWNfa2V5LnBiXCI7XG5pbXBvcnQgeyBDaXBoZXJ0ZXh0IH0gZnJvbSBcIi4vY2lwaGVydGV4dC5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZWRQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiB7IGNyZWF0ZWROczogTG9uZy5VWkVSTywgc2VjcDI1NmsxOiB1bmRlZmluZWQsIHB1YmxpY0tleTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkUHJpdmF0ZUtleSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLmNyZWF0ZWROcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VjcDI1NmsxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxLmVuY29kZShtZXNzYWdlLnNlY3AyNTZrMSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5LmVuY29kZShtZXNzYWdlLnB1YmxpY0tleSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFByaXZhdGVLZXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMSA9IFNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgPSBTaWduZWRQdWJsaWNLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlZE5zOiBpc1NldChvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBzZWNwMjU2azE6IGlzU2V0KG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQcml2YXRlS2V5X1NlY3AyNTZrMS5mcm9tSlNPTihvYmplY3Quc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHVibGljS2V5OiBpc1NldChvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LmZyb21KU09OKG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkTnMgPSAobWVzc2FnZS5jcmVhdGVkTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VjcDI1NmsxID0gbWVzc2FnZS5zZWNwMjU2azFcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxLnRvSlNPTihtZXNzYWdlLnNlY3AyNTZrMSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVibGljS2V5ID0gbWVzc2FnZS5wdWJsaWNLZXlcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleS50b0pTT04obWVzc2FnZS5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUHJpdmF0ZUtleSgpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWF0ZWROcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxID1cbiAgICAgICAgICAgIG9iamVjdC5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2VjcDI1NmsxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQcml2YXRlS2V5X1NlY3AyNTZrMS5mcm9tUGFydGlhbChvYmplY3Quc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9XG4gICAgICAgICAgICBvYmplY3QucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YmxpY0tleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxKCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkUHJpdmF0ZUtleV9TZWNwMjU2azEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFByaXZhdGVLZXlfU2VjcDI1NmsxKCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByaXZhdGVLZXlCdW5kbGVWMigpIHtcbiAgICByZXR1cm4geyBpZGVudGl0eUtleTogdW5kZWZpbmVkLCBwcmVLZXlzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVLZXlCdW5kbGVWMiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQcml2YXRlS2V5LmVuY29kZShtZXNzYWdlLmlkZW50aXR5S2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnByZUtleXMpIHtcbiAgICAgICAgICAgIFNpZ25lZFByaXZhdGVLZXkuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlVjIoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID0gU2lnbmVkUHJpdmF0ZUtleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlS2V5cy5wdXNoKFNpZ25lZFByaXZhdGVLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBpc1NldChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQcml2YXRlS2V5LmZyb21KU09OKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZUtleXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnByZUtleXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucHJlS2V5cy5tYXAoKGUpID0+IFNpZ25lZFByaXZhdGVLZXkuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaWRlbnRpdHlLZXkgPSBtZXNzYWdlLmlkZW50aXR5S2V5XG4gICAgICAgICAgICAgICAgPyBTaWduZWRQcml2YXRlS2V5LnRvSlNPTihtZXNzYWdlLmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHJlS2V5cykge1xuICAgICAgICAgICAgb2JqLnByZUtleXMgPSBtZXNzYWdlLnByZUtleXMubWFwKChlKSA9PiBlID8gU2lnbmVkUHJpdmF0ZUtleS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnByZUtleXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5QnVuZGxlVjIoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9XG4gICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWRlbnRpdHlLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFByaXZhdGVLZXkuZnJvbVBhcnRpYWwob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnByZUtleXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5wcmVLZXlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBTaWduZWRQcml2YXRlS2V5LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIHsgdGltZXN0YW1wOiBMb25nLlVaRVJPLCBzZWNwMjU2azE6IHVuZGVmaW5lZCwgcHVibGljS2V5OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXAuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UudGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZUtleV9TZWNwMjU2azEuZW5jb2RlKG1lc3NhZ2Uuc2VjcDI1NmsxLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UucHVibGljS2V5LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxID0gUHJpdmF0ZUtleV9TZWNwMjU2azEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9IFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIHNlY3AyNTZrMTogaXNTZXQob2JqZWN0LnNlY3AyNTZrMSlcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXlfU2VjcDI1NmsxLmZyb21KU09OKG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGlzU2V0KG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZWNwMjU2azEgPSBtZXNzYWdlLnNlY3AyNTZrMVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleV9TZWNwMjU2azEudG9KU09OKG1lc3NhZ2Uuc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wdWJsaWNLZXkgPSBtZXNzYWdlLnB1YmxpY0tleVxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LnRvSlNPTihtZXNzYWdlLnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlS2V5KCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID1cbiAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgPVxuICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZWNwMjU2azEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXlfU2VjcDI1NmsxLmZyb21QYXJ0aWFsKG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHVibGljS2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkuZnJvbVBhcnRpYWwob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZUtleV9TZWNwMjU2azEoKSB7XG4gICAgcmV0dXJuIHsgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5X1NlY3AyNTZrMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleV9TZWNwMjU2azEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBpc1NldChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleV9TZWNwMjU2azEoKTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IChfYSA9IG9iamVjdC5ieXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZVYxKCkge1xuICAgIHJldHVybiB7IGlkZW50aXR5S2V5OiB1bmRlZmluZWQsIHByZUtleXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZUtleUJ1bmRsZVYxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFByaXZhdGVLZXkuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucHJlS2V5cykge1xuICAgICAgICAgICAgUHJpdmF0ZUtleS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVLZXlCdW5kbGVWMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgPSBQcml2YXRlS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVLZXlzLnB1c2goUHJpdmF0ZUtleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IGlzU2V0KG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXkuZnJvbUpTT04ob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlS2V5czogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucHJlS2V5cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5wcmVLZXlzLm1hcCgoZSkgPT4gUHJpdmF0ZUtleS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZGVudGl0eUtleSA9IG1lc3NhZ2UuaWRlbnRpdHlLZXlcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXkudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWVzc2FnZS5wcmVLZXlzKSB7XG4gICAgICAgICAgICBvYmoucHJlS2V5cyA9IG1lc3NhZ2UucHJlS2V5cy5tYXAoKGUpID0+IGUgPyBQcml2YXRlS2V5LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucHJlS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVLZXlCdW5kbGVWMSgpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleS5mcm9tUGFydGlhbChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucHJlS2V5cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnByZUtleXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFByaXZhdGVLZXkuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZSgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkLCB2MjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZUtleUJ1bmRsZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQcml2YXRlS2V5QnVuZGxlVjEuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZUtleUJ1bmRsZVYyLmVuY29kZShtZXNzYWdlLnYyLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBQcml2YXRlS2V5QnVuZGxlVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYyID0gUHJpdmF0ZUtleUJ1bmRsZVYyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gUHJpdmF0ZUtleUJ1bmRsZVYxLmZyb21KU09OKG9iamVjdC52MSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2MjogaXNTZXQob2JqZWN0LnYyKSA/IFByaXZhdGVLZXlCdW5kbGVWMi5mcm9tSlNPTihvYmplY3QudjIpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBQcml2YXRlS2V5QnVuZGxlVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYyID0gbWVzc2FnZS52MiA/IFByaXZhdGVLZXlCdW5kbGVWMi50b0pTT04obWVzc2FnZS52MikgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZUtleUJ1bmRsZSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZUtleUJ1bmRsZVYxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52MiA9XG4gICAgICAgICAgICBvYmplY3QudjIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVLZXlCdW5kbGVWMi5mcm9tUGFydGlhbChvYmplY3QudjIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMSgpIHtcbiAgICByZXR1cm4geyB3YWxsZXRQcmVLZXk6IG5ldyBVaW50OEFycmF5KCksIGNpcGhlcnRleHQ6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS53YWxsZXRQcmVLZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLndhbGxldFByZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLmNpcGhlcnRleHQsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldFByZUtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9IENpcGhlcnRleHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0UHJlS2V5OiBpc1NldChvYmplY3Qud2FsbGV0UHJlS2V5KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC53YWxsZXRQcmVLZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaXNTZXQob2JqZWN0LmNpcGhlcnRleHQpXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21KU09OKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0UHJlS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoud2FsbGV0UHJlS2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uud2FsbGV0UHJlS2V5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2Uud2FsbGV0UHJlS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNpcGhlcnRleHQgPSBtZXNzYWdlLmNpcGhlcnRleHRcbiAgICAgICAgICAgICAgICA/IENpcGhlcnRleHQudG9KU09OKG1lc3NhZ2UuY2lwaGVydGV4dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMSgpO1xuICAgICAgICBtZXNzYWdlLndhbGxldFByZUtleSA9IChfYSA9IG9iamVjdC53YWxsZXRQcmVLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY2lwaGVydGV4dCA9XG4gICAgICAgICAgICBvYmplY3QuY2lwaGVydGV4dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jaXBoZXJ0ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC5jaXBoZXJ0ZXh0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gRW5jcnlwdGVkUHJpdmF0ZUtleUJ1bmRsZVYxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgPyBFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlVjEuZnJvbUpTT04ob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjFcbiAgICAgICAgICAgICAgICA/IEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVWMS50b0pTT04obWVzc2FnZS52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlVjEuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaXZhdGVfa2V5LnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_key.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrivatePreferencesAction: () => (/* binding */ PrivatePreferencesAction),\n/* harmony export */   PrivatePreferencesAction_AllowAddress: () => (/* binding */ PrivatePreferencesAction_AllowAddress),\n/* harmony export */   PrivatePreferencesAction_AllowGroup: () => (/* binding */ PrivatePreferencesAction_AllowGroup),\n/* harmony export */   PrivatePreferencesAction_AllowInboxId: () => (/* binding */ PrivatePreferencesAction_AllowInboxId),\n/* harmony export */   PrivatePreferencesAction_DenyAddress: () => (/* binding */ PrivatePreferencesAction_DenyAddress),\n/* harmony export */   PrivatePreferencesAction_DenyGroup: () => (/* binding */ PrivatePreferencesAction_DenyGroup),\n/* harmony export */   PrivatePreferencesAction_DenyInboxId: () => (/* binding */ PrivatePreferencesAction_DenyInboxId),\n/* harmony export */   PrivatePreferencesPayload: () => (/* binding */ PrivatePreferencesPayload),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ciphertext.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/ciphertext.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBasePrivatePreferencesAction() {\n    return {\n        allowAddress: undefined,\n        denyAddress: undefined,\n        allowGroup: undefined,\n        denyGroup: undefined,\n        allowInboxId: undefined,\n        denyInboxId: undefined,\n    };\n}\nconst PrivatePreferencesAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.allowAddress !== undefined) {\n            PrivatePreferencesAction_AllowAddress.encode(message.allowAddress, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.denyAddress !== undefined) {\n            PrivatePreferencesAction_DenyAddress.encode(message.denyAddress, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.allowGroup !== undefined) {\n            PrivatePreferencesAction_AllowGroup.encode(message.allowGroup, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.denyGroup !== undefined) {\n            PrivatePreferencesAction_DenyGroup.encode(message.denyGroup, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.allowInboxId !== undefined) {\n            PrivatePreferencesAction_AllowInboxId.encode(message.allowInboxId, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.denyInboxId !== undefined) {\n            PrivatePreferencesAction_DenyInboxId.encode(message.denyInboxId, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.allowAddress = PrivatePreferencesAction_AllowAddress.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.denyAddress = PrivatePreferencesAction_DenyAddress.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.allowGroup = PrivatePreferencesAction_AllowGroup.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.denyGroup = PrivatePreferencesAction_DenyGroup.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.allowInboxId = PrivatePreferencesAction_AllowInboxId.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.denyInboxId = PrivatePreferencesAction_DenyInboxId.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            allowAddress: isSet(object.allowAddress)\n                ? PrivatePreferencesAction_AllowAddress.fromJSON(object.allowAddress)\n                : undefined,\n            denyAddress: isSet(object.denyAddress)\n                ? PrivatePreferencesAction_DenyAddress.fromJSON(object.denyAddress)\n                : undefined,\n            allowGroup: isSet(object.allowGroup)\n                ? PrivatePreferencesAction_AllowGroup.fromJSON(object.allowGroup)\n                : undefined,\n            denyGroup: isSet(object.denyGroup)\n                ? PrivatePreferencesAction_DenyGroup.fromJSON(object.denyGroup)\n                : undefined,\n            allowInboxId: isSet(object.allowInboxId)\n                ? PrivatePreferencesAction_AllowInboxId.fromJSON(object.allowInboxId)\n                : undefined,\n            denyInboxId: isSet(object.denyInboxId)\n                ? PrivatePreferencesAction_DenyInboxId.fromJSON(object.denyInboxId)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.allowAddress !== undefined &&\n            (obj.allowAddress = message.allowAddress\n                ? PrivatePreferencesAction_AllowAddress.toJSON(message.allowAddress)\n                : undefined);\n        message.denyAddress !== undefined &&\n            (obj.denyAddress = message.denyAddress\n                ? PrivatePreferencesAction_DenyAddress.toJSON(message.denyAddress)\n                : undefined);\n        message.allowGroup !== undefined &&\n            (obj.allowGroup = message.allowGroup\n                ? PrivatePreferencesAction_AllowGroup.toJSON(message.allowGroup)\n                : undefined);\n        message.denyGroup !== undefined &&\n            (obj.denyGroup = message.denyGroup\n                ? PrivatePreferencesAction_DenyGroup.toJSON(message.denyGroup)\n                : undefined);\n        message.allowInboxId !== undefined &&\n            (obj.allowInboxId = message.allowInboxId\n                ? PrivatePreferencesAction_AllowInboxId.toJSON(message.allowInboxId)\n                : undefined);\n        message.denyInboxId !== undefined &&\n            (obj.denyInboxId = message.denyInboxId\n                ? PrivatePreferencesAction_DenyInboxId.toJSON(message.denyInboxId)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivatePreferencesAction();\n        message.allowAddress =\n            object.allowAddress !== undefined && object.allowAddress !== null\n                ? PrivatePreferencesAction_AllowAddress.fromPartial(object.allowAddress)\n                : undefined;\n        message.denyAddress =\n            object.denyAddress !== undefined && object.denyAddress !== null\n                ? PrivatePreferencesAction_DenyAddress.fromPartial(object.denyAddress)\n                : undefined;\n        message.allowGroup =\n            object.allowGroup !== undefined && object.allowGroup !== null\n                ? PrivatePreferencesAction_AllowGroup.fromPartial(object.allowGroup)\n                : undefined;\n        message.denyGroup =\n            object.denyGroup !== undefined && object.denyGroup !== null\n                ? PrivatePreferencesAction_DenyGroup.fromPartial(object.denyGroup)\n                : undefined;\n        message.allowInboxId =\n            object.allowInboxId !== undefined && object.allowInboxId !== null\n                ? PrivatePreferencesAction_AllowInboxId.fromPartial(object.allowInboxId)\n                : undefined;\n        message.denyInboxId =\n            object.denyInboxId !== undefined && object.denyInboxId !== null\n                ? PrivatePreferencesAction_DenyInboxId.fromPartial(object.denyInboxId)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_AllowAddress() {\n    return { walletAddresses: [] };\n}\nconst PrivatePreferencesAction_AllowAddress = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.walletAddresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_AllowAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses)\n                ? object.walletAddresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.walletAddresses) {\n            obj.walletAddresses = message.walletAddresses.map((e) => e);\n        }\n        else {\n            obj.walletAddresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_AllowAddress();\n        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_DenyAddress() {\n    return { walletAddresses: [] };\n}\nconst PrivatePreferencesAction_DenyAddress = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.walletAddresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_DenyAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.walletAddresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses)\n                ? object.walletAddresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.walletAddresses) {\n            obj.walletAddresses = message.walletAddresses.map((e) => e);\n        }\n        else {\n            obj.walletAddresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_DenyAddress();\n        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_AllowInboxId() {\n    return { inboxIds: [] };\n}\nconst PrivatePreferencesAction_AllowInboxId = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.inboxIds) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_AllowInboxId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds)\n                ? object.inboxIds.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.inboxIds) {\n            obj.inboxIds = message.inboxIds.map((e) => e);\n        }\n        else {\n            obj.inboxIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_AllowInboxId();\n        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_DenyInboxId() {\n    return { inboxIds: [] };\n}\nconst PrivatePreferencesAction_DenyInboxId = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.inboxIds) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_DenyInboxId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds)\n                ? object.inboxIds.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.inboxIds) {\n            obj.inboxIds = message.inboxIds.map((e) => e);\n        }\n        else {\n            obj.inboxIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_DenyInboxId();\n        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_AllowGroup() {\n    return { groupIds: [] };\n}\nconst PrivatePreferencesAction_AllowGroup = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.groupIds) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_AllowGroup();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds)\n                ? object.groupIds.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groupIds) {\n            obj.groupIds = message.groupIds.map((e) => e);\n        }\n        else {\n            obj.groupIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_AllowGroup();\n        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesAction_DenyGroup() {\n    return { groupIds: [] };\n}\nconst PrivatePreferencesAction_DenyGroup = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        for (const v of message.groupIds) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesAction_DenyGroup();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds)\n                ? object.groupIds.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groupIds) {\n            obj.groupIds = message.groupIds.map((e) => e);\n        }\n        else {\n            obj.groupIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePrivatePreferencesAction_DenyGroup();\n        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePrivatePreferencesPayload() {\n    return { v1: undefined };\n}\nconst PrivatePreferencesPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivatePreferencesPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePrivatePreferencesPayload();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? _ciphertext_pb__WEBPACK_IMPORTED_MODULE_1__.Ciphertext.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=private_preferences.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9wcml2YXRlX3ByZWZlcmVuY2VzLnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNxQjtBQUNSO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0EsWUFBWSxzREFBVTtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQVU7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFVO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFVO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvcHJpdmF0ZV9wcmVmZXJlbmNlcy5wYi5qcz8zZTZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgQ2lwaGVydGV4dCB9IGZyb20gXCIuL2NpcGhlcnRleHQucGJcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tZXNzYWdlX2NvbnRlbnRzXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93QWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgICBkZW55QWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvd0dyb3VwOiB1bmRlZmluZWQsXG4gICAgICAgIGRlbnlHcm91cDogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvd0luYm94SWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVueUluYm94SWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hbGxvd0FkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5lbmNvZGUobWVzc2FnZS5hbGxvd0FkZHJlc3MsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVueUFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlBZGRyZXNzLmVuY29kZShtZXNzYWdlLmRlbnlBZGRyZXNzLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFsbG93R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAuZW5jb2RlKG1lc3NhZ2UuYWxsb3dHcm91cCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZW55R3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5lbmNvZGUobWVzc2FnZS5kZW55R3JvdXAsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWxsb3dJbmJveElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0luYm94SWQuZW5jb2RlKG1lc3NhZ2UuYWxsb3dJbmJveElkLCB3cml0ZXIudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbnlJbmJveElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55SW5ib3hJZC5lbmNvZGUobWVzc2FnZS5kZW55SW5ib3hJZCwgd3JpdGVyLnVpbnQzMig1MCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWxsb3dBZGRyZXNzID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVueUFkZHJlc3MgPSBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsbG93R3JvdXAgPSBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dHcm91cC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVueUdyb3VwID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWxsb3dJbmJveElkID0gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93SW5ib3hJZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVueUluYm94SWQgPSBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUluYm94SWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dBZGRyZXNzOiBpc1NldChvYmplY3QuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy5mcm9tSlNPTihvYmplY3QuYWxsb3dBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueUFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZW55QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55QWRkcmVzcy5mcm9tSlNPTihvYmplY3QuZGVueUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvd0dyb3VwOiBpc1NldChvYmplY3QuYWxsb3dHcm91cClcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0dyb3VwLmZyb21KU09OKG9iamVjdC5hbGxvd0dyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueUdyb3VwOiBpc1NldChvYmplY3QuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC5mcm9tSlNPTihvYmplY3QuZGVueUdyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dJbmJveElkOiBpc1NldChvYmplY3QuYWxsb3dJbmJveElkKVxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93SW5ib3hJZC5mcm9tSlNPTihvYmplY3QuYWxsb3dJbmJveElkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueUluYm94SWQ6IGlzU2V0KG9iamVjdC5kZW55SW5ib3hJZClcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55SW5ib3hJZC5mcm9tSlNPTihvYmplY3QuZGVueUluYm94SWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hbGxvd0FkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hbGxvd0FkZHJlc3MgPSBtZXNzYWdlLmFsbG93QWRkcmVzc1xuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93QWRkcmVzcy50b0pTT04obWVzc2FnZS5hbGxvd0FkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmRlbnlBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVueUFkZHJlc3MgPSBtZXNzYWdlLmRlbnlBZGRyZXNzXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MudG9KU09OKG1lc3NhZ2UuZGVueUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmFsbG93R3JvdXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hbGxvd0dyb3VwID0gbWVzc2FnZS5hbGxvd0dyb3VwXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dHcm91cC50b0pTT04obWVzc2FnZS5hbGxvd0dyb3VwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5kZW55R3JvdXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZW55R3JvdXAgPSBtZXNzYWdlLmRlbnlHcm91cFxuICAgICAgICAgICAgICAgID8gUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlHcm91cC50b0pTT04obWVzc2FnZS5kZW55R3JvdXApXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmFsbG93SW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFsbG93SW5ib3hJZCA9IG1lc3NhZ2UuYWxsb3dJbmJveElkXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dJbmJveElkLnRvSlNPTihtZXNzYWdlLmFsbG93SW5ib3hJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuZGVueUluYm94SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZW55SW5ib3hJZCA9IG1lc3NhZ2UuZGVueUluYm94SWRcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55SW5ib3hJZC50b0pTT04obWVzc2FnZS5kZW55SW5ib3hJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24oKTtcbiAgICAgICAgbWVzc2FnZS5hbGxvd0FkZHJlc3MgPVxuICAgICAgICAgICAgb2JqZWN0LmFsbG93QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbGxvd0FkZHJlc3MgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MuZnJvbVBhcnRpYWwob2JqZWN0LmFsbG93QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5kZW55QWRkcmVzcyA9XG4gICAgICAgICAgICBvYmplY3QuZGVueUFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGVueUFkZHJlc3MgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55QWRkcmVzcy5mcm9tUGFydGlhbChvYmplY3QuZGVueUFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYWxsb3dHcm91cCA9XG4gICAgICAgICAgICBvYmplY3QuYWxsb3dHcm91cCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbGxvd0dyb3VwICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dHcm91cC5mcm9tUGFydGlhbChvYmplY3QuYWxsb3dHcm91cClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5kZW55R3JvdXAgPVxuICAgICAgICAgICAgb2JqZWN0LmRlbnlHcm91cCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kZW55R3JvdXAgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAuZnJvbVBhcnRpYWwob2JqZWN0LmRlbnlHcm91cClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5hbGxvd0luYm94SWQgPVxuICAgICAgICAgICAgb2JqZWN0LmFsbG93SW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbGxvd0luYm94SWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0luYm94SWQuZnJvbVBhcnRpYWwob2JqZWN0LmFsbG93SW5ib3hJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5kZW55SW5ib3hJZCA9XG4gICAgICAgICAgICBvYmplY3QuZGVueUluYm94SWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGVueUluYm94SWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55SW5ib3hJZC5mcm9tUGFydGlhbChvYmplY3QuZGVueUluYm94SWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHsgd2FsbGV0QWRkcmVzc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dBZGRyZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3YWxsZXRBZGRyZXNzZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LndhbGxldEFkZHJlc3NlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC53YWxsZXRBZGRyZXNzZXMubWFwKChlKSA9PiBTdHJpbmcoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS53YWxsZXRBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIG9iai53YWxsZXRBZGRyZXNzZXMgPSBtZXNzYWdlLndhbGxldEFkZHJlc3Nlcy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLndhbGxldEFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0FkZHJlc3MoKTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMgPSAoKF9hID0gb2JqZWN0LndhbGxldEFkZHJlc3NlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHsgd2FsbGV0QWRkcmVzc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55QWRkcmVzcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55QWRkcmVzcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0QWRkcmVzc2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC53YWxsZXRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Qud2FsbGV0QWRkcmVzc2VzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uud2FsbGV0QWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBvYmoud2FsbGV0QWRkcmVzc2VzID0gbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai53YWxsZXRBZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUFkZHJlc3MoKTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRBZGRyZXNzZXMgPSAoKF9hID0gb2JqZWN0LndhbGxldEFkZHJlc3NlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dJbmJveElkKCkge1xuICAgIHJldHVybiB7IGluYm94SWRzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0luYm94SWQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaW5ib3hJZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0luYm94SWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluYm94SWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5ib3hJZHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmluYm94SWRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmluYm94SWRzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5ib3hJZHMpIHtcbiAgICAgICAgICAgIG9iai5pbmJveElkcyA9IG1lc3NhZ2UuaW5ib3hJZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbmJveElkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0luYm94SWQoKTtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkcyA9ICgoX2EgPSBvYmplY3QuaW5ib3hJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlJbmJveElkKCkge1xuICAgIHJldHVybiB7IGluYm94SWRzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55SW5ib3hJZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5pbmJveElkcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0RlbnlJbmJveElkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmJveElkcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluYm94SWRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbmJveElkcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5pbmJveElkcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmluYm94SWRzKSB7XG4gICAgICAgICAgICBvYmouaW5ib3hJZHMgPSBtZXNzYWdlLmluYm94SWRzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouaW5ib3hJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUluYm94SWQoKTtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkcyA9ICgoX2EgPSBvYmplY3QuaW5ib3hJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAoKSB7XG4gICAgcmV0dXJuIHsgZ3JvdXBJZHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZVByZWZlcmVuY2VzQWN0aW9uX0FsbG93R3JvdXAgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBJZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9BbGxvd0dyb3VwKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cElkcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwSWRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5ncm91cElkcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5ncm91cElkcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwSWRzKSB7XG4gICAgICAgICAgICBvYmouZ3JvdXBJZHMgPSBtZXNzYWdlLmdyb3VwSWRzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZ3JvdXBJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fQWxsb3dHcm91cCgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwSWRzID0gKChfYSA9IG9iamVjdC5ncm91cElkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25fRGVueUdyb3VwKCkge1xuICAgIHJldHVybiB7IGdyb3VwSWRzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBJZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwSWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBJZHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lmdyb3VwSWRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lmdyb3VwSWRzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBJZHMpIHtcbiAgICAgICAgICAgIG9iai5ncm91cElkcyA9IG1lc3NhZ2UuZ3JvdXBJZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5ncm91cElkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbl9EZW55R3JvdXAoKTtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkcyA9ICgoX2EgPSBvYmplY3QuZ3JvdXBJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzUGF5bG9hZCgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUHJpdmF0ZVByZWZlcmVuY2VzUGF5bG9hZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDaXBoZXJ0ZXh0LmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJpdmF0ZVByZWZlcmVuY2VzUGF5bG9hZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBDaXBoZXJ0ZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gQ2lwaGVydGV4dC5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBDaXBoZXJ0ZXh0LnRvSlNPTihtZXNzYWdlLnYxKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcml2YXRlUHJlZmVyZW5jZXNQYXlsb2FkKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBDaXBoZXJ0ZXh0LmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcml2YXRlX3ByZWZlcmVuY2VzLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/private_preferences.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   PublicKeyBundle: () => (/* binding */ PublicKeyBundle),\n/* harmony export */   PublicKey_Secp256k1Uncompressed: () => (/* binding */ PublicKey_Secp256k1Uncompressed),\n/* harmony export */   SignedPublicKey: () => (/* binding */ SignedPublicKey),\n/* harmony export */   SignedPublicKeyBundle: () => (/* binding */ SignedPublicKeyBundle),\n/* harmony export */   UnsignedPublicKey: () => (/* binding */ UnsignedPublicKey),\n/* harmony export */   UnsignedPublicKey_Secp256k1Uncompressed: () => (/* binding */ UnsignedPublicKey_Secp256k1Uncompressed),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseUnsignedPublicKey() {\n    return { createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO, secp256k1Uncompressed: undefined };\n}\nconst UnsignedPublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (!message.createdNs.isZero()) {\n            writer.uint32(8).uint64(message.createdNs);\n        }\n        if (message.secp256k1Uncompressed !== undefined) {\n            UnsignedPublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsignedPublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 3:\n                    message.secp256k1Uncompressed =\n                        UnsignedPublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed)\n                ? UnsignedPublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.secp256k1Uncompressed !== undefined &&\n            (obj.secp256k1Uncompressed = message.secp256k1Uncompressed\n                ? UnsignedPublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUnsignedPublicKey();\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.secp256k1Uncompressed =\n            object.secp256k1Uncompressed !== undefined &&\n                object.secp256k1Uncompressed !== null\n                ? UnsignedPublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUnsignedPublicKey_Secp256k1Uncompressed() {\n    return { bytes: new Uint8Array() };\n}\nconst UnsignedPublicKey_Secp256k1Uncompressed = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignedPublicKey() {\n    return { keyBytes: new Uint8Array(), signature: undefined };\n}\nconst SignedPublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.keyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.keyBytes);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyBytes: isSet(object.keyBytes)\n                ? bytesFromBase64(object.keyBytes)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyBytes !== undefined &&\n            (obj.keyBytes = base64FromBytes(message.keyBytes !== undefined ? message.keyBytes : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPublicKey();\n        message.keyBytes = (_a = object.keyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignedPublicKeyBundle() {\n    return { identityKey: undefined, preKey: undefined };\n}\nconst SignedPublicKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            SignedPublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.preKey !== undefined) {\n            SignedPublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPublicKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKey = SignedPublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? SignedPublicKey.fromJSON(object.identityKey)\n                : undefined,\n            preKey: isSet(object.preKey)\n                ? SignedPublicKey.fromJSON(object.preKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? SignedPublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.preKey !== undefined &&\n            (obj.preKey = message.preKey\n                ? SignedPublicKey.toJSON(message.preKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignedPublicKeyBundle();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? SignedPublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKey =\n            object.preKey !== undefined && object.preKey !== null\n                ? SignedPublicKey.fromPartial(object.preKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePublicKey() {\n    return {\n        timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        signature: undefined,\n        secp256k1Uncompressed: undefined,\n    };\n}\nconst PublicKey = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (!message.timestamp.isZero()) {\n            writer.uint32(8).uint64(message.timestamp);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.secp256k1Uncompressed !== undefined) {\n            PublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestamp = reader.uint64();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.secp256k1Uncompressed =\n                        PublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestamp: isSet(object.timestamp)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed)\n                ? PublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestamp !== undefined &&\n            (obj.timestamp = (message.timestamp || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        message.secp256k1Uncompressed !== undefined &&\n            (obj.secp256k1Uncompressed = message.secp256k1Uncompressed\n                ? PublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePublicKey();\n        message.timestamp =\n            object.timestamp !== undefined && object.timestamp !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestamp)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        message.secp256k1Uncompressed =\n            object.secp256k1Uncompressed !== undefined &&\n                object.secp256k1Uncompressed !== null\n                ? PublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePublicKey_Secp256k1Uncompressed() {\n    return { bytes: new Uint8Array() };\n}\nconst PublicKey_Secp256k1Uncompressed = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKey_Secp256k1Uncompressed();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePublicKey_Secp256k1Uncompressed();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePublicKeyBundle() {\n    return { identityKey: undefined, preKey: undefined };\n}\nconst PublicKeyBundle = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.identityKey !== undefined) {\n            PublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.preKey !== undefined) {\n            PublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKeyBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identityKey = PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.preKey = PublicKey.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            identityKey: isSet(object.identityKey)\n                ? PublicKey.fromJSON(object.identityKey)\n                : undefined,\n            preKey: isSet(object.preKey)\n                ? PublicKey.fromJSON(object.preKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identityKey !== undefined &&\n            (obj.identityKey = message.identityKey\n                ? PublicKey.toJSON(message.identityKey)\n                : undefined);\n        message.preKey !== undefined &&\n            (obj.preKey = message.preKey\n                ? PublicKey.toJSON(message.preKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePublicKeyBundle();\n        message.identityKey =\n            object.identityKey !== undefined && object.identityKey !== null\n                ? PublicKey.fromPartial(object.identityKey)\n                : undefined;\n        message.preKey =\n            object.preKey !== undefined && object.preKey !== null\n                ? PublicKey.fromPartial(object.preKey)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=public_key.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9wdWJsaWNfa2V5LnBiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ21CO0FBQ047QUFDOUI7QUFDUDtBQUNBLGFBQWEsV0FBVyw0Q0FBSTtBQUM1QjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRDQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQUk7QUFDdEIsa0JBQWtCLDRDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvcHVibGljX2tleS5wYi5qcz8yODBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVuc2lnbmVkUHVibGljS2V5KCkge1xuICAgIHJldHVybiB7IGNyZWF0ZWROczogTG9uZy5VWkVSTywgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBVbnNpZ25lZFB1YmxpY0tleSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLmNyZWF0ZWROcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5lbmNvZGUobWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVbnNpZ25lZFB1YmxpY0tleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkTnM6IGlzU2V0KG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDogaXNTZXQob2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICA/IFVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5mcm9tSlNPTihvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY3JlYXRlZE5zID0gKG1lc3NhZ2UuY3JlYXRlZE5zIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlY3AyNTZrMVVuY29tcHJlc3NlZCA9IG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkXG4gICAgICAgICAgICAgICAgPyBVbnNpZ25lZFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQudG9KU09OKG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVuc2lnbmVkUHVibGljS2V5KCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgPVxuICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkLmZyb21QYXJ0aWFsKG9iamVjdC5zZWNwMjU2azFVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZCgpIHtcbiAgICByZXR1cm4geyBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IFVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVW5zaWduZWRQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVuc2lnbmVkUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZCgpO1xuICAgICAgICBtZXNzYWdlLmJ5dGVzID0gKF9hID0gb2JqZWN0LmJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIHsga2V5Qnl0ZXM6IG5ldyBVaW50OEFycmF5KCksIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkUHVibGljS2V5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleUJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5rZXlCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS5zaWduYXR1cmUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleUJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSBTaWduYXR1cmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5Qnl0ZXM6IGlzU2V0KG9iamVjdC5rZXlCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qua2V5Qnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLmZyb21KU09OKG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleUJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uua2V5Qnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uua2V5Qnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gbWVzc2FnZS5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS50b0pTT04obWVzc2FnZS5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXlCeXRlcyA9IChfYSA9IG9iamVjdC5rZXlCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXlCdW5kbGUoKSB7XG4gICAgcmV0dXJuIHsgaWRlbnRpdHlLZXk6IHVuZGVmaW5lZCwgcHJlS2V5OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduZWRQdWJsaWNLZXlCdW5kbGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmVkUHVibGljS2V5LmVuY29kZShtZXNzYWdlLmlkZW50aXR5S2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduZWRQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UucHJlS2V5LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUHVibGljS2V5QnVuZGxlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9IFNpZ25lZFB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlS2V5ID0gU2lnbmVkUHVibGljS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBpc1NldChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlS2V5OiBpc1NldChvYmplY3QucHJlS2V5KVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LmZyb21KU09OKG9iamVjdC5wcmVLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW50aXR5S2V5ID0gbWVzc2FnZS5pZGVudGl0eUtleVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LnRvSlNPTihtZXNzYWdlLmlkZW50aXR5S2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5wcmVLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wcmVLZXkgPSBtZXNzYWdlLnByZUtleVxuICAgICAgICAgICAgICAgID8gU2lnbmVkUHVibGljS2V5LnRvSlNPTihtZXNzYWdlLnByZUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduZWRQdWJsaWNLZXlCdW5kbGUoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eUtleSA9XG4gICAgICAgICAgICBvYmplY3QuaWRlbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWRlbnRpdHlLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25lZFB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucHJlS2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5wcmVLZXkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHJlS2V5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduZWRQdWJsaWNLZXkuZnJvbVBhcnRpYWwob2JqZWN0LnByZUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHVibGljS2V5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzdGFtcDogTG9uZy5VWkVSTyxcbiAgICAgICAgc2lnbmF0dXJlOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgUHVibGljS2V5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXAuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UudGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5lbmNvZGUobWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaWNLZXkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDogaXNTZXQob2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQuZnJvbUpTT04ob2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBtZXNzYWdlLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlLnRvSlNPTihtZXNzYWdlLnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VjcDI1NmsxVW5jb21wcmVzc2VkID0gbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleV9TZWNwMjU2azFVbmNvbXByZXNzZWQudG9KU09OKG1lc3NhZ2Uuc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleSgpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9XG4gICAgICAgICAgICBvYmplY3QudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRpbWVzdGFtcCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azFVbmNvbXByZXNzZWQgPVxuICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNlY3AyNTZrMVVuY29tcHJlc3NlZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZC5mcm9tUGFydGlhbChvYmplY3Quc2VjcDI1NmsxVW5jb21wcmVzc2VkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVibGljS2V5X1NlY3AyNTZrMVVuY29tcHJlc3NlZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXM6IGlzU2V0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ieXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmJ5dGVzIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaWNLZXlfU2VjcDI1NmsxVW5jb21wcmVzc2VkKCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1YmxpY0tleUJ1bmRsZSgpIHtcbiAgICByZXR1cm4geyBpZGVudGl0eUtleTogdW5kZWZpbmVkLCBwcmVLZXk6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFB1YmxpY0tleUJ1bmRsZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQdWJsaWNLZXkuZW5jb2RlKG1lc3NhZ2UuaWRlbnRpdHlLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFB1YmxpY0tleS5lbmNvZGUobWVzc2FnZS5wcmVLZXksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaWNLZXlCdW5kbGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID0gUHVibGljS2V5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVLZXkgPSBQdWJsaWNLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IGlzU2V0KG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVLZXk6IGlzU2V0KG9iamVjdC5wcmVLZXkpXG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LnByZUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaWRlbnRpdHlLZXkgPSBtZXNzYWdlLmlkZW50aXR5S2V5XG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UuaWRlbnRpdHlLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnByZUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnByZUtleSA9IG1lc3NhZ2UucHJlS2V5XG4gICAgICAgICAgICAgICAgPyBQdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UucHJlS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleUJ1bmRsZSgpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5S2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5pZGVudGl0eUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pZGVudGl0eUtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUHVibGljS2V5LmZyb21QYXJ0aWFsKG9iamVjdC5pZGVudGl0eUtleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wcmVLZXkgPVxuICAgICAgICAgICAgb2JqZWN0LnByZUtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wcmVLZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QucHJlS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1YmxpY19rZXkucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/public_key.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   Signature_ECDSACompact: () => (/* binding */ Signature_ECDSACompact),\n/* harmony export */   Signature_WalletECDSACompact: () => (/* binding */ Signature_WalletECDSACompact),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignature() {\n    return { ecdsaCompact: undefined, walletEcdsaCompact: undefined };\n}\nconst Signature = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.ecdsaCompact !== undefined) {\n            Signature_ECDSACompact.encode(message.ecdsaCompact, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.walletEcdsaCompact !== undefined) {\n            Signature_WalletECDSACompact.encode(message.walletEcdsaCompact, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ecdsaCompact = Signature_ECDSACompact.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.walletEcdsaCompact = Signature_WalletECDSACompact.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ecdsaCompact: isSet(object.ecdsaCompact)\n                ? Signature_ECDSACompact.fromJSON(object.ecdsaCompact)\n                : undefined,\n            walletEcdsaCompact: isSet(object.walletEcdsaCompact)\n                ? Signature_WalletECDSACompact.fromJSON(object.walletEcdsaCompact)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ecdsaCompact !== undefined &&\n            (obj.ecdsaCompact = message.ecdsaCompact\n                ? Signature_ECDSACompact.toJSON(message.ecdsaCompact)\n                : undefined);\n        message.walletEcdsaCompact !== undefined &&\n            (obj.walletEcdsaCompact = message.walletEcdsaCompact\n                ? Signature_WalletECDSACompact.toJSON(message.walletEcdsaCompact)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignature();\n        message.ecdsaCompact =\n            object.ecdsaCompact !== undefined && object.ecdsaCompact !== null\n                ? Signature_ECDSACompact.fromPartial(object.ecdsaCompact)\n                : undefined;\n        message.walletEcdsaCompact =\n            object.walletEcdsaCompact !== undefined &&\n                object.walletEcdsaCompact !== null\n                ? Signature_WalletECDSACompact.fromPartial(object.walletEcdsaCompact)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignature_ECDSACompact() {\n    return { bytes: new Uint8Array(), recovery: 0 };\n}\nconst Signature_ECDSACompact = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        if (message.recovery !== 0) {\n            writer.uint32(16).uint32(message.recovery);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature_ECDSACompact();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                case 2:\n                    message.recovery = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            recovery: isSet(object.recovery) ? Number(object.recovery) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.recovery !== undefined &&\n            (obj.recovery = Math.round(message.recovery));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignature_ECDSACompact();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseSignature_WalletECDSACompact() {\n    return { bytes: new Uint8Array(), recovery: 0 };\n}\nconst Signature_WalletECDSACompact = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.bytes.length !== 0) {\n            writer.uint32(10).bytes(message.bytes);\n        }\n        if (message.recovery !== 0) {\n            writer.uint32(16).uint32(message.recovery);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignature_WalletECDSACompact();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bytes = reader.bytes();\n                    break;\n                case 2:\n                    message.recovery = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            recovery: isSet(object.recovery) ? Number(object.recovery) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.recovery !== undefined &&\n            (obj.recovery = Math.round(message.recovery));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignature_WalletECDSACompact();\n        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signature.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9zaWduYXR1cmUucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2E7QUFDOUI7QUFDUDtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tZXNzYWdlX2NvbnRlbnRzL3NpZ25hdHVyZS5wYi5qcz8xNTBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHsgZWNkc2FDb21wYWN0OiB1bmRlZmluZWQsIHdhbGxldEVjZHNhQ29tcGFjdDogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmF0dXJlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVjZHNhQ29tcGFjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBTaWduYXR1cmVfRUNEU0FDb21wYWN0LmVuY29kZShtZXNzYWdlLmVjZHNhQ29tcGFjdCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS53YWxsZXRFY2RzYUNvbXBhY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdC5lbmNvZGUobWVzc2FnZS53YWxsZXRFY2RzYUNvbXBhY3QsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVjZHNhQ29tcGFjdCA9IFNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdCA9IFNpZ25hdHVyZV9XYWxsZXRFQ0RTQUNvbXBhY3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWNkc2FDb21wYWN0OiBpc1NldChvYmplY3QuZWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlX0VDRFNBQ29tcGFjdC5mcm9tSlNPTihvYmplY3QuZWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2FsbGV0RWNkc2FDb21wYWN0OiBpc1NldChvYmplY3Qud2FsbGV0RWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdC5mcm9tSlNPTihvYmplY3Qud2FsbGV0RWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZWNkc2FDb21wYWN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZWNkc2FDb21wYWN0ID0gbWVzc2FnZS5lY2RzYUNvbXBhY3RcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QudG9KU09OKG1lc3NhZ2UuZWNkc2FDb21wYWN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS53YWxsZXRFY2RzYUNvbXBhY3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai53YWxsZXRFY2RzYUNvbXBhY3QgPSBtZXNzYWdlLndhbGxldEVjZHNhQ29tcGFjdFxuICAgICAgICAgICAgICAgID8gU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdC50b0pTT04obWVzc2FnZS53YWxsZXRFY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlKCk7XG4gICAgICAgIG1lc3NhZ2UuZWNkc2FDb21wYWN0ID1cbiAgICAgICAgICAgIG9iamVjdC5lY2RzYUNvbXBhY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZWNkc2FDb21wYWN0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmVfRUNEU0FDb21wYWN0LmZyb21QYXJ0aWFsKG9iamVjdC5lY2RzYUNvbXBhY3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0RWNkc2FDb21wYWN0ID1cbiAgICAgICAgICAgIG9iamVjdC53YWxsZXRFY2RzYUNvbXBhY3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC53YWxsZXRFY2RzYUNvbXBhY3QgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZV9XYWxsZXRFQ0RTQUNvbXBhY3QuZnJvbVBhcnRpYWwob2JqZWN0LndhbGxldEVjZHNhQ29tcGFjdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlX0VDRFNBQ29tcGFjdCgpIHtcbiAgICByZXR1cm4geyBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSwgcmVjb3Zlcnk6IDAgfTtcbn1cbmV4cG9ydCBjb25zdCBTaWduYXR1cmVfRUNEU0FDb21wYWN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjb3ZlcnkgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQzMihtZXNzYWdlLnJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZV9FQ0RTQUNvbXBhY3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNvdmVyeSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXM6IGlzU2V0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgcmVjb3Zlcnk6IGlzU2V0KG9iamVjdC5yZWNvdmVyeSkgPyBOdW1iZXIob2JqZWN0LnJlY292ZXJ5KSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYnl0ZXMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucmVjb3ZlcnkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZWNvdmVyeSA9IE1hdGgucm91bmQobWVzc2FnZS5yZWNvdmVyeSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlX0VDRFNBQ29tcGFjdCgpO1xuICAgICAgICBtZXNzYWdlLmJ5dGVzID0gKF9hID0gb2JqZWN0LmJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnJlY292ZXJ5ID0gKF9iID0gb2JqZWN0LnJlY292ZXJ5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0KCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLCByZWNvdmVyeTogMCB9O1xufVxuZXhwb3J0IGNvbnN0IFNpZ25hdHVyZV9XYWxsZXRFQ0RTQUNvbXBhY3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNvdmVyeSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDMyKG1lc3NhZ2UucmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlX1dhbGxldEVDRFNBQ29tcGFjdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY292ZXJ5ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICByZWNvdmVyeTogaXNTZXQob2JqZWN0LnJlY292ZXJ5KSA/IE51bWJlcihvYmplY3QucmVjb3ZlcnkpIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvdmVyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnJlY292ZXJ5ID0gTWF0aC5yb3VuZChtZXNzYWdlLnJlY292ZXJ5KSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVfV2FsbGV0RUNEU0FDb21wYWN0KCk7XG4gICAgICAgIG1lc3NhZ2UuYnl0ZXMgPSAoX2EgPSBvYmplY3QuYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucmVjb3ZlcnkgPSAoX2IgPSBvYmplY3QucmVjb3ZlcnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignedPayload: () => (/* binding */ SignedPayload),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable */\n\n\n\nconst protobufPackage = \"xmtp.message_contents\";\nfunction createBaseSignedPayload() {\n    return { payload: new Uint8Array(), signature: undefined };\n}\nconst SignedPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Writer.create()) {\n        if (message.payload.length !== 0) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.signature !== undefined) {\n            _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.signature = _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(),\n            signature: isSet(object.signature)\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.signature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.signature !== undefined &&\n            (obj.signature = message.signature\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.signature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedPayload();\n        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? _signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.signature)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_2___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signed_payload.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWVzc2FnZV9jb250ZW50cy9zaWduZWRfcGF5bG9hZC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNtQjtBQUNOO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVM7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21lc3NhZ2VfY29udGVudHMvc2lnbmVkX3BheWxvYWQucGIuanM/MWQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuL3NpZ25hdHVyZS5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZWRQYXlsb2FkKCkge1xuICAgIHJldHVybiB7IHBheWxvYWQ6IG5ldyBVaW50OEFycmF5KCksIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgU2lnbmVkUGF5bG9hZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2lnbmF0dXJlLmVuY29kZShtZXNzYWdlLnNpZ25hdHVyZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZFBheWxvYWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5wYXlsb2FkIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpZ25hdHVyZSA9IG1lc3NhZ2Uuc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2Uuc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVkUGF5bG9hZCgpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSAoX2EgPSBvYmplY3QucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPVxuICAgICAgICAgICAgb2JqZWN0LnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zaWduYXR1cmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFNpZ25hdHVyZS5mcm9tUGFydGlhbChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25lZF9wYXlsb2FkLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signed_payload.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/api/v1/mls.pb.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/api/v1/mls.pb.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchKeyPackagesRequest: () => (/* binding */ FetchKeyPackagesRequest),\n/* harmony export */   FetchKeyPackagesResponse: () => (/* binding */ FetchKeyPackagesResponse),\n/* harmony export */   FetchKeyPackagesResponse_KeyPackage: () => (/* binding */ FetchKeyPackagesResponse_KeyPackage),\n/* harmony export */   GetIdentityUpdatesRequest: () => (/* binding */ GetIdentityUpdatesRequest),\n/* harmony export */   GetIdentityUpdatesResponse: () => (/* binding */ GetIdentityUpdatesResponse),\n/* harmony export */   GetIdentityUpdatesResponse_NewInstallationUpdate: () => (/* binding */ GetIdentityUpdatesResponse_NewInstallationUpdate),\n/* harmony export */   GetIdentityUpdatesResponse_RevokedInstallationUpdate: () => (/* binding */ GetIdentityUpdatesResponse_RevokedInstallationUpdate),\n/* harmony export */   GetIdentityUpdatesResponse_Update: () => (/* binding */ GetIdentityUpdatesResponse_Update),\n/* harmony export */   GetIdentityUpdatesResponse_WalletUpdates: () => (/* binding */ GetIdentityUpdatesResponse_WalletUpdates),\n/* harmony export */   GroupMessage: () => (/* binding */ GroupMessage),\n/* harmony export */   GroupMessageInput: () => (/* binding */ GroupMessageInput),\n/* harmony export */   GroupMessageInput_V1: () => (/* binding */ GroupMessageInput_V1),\n/* harmony export */   GroupMessage_V1: () => (/* binding */ GroupMessage_V1),\n/* harmony export */   KeyPackageUpload: () => (/* binding */ KeyPackageUpload),\n/* harmony export */   MlsApiClientImpl: () => (/* binding */ MlsApiClientImpl),\n/* harmony export */   PagingInfo: () => (/* binding */ PagingInfo),\n/* harmony export */   QueryGroupMessagesRequest: () => (/* binding */ QueryGroupMessagesRequest),\n/* harmony export */   QueryGroupMessagesResponse: () => (/* binding */ QueryGroupMessagesResponse),\n/* harmony export */   QueryWelcomeMessagesRequest: () => (/* binding */ QueryWelcomeMessagesRequest),\n/* harmony export */   QueryWelcomeMessagesResponse: () => (/* binding */ QueryWelcomeMessagesResponse),\n/* harmony export */   RegisterInstallationRequest: () => (/* binding */ RegisterInstallationRequest),\n/* harmony export */   RegisterInstallationResponse: () => (/* binding */ RegisterInstallationResponse),\n/* harmony export */   RevokeInstallationRequest: () => (/* binding */ RevokeInstallationRequest),\n/* harmony export */   SendGroupMessagesRequest: () => (/* binding */ SendGroupMessagesRequest),\n/* harmony export */   SendWelcomeMessagesRequest: () => (/* binding */ SendWelcomeMessagesRequest),\n/* harmony export */   SortDirection: () => (/* binding */ SortDirection),\n/* harmony export */   SubscribeGroupMessagesRequest: () => (/* binding */ SubscribeGroupMessagesRequest),\n/* harmony export */   SubscribeGroupMessagesRequest_Filter: () => (/* binding */ SubscribeGroupMessagesRequest_Filter),\n/* harmony export */   SubscribeWelcomeMessagesRequest: () => (/* binding */ SubscribeWelcomeMessagesRequest),\n/* harmony export */   SubscribeWelcomeMessagesRequest_Filter: () => (/* binding */ SubscribeWelcomeMessagesRequest_Filter),\n/* harmony export */   UploadKeyPackageRequest: () => (/* binding */ UploadKeyPackageRequest),\n/* harmony export */   WelcomeMessage: () => (/* binding */ WelcomeMessage),\n/* harmony export */   WelcomeMessageInput: () => (/* binding */ WelcomeMessageInput),\n/* harmony export */   WelcomeMessageInput_V1: () => (/* binding */ WelcomeMessageInput_V1),\n/* harmony export */   WelcomeMessage_V1: () => (/* binding */ WelcomeMessage_V1),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage),\n/* harmony export */   sortDirectionFromJSON: () => (/* binding */ sortDirectionFromJSON),\n/* harmony export */   sortDirectionToJSON: () => (/* binding */ sortDirectionToJSON)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../message_contents/signature.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/message_contents/signature.pb.js\");\n/* harmony import */ var _google_protobuf_empty_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../google/protobuf/empty.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/google/protobuf/empty.pb.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"(ssr)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3__);\n/* eslint-disable */\n\n\n\n\n\nconst protobufPackage = \"xmtp.mls.api.v1\";\n/** Message API */\n/** Sort direction for queries */\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection[SortDirection[\"SORT_DIRECTION_UNSPECIFIED\"] = 0] = \"SORT_DIRECTION_UNSPECIFIED\";\n    SortDirection[SortDirection[\"SORT_DIRECTION_ASCENDING\"] = 1] = \"SORT_DIRECTION_ASCENDING\";\n    SortDirection[SortDirection[\"SORT_DIRECTION_DESCENDING\"] = 2] = \"SORT_DIRECTION_DESCENDING\";\n    SortDirection[SortDirection[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SortDirection || (SortDirection = {}));\nfunction sortDirectionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SORT_DIRECTION_UNSPECIFIED\":\n            return SortDirection.SORT_DIRECTION_UNSPECIFIED;\n        case 1:\n        case \"SORT_DIRECTION_ASCENDING\":\n            return SortDirection.SORT_DIRECTION_ASCENDING;\n        case 2:\n        case \"SORT_DIRECTION_DESCENDING\":\n            return SortDirection.SORT_DIRECTION_DESCENDING;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return SortDirection.UNRECOGNIZED;\n    }\n}\nfunction sortDirectionToJSON(object) {\n    switch (object) {\n        case SortDirection.SORT_DIRECTION_UNSPECIFIED:\n            return \"SORT_DIRECTION_UNSPECIFIED\";\n        case SortDirection.SORT_DIRECTION_ASCENDING:\n            return \"SORT_DIRECTION_ASCENDING\";\n        case SortDirection.SORT_DIRECTION_DESCENDING:\n            return \"SORT_DIRECTION_DESCENDING\";\n        case SortDirection.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseWelcomeMessage() {\n    return { v1: undefined };\n}\nconst WelcomeMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            WelcomeMessage_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWelcomeMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = WelcomeMessage_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? WelcomeMessage_V1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? WelcomeMessage_V1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseWelcomeMessage();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? WelcomeMessage_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseWelcomeMessage_V1() {\n    return {\n        id: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        installationKey: new Uint8Array(),\n        data: new Uint8Array(),\n        hpkePublicKey: new Uint8Array(),\n    };\n}\nconst WelcomeMessage_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.id.isZero()) {\n            writer.uint32(8).uint64(message.id);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(16).uint64(message.createdNs);\n        }\n        if (message.installationKey.length !== 0) {\n            writer.uint32(26).bytes(message.installationKey);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(34).bytes(message.data);\n        }\n        if (message.hpkePublicKey.length !== 0) {\n            writer.uint32(42).bytes(message.hpkePublicKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWelcomeMessage_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint64();\n                    break;\n                case 2:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 3:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 4:\n                    message.data = reader.bytes();\n                    break;\n                case 5:\n                    message.hpkePublicKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.id) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n            hpkePublicKey: isSet(object.hpkePublicKey)\n                ? bytesFromBase64(object.hpkePublicKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined &&\n            (obj.id = (message.id || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        message.hpkePublicKey !== undefined &&\n            (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined\n                ? message.hpkePublicKey\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseWelcomeMessage_V1();\n        message.id =\n            object.id !== undefined && object.id !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.id)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.hpkePublicKey = (_c = object.hpkePublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseWelcomeMessageInput() {\n    return { v1: undefined };\n}\nconst WelcomeMessageInput = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            WelcomeMessageInput_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWelcomeMessageInput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = WelcomeMessageInput_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? WelcomeMessageInput_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? WelcomeMessageInput_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseWelcomeMessageInput();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? WelcomeMessageInput_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseWelcomeMessageInput_V1() {\n    return {\n        installationKey: new Uint8Array(),\n        data: new Uint8Array(),\n        hpkePublicKey: new Uint8Array(),\n    };\n}\nconst WelcomeMessageInput_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(18).bytes(message.data);\n        }\n        if (message.hpkePublicKey.length !== 0) {\n            writer.uint32(26).bytes(message.hpkePublicKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWelcomeMessageInput_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.data = reader.bytes();\n                    break;\n                case 3:\n                    message.hpkePublicKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n            hpkePublicKey: isSet(object.hpkePublicKey)\n                ? bytesFromBase64(object.hpkePublicKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        message.hpkePublicKey !== undefined &&\n            (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined\n                ? message.hpkePublicKey\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseWelcomeMessageInput_V1();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.hpkePublicKey = (_c = object.hpkePublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGroupMessage() {\n    return { v1: undefined };\n}\nconst GroupMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            GroupMessage_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = GroupMessage_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? GroupMessage_V1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? GroupMessage_V1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGroupMessage();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? GroupMessage_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGroupMessage_V1() {\n    return {\n        id: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        createdNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        groupId: new Uint8Array(),\n        data: new Uint8Array(),\n        senderHmac: new Uint8Array(),\n    };\n}\nconst GroupMessage_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.id.isZero()) {\n            writer.uint32(8).uint64(message.id);\n        }\n        if (!message.createdNs.isZero()) {\n            writer.uint32(16).uint64(message.createdNs);\n        }\n        if (message.groupId.length !== 0) {\n            writer.uint32(26).bytes(message.groupId);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(34).bytes(message.data);\n        }\n        if (message.senderHmac.length !== 0) {\n            writer.uint32(42).bytes(message.senderHmac);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMessage_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint64();\n                    break;\n                case 2:\n                    message.createdNs = reader.uint64();\n                    break;\n                case 3:\n                    message.groupId = reader.bytes();\n                    break;\n                case 4:\n                    message.data = reader.bytes();\n                    break;\n                case 5:\n                    message.senderHmac = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.id) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            createdNs: isSet(object.createdNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            groupId: isSet(object.groupId)\n                ? bytesFromBase64(object.groupId)\n                : new Uint8Array(),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined &&\n            (obj.id = (message.id || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.createdNs !== undefined &&\n            (obj.createdNs = (message.createdNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.groupId !== undefined &&\n            (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        message.senderHmac !== undefined &&\n            (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseGroupMessage_V1();\n        message.id =\n            object.id !== undefined && object.id !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.id)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.createdNs =\n            object.createdNs !== undefined && object.createdNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.createdNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.senderHmac = (_c = object.senderHmac) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGroupMessageInput() {\n    return { v1: undefined };\n}\nconst GroupMessageInput = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            GroupMessageInput_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMessageInput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = GroupMessageInput_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? GroupMessageInput_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? GroupMessageInput_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGroupMessageInput();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? GroupMessageInput_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGroupMessageInput_V1() {\n    return { data: new Uint8Array(), senderHmac: new Uint8Array() };\n}\nconst GroupMessageInput_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.data.length !== 0) {\n            writer.uint32(10).bytes(message.data);\n        }\n        if (message.senderHmac.length !== 0) {\n            writer.uint32(18).bytes(message.senderHmac);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMessageInput_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = reader.bytes();\n                    break;\n                case 2:\n                    message.senderHmac = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n            senderHmac: isSet(object.senderHmac)\n                ? bytesFromBase64(object.senderHmac)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        message.senderHmac !== undefined &&\n            (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGroupMessageInput_V1();\n        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.senderHmac = (_b = object.senderHmac) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSendGroupMessagesRequest() {\n    return { messages: [] };\n}\nconst SendGroupMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.messages) {\n            GroupMessageInput.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendGroupMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(GroupMessageInput.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => GroupMessageInput.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? GroupMessageInput.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendGroupMessagesRequest();\n        message.messages =\n            ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => GroupMessageInput.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSendWelcomeMessagesRequest() {\n    return { messages: [] };\n}\nconst SendWelcomeMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.messages) {\n            WelcomeMessageInput.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendWelcomeMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(WelcomeMessageInput.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => WelcomeMessageInput.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? WelcomeMessageInput.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendWelcomeMessagesRequest();\n        message.messages =\n            ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => WelcomeMessageInput.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseKeyPackageUpload() {\n    return { keyPackageTlsSerialized: new Uint8Array() };\n}\nconst KeyPackageUpload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyPackageTlsSerialized.length !== 0) {\n            writer.uint32(10).bytes(message.keyPackageTlsSerialized);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseKeyPackageUpload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackageTlsSerialized = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackageTlsSerialized: isSet(object.keyPackageTlsSerialized)\n                ? bytesFromBase64(object.keyPackageTlsSerialized)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackageTlsSerialized !== undefined &&\n            (obj.keyPackageTlsSerialized = base64FromBytes(message.keyPackageTlsSerialized !== undefined\n                ? message.keyPackageTlsSerialized\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseKeyPackageUpload();\n        message.keyPackageTlsSerialized =\n            (_a = object.keyPackageTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseRegisterInstallationRequest() {\n    return { keyPackage: undefined, isInboxIdCredential: false };\n}\nconst RegisterInstallationRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyPackage !== undefined) {\n            KeyPackageUpload.encode(message.keyPackage, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.isInboxIdCredential === true) {\n            writer.uint32(16).bool(message.isInboxIdCredential);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRegisterInstallationRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackage = KeyPackageUpload.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.isInboxIdCredential = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackage: isSet(object.keyPackage)\n                ? KeyPackageUpload.fromJSON(object.keyPackage)\n                : undefined,\n            isInboxIdCredential: isSet(object.isInboxIdCredential)\n                ? Boolean(object.isInboxIdCredential)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackage !== undefined &&\n            (obj.keyPackage = message.keyPackage\n                ? KeyPackageUpload.toJSON(message.keyPackage)\n                : undefined);\n        message.isInboxIdCredential !== undefined &&\n            (obj.isInboxIdCredential = message.isInboxIdCredential);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRegisterInstallationRequest();\n        message.keyPackage =\n            object.keyPackage !== undefined && object.keyPackage !== null\n                ? KeyPackageUpload.fromPartial(object.keyPackage)\n                : undefined;\n        message.isInboxIdCredential = (_a = object.isInboxIdCredential) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseRegisterInstallationResponse() {\n    return { installationKey: new Uint8Array() };\n}\nconst RegisterInstallationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRegisterInstallationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRegisterInstallationResponse();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseUploadKeyPackageRequest() {\n    return { keyPackage: undefined, isInboxIdCredential: false };\n}\nconst UploadKeyPackageRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyPackage !== undefined) {\n            KeyPackageUpload.encode(message.keyPackage, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.isInboxIdCredential === true) {\n            writer.uint32(16).bool(message.isInboxIdCredential);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUploadKeyPackageRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackage = KeyPackageUpload.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.isInboxIdCredential = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackage: isSet(object.keyPackage)\n                ? KeyPackageUpload.fromJSON(object.keyPackage)\n                : undefined,\n            isInboxIdCredential: isSet(object.isInboxIdCredential)\n                ? Boolean(object.isInboxIdCredential)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackage !== undefined &&\n            (obj.keyPackage = message.keyPackage\n                ? KeyPackageUpload.toJSON(message.keyPackage)\n                : undefined);\n        message.isInboxIdCredential !== undefined &&\n            (obj.isInboxIdCredential = message.isInboxIdCredential);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUploadKeyPackageRequest();\n        message.keyPackage =\n            object.keyPackage !== undefined && object.keyPackage !== null\n                ? KeyPackageUpload.fromPartial(object.keyPackage)\n                : undefined;\n        message.isInboxIdCredential = (_a = object.isInboxIdCredential) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseFetchKeyPackagesRequest() {\n    return { installationKeys: [] };\n}\nconst FetchKeyPackagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.installationKeys) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFetchKeyPackagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKeys.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.installationKeys)\n                ? object.installationKeys.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.installationKeys) {\n            obj.installationKeys = message.installationKeys.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.installationKeys = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseFetchKeyPackagesRequest();\n        message.installationKeys = ((_a = object.installationKeys) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseFetchKeyPackagesResponse() {\n    return { keyPackages: [] };\n}\nconst FetchKeyPackagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.keyPackages) {\n            FetchKeyPackagesResponse_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFetchKeyPackagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackages.push(FetchKeyPackagesResponse_KeyPackage.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages)\n                ? object.keyPackages.map((e) => FetchKeyPackagesResponse_KeyPackage.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.keyPackages) {\n            obj.keyPackages = message.keyPackages.map((e) => e ? FetchKeyPackagesResponse_KeyPackage.toJSON(e) : undefined);\n        }\n        else {\n            obj.keyPackages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseFetchKeyPackagesResponse();\n        message.keyPackages =\n            ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e) => FetchKeyPackagesResponse_KeyPackage.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseFetchKeyPackagesResponse_KeyPackage() {\n    return { keyPackageTlsSerialized: new Uint8Array() };\n}\nconst FetchKeyPackagesResponse_KeyPackage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.keyPackageTlsSerialized.length !== 0) {\n            writer.uint32(10).bytes(message.keyPackageTlsSerialized);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFetchKeyPackagesResponse_KeyPackage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackageTlsSerialized = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackageTlsSerialized: isSet(object.keyPackageTlsSerialized)\n                ? bytesFromBase64(object.keyPackageTlsSerialized)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackageTlsSerialized !== undefined &&\n            (obj.keyPackageTlsSerialized = base64FromBytes(message.keyPackageTlsSerialized !== undefined\n                ? message.keyPackageTlsSerialized\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseFetchKeyPackagesResponse_KeyPackage();\n        message.keyPackageTlsSerialized =\n            (_a = object.keyPackageTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseRevokeInstallationRequest() {\n    return { installationKey: new Uint8Array(), walletSignature: undefined };\n}\nconst RevokeInstallationRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (message.walletSignature !== undefined) {\n            _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.encode(message.walletSignature, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRevokeInstallationRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.walletSignature = _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            walletSignature: isSet(object.walletSignature)\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromJSON(object.walletSignature)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.walletSignature !== undefined &&\n            (obj.walletSignature = message.walletSignature\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.toJSON(message.walletSignature)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRevokeInstallationRequest();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.walletSignature =\n            object.walletSignature !== undefined && object.walletSignature !== null\n                ? _message_contents_signature_pb__WEBPACK_IMPORTED_MODULE_1__.Signature.fromPartial(object.walletSignature)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesRequest() {\n    return { accountAddresses: [], startTimeNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst GetIdentityUpdatesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.accountAddresses) {\n            writer.uint32(10).string(v);\n        }\n        if (!message.startTimeNs.isZero()) {\n            writer.uint32(16).uint64(message.startTimeNs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountAddresses.push(reader.string());\n                    break;\n                case 2:\n                    message.startTimeNs = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            accountAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.accountAddresses)\n                ? object.accountAddresses.map((e) => String(e))\n                : [],\n            startTimeNs: isSet(object.startTimeNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.startTimeNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.accountAddresses) {\n            obj.accountAddresses = message.accountAddresses.map((e) => e);\n        }\n        else {\n            obj.accountAddresses = [];\n        }\n        message.startTimeNs !== undefined &&\n            (obj.startTimeNs = (message.startTimeNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesRequest();\n        message.accountAddresses = ((_a = object.accountAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        message.startTimeNs =\n            object.startTimeNs !== undefined && object.startTimeNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.startTimeNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse() {\n    return { updates: [] };\n}\nconst GetIdentityUpdatesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.updates) {\n            GetIdentityUpdatesResponse_WalletUpdates.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.updates.push(GetIdentityUpdatesResponse_WalletUpdates.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates)\n                ? object.updates.map((e) => GetIdentityUpdatesResponse_WalletUpdates.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.updates) {\n            obj.updates = message.updates.map((e) => e ? GetIdentityUpdatesResponse_WalletUpdates.toJSON(e) : undefined);\n        }\n        else {\n            obj.updates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesResponse();\n        message.updates =\n            ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e) => GetIdentityUpdatesResponse_WalletUpdates.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_NewInstallationUpdate() {\n    return {\n        installationKey: new Uint8Array(),\n        credentialIdentity: new Uint8Array(),\n    };\n}\nconst GetIdentityUpdatesResponse_NewInstallationUpdate = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (message.credentialIdentity.length !== 0) {\n            writer.uint32(18).bytes(message.credentialIdentity);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_NewInstallationUpdate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.credentialIdentity = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            credentialIdentity: isSet(object.credentialIdentity)\n                ? bytesFromBase64(object.credentialIdentity)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.credentialIdentity !== undefined &&\n            (obj.credentialIdentity = base64FromBytes(message.credentialIdentity !== undefined\n                ? message.credentialIdentity\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetIdentityUpdatesResponse_NewInstallationUpdate();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.credentialIdentity = (_b = object.credentialIdentity) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate() {\n    return { installationKey: new Uint8Array() };\n}\nconst GetIdentityUpdatesResponse_RevokedInstallationUpdate = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_Update() {\n    return {\n        timestampNs: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        newInstallation: undefined,\n        revokedInstallation: undefined,\n    };\n}\nconst GetIdentityUpdatesResponse_Update = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (!message.timestampNs.isZero()) {\n            writer.uint32(8).uint64(message.timestampNs);\n        }\n        if (message.newInstallation !== undefined) {\n            GetIdentityUpdatesResponse_NewInstallationUpdate.encode(message.newInstallation, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.revokedInstallation !== undefined) {\n            GetIdentityUpdatesResponse_RevokedInstallationUpdate.encode(message.revokedInstallation, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_Update();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timestampNs = reader.uint64();\n                    break;\n                case 2:\n                    message.newInstallation =\n                        GetIdentityUpdatesResponse_NewInstallationUpdate.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.revokedInstallation =\n                        GetIdentityUpdatesResponse_RevokedInstallationUpdate.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            timestampNs: isSet(object.timestampNs)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n            newInstallation: isSet(object.newInstallation)\n                ? GetIdentityUpdatesResponse_NewInstallationUpdate.fromJSON(object.newInstallation)\n                : undefined,\n            revokedInstallation: isSet(object.revokedInstallation)\n                ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.fromJSON(object.revokedInstallation)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.timestampNs !== undefined &&\n            (obj.timestampNs = (message.timestampNs || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        message.newInstallation !== undefined &&\n            (obj.newInstallation = message.newInstallation\n                ? GetIdentityUpdatesResponse_NewInstallationUpdate.toJSON(message.newInstallation)\n                : undefined);\n        message.revokedInstallation !== undefined &&\n            (obj.revokedInstallation = message.revokedInstallation\n                ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.toJSON(message.revokedInstallation)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetIdentityUpdatesResponse_Update();\n        message.timestampNs =\n            object.timestampNs !== undefined && object.timestampNs !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.timestampNs)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        message.newInstallation =\n            object.newInstallation !== undefined && object.newInstallation !== null\n                ? GetIdentityUpdatesResponse_NewInstallationUpdate.fromPartial(object.newInstallation)\n                : undefined;\n        message.revokedInstallation =\n            object.revokedInstallation !== undefined &&\n                object.revokedInstallation !== null\n                ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.fromPartial(object.revokedInstallation)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGetIdentityUpdatesResponse_WalletUpdates() {\n    return { updates: [] };\n}\nconst GetIdentityUpdatesResponse_WalletUpdates = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.updates) {\n            GetIdentityUpdatesResponse_Update.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIdentityUpdatesResponse_WalletUpdates();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.updates.push(GetIdentityUpdatesResponse_Update.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates)\n                ? object.updates.map((e) => GetIdentityUpdatesResponse_Update.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.updates) {\n            obj.updates = message.updates.map((e) => e ? GetIdentityUpdatesResponse_Update.toJSON(e) : undefined);\n        }\n        else {\n            obj.updates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIdentityUpdatesResponse_WalletUpdates();\n        message.updates =\n            ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e) => GetIdentityUpdatesResponse_Update.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePagingInfo() {\n    return { direction: 0, limit: 0, idCursor: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst PagingInfo = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.direction !== 0) {\n            writer.uint32(8).int32(message.direction);\n        }\n        if (message.limit !== 0) {\n            writer.uint32(16).uint32(message.limit);\n        }\n        if (!message.idCursor.isZero()) {\n            writer.uint32(24).uint64(message.idCursor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePagingInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.direction = reader.int32();\n                    break;\n                case 2:\n                    message.limit = reader.uint32();\n                    break;\n                case 3:\n                    message.idCursor = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            direction: isSet(object.direction)\n                ? sortDirectionFromJSON(object.direction)\n                : 0,\n            limit: isSet(object.limit) ? Number(object.limit) : 0,\n            idCursor: isSet(object.idCursor)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.direction !== undefined &&\n            (obj.direction = sortDirectionToJSON(message.direction));\n        message.limit !== undefined && (obj.limit = Math.round(message.limit));\n        message.idCursor !== undefined &&\n            (obj.idCursor = (message.idCursor || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePagingInfo();\n        message.direction = (_a = object.direction) !== null && _a !== void 0 ? _a : 0;\n        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : 0;\n        message.idCursor =\n            object.idCursor !== undefined && object.idCursor !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseQueryGroupMessagesRequest() {\n    return { groupId: new Uint8Array(), pagingInfo: undefined };\n}\nconst QueryGroupMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.groupId.length !== 0) {\n            writer.uint32(10).bytes(message.groupId);\n        }\n        if (message.pagingInfo !== undefined) {\n            PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseQueryGroupMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupId = reader.bytes();\n                    break;\n                case 2:\n                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupId: isSet(object.groupId)\n                ? bytesFromBase64(object.groupId)\n                : new Uint8Array(),\n            pagingInfo: isSet(object.pagingInfo)\n                ? PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.groupId !== undefined &&\n            (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseQueryGroupMessagesRequest();\n        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseQueryGroupMessagesResponse() {\n    return { messages: [], pagingInfo: undefined };\n}\nconst QueryGroupMessagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.messages) {\n            GroupMessage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseQueryGroupMessagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(GroupMessage.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => GroupMessage.fromJSON(e))\n                : [],\n            pagingInfo: isSet(object.pagingInfo)\n                ? PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? GroupMessage.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseQueryGroupMessagesResponse();\n        message.messages =\n            ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => GroupMessage.fromPartial(e))) || [];\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseQueryWelcomeMessagesRequest() {\n    return { installationKey: new Uint8Array(), pagingInfo: undefined };\n}\nconst QueryWelcomeMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (message.pagingInfo !== undefined) {\n            PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseQueryWelcomeMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            pagingInfo: isSet(object.pagingInfo)\n                ? PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseQueryWelcomeMessagesRequest();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseQueryWelcomeMessagesResponse() {\n    return { messages: [], pagingInfo: undefined };\n}\nconst QueryWelcomeMessagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.messages) {\n            WelcomeMessage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseQueryWelcomeMessagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(WelcomeMessage.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => WelcomeMessage.fromJSON(e))\n                : [],\n            pagingInfo: isSet(object.pagingInfo)\n                ? PagingInfo.fromJSON(object.pagingInfo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? WelcomeMessage.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseQueryWelcomeMessagesResponse();\n        message.messages =\n            ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => WelcomeMessage.fromPartial(e))) || [];\n        message.pagingInfo =\n            object.pagingInfo !== undefined && object.pagingInfo !== null\n                ? PagingInfo.fromPartial(object.pagingInfo)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSubscribeGroupMessagesRequest() {\n    return { filters: [] };\n}\nconst SubscribeGroupMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.filters) {\n            SubscribeGroupMessagesRequest_Filter.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeGroupMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.filters.push(SubscribeGroupMessagesRequest_Filter.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            filters: Array.isArray(object === null || object === void 0 ? void 0 : object.filters)\n                ? object.filters.map((e) => SubscribeGroupMessagesRequest_Filter.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.filters) {\n            obj.filters = message.filters.map((e) => e ? SubscribeGroupMessagesRequest_Filter.toJSON(e) : undefined);\n        }\n        else {\n            obj.filters = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSubscribeGroupMessagesRequest();\n        message.filters =\n            ((_a = object.filters) === null || _a === void 0 ? void 0 : _a.map((e) => SubscribeGroupMessagesRequest_Filter.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSubscribeGroupMessagesRequest_Filter() {\n    return { groupId: new Uint8Array(), idCursor: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst SubscribeGroupMessagesRequest_Filter = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.groupId.length !== 0) {\n            writer.uint32(10).bytes(message.groupId);\n        }\n        if (!message.idCursor.isZero()) {\n            writer.uint32(16).uint64(message.idCursor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeGroupMessagesRequest_Filter();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupId = reader.bytes();\n                    break;\n                case 2:\n                    message.idCursor = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupId: isSet(object.groupId)\n                ? bytesFromBase64(object.groupId)\n                : new Uint8Array(),\n            idCursor: isSet(object.idCursor)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.groupId !== undefined &&\n            (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));\n        message.idCursor !== undefined &&\n            (obj.idCursor = (message.idCursor || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSubscribeGroupMessagesRequest_Filter();\n        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.idCursor =\n            object.idCursor !== undefined && object.idCursor !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseSubscribeWelcomeMessagesRequest() {\n    return { filters: [] };\n}\nconst SubscribeWelcomeMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        for (const v of message.filters) {\n            SubscribeWelcomeMessagesRequest_Filter.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeWelcomeMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.filters.push(SubscribeWelcomeMessagesRequest_Filter.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            filters: Array.isArray(object === null || object === void 0 ? void 0 : object.filters)\n                ? object.filters.map((e) => SubscribeWelcomeMessagesRequest_Filter.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.filters) {\n            obj.filters = message.filters.map((e) => e ? SubscribeWelcomeMessagesRequest_Filter.toJSON(e) : undefined);\n        }\n        else {\n            obj.filters = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSubscribeWelcomeMessagesRequest();\n        message.filters =\n            ((_a = object.filters) === null || _a === void 0 ? void 0 : _a.map((e) => SubscribeWelcomeMessagesRequest_Filter.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSubscribeWelcomeMessagesRequest_Filter() {\n    return { installationKey: new Uint8Array(), idCursor: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst SubscribeWelcomeMessagesRequest_Filter = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (!message.idCursor.isZero()) {\n            writer.uint32(16).uint64(message.idCursor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeWelcomeMessagesRequest_Filter();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.idCursor = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            idCursor: isSet(object.idCursor)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.idCursor !== undefined &&\n            (obj.idCursor = (message.idCursor || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSubscribeWelcomeMessagesRequest_Filter();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.idCursor =\n            object.idCursor !== undefined && object.idCursor !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.idCursor)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nclass MlsApiClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n        this.SendGroupMessages = this.SendGroupMessages.bind(this);\n        this.SendWelcomeMessages = this.SendWelcomeMessages.bind(this);\n        this.RegisterInstallation = this.RegisterInstallation.bind(this);\n        this.UploadKeyPackage = this.UploadKeyPackage.bind(this);\n        this.FetchKeyPackages = this.FetchKeyPackages.bind(this);\n        this.RevokeInstallation = this.RevokeInstallation.bind(this);\n        this.GetIdentityUpdates = this.GetIdentityUpdates.bind(this);\n        this.QueryGroupMessages = this.QueryGroupMessages.bind(this);\n        this.QueryWelcomeMessages = this.QueryWelcomeMessages.bind(this);\n        this.SubscribeGroupMessages = this.SubscribeGroupMessages.bind(this);\n        this.SubscribeWelcomeMessages = this.SubscribeWelcomeMessages.bind(this);\n    }\n    SendGroupMessages(request) {\n        const data = SendGroupMessagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"SendGroupMessages\", data);\n        return promise.then((data) => _google_protobuf_empty_pb__WEBPACK_IMPORTED_MODULE_2__.Empty.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    SendWelcomeMessages(request) {\n        const data = SendWelcomeMessagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"SendWelcomeMessages\", data);\n        return promise.then((data) => _google_protobuf_empty_pb__WEBPACK_IMPORTED_MODULE_2__.Empty.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    RegisterInstallation(request) {\n        const data = RegisterInstallationRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"RegisterInstallation\", data);\n        return promise.then((data) => RegisterInstallationResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    UploadKeyPackage(request) {\n        const data = UploadKeyPackageRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"UploadKeyPackage\", data);\n        return promise.then((data) => _google_protobuf_empty_pb__WEBPACK_IMPORTED_MODULE_2__.Empty.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    FetchKeyPackages(request) {\n        const data = FetchKeyPackagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"FetchKeyPackages\", data);\n        return promise.then((data) => FetchKeyPackagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    RevokeInstallation(request) {\n        const data = RevokeInstallationRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"RevokeInstallation\", data);\n        return promise.then((data) => _google_protobuf_empty_pb__WEBPACK_IMPORTED_MODULE_2__.Empty.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    GetIdentityUpdates(request) {\n        const data = GetIdentityUpdatesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"GetIdentityUpdates\", data);\n        return promise.then((data) => GetIdentityUpdatesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    QueryGroupMessages(request) {\n        const data = QueryGroupMessagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"QueryGroupMessages\", data);\n        return promise.then((data) => QueryGroupMessagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    QueryWelcomeMessages(request) {\n        const data = QueryWelcomeMessagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls.api.v1.MlsApi\", \"QueryWelcomeMessages\", data);\n        return promise.then((data) => QueryWelcomeMessagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data)));\n    }\n    SubscribeGroupMessages(request) {\n        const data = SubscribeGroupMessagesRequest.encode(request).finish();\n        const result = this.rpc.serverStreamingRequest(\"xmtp.mls.api.v1.MlsApi\", \"SubscribeGroupMessages\", data);\n        return result.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((data) => GroupMessage.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data))));\n    }\n    SubscribeWelcomeMessages(request) {\n        const data = SubscribeWelcomeMessagesRequest.encode(request).finish();\n        const result = this.rpc.serverStreamingRequest(\"xmtp.mls.api.v1.MlsApi\", \"SubscribeWelcomeMessages\", data);\n        return result.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((data) => WelcomeMessage.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().Reader)(data))));\n    }\n}\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_3___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=mls.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL2FwaS92MS9tbHMucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUMyQztBQUNUO0FBQ3JCO0FBQ0E7QUFDOUI7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFJO0FBQ2hCLG1CQUFtQiw0Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Ms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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tbHMvYXBpL3YxL21scy5wYi5qcz9kZWJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uLy4uLy4uL21lc3NhZ2VfY29udGVudHMvc2lnbmF0dXJlLnBiXCI7XG5pbXBvcnQgeyBFbXB0eSB9IGZyb20gXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvZW1wdHkucGJcIjtcbmltcG9ydCB7IG1hcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1scy5hcGkudjFcIjtcbi8qKiBNZXNzYWdlIEFQSSAqL1xuLyoqIFNvcnQgZGlyZWN0aW9uIGZvciBxdWVyaWVzICovXG5leHBvcnQgdmFyIFNvcnREaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNvcnREaXJlY3Rpb24pIHtcbiAgICBTb3J0RGlyZWN0aW9uW1NvcnREaXJlY3Rpb25bXCJTT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJTT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIFNvcnREaXJlY3Rpb25bU29ydERpcmVjdGlvbltcIlNPUlRfRElSRUNUSU9OX0FTQ0VORElOR1wiXSA9IDFdID0gXCJTT1JUX0RJUkVDVElPTl9BU0NFTkRJTkdcIjtcbiAgICBTb3J0RGlyZWN0aW9uW1NvcnREaXJlY3Rpb25bXCJTT1JUX0RJUkVDVElPTl9ERVNDRU5ESU5HXCJdID0gMl0gPSBcIlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkdcIjtcbiAgICBTb3J0RGlyZWN0aW9uW1NvcnREaXJlY3Rpb25bXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoU29ydERpcmVjdGlvbiB8fCAoU29ydERpcmVjdGlvbiA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gc29ydERpcmVjdGlvbkZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIlNPUlRfRElSRUNUSU9OX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HXCI6XG4gICAgICAgICAgICByZXR1cm4gU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9BU0NFTkRJTkc7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkdcIjpcbiAgICAgICAgICAgIHJldHVybiBTb3J0RGlyZWN0aW9uLlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkc7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBTb3J0RGlyZWN0aW9uLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc29ydERpcmVjdGlvblRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJTT1JUX0RJUkVDVElPTl9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HXCI7XG4gICAgICAgIGNhc2UgU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9ERVNDRU5ESU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiU09SVF9ESVJFQ1RJT05fREVTQ0VORElOR1wiO1xuICAgICAgICBjYXNlIFNvcnREaXJlY3Rpb24uVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBXZWxjb21lTWVzc2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBXZWxjb21lTWVzc2FnZV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFdlbGNvbWVNZXNzYWdlX1YxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gV2VsY29tZU1lc3NhZ2VfVjEuZnJvbUpTT04ob2JqZWN0LnYxKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxID8gV2VsY29tZU1lc3NhZ2VfVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBXZWxjb21lTWVzc2FnZV9WMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlX1YxKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBMb25nLlVaRVJPLFxuICAgICAgICBjcmVhdGVkTnM6IExvbmcuVVpFUk8sXG4gICAgICAgIGluc3RhbGxhdGlvbktleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaHBrZVB1YmxpY0tleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFdlbGNvbWVNZXNzYWdlX1YxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5pZC5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLmNyZWF0ZWROcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UuY3JlYXRlZE5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLmJ5dGVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaHBrZVB1YmxpY0tleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDIpLmJ5dGVzKG1lc3NhZ2UuaHBrZVB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXZWxjb21lTWVzc2FnZV9WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhwa2VQdWJsaWNLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlzU2V0KG9iamVjdC5pZCkgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuaWQpIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgaW5zdGFsbGF0aW9uS2V5OiBpc1NldChvYmplY3QuaW5zdGFsbGF0aW9uS2V5KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZGF0YTogaXNTZXQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaHBrZVB1YmxpY0tleTogaXNTZXQob2JqZWN0Lmhwa2VQdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmhwa2VQdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZCA9IChtZXNzYWdlLmlkIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5ocGtlUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaHBrZVB1YmxpY0tleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhwa2VQdWJsaWNLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5ocGtlUHVibGljS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV2VsY29tZU1lc3NhZ2VfVjEoKTtcbiAgICAgICAgbWVzc2FnZS5pZCA9XG4gICAgICAgICAgICBvYmplY3QuaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5pZClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgPSAoX2EgPSBvYmplY3QuaW5zdGFsbGF0aW9uS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSAoX2IgPSBvYmplY3QuZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5ocGtlUHVibGljS2V5ID0gKF9jID0gb2JqZWN0Lmhwa2VQdWJsaWNLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFdlbGNvbWVNZXNzYWdlSW5wdXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgV2VsY29tZU1lc3NhZ2VJbnB1dF9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlSW5wdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gV2VsY29tZU1lc3NhZ2VJbnB1dF9WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgID8gV2VsY29tZU1lc3NhZ2VJbnB1dF9WMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MVxuICAgICAgICAgICAgICAgID8gV2VsY29tZU1lc3NhZ2VJbnB1dF9WMS50b0pTT04obWVzc2FnZS52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXZWxjb21lTWVzc2FnZUlucHV0KCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBXZWxjb21lTWVzc2FnZUlucHV0X1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlV2VsY29tZU1lc3NhZ2VJbnB1dF9WMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YWxsYXRpb25LZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGhwa2VQdWJsaWNLZXk6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBXZWxjb21lTWVzc2FnZUlucHV0X1YxID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvbktleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ocGtlUHVibGljS2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5ocGtlUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdlbGNvbWVNZXNzYWdlSW5wdXRfVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaHBrZVB1YmxpY0tleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBkYXRhOiBpc1NldChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBocGtlUHVibGljS2V5OiBpc1NldChvYmplY3QuaHBrZVB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaHBrZVB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5ocGtlUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaHBrZVB1YmxpY0tleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhwa2VQdWJsaWNLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5ocGtlUHVibGljS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV2VsY29tZU1lc3NhZ2VJbnB1dF9WMSgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IChfYSA9IG9iamVjdC5pbnN0YWxsYXRpb25LZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IChfYiA9IG9iamVjdC5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmhwa2VQdWJsaWNLZXkgPSAoX2MgPSBvYmplY3QuaHBrZVB1YmxpY0tleSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cE1lc3NhZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgR3JvdXBNZXNzYWdlX1YxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IEdyb3VwTWVzc2FnZV9WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IEdyb3VwTWVzc2FnZV9WMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBHcm91cE1lc3NhZ2VfVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTWVzc2FnZSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gR3JvdXBNZXNzYWdlX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlX1YxKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBMb25nLlVaRVJPLFxuICAgICAgICBjcmVhdGVkTnM6IExvbmcuVVpFUk8sXG4gICAgICAgIGdyb3VwSWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHNlbmRlckhtYWM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cE1lc3NhZ2VfVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmlkLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuY3JlYXRlZE5zLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS5jcmVhdGVkTnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwSWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLmdyb3VwSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlckhtYWMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQyKS5ieXRlcyhtZXNzYWdlLnNlbmRlckhtYWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlX1YxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwSWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlzU2V0KG9iamVjdC5pZCkgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuaWQpIDogTG9uZy5VWkVSTyxcbiAgICAgICAgICAgIGNyZWF0ZWROczogaXNTZXQob2JqZWN0LmNyZWF0ZWROcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5jcmVhdGVkTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgZ3JvdXBJZDogaXNTZXQob2JqZWN0Lmdyb3VwSWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmdyb3VwSWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZGF0YTogaXNTZXQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgc2VuZGVySG1hYzogaXNTZXQob2JqZWN0LnNlbmRlckhtYWMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnNlbmRlckhtYWMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZCA9IChtZXNzYWdlLmlkIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWROcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0ZWROcyA9IChtZXNzYWdlLmNyZWF0ZWROcyB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZ3JvdXBJZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmdyb3VwSWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZ3JvdXBJZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXJIbWFjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VuZGVySG1hYyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc2VuZGVySG1hYyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cE1lc3NhZ2VfVjEoKTtcbiAgICAgICAgbWVzc2FnZS5pZCA9XG4gICAgICAgICAgICBvYmplY3QuaWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5pZClcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZE5zID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVhdGVkTnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3JlYXRlZE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuY3JlYXRlZE5zKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgbWVzc2FnZS5ncm91cElkID0gKF9hID0gb2JqZWN0Lmdyb3VwSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IChfYiA9IG9iamVjdC5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgPSAoX2MgPSBvYmplY3Quc2VuZGVySG1hYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEdyb3VwTWVzc2FnZUlucHV0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEdyb3VwTWVzc2FnZUlucHV0X1YxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZXNzYWdlSW5wdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gR3JvdXBNZXNzYWdlSW5wdXRfVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA/IEdyb3VwTWVzc2FnZUlucHV0X1YxLmZyb21KU09OKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxXG4gICAgICAgICAgICAgICAgPyBHcm91cE1lc3NhZ2VJbnB1dF9WMS50b0pTT04obWVzc2FnZS52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cE1lc3NhZ2VJbnB1dCgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gR3JvdXBNZXNzYWdlSW5wdXRfVjEuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHcm91cE1lc3NhZ2VJbnB1dF9WMSgpIHtcbiAgICByZXR1cm4geyBkYXRhOiBuZXcgVWludDhBcnJheSgpLCBzZW5kZXJIbWFjOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgR3JvdXBNZXNzYWdlSW5wdXRfVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVySG1hYy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uuc2VuZGVySG1hYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cE1lc3NhZ2VJbnB1dF9WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVySG1hYyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpc1NldChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBzZW5kZXJIbWFjOiBpc1NldChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Quc2VuZGVySG1hYylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXJIbWFjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VuZGVySG1hYyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnNlbmRlckhtYWMgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc2VuZGVySG1hYyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTWVzc2FnZUlucHV0X1YxKCk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IChfYSA9IG9iamVjdC5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlckhtYWMgPSAoX2IgPSBvYmplY3Quc2VuZGVySG1hYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VuZEdyb3VwTWVzc2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IG1lc3NhZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbmRHcm91cE1lc3NhZ2VzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICAgICAgR3JvdXBNZXNzYWdlSW5wdXQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZW5kR3JvdXBNZXNzYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzLnB1c2goR3JvdXBNZXNzYWdlSW5wdXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5tZXNzYWdlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5tZXNzYWdlcy5tYXAoKGUpID0+IEdyb3VwTWVzc2FnZUlucHV0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PiBlID8gR3JvdXBNZXNzYWdlSW5wdXQudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbmRHcm91cE1lc3NhZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QubWVzc2FnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEdyb3VwTWVzc2FnZUlucHV0LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbmRXZWxjb21lTWVzc2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IG1lc3NhZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbmRXZWxjb21lTWVzc2FnZXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBXZWxjb21lTWVzc2FnZUlucHV0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZFdlbGNvbWVNZXNzYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzLnB1c2goV2VsY29tZU1lc3NhZ2VJbnB1dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1lc3NhZ2VzLm1hcCgoZSkgPT4gV2VsY29tZU1lc3NhZ2VJbnB1dC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBvYmoubWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLm1hcCgoZSkgPT4gZSA/IFdlbGNvbWVNZXNzYWdlSW5wdXQudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbmRXZWxjb21lTWVzc2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5tZXNzYWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gV2VsY29tZU1lc3NhZ2VJbnB1dC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VLZXlQYWNrYWdlVXBsb2FkKCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2VUbHNTZXJpYWxpemVkOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgS2V5UGFja2FnZVVwbG9hZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlS2V5UGFja2FnZVVwbG9hZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQ6IGlzU2V0KG9iamVjdC5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmtleVBhY2thZ2VUbHNTZXJpYWxpemVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWRcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlS2V5UGFja2FnZVVwbG9hZCgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VUbHNTZXJpYWxpemVkID1cbiAgICAgICAgICAgIChfYSA9IG9iamVjdC5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVnaXN0ZXJJbnN0YWxsYXRpb25SZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2U6IHVuZGVmaW5lZCwgaXNJbmJveElkQ3JlZGVudGlhbDogZmFsc2UgfTtcbn1cbmV4cG9ydCBjb25zdCBSZWdpc3Rlckluc3RhbGxhdGlvblJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5UGFja2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBLZXlQYWNrYWdlVXBsb2FkLmVuY29kZShtZXNzYWdlLmtleVBhY2thZ2UsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuYm9vbChtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVnaXN0ZXJJbnN0YWxsYXRpb25SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlID0gS2V5UGFja2FnZVVwbG9hZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleVBhY2thZ2U6IGlzU2V0KG9iamVjdC5rZXlQYWNrYWdlKVxuICAgICAgICAgICAgICAgID8gS2V5UGFja2FnZVVwbG9hZC5mcm9tSlNPTihvYmplY3Qua2V5UGFja2FnZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzSW5ib3hJZENyZWRlbnRpYWw6IGlzU2V0KG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKVxuICAgICAgICAgICAgICAgID8gQm9vbGVhbihvYmplY3QuaXNJbmJveElkQ3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uua2V5UGFja2FnZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleVBhY2thZ2UgPSBtZXNzYWdlLmtleVBhY2thZ2VcbiAgICAgICAgICAgICAgICA/IEtleVBhY2thZ2VVcGxvYWQudG9KU09OKG1lc3NhZ2Uua2V5UGFja2FnZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlzSW5ib3hJZENyZWRlbnRpYWwgPSBtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZWdpc3Rlckluc3RhbGxhdGlvblJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlID1cbiAgICAgICAgICAgIG9iamVjdC5rZXlQYWNrYWdlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmtleVBhY2thZ2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEtleVBhY2thZ2VVcGxvYWQuZnJvbVBhcnRpYWwob2JqZWN0LmtleVBhY2thZ2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9IChfYSA9IG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVnaXN0ZXJJbnN0YWxsYXRpb25SZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBpbnN0YWxsYXRpb25LZXk6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBSZWdpc3Rlckluc3RhbGxhdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvbktleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJlZ2lzdGVySW5zdGFsbGF0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVnaXN0ZXJJbnN0YWxsYXRpb25SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IChfYSA9IG9iamVjdC5pbnN0YWxsYXRpb25LZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwbG9hZEtleVBhY2thZ2VSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2U6IHVuZGVmaW5lZCwgaXNJbmJveElkQ3JlZGVudGlhbDogZmFsc2UgfTtcbn1cbmV4cG9ydCBjb25zdCBVcGxvYWRLZXlQYWNrYWdlUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlQYWNrYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEtleVBhY2thZ2VVcGxvYWQuZW5jb2RlKG1lc3NhZ2Uua2V5UGFja2FnZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0luYm94SWRDcmVkZW50aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGxvYWRLZXlQYWNrYWdlUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5UGFja2FnZSA9IEtleVBhY2thZ2VVcGxvYWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlQYWNrYWdlOiBpc1NldChvYmplY3Qua2V5UGFja2FnZSlcbiAgICAgICAgICAgICAgICA/IEtleVBhY2thZ2VVcGxvYWQuZnJvbUpTT04ob2JqZWN0LmtleVBhY2thZ2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0luYm94SWRDcmVkZW50aWFsOiBpc1NldChvYmplY3QuaXNJbmJveElkQ3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA/IEJvb2xlYW4ob2JqZWN0LmlzSW5ib3hJZENyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXlQYWNrYWdlID0gbWVzc2FnZS5rZXlQYWNrYWdlXG4gICAgICAgICAgICAgICAgPyBLZXlQYWNrYWdlVXBsb2FkLnRvSlNPTihtZXNzYWdlLmtleVBhY2thZ2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pc0luYm94SWRDcmVkZW50aWFsID0gbWVzc2FnZS5pc0luYm94SWRDcmVkZW50aWFsKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXBsb2FkS2V5UGFja2FnZVJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlID1cbiAgICAgICAgICAgIG9iamVjdC5rZXlQYWNrYWdlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmtleVBhY2thZ2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEtleVBhY2thZ2VVcGxvYWQuZnJvbVBhcnRpYWwob2JqZWN0LmtleVBhY2thZ2UpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9IChfYSA9IG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRmV0Y2hLZXlQYWNrYWdlc1JlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uS2V5czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBGZXRjaEtleVBhY2thZ2VzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZldGNoS2V5UGFja2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXlzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbnN0YWxsYXRpb25LZXlzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lmluc3RhbGxhdGlvbktleXMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25LZXlzKSB7XG4gICAgICAgICAgICBvYmouaW5zdGFsbGF0aW9uS2V5cyA9IG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5cy5tYXAoKGUpID0+IGJhc2U2NEZyb21CeXRlcyhlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmluc3RhbGxhdGlvbktleXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGZXRjaEtleVBhY2thZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleXMgPSAoKF9hID0gb2JqZWN0Lmluc3RhbGxhdGlvbktleXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRmV0Y2hLZXlQYWNrYWdlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEZldGNoS2V5UGFja2FnZXNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5rZXlQYWNrYWdlcykge1xuICAgICAgICAgICAgRmV0Y2hLZXlQYWNrYWdlc1Jlc3BvbnNlX0tleVBhY2thZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGZXRjaEtleVBhY2thZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VzLnB1c2goRmV0Y2hLZXlQYWNrYWdlc1Jlc3BvbnNlX0tleVBhY2thZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleVBhY2thZ2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5rZXlQYWNrYWdlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5rZXlQYWNrYWdlcy5tYXAoKGUpID0+IEZldGNoS2V5UGFja2FnZXNSZXNwb25zZV9LZXlQYWNrYWdlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5UGFja2FnZXMpIHtcbiAgICAgICAgICAgIG9iai5rZXlQYWNrYWdlcyA9IG1lc3NhZ2Uua2V5UGFja2FnZXMubWFwKChlKSA9PiBlID8gRmV0Y2hLZXlQYWNrYWdlc1Jlc3BvbnNlX0tleVBhY2thZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5rZXlQYWNrYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZldGNoS2V5UGFja2FnZXNSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3Qua2V5UGFja2FnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEZldGNoS2V5UGFja2FnZXNSZXNwb25zZV9LZXlQYWNrYWdlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZldGNoS2V5UGFja2FnZXNSZXNwb25zZV9LZXlQYWNrYWdlKCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2VUbHNTZXJpYWxpemVkOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgRmV0Y2hLZXlQYWNrYWdlc1Jlc3BvbnNlX0tleVBhY2thZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmtleVBhY2thZ2VUbHNTZXJpYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZldGNoS2V5UGFja2FnZXNSZXNwb25zZV9LZXlQYWNrYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlQYWNrYWdlVGxzU2VyaWFsaXplZDogaXNTZXQob2JqZWN0LmtleVBhY2thZ2VUbHNTZXJpYWxpemVkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleVBhY2thZ2VUbHNTZXJpYWxpemVkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uua2V5UGFja2FnZVRsc1NlcmlhbGl6ZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGZXRjaEtleVBhY2thZ2VzUmVzcG9uc2VfS2V5UGFja2FnZSgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VUbHNTZXJpYWxpemVkID1cbiAgICAgICAgICAgIChfYSA9IG9iamVjdC5rZXlQYWNrYWdlVGxzU2VyaWFsaXplZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUmV2b2tlSW5zdGFsbGF0aW9uUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBpbnN0YWxsYXRpb25LZXk6IG5ldyBVaW50OEFycmF5KCksIHdhbGxldFNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUmV2b2tlSW5zdGFsbGF0aW9uUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2FsbGV0U2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFNpZ25hdHVyZS5lbmNvZGUobWVzc2FnZS53YWxsZXRTaWduYXR1cmUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZXZva2VJbnN0YWxsYXRpb25SZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhbGxldFNpZ25hdHVyZSA9IFNpZ25hdHVyZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICB3YWxsZXRTaWduYXR1cmU6IGlzU2V0KG9iamVjdC53YWxsZXRTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbUpTT04ob2JqZWN0LndhbGxldFNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbGxhdGlvbktleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmluc3RhbGxhdGlvbktleVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLndhbGxldFNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLndhbGxldFNpZ25hdHVyZSA9IG1lc3NhZ2Uud2FsbGV0U2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUudG9KU09OKG1lc3NhZ2Uud2FsbGV0U2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmV2b2tlSW5zdGFsbGF0aW9uUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IChfYSA9IG9iamVjdC5pbnN0YWxsYXRpb25LZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2Uud2FsbGV0U2lnbmF0dXJlID1cbiAgICAgICAgICAgIG9iamVjdC53YWxsZXRTaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qud2FsbGV0U2lnbmF0dXJlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBTaWduYXR1cmUuZnJvbVBhcnRpYWwob2JqZWN0LndhbGxldFNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBhY2NvdW50QWRkcmVzc2VzOiBbXSwgc3RhcnRUaW1lTnM6IExvbmcuVVpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJZGVudGl0eVVwZGF0ZXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2Uuc3RhcnRUaW1lTnMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnN0YXJ0VGltZU5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRUaW1lTnMgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRBZGRyZXNzZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFjY291bnRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuYWNjb3VudEFkZHJlc3Nlcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgc3RhcnRUaW1lTnM6IGlzU2V0KG9iamVjdC5zdGFydFRpbWVOcylcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5zdGFydFRpbWVOcylcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWNjb3VudEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgb2JqLmFjY291bnRBZGRyZXNzZXMgPSBtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hY2NvdW50QWRkcmVzc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5zdGFydFRpbWVOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN0YXJ0VGltZU5zID0gKG1lc3NhZ2Uuc3RhcnRUaW1lTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5hY2NvdW50QWRkcmVzc2VzID0gKChfYSA9IG9iamVjdC5hY2NvdW50QWRkcmVzc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2Uuc3RhcnRUaW1lTnMgPVxuICAgICAgICAgICAgb2JqZWN0LnN0YXJ0VGltZU5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnN0YXJ0VGltZU5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3Quc3RhcnRUaW1lTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyB1cGRhdGVzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlcy5wdXNoKEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudXBkYXRlcy5tYXAoKGUpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGVzKSB7XG4gICAgICAgICAgICBvYmoudXBkYXRlcyA9IG1lc3NhZ2UudXBkYXRlcy5tYXAoKGUpID0+IGUgPyBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9XYWxsZXRVcGRhdGVzLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudXBkYXRlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnVwZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfTmV3SW5zdGFsbGF0aW9uVXBkYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbGxhdGlvbktleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgY3JlZGVudGlhbElkZW50aXR5OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfTmV3SW5zdGFsbGF0aW9uVXBkYXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvbktleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jcmVkZW50aWFsSWRlbnRpdHkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9OZXdJbnN0YWxsYXRpb25VcGRhdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlZGVudGlhbElkZW50aXR5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbktleTogaXNTZXQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaW5zdGFsbGF0aW9uS2V5KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxJZGVudGl0eTogaXNTZXQob2JqZWN0LmNyZWRlbnRpYWxJZGVudGl0eSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY3JlZGVudGlhbElkZW50aXR5KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbGxhdGlvbktleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmluc3RhbGxhdGlvbktleVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWRlbnRpYWxJZGVudGl0eSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfTmV3SW5zdGFsbGF0aW9uVXBkYXRlKCk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ID0gKF9hID0gb2JqZWN0Lmluc3RhbGxhdGlvbktleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jcmVkZW50aWFsSWRlbnRpdHkgPSAoX2IgPSBvYmplY3QuY3JlZGVudGlhbElkZW50aXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXZva2VkSW5zdGFsbGF0aW9uVXBkYXRlKCkge1xuICAgIHJldHVybiB7IGluc3RhbGxhdGlvbktleTogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1Jldm9rZWRJbnN0YWxsYXRpb25VcGRhdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfUmV2b2tlZEluc3RhbGxhdGlvblVwZGF0ZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbktleTogaXNTZXQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaW5zdGFsbGF0aW9uS2V5KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbGxhdGlvbktleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmluc3RhbGxhdGlvbktleVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXZva2VkSW5zdGFsbGF0aW9uVXBkYXRlKCk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ID0gKF9hID0gb2JqZWN0Lmluc3RhbGxhdGlvbktleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfVXBkYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzdGFtcE5zOiBMb25nLlVaRVJPLFxuICAgICAgICBuZXdJbnN0YWxsYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgcmV2b2tlZEluc3RhbGxhdGlvbjogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfVXBkYXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXBOcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS50aW1lc3RhbXBOcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmV3SW5zdGFsbGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX05ld0luc3RhbGxhdGlvblVwZGF0ZS5lbmNvZGUobWVzc2FnZS5uZXdJbnN0YWxsYXRpb24sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmV2b2tlZEluc3RhbGxhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXZva2VkSW5zdGFsbGF0aW9uVXBkYXRlLmVuY29kZShtZXNzYWdlLnJldm9rZWRJbnN0YWxsYXRpb24sIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9VcGRhdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE5zID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmV3SW5zdGFsbGF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX05ld0luc3RhbGxhdGlvblVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmV2b2tlZEluc3RhbGxhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXZva2VkSW5zdGFsbGF0aW9uVXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcE5zOiBpc1NldChvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICAgICAgbmV3SW5zdGFsbGF0aW9uOiBpc1NldChvYmplY3QubmV3SW5zdGFsbGF0aW9uKVxuICAgICAgICAgICAgICAgID8gR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfTmV3SW5zdGFsbGF0aW9uVXBkYXRlLmZyb21KU09OKG9iamVjdC5uZXdJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXZva2VkSW5zdGFsbGF0aW9uOiBpc1NldChvYmplY3QucmV2b2tlZEluc3RhbGxhdGlvbilcbiAgICAgICAgICAgICAgICA/IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1Jldm9rZWRJbnN0YWxsYXRpb25VcGRhdGUuZnJvbUpTT04ob2JqZWN0LnJldm9rZWRJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBOcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcE5zID0gKG1lc3NhZ2UudGltZXN0YW1wTnMgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UubmV3SW5zdGFsbGF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubmV3SW5zdGFsbGF0aW9uID0gbWVzc2FnZS5uZXdJbnN0YWxsYXRpb25cbiAgICAgICAgICAgICAgICA/IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX05ld0luc3RhbGxhdGlvblVwZGF0ZS50b0pTT04obWVzc2FnZS5uZXdJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnJldm9rZWRJbnN0YWxsYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXZva2VkSW5zdGFsbGF0aW9uID0gbWVzc2FnZS5yZXZva2VkSW5zdGFsbGF0aW9uXG4gICAgICAgICAgICAgICAgPyBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9SZXZva2VkSW5zdGFsbGF0aW9uVXBkYXRlLnRvSlNPTihtZXNzYWdlLnJldm9rZWRJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfVXBkYXRlKCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTnMgPVxuICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcE5zICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRpbWVzdGFtcE5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wTnMpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICBtZXNzYWdlLm5ld0luc3RhbGxhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QubmV3SW5zdGFsbGF0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm5ld0luc3RhbGxhdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gR2V0SWRlbnRpdHlVcGRhdGVzUmVzcG9uc2VfTmV3SW5zdGFsbGF0aW9uVXBkYXRlLmZyb21QYXJ0aWFsKG9iamVjdC5uZXdJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucmV2b2tlZEluc3RhbGxhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QucmV2b2tlZEluc3RhbGxhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJldm9rZWRJbnN0YWxsYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1Jldm9rZWRJbnN0YWxsYXRpb25VcGRhdGUuZnJvbVBhcnRpYWwob2JqZWN0LnJldm9rZWRJbnN0YWxsYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMoKSB7XG4gICAgcmV0dXJuIHsgdXBkYXRlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9XYWxsZXRVcGRhdGVzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1VwZGF0ZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1dhbGxldFVwZGF0ZXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZXMucHVzaChHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9VcGRhdGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudXBkYXRlcy5tYXAoKGUpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1VwZGF0ZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZXMpIHtcbiAgICAgICAgICAgIG9iai51cGRhdGVzID0gbWVzc2FnZS51cGRhdGVzLm1hcCgoZSkgPT4gZSA/IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1VwZGF0ZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRJZGVudGl0eVVwZGF0ZXNSZXNwb25zZV9XYWxsZXRVcGRhdGVzKCk7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnVwZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlX1VwZGF0ZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQYWdpbmdJbmZvKCkge1xuICAgIHJldHVybiB7IGRpcmVjdGlvbjogMCwgbGltaXQ6IDAsIGlkQ3Vyc29yOiBMb25nLlVaRVJPIH07XG59XG5leHBvcnQgY29uc3QgUGFnaW5nSW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS5kaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50MzIobWVzc2FnZS5saW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLmlkQ3Vyc29yLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5pZEN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYWdpbmdJbmZvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaXJlY3Rpb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbWl0ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogaXNTZXQob2JqZWN0LmRpcmVjdGlvbilcbiAgICAgICAgICAgICAgICA/IHNvcnREaXJlY3Rpb25Gcm9tSlNPTihvYmplY3QuZGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGxpbWl0OiBpc1NldChvYmplY3QubGltaXQpID8gTnVtYmVyKG9iamVjdC5saW1pdCkgOiAwLFxuICAgICAgICAgICAgaWRDdXJzb3I6IGlzU2V0KG9iamVjdC5pZEN1cnNvcilcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5pZEN1cnNvcilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kaXJlY3Rpb24gPSBzb3J0RGlyZWN0aW9uVG9KU09OKG1lc3NhZ2UuZGlyZWN0aW9uKSk7XG4gICAgICAgIG1lc3NhZ2UubGltaXQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmxpbWl0ID0gTWF0aC5yb3VuZChtZXNzYWdlLmxpbWl0KSk7XG4gICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZEN1cnNvciA9IChtZXNzYWdlLmlkQ3Vyc29yIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFnaW5nSW5mbygpO1xuICAgICAgICBtZXNzYWdlLmRpcmVjdGlvbiA9IChfYSA9IG9iamVjdC5kaXJlY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UubGltaXQgPSAoX2IgPSBvYmplY3QubGltaXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmlkQ3Vyc29yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlkQ3Vyc29yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuaWRDdXJzb3IpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VRdWVyeUdyb3VwTWVzc2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGdyb3VwSWQ6IG5ldyBVaW50OEFycmF5KCksIHBhZ2luZ0luZm86IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFF1ZXJ5R3JvdXBNZXNzYWdlc1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBJZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZ3JvdXBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQYWdpbmdJbmZvLmVuY29kZShtZXNzYWdlLnBhZ2luZ0luZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VRdWVyeUdyb3VwTWVzc2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cElkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID0gUGFnaW5nSW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cElkOiBpc1NldChvYmplY3QuZ3JvdXBJZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZ3JvdXBJZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBwYWdpbmdJbmZvOiBpc1NldChvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbUpTT04ob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZ3JvdXBJZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmdyb3VwSWQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZ3JvdXBJZCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICAgICAgICAgID8gUGFnaW5nSW5mby50b0pTT04obWVzc2FnZS5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUXVlcnlHcm91cE1lc3NhZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwSWQgPSAoX2EgPSBvYmplY3QuZ3JvdXBJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID1cbiAgICAgICAgICAgIG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVF1ZXJ5R3JvdXBNZXNzYWdlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IG1lc3NhZ2VzOiBbXSwgcGFnaW5nSW5mbzogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUXVlcnlHcm91cE1lc3NhZ2VzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIEdyb3VwTWVzc2FnZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFBhZ2luZ0luZm8uZW5jb2RlKG1lc3NhZ2UucGFnaW5nSW5mbywgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVF1ZXJ5R3JvdXBNZXNzYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKEdyb3VwTWVzc2FnZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5tZXNzYWdlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5tZXNzYWdlcy5tYXAoKGUpID0+IEdyb3VwTWVzc2FnZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgICAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21KU09OKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBvYmoubWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLm1hcCgoZSkgPT4gZSA/IEdyb3VwTWVzc2FnZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1lc3NhZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICAgICAgICAgID8gUGFnaW5nSW5mby50b0pTT04obWVzc2FnZS5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUXVlcnlHcm91cE1lc3NhZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0Lm1lc3NhZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBHcm91cE1lc3NhZ2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID1cbiAgICAgICAgICAgIG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVF1ZXJ5V2VsY29tZU1lc3NhZ2VzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBpbnN0YWxsYXRpb25LZXk6IG5ldyBVaW50OEFycmF5KCksIHBhZ2luZ0luZm86IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFF1ZXJ5V2VsY29tZU1lc3NhZ2VzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQYWdpbmdJbmZvLmVuY29kZShtZXNzYWdlLnBhZ2luZ0luZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VRdWVyeVdlbGNvbWVNZXNzYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFsbGF0aW9uS2V5OiBpc1NldChvYmplY3QuaW5zdGFsbGF0aW9uS2V5KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgICAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21KU09OKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaW5zdGFsbGF0aW9uS2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBhZ2luZ0luZm8gPSBtZXNzYWdlLnBhZ2luZ0luZm9cbiAgICAgICAgICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVF1ZXJ5V2VsY29tZU1lc3NhZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IChfYSA9IG9iamVjdC5pbnN0YWxsYXRpb25LZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9XG4gICAgICAgICAgICBvYmplY3QucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdpbmdJbmZvICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VRdWVyeVdlbGNvbWVNZXNzYWdlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IG1lc3NhZ2VzOiBbXSwgcGFnaW5nSW5mbzogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUXVlcnlXZWxjb21lTWVzc2FnZXNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICAgICAgV2VsY29tZU1lc3NhZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQYWdpbmdJbmZvLmVuY29kZShtZXNzYWdlLnBhZ2luZ0luZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VRdWVyeVdlbGNvbWVNZXNzYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKFdlbGNvbWVNZXNzYWdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1lc3NhZ2VzLm1hcCgoZSkgPT4gV2VsY29tZU1lc3NhZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHBhZ2luZ0luZm86IGlzU2V0KG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICAgICAgb2JqLm1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcy5tYXAoKGUpID0+IGUgPyBXZWxjb21lTWVzc2FnZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1lc3NhZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICAgICAgICAgID8gUGFnaW5nSW5mby50b0pTT04obWVzc2FnZS5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUXVlcnlXZWxjb21lTWVzc2FnZXNSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QubWVzc2FnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFdlbGNvbWVNZXNzYWdlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9XG4gICAgICAgICAgICBvYmplY3QucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdpbmdJbmZvICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTdWJzY3JpYmVHcm91cE1lc3NhZ2VzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBmaWx0ZXJzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIFN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maWx0ZXJzLnB1c2goU3Vic2NyaWJlR3JvdXBNZXNzYWdlc1JlcXVlc3RfRmlsdGVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWx0ZXJzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5maWx0ZXJzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmZpbHRlcnMubWFwKChlKSA9PiBTdWJzY3JpYmVHcm91cE1lc3NhZ2VzUmVxdWVzdF9GaWx0ZXIuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5maWx0ZXJzKSB7XG4gICAgICAgICAgICBvYmouZmlsdGVycyA9IG1lc3NhZ2UuZmlsdGVycy5tYXAoKGUpID0+IGUgPyBTdWJzY3JpYmVHcm91cE1lc3NhZ2VzUmVxdWVzdF9GaWx0ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5maWx0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU3Vic2NyaWJlR3JvdXBNZXNzYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5maWx0ZXJzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuZmlsdGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gU3Vic2NyaWJlR3JvdXBNZXNzYWdlc1JlcXVlc3RfRmlsdGVyLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlcigpIHtcbiAgICByZXR1cm4geyBncm91cElkOiBuZXcgVWludDhBcnJheSgpLCBpZEN1cnNvcjogTG9uZy5VWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IFN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ncm91cElkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuaWRDdXJzb3IuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLmlkQ3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBJZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlzU2V0KG9iamVjdC5ncm91cElkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ncm91cElkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGlkQ3Vyc29yOiBpc1NldChvYmplY3QuaWRDdXJzb3IpXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuaWRDdXJzb3IpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZ3JvdXBJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmdyb3VwSWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ncm91cElkICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmdyb3VwSWQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pZEN1cnNvciA9IChtZXNzYWdlLmlkQ3Vyc29yIHx8IExvbmcuVVpFUk8pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTdWJzY3JpYmVHcm91cE1lc3NhZ2VzUmVxdWVzdF9GaWx0ZXIoKTtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkID0gKF9hID0gb2JqZWN0Lmdyb3VwSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaWRDdXJzb3IgPVxuICAgICAgICAgICAgb2JqZWN0LmlkQ3Vyc29yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlkQ3Vyc29yICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuaWRDdXJzb3IpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGZpbHRlcnM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgU3Vic2NyaWJlV2VsY29tZU1lc3NhZ2VzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5maWx0ZXJzKSB7XG4gICAgICAgICAgICBTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlci5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN1YnNjcmliZVdlbGNvbWVNZXNzYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpbHRlcnMucHVzaChTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsdGVyczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuZmlsdGVycylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5maWx0ZXJzLm1hcCgoZSkgPT4gU3Vic2NyaWJlV2VsY29tZU1lc3NhZ2VzUmVxdWVzdF9GaWx0ZXIuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5maWx0ZXJzKSB7XG4gICAgICAgICAgICBvYmouZmlsdGVycyA9IG1lc3NhZ2UuZmlsdGVycy5tYXAoKGUpID0+IGUgPyBTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlci50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmZpbHRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuZmlsdGVycyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LmZpbHRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFN1YnNjcmliZVdlbGNvbWVNZXNzYWdlc1JlcXVlc3RfRmlsdGVyLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVN1YnNjcmliZVdlbGNvbWVNZXNzYWdlc1JlcXVlc3RfRmlsdGVyKCkge1xuICAgIHJldHVybiB7IGluc3RhbGxhdGlvbktleTogbmV3IFVpbnQ4QXJyYXkoKSwgaWRDdXJzb3I6IExvbmcuVVpFUk8gfTtcbn1cbmV4cG9ydCBjb25zdCBTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlLmlkQ3Vyc29yLmlzWmVybygpKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS5pZEN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXNSZXF1ZXN0X0ZpbHRlcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZEN1cnNvciA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFsbGF0aW9uS2V5OiBpc1NldChvYmplY3QuaW5zdGFsbGF0aW9uS2V5KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaWRDdXJzb3I6IGlzU2V0KG9iamVjdC5pZEN1cnNvcilcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5pZEN1cnNvcilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5pZEN1cnNvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkQ3Vyc29yID0gKG1lc3NhZ2UuaWRDdXJzb3IgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN1YnNjcmliZVdlbGNvbWVNZXNzYWdlc1JlcXVlc3RfRmlsdGVyKCk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5ID0gKF9hID0gb2JqZWN0Lmluc3RhbGxhdGlvbktleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5pZEN1cnNvciA9XG4gICAgICAgICAgICBvYmplY3QuaWRDdXJzb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaWRDdXJzb3IgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5pZEN1cnNvcilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZXhwb3J0IGNsYXNzIE1sc0FwaUNsaWVudEltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJwYykge1xuICAgICAgICB0aGlzLnJwYyA9IHJwYztcbiAgICAgICAgdGhpcy5TZW5kR3JvdXBNZXNzYWdlcyA9IHRoaXMuU2VuZEdyb3VwTWVzc2FnZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5TZW5kV2VsY29tZU1lc3NhZ2VzID0gdGhpcy5TZW5kV2VsY29tZU1lc3NhZ2VzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJJbnN0YWxsYXRpb24gPSB0aGlzLlJlZ2lzdGVySW5zdGFsbGF0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuVXBsb2FkS2V5UGFja2FnZSA9IHRoaXMuVXBsb2FkS2V5UGFja2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLkZldGNoS2V5UGFja2FnZXMgPSB0aGlzLkZldGNoS2V5UGFja2FnZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5SZXZva2VJbnN0YWxsYXRpb24gPSB0aGlzLlJldm9rZUluc3RhbGxhdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLkdldElkZW50aXR5VXBkYXRlcyA9IHRoaXMuR2V0SWRlbnRpdHlVcGRhdGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuUXVlcnlHcm91cE1lc3NhZ2VzID0gdGhpcy5RdWVyeUdyb3VwTWVzc2FnZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5RdWVyeVdlbGNvbWVNZXNzYWdlcyA9IHRoaXMuUXVlcnlXZWxjb21lTWVzc2FnZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5TdWJzY3JpYmVHcm91cE1lc3NhZ2VzID0gdGhpcy5TdWJzY3JpYmVHcm91cE1lc3NhZ2VzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuU3Vic2NyaWJlV2VsY29tZU1lc3NhZ2VzID0gdGhpcy5TdWJzY3JpYmVXZWxjb21lTWVzc2FnZXMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgU2VuZEdyb3VwTWVzc2FnZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gU2VuZEdyb3VwTWVzc2FnZXNSZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJ4bXRwLm1scy5hcGkudjEuTWxzQXBpXCIsIFwiU2VuZEdyb3VwTWVzc2FnZXNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IEVtcHR5LmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBTZW5kV2VsY29tZU1lc3NhZ2VzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFNlbmRXZWxjb21lTWVzc2FnZXNSZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJ4bXRwLm1scy5hcGkudjEuTWxzQXBpXCIsIFwiU2VuZFdlbGNvbWVNZXNzYWdlc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gRW1wdHkuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIFJlZ2lzdGVySW5zdGFsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFJlZ2lzdGVySW5zdGFsbGF0aW9uUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHMuYXBpLnYxLk1sc0FwaVwiLCBcIlJlZ2lzdGVySW5zdGFsbGF0aW9uXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBSZWdpc3Rlckluc3RhbGxhdGlvblJlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBVcGxvYWRLZXlQYWNrYWdlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFVwbG9hZEtleVBhY2thZ2VSZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJ4bXRwLm1scy5hcGkudjEuTWxzQXBpXCIsIFwiVXBsb2FkS2V5UGFja2FnZVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gRW1wdHkuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIEZldGNoS2V5UGFja2FnZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gRmV0Y2hLZXlQYWNrYWdlc1JlcXVlc3QuZW5jb2RlKHJlcXVlc3QpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ycGMucmVxdWVzdChcInhtdHAubWxzLmFwaS52MS5NbHNBcGlcIiwgXCJGZXRjaEtleVBhY2thZ2VzXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBGZXRjaEtleVBhY2thZ2VzUmVzcG9uc2UuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIFJldm9rZUluc3RhbGxhdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBSZXZva2VJbnN0YWxsYXRpb25SZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJ4bXRwLm1scy5hcGkudjEuTWxzQXBpXCIsIFwiUmV2b2tlSW5zdGFsbGF0aW9uXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBFbXB0eS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKTtcbiAgICB9XG4gICAgR2V0SWRlbnRpdHlVcGRhdGVzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEdldElkZW50aXR5VXBkYXRlc1JlcXVlc3QuZW5jb2RlKHJlcXVlc3QpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ycGMucmVxdWVzdChcInhtdHAubWxzLmFwaS52MS5NbHNBcGlcIiwgXCJHZXRJZGVudGl0eVVwZGF0ZXNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IEdldElkZW50aXR5VXBkYXRlc1Jlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBRdWVyeUdyb3VwTWVzc2FnZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gUXVlcnlHcm91cE1lc3NhZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHMuYXBpLnYxLk1sc0FwaVwiLCBcIlF1ZXJ5R3JvdXBNZXNzYWdlc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gUXVlcnlHcm91cE1lc3NhZ2VzUmVzcG9uc2UuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIFF1ZXJ5V2VsY29tZU1lc3NhZ2VzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFF1ZXJ5V2VsY29tZU1lc3NhZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHMuYXBpLnYxLk1sc0FwaVwiLCBcIlF1ZXJ5V2VsY29tZU1lc3NhZ2VzXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBRdWVyeVdlbGNvbWVNZXNzYWdlc1Jlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBTdWJzY3JpYmVHcm91cE1lc3NhZ2VzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFN1YnNjcmliZUdyb3VwTWVzc2FnZXNSZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ycGMuc2VydmVyU3RyZWFtaW5nUmVxdWVzdChcInhtdHAubWxzLmFwaS52MS5NbHNBcGlcIiwgXCJTdWJzY3JpYmVHcm91cE1lc3NhZ2VzXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnBpcGUobWFwKChkYXRhKSA9PiBHcm91cE1lc3NhZ2UuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSkpO1xuICAgIH1cbiAgICBTdWJzY3JpYmVXZWxjb21lTWVzc2FnZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gU3Vic2NyaWJlV2VsY29tZU1lc3NhZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucnBjLnNlcnZlclN0cmVhbWluZ1JlcXVlc3QoXCJ4bXRwLm1scy5hcGkudjEuTWxzQXBpXCIsIFwiU3Vic2NyaWJlV2VsY29tZU1lc3NhZ2VzXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnBpcGUobWFwKChkYXRhKSA9PiBXZWxjb21lTWVzc2FnZS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKSk7XG4gICAgfVxufVxudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWxzLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/api/v1/mls.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/database/intents.pb.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/database/intents.pb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountAddresses: () => (/* binding */ AccountAddresses),\n/* harmony export */   AddMembersData: () => (/* binding */ AddMembersData),\n/* harmony export */   AddMembersData_V1: () => (/* binding */ AddMembersData_V1),\n/* harmony export */   AddressesOrInstallationIds: () => (/* binding */ AddressesOrInstallationIds),\n/* harmony export */   AdminListUpdateType: () => (/* binding */ AdminListUpdateType),\n/* harmony export */   InstallationIds: () => (/* binding */ InstallationIds),\n/* harmony export */   PermissionPolicyOption: () => (/* binding */ PermissionPolicyOption),\n/* harmony export */   PermissionUpdateType: () => (/* binding */ PermissionUpdateType),\n/* harmony export */   PostCommitAction: () => (/* binding */ PostCommitAction),\n/* harmony export */   PostCommitAction_Installation: () => (/* binding */ PostCommitAction_Installation),\n/* harmony export */   PostCommitAction_SendWelcomes: () => (/* binding */ PostCommitAction_SendWelcomes),\n/* harmony export */   RemoveMembersData: () => (/* binding */ RemoveMembersData),\n/* harmony export */   RemoveMembersData_V1: () => (/* binding */ RemoveMembersData_V1),\n/* harmony export */   SendMessageData: () => (/* binding */ SendMessageData),\n/* harmony export */   SendMessageData_V1: () => (/* binding */ SendMessageData_V1),\n/* harmony export */   UpdateAdminListsData: () => (/* binding */ UpdateAdminListsData),\n/* harmony export */   UpdateAdminListsData_V1: () => (/* binding */ UpdateAdminListsData_V1),\n/* harmony export */   UpdateGroupMembershipData: () => (/* binding */ UpdateGroupMembershipData),\n/* harmony export */   UpdateGroupMembershipData_V1: () => (/* binding */ UpdateGroupMembershipData_V1),\n/* harmony export */   UpdateGroupMembershipData_V1_MembershipUpdatesEntry: () => (/* binding */ UpdateGroupMembershipData_V1_MembershipUpdatesEntry),\n/* harmony export */   UpdateMetadataData: () => (/* binding */ UpdateMetadataData),\n/* harmony export */   UpdateMetadataData_V1: () => (/* binding */ UpdateMetadataData_V1),\n/* harmony export */   UpdatePermissionData: () => (/* binding */ UpdatePermissionData),\n/* harmony export */   UpdatePermissionData_V1: () => (/* binding */ UpdatePermissionData_V1),\n/* harmony export */   adminListUpdateTypeFromJSON: () => (/* binding */ adminListUpdateTypeFromJSON),\n/* harmony export */   adminListUpdateTypeToJSON: () => (/* binding */ adminListUpdateTypeToJSON),\n/* harmony export */   permissionPolicyOptionFromJSON: () => (/* binding */ permissionPolicyOptionFromJSON),\n/* harmony export */   permissionPolicyOptionToJSON: () => (/* binding */ permissionPolicyOptionToJSON),\n/* harmony export */   permissionUpdateTypeFromJSON: () => (/* binding */ permissionUpdateTypeFromJSON),\n/* harmony export */   permissionUpdateTypeToJSON: () => (/* binding */ permissionUpdateTypeToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.database\";\n/** Type of update to admin lists */\nvar AdminListUpdateType;\n(function (AdminListUpdateType) {\n    AdminListUpdateType[AdminListUpdateType[\"ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED\"] = 0] = \"ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED\";\n    AdminListUpdateType[AdminListUpdateType[\"ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN\"] = 1] = \"ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN\";\n    AdminListUpdateType[AdminListUpdateType[\"ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN\"] = 2] = \"ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN\";\n    AdminListUpdateType[AdminListUpdateType[\"ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN\"] = 3] = \"ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN\";\n    AdminListUpdateType[AdminListUpdateType[\"ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN\"] = 4] = \"ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN\";\n    AdminListUpdateType[AdminListUpdateType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AdminListUpdateType || (AdminListUpdateType = {}));\nfunction adminListUpdateTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED\":\n            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED;\n        case 1:\n        case \"ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN\":\n            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN;\n        case 2:\n        case \"ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN\":\n            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN;\n        case 3:\n        case \"ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN\":\n            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN;\n        case 4:\n        case \"ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN\":\n            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return AdminListUpdateType.UNRECOGNIZED;\n    }\n}\nfunction adminListUpdateTypeToJSON(object) {\n    switch (object) {\n        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED:\n            return \"ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED\";\n        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN:\n            return \"ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN\";\n        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN:\n            return \"ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN\";\n        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN:\n            return \"ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN\";\n        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN:\n            return \"ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN\";\n        case AdminListUpdateType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** Type of Permission to Update */\nvar PermissionUpdateType;\n(function (PermissionUpdateType) {\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_UNSPECIFIED\"] = 0] = \"PERMISSION_UPDATE_TYPE_UNSPECIFIED\";\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_ADD_MEMBER\"] = 1] = \"PERMISSION_UPDATE_TYPE_ADD_MEMBER\";\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_REMOVE_MEMBER\"] = 2] = \"PERMISSION_UPDATE_TYPE_REMOVE_MEMBER\";\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_ADD_ADMIN\"] = 3] = \"PERMISSION_UPDATE_TYPE_ADD_ADMIN\";\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_REMOVE_ADMIN\"] = 4] = \"PERMISSION_UPDATE_TYPE_REMOVE_ADMIN\";\n    PermissionUpdateType[PermissionUpdateType[\"PERMISSION_UPDATE_TYPE_UPDATE_METADATA\"] = 5] = \"PERMISSION_UPDATE_TYPE_UPDATE_METADATA\";\n    PermissionUpdateType[PermissionUpdateType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PermissionUpdateType || (PermissionUpdateType = {}));\nfunction permissionUpdateTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"PERMISSION_UPDATE_TYPE_UNSPECIFIED\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_UNSPECIFIED;\n        case 1:\n        case \"PERMISSION_UPDATE_TYPE_ADD_MEMBER\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_MEMBER;\n        case 2:\n        case \"PERMISSION_UPDATE_TYPE_REMOVE_MEMBER\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_MEMBER;\n        case 3:\n        case \"PERMISSION_UPDATE_TYPE_ADD_ADMIN\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_ADMIN;\n        case 4:\n        case \"PERMISSION_UPDATE_TYPE_REMOVE_ADMIN\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_ADMIN;\n        case 5:\n        case \"PERMISSION_UPDATE_TYPE_UPDATE_METADATA\":\n            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_UPDATE_METADATA;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return PermissionUpdateType.UNRECOGNIZED;\n    }\n}\nfunction permissionUpdateTypeToJSON(object) {\n    switch (object) {\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_UNSPECIFIED:\n            return \"PERMISSION_UPDATE_TYPE_UNSPECIFIED\";\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_MEMBER:\n            return \"PERMISSION_UPDATE_TYPE_ADD_MEMBER\";\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_MEMBER:\n            return \"PERMISSION_UPDATE_TYPE_REMOVE_MEMBER\";\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_ADMIN:\n            return \"PERMISSION_UPDATE_TYPE_ADD_ADMIN\";\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_ADMIN:\n            return \"PERMISSION_UPDATE_TYPE_REMOVE_ADMIN\";\n        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_UPDATE_METADATA:\n            return \"PERMISSION_UPDATE_TYPE_UPDATE_METADATA\";\n        case PermissionUpdateType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/** Permission Policy */\nvar PermissionPolicyOption;\n(function (PermissionPolicyOption) {\n    PermissionPolicyOption[PermissionPolicyOption[\"PERMISSION_POLICY_OPTION_UNSPECIFIED\"] = 0] = \"PERMISSION_POLICY_OPTION_UNSPECIFIED\";\n    PermissionPolicyOption[PermissionPolicyOption[\"PERMISSION_POLICY_OPTION_ALLOW\"] = 1] = \"PERMISSION_POLICY_OPTION_ALLOW\";\n    PermissionPolicyOption[PermissionPolicyOption[\"PERMISSION_POLICY_OPTION_DENY\"] = 2] = \"PERMISSION_POLICY_OPTION_DENY\";\n    PermissionPolicyOption[PermissionPolicyOption[\"PERMISSION_POLICY_OPTION_ADMIN_ONLY\"] = 3] = \"PERMISSION_POLICY_OPTION_ADMIN_ONLY\";\n    PermissionPolicyOption[PermissionPolicyOption[\"PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY\"] = 4] = \"PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY\";\n    PermissionPolicyOption[PermissionPolicyOption[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PermissionPolicyOption || (PermissionPolicyOption = {}));\nfunction permissionPolicyOptionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"PERMISSION_POLICY_OPTION_UNSPECIFIED\":\n            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_UNSPECIFIED;\n        case 1:\n        case \"PERMISSION_POLICY_OPTION_ALLOW\":\n            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_ALLOW;\n        case 2:\n        case \"PERMISSION_POLICY_OPTION_DENY\":\n            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_DENY;\n        case 3:\n        case \"PERMISSION_POLICY_OPTION_ADMIN_ONLY\":\n            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_ADMIN_ONLY;\n        case 4:\n        case \"PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY\":\n            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return PermissionPolicyOption.UNRECOGNIZED;\n    }\n}\nfunction permissionPolicyOptionToJSON(object) {\n    switch (object) {\n        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_UNSPECIFIED:\n            return \"PERMISSION_POLICY_OPTION_UNSPECIFIED\";\n        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_ALLOW:\n            return \"PERMISSION_POLICY_OPTION_ALLOW\";\n        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_DENY:\n            return \"PERMISSION_POLICY_OPTION_DENY\";\n        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_ADMIN_ONLY:\n            return \"PERMISSION_POLICY_OPTION_ADMIN_ONLY\";\n        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY:\n            return \"PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY\";\n        case PermissionPolicyOption.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseSendMessageData() {\n    return { v1: undefined };\n}\nconst SendMessageData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            SendMessageData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendMessageData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = SendMessageData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? SendMessageData_V1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? SendMessageData_V1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSendMessageData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? SendMessageData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSendMessageData_V1() {\n    return { payloadBytes: new Uint8Array() };\n}\nconst SendMessageData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.payloadBytes.length !== 0) {\n            writer.uint32(10).bytes(message.payloadBytes);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendMessageData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payloadBytes = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            payloadBytes: isSet(object.payloadBytes)\n                ? bytesFromBase64(object.payloadBytes)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payloadBytes !== undefined &&\n            (obj.payloadBytes = base64FromBytes(message.payloadBytes !== undefined\n                ? message.payloadBytes\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendMessageData_V1();\n        message.payloadBytes = (_a = object.payloadBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseAccountAddresses() {\n    return { accountAddresses: [] };\n}\nconst AccountAddresses = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.accountAddresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAccountAddresses();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountAddresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            accountAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.accountAddresses)\n                ? object.accountAddresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.accountAddresses) {\n            obj.accountAddresses = message.accountAddresses.map((e) => e);\n        }\n        else {\n            obj.accountAddresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAccountAddresses();\n        message.accountAddresses = ((_a = object.accountAddresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseInstallationIds() {\n    return { installationIds: [] };\n}\nconst InstallationIds = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.installationIds) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInstallationIds();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationIds.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationIds: Array.isArray(object === null || object === void 0 ? void 0 : object.installationIds)\n                ? object.installationIds.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.installationIds) {\n            obj.installationIds = message.installationIds.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.installationIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInstallationIds();\n        message.installationIds = ((_a = object.installationIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseAddressesOrInstallationIds() {\n    return { accountAddresses: undefined, installationIds: undefined };\n}\nconst AddressesOrInstallationIds = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.accountAddresses !== undefined) {\n            AccountAddresses.encode(message.accountAddresses, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.installationIds !== undefined) {\n            InstallationIds.encode(message.installationIds, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAddressesOrInstallationIds();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountAddresses = AccountAddresses.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.installationIds = InstallationIds.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            accountAddresses: isSet(object.accountAddresses)\n                ? AccountAddresses.fromJSON(object.accountAddresses)\n                : undefined,\n            installationIds: isSet(object.installationIds)\n                ? InstallationIds.fromJSON(object.installationIds)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.accountAddresses !== undefined &&\n            (obj.accountAddresses = message.accountAddresses\n                ? AccountAddresses.toJSON(message.accountAddresses)\n                : undefined);\n        message.installationIds !== undefined &&\n            (obj.installationIds = message.installationIds\n                ? InstallationIds.toJSON(message.installationIds)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAddressesOrInstallationIds();\n        message.accountAddresses =\n            object.accountAddresses !== undefined && object.accountAddresses !== null\n                ? AccountAddresses.fromPartial(object.accountAddresses)\n                : undefined;\n        message.installationIds =\n            object.installationIds !== undefined && object.installationIds !== null\n                ? InstallationIds.fromPartial(object.installationIds)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAddMembersData() {\n    return { v1: undefined };\n}\nconst AddMembersData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            AddMembersData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAddMembersData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = AddMembersData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1) ? AddMembersData_V1.fromJSON(object.v1) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1 ? AddMembersData_V1.toJSON(message.v1) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAddMembersData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? AddMembersData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseAddMembersData_V1() {\n    return { addressesOrInstallationIds: undefined };\n}\nconst AddMembersData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.addressesOrInstallationIds !== undefined) {\n            AddressesOrInstallationIds.encode(message.addressesOrInstallationIds, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAddMembersData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.addressesOrInstallationIds =\n                        AddressesOrInstallationIds.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            addressesOrInstallationIds: isSet(object.addressesOrInstallationIds)\n                ? AddressesOrInstallationIds.fromJSON(object.addressesOrInstallationIds)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.addressesOrInstallationIds !== undefined &&\n            (obj.addressesOrInstallationIds = message.addressesOrInstallationIds\n                ? AddressesOrInstallationIds.toJSON(message.addressesOrInstallationIds)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseAddMembersData_V1();\n        message.addressesOrInstallationIds =\n            object.addressesOrInstallationIds !== undefined &&\n                object.addressesOrInstallationIds !== null\n                ? AddressesOrInstallationIds.fromPartial(object.addressesOrInstallationIds)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseRemoveMembersData() {\n    return { v1: undefined };\n}\nconst RemoveMembersData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            RemoveMembersData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRemoveMembersData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = RemoveMembersData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? RemoveMembersData_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? RemoveMembersData_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseRemoveMembersData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? RemoveMembersData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseRemoveMembersData_V1() {\n    return { addressesOrInstallationIds: undefined };\n}\nconst RemoveMembersData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.addressesOrInstallationIds !== undefined) {\n            AddressesOrInstallationIds.encode(message.addressesOrInstallationIds, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRemoveMembersData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.addressesOrInstallationIds =\n                        AddressesOrInstallationIds.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            addressesOrInstallationIds: isSet(object.addressesOrInstallationIds)\n                ? AddressesOrInstallationIds.fromJSON(object.addressesOrInstallationIds)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.addressesOrInstallationIds !== undefined &&\n            (obj.addressesOrInstallationIds = message.addressesOrInstallationIds\n                ? AddressesOrInstallationIds.toJSON(message.addressesOrInstallationIds)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseRemoveMembersData_V1();\n        message.addressesOrInstallationIds =\n            object.addressesOrInstallationIds !== undefined &&\n                object.addressesOrInstallationIds !== null\n                ? AddressesOrInstallationIds.fromPartial(object.addressesOrInstallationIds)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUpdateGroupMembershipData() {\n    return { v1: undefined };\n}\nconst UpdateGroupMembershipData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            UpdateGroupMembershipData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateGroupMembershipData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = UpdateGroupMembershipData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? UpdateGroupMembershipData_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? UpdateGroupMembershipData_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUpdateGroupMembershipData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? UpdateGroupMembershipData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUpdateGroupMembershipData_V1() {\n    return { membershipUpdates: {}, removedMembers: [] };\n}\nconst UpdateGroupMembershipData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        Object.entries(message.membershipUpdates).forEach(([key, value]) => {\n            UpdateGroupMembershipData_V1_MembershipUpdatesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        for (const v of message.removedMembers) {\n            writer.uint32(18).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateGroupMembershipData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = UpdateGroupMembershipData_V1_MembershipUpdatesEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.membershipUpdates[entry1.key] = entry1.value;\n                    }\n                    break;\n                case 2:\n                    message.removedMembers.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            membershipUpdates: isObject(object.membershipUpdates)\n                ? Object.entries(object.membershipUpdates).reduce((acc, [key, value]) => {\n                    acc[key] = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(value);\n                    return acc;\n                }, {})\n                : {},\n            removedMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.removedMembers)\n                ? object.removedMembers.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.membershipUpdates = {};\n        if (message.membershipUpdates) {\n            Object.entries(message.membershipUpdates).forEach(([k, v]) => {\n                obj.membershipUpdates[k] = v.toString();\n            });\n        }\n        if (message.removedMembers) {\n            obj.removedMembers = message.removedMembers.map((e) => e);\n        }\n        else {\n            obj.removedMembers = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseUpdateGroupMembershipData_V1();\n        message.membershipUpdates = Object.entries((_a = object.membershipUpdates) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(value);\n            }\n            return acc;\n        }, {});\n        message.removedMembers = ((_b = object.removedMembers) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry() {\n    return { key: \"\", value: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst UpdateGroupMembershipData_V1_MembershipUpdatesEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (!message.value.isZero()) {\n            writer.uint32(16).uint64(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.value) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = (message.value || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.value)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseUpdateMetadataData() {\n    return { v1: undefined };\n}\nconst UpdateMetadataData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            UpdateMetadataData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateMetadataData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = UpdateMetadataData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? UpdateMetadataData_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? UpdateMetadataData_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUpdateMetadataData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? UpdateMetadataData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUpdateMetadataData_V1() {\n    return { fieldName: \"\", fieldValue: \"\" };\n}\nconst UpdateMetadataData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.fieldName !== \"\") {\n            writer.uint32(10).string(message.fieldName);\n        }\n        if (message.fieldValue !== \"\") {\n            writer.uint32(18).string(message.fieldValue);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateMetadataData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fieldName = reader.string();\n                    break;\n                case 2:\n                    message.fieldValue = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            fieldName: isSet(object.fieldName) ? String(object.fieldName) : \"\",\n            fieldValue: isSet(object.fieldValue) ? String(object.fieldValue) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.fieldName !== undefined && (obj.fieldName = message.fieldName);\n        message.fieldValue !== undefined && (obj.fieldValue = message.fieldValue);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseUpdateMetadataData_V1();\n        message.fieldName = (_a = object.fieldName) !== null && _a !== void 0 ? _a : \"\";\n        message.fieldValue = (_b = object.fieldValue) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseUpdateAdminListsData() {\n    return { v1: undefined };\n}\nconst UpdateAdminListsData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            UpdateAdminListsData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateAdminListsData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = UpdateAdminListsData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? UpdateAdminListsData_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? UpdateAdminListsData_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUpdateAdminListsData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? UpdateAdminListsData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUpdateAdminListsData_V1() {\n    return { adminListUpdateType: 0, inboxId: \"\" };\n}\nconst UpdateAdminListsData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.adminListUpdateType !== 0) {\n            writer.uint32(8).int32(message.adminListUpdateType);\n        }\n        if (message.inboxId !== \"\") {\n            writer.uint32(18).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateAdminListsData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.adminListUpdateType = reader.int32();\n                    break;\n                case 2:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            adminListUpdateType: isSet(object.adminListUpdateType)\n                ? adminListUpdateTypeFromJSON(object.adminListUpdateType)\n                : 0,\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.adminListUpdateType !== undefined &&\n            (obj.adminListUpdateType = adminListUpdateTypeToJSON(message.adminListUpdateType));\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseUpdateAdminListsData_V1();\n        message.adminListUpdateType = (_a = object.adminListUpdateType) !== null && _a !== void 0 ? _a : 0;\n        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseUpdatePermissionData() {\n    return { v1: undefined };\n}\nconst UpdatePermissionData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            UpdatePermissionData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdatePermissionData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = UpdatePermissionData_V1.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? UpdatePermissionData_V1.fromJSON(object.v1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? UpdatePermissionData_V1.toJSON(message.v1)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseUpdatePermissionData();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? UpdatePermissionData_V1.fromPartial(object.v1)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUpdatePermissionData_V1() {\n    return {\n        permissionUpdateType: 0,\n        permissionPolicyOption: 0,\n        metadataFieldName: undefined,\n    };\n}\nconst UpdatePermissionData_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.permissionUpdateType !== 0) {\n            writer.uint32(8).int32(message.permissionUpdateType);\n        }\n        if (message.permissionPolicyOption !== 0) {\n            writer.uint32(16).int32(message.permissionPolicyOption);\n        }\n        if (message.metadataFieldName !== undefined) {\n            writer.uint32(26).string(message.metadataFieldName);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdatePermissionData_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.permissionUpdateType = reader.int32();\n                    break;\n                case 2:\n                    message.permissionPolicyOption = reader.int32();\n                    break;\n                case 3:\n                    message.metadataFieldName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            permissionUpdateType: isSet(object.permissionUpdateType)\n                ? permissionUpdateTypeFromJSON(object.permissionUpdateType)\n                : 0,\n            permissionPolicyOption: isSet(object.permissionPolicyOption)\n                ? permissionPolicyOptionFromJSON(object.permissionPolicyOption)\n                : 0,\n            metadataFieldName: isSet(object.metadataFieldName)\n                ? String(object.metadataFieldName)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.permissionUpdateType !== undefined &&\n            (obj.permissionUpdateType = permissionUpdateTypeToJSON(message.permissionUpdateType));\n        message.permissionPolicyOption !== undefined &&\n            (obj.permissionPolicyOption = permissionPolicyOptionToJSON(message.permissionPolicyOption));\n        message.metadataFieldName !== undefined &&\n            (obj.metadataFieldName = message.metadataFieldName);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseUpdatePermissionData_V1();\n        message.permissionUpdateType = (_a = object.permissionUpdateType) !== null && _a !== void 0 ? _a : 0;\n        message.permissionPolicyOption = (_b = object.permissionPolicyOption) !== null && _b !== void 0 ? _b : 0;\n        message.metadataFieldName = (_c = object.metadataFieldName) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBasePostCommitAction() {\n    return { sendWelcomes: undefined };\n}\nconst PostCommitAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.sendWelcomes !== undefined) {\n            PostCommitAction_SendWelcomes.encode(message.sendWelcomes, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePostCommitAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sendWelcomes = PostCommitAction_SendWelcomes.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sendWelcomes: isSet(object.sendWelcomes)\n                ? PostCommitAction_SendWelcomes.fromJSON(object.sendWelcomes)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sendWelcomes !== undefined &&\n            (obj.sendWelcomes = message.sendWelcomes\n                ? PostCommitAction_SendWelcomes.toJSON(message.sendWelcomes)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePostCommitAction();\n        message.sendWelcomes =\n            object.sendWelcomes !== undefined && object.sendWelcomes !== null\n                ? PostCommitAction_SendWelcomes.fromPartial(object.sendWelcomes)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePostCommitAction_Installation() {\n    return { installationKey: new Uint8Array(), hpkePublicKey: new Uint8Array() };\n}\nconst PostCommitAction_Installation = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.installationKey.length !== 0) {\n            writer.uint32(10).bytes(message.installationKey);\n        }\n        if (message.hpkePublicKey.length !== 0) {\n            writer.uint32(18).bytes(message.hpkePublicKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePostCommitAction_Installation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationKey = reader.bytes();\n                    break;\n                case 2:\n                    message.hpkePublicKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationKey: isSet(object.installationKey)\n                ? bytesFromBase64(object.installationKey)\n                : new Uint8Array(),\n            hpkePublicKey: isSet(object.hpkePublicKey)\n                ? bytesFromBase64(object.hpkePublicKey)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.installationKey !== undefined &&\n            (obj.installationKey = base64FromBytes(message.installationKey !== undefined\n                ? message.installationKey\n                : new Uint8Array()));\n        message.hpkePublicKey !== undefined &&\n            (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined\n                ? message.hpkePublicKey\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePostCommitAction_Installation();\n        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.hpkePublicKey = (_b = object.hpkePublicKey) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePostCommitAction_SendWelcomes() {\n    return { installations: [], welcomeMessage: new Uint8Array() };\n}\nconst PostCommitAction_SendWelcomes = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.installations) {\n            PostCommitAction_Installation.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.welcomeMessage.length !== 0) {\n            writer.uint32(18).bytes(message.welcomeMessage);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePostCommitAction_SendWelcomes();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installations.push(PostCommitAction_Installation.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.welcomeMessage = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installations: Array.isArray(object === null || object === void 0 ? void 0 : object.installations)\n                ? object.installations.map((e) => PostCommitAction_Installation.fromJSON(e))\n                : [],\n            welcomeMessage: isSet(object.welcomeMessage)\n                ? bytesFromBase64(object.welcomeMessage)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.installations) {\n            obj.installations = message.installations.map((e) => e ? PostCommitAction_Installation.toJSON(e) : undefined);\n        }\n        else {\n            obj.installations = [];\n        }\n        message.welcomeMessage !== undefined &&\n            (obj.welcomeMessage = base64FromBytes(message.welcomeMessage !== undefined\n                ? message.welcomeMessage\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePostCommitAction_SendWelcomes();\n        message.installations =\n            ((_a = object.installations) === null || _a === void 0 ? void 0 : _a.map((e) => PostCommitAction_Installation.fromPartial(e))) || [];\n        message.welcomeMessage = (_b = object.welcomeMessage) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=intents.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL2RhdGFiYXNlL2ludGVudHMucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2E7QUFDOUI7QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUM1QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0Q7QUFDbEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVEsVUFBVSw0Q0FBSTtBQUMxQixJQUFJLGdFQUFRLFFBQVEsNENBQUk7QUFDeEIsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL2RhdGFiYXNlL2ludGVudHMucGIuanM/ODJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tbHMuZGF0YWJhc2VcIjtcbi8qKiBUeXBlIG9mIHVwZGF0ZSB0byBhZG1pbiBsaXN0cyAqL1xuZXhwb3J0IHZhciBBZG1pbkxpc3RVcGRhdGVUeXBlO1xuKGZ1bmN0aW9uIChBZG1pbkxpc3RVcGRhdGVUeXBlKSB7XG4gICAgQWRtaW5MaXN0VXBkYXRlVHlwZVtBZG1pbkxpc3RVcGRhdGVUeXBlW1wiQURNSU5fTElTVF9VUERBVEVfVFlQRV9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgQWRtaW5MaXN0VXBkYXRlVHlwZVtBZG1pbkxpc3RVcGRhdGVUeXBlW1wiQURNSU5fTElTVF9VUERBVEVfVFlQRV9BRERfQURNSU5cIl0gPSAxXSA9IFwiQURNSU5fTElTVF9VUERBVEVfVFlQRV9BRERfQURNSU5cIjtcbiAgICBBZG1pbkxpc3RVcGRhdGVUeXBlW0FkbWluTGlzdFVwZGF0ZVR5cGVbXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiXSA9IDJdID0gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiO1xuICAgIEFkbWluTGlzdFVwZGF0ZVR5cGVbQWRtaW5MaXN0VXBkYXRlVHlwZVtcIkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfQUREX1NVUEVSX0FETUlOXCJdID0gM10gPSBcIkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfQUREX1NVUEVSX0FETUlOXCI7XG4gICAgQWRtaW5MaXN0VXBkYXRlVHlwZVtBZG1pbkxpc3RVcGRhdGVUeXBlW1wiQURNSU5fTElTVF9VUERBVEVfVFlQRV9SRU1PVkVfU1VQRVJfQURNSU5cIl0gPSA0XSA9IFwiQURNSU5fTElTVF9VUERBVEVfVFlQRV9SRU1PVkVfU1VQRVJfQURNSU5cIjtcbiAgICBBZG1pbkxpc3RVcGRhdGVUeXBlW0FkbWluTGlzdFVwZGF0ZVR5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQWRtaW5MaXN0VXBkYXRlVHlwZSB8fCAoQWRtaW5MaXN0VXBkYXRlVHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gYWRtaW5MaXN0VXBkYXRlVHlwZUZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBBZG1pbkxpc3RVcGRhdGVUeXBlLkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfQUREX0FETUlOXCI6XG4gICAgICAgICAgICByZXR1cm4gQWRtaW5MaXN0VXBkYXRlVHlwZS5BRE1JTl9MSVNUX1VQREFURV9UWVBFX0FERF9BRE1JTjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiQURNSU5fTElTVF9VUERBVEVfVFlQRV9SRU1PVkVfQURNSU5cIjpcbiAgICAgICAgICAgIHJldHVybiBBZG1pbkxpc3RVcGRhdGVUeXBlLkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfUkVNT1ZFX0FETUlOO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX0FERF9TVVBFUl9BRE1JTlwiOlxuICAgICAgICAgICAgcmV0dXJuIEFkbWluTGlzdFVwZGF0ZVR5cGUuQURNSU5fTElTVF9VUERBVEVfVFlQRV9BRERfU1VQRVJfQURNSU47XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSBcIkFETUlOX0xJU1RfVVBEQVRFX1RZUEVfUkVNT1ZFX1NVUEVSX0FETUlOXCI6XG4gICAgICAgICAgICByZXR1cm4gQWRtaW5MaXN0VXBkYXRlVHlwZS5BRE1JTl9MSVNUX1VQREFURV9UWVBFX1JFTU9WRV9TVVBFUl9BRE1JTjtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEFkbWluTGlzdFVwZGF0ZVR5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZG1pbkxpc3RVcGRhdGVUeXBlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQWRtaW5MaXN0VXBkYXRlVHlwZS5BRE1JTl9MSVNUX1VQREFURV9UWVBFX1VOU1BFQ0lGSUVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiQURNSU5fTElTVF9VUERBVEVfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIEFkbWluTGlzdFVwZGF0ZVR5cGUuQURNSU5fTElTVF9VUERBVEVfVFlQRV9BRERfQURNSU46XG4gICAgICAgICAgICByZXR1cm4gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX0FERF9BRE1JTlwiO1xuICAgICAgICBjYXNlIEFkbWluTGlzdFVwZGF0ZVR5cGUuQURNSU5fTElTVF9VUERBVEVfVFlQRV9SRU1PVkVfQURNSU46XG4gICAgICAgICAgICByZXR1cm4gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiO1xuICAgICAgICBjYXNlIEFkbWluTGlzdFVwZGF0ZVR5cGUuQURNSU5fTElTVF9VUERBVEVfVFlQRV9BRERfU1VQRVJfQURNSU46XG4gICAgICAgICAgICByZXR1cm4gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX0FERF9TVVBFUl9BRE1JTlwiO1xuICAgICAgICBjYXNlIEFkbWluTGlzdFVwZGF0ZVR5cGUuQURNSU5fTElTVF9VUERBVEVfVFlQRV9SRU1PVkVfU1VQRVJfQURNSU46XG4gICAgICAgICAgICByZXR1cm4gXCJBRE1JTl9MSVNUX1VQREFURV9UWVBFX1JFTU9WRV9TVVBFUl9BRE1JTlwiO1xuICAgICAgICBjYXNlIEFkbWluTGlzdFVwZGF0ZVR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuLyoqIFR5cGUgb2YgUGVybWlzc2lvbiB0byBVcGRhdGUgKi9cbmV4cG9ydCB2YXIgUGVybWlzc2lvblVwZGF0ZVR5cGU7XG4oZnVuY3Rpb24gKFBlcm1pc3Npb25VcGRhdGVUeXBlKSB7XG4gICAgUGVybWlzc2lvblVwZGF0ZVR5cGVbUGVybWlzc2lvblVwZGF0ZVR5cGVbXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICBQZXJtaXNzaW9uVXBkYXRlVHlwZVtQZXJtaXNzaW9uVXBkYXRlVHlwZVtcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX01FTUJFUlwiXSA9IDFdID0gXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX0FERF9NRU1CRVJcIjtcbiAgICBQZXJtaXNzaW9uVXBkYXRlVHlwZVtQZXJtaXNzaW9uVXBkYXRlVHlwZVtcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfUkVNT1ZFX01FTUJFUlwiXSA9IDJdID0gXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1JFTU9WRV9NRU1CRVJcIjtcbiAgICBQZXJtaXNzaW9uVXBkYXRlVHlwZVtQZXJtaXNzaW9uVXBkYXRlVHlwZVtcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX0FETUlOXCJdID0gM10gPSBcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX0FETUlOXCI7XG4gICAgUGVybWlzc2lvblVwZGF0ZVR5cGVbUGVybWlzc2lvblVwZGF0ZVR5cGVbXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiXSA9IDRdID0gXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiO1xuICAgIFBlcm1pc3Npb25VcGRhdGVUeXBlW1Blcm1pc3Npb25VcGRhdGVUeXBlW1wiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9VUERBVEVfTUVUQURBVEFcIl0gPSA1XSA9IFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9VUERBVEVfTUVUQURBVEFcIjtcbiAgICBQZXJtaXNzaW9uVXBkYXRlVHlwZVtQZXJtaXNzaW9uVXBkYXRlVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShQZXJtaXNzaW9uVXBkYXRlVHlwZSB8fCAoUGVybWlzc2lvblVwZGF0ZVR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIHBlcm1pc3Npb25VcGRhdGVUeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX01FTUJFUlwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX01FTUJFUjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9SRU1PVkVfTUVNQkVSXCI6XG4gICAgICAgICAgICByZXR1cm4gUGVybWlzc2lvblVwZGF0ZVR5cGUuUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9SRU1PVkVfTUVNQkVSO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX0FERF9BRE1JTlwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfQUREX0FETUlOO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1JFTU9WRV9BRE1JTlwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfUkVNT1ZFX0FETUlOO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1VQREFURV9NRVRBREFUQVwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfVVBEQVRFX01FVEFEQVRBO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUGVybWlzc2lvblVwZGF0ZVR5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJtaXNzaW9uVXBkYXRlVHlwZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblVwZGF0ZVR5cGUuUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9BRERfTUVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9BRERfTUVNQkVSXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblVwZGF0ZVR5cGUuUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9SRU1PVkVfTUVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9SRU1PVkVfTUVNQkVSXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblVwZGF0ZVR5cGUuUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9BRERfQURNSU46XG4gICAgICAgICAgICByZXR1cm4gXCJQRVJNSVNTSU9OX1VQREFURV9UWVBFX0FERF9BRE1JTlwiO1xuICAgICAgICBjYXNlIFBlcm1pc3Npb25VcGRhdGVUeXBlLlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfUkVNT1ZFX0FETUlOOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEVSTUlTU0lPTl9VUERBVEVfVFlQRV9SRU1PVkVfQURNSU5cIjtcbiAgICAgICAgY2FzZSBQZXJtaXNzaW9uVXBkYXRlVHlwZS5QRVJNSVNTSU9OX1VQREFURV9UWVBFX1VQREFURV9NRVRBREFUQTpcbiAgICAgICAgICAgIHJldHVybiBcIlBFUk1JU1NJT05fVVBEQVRFX1RZUEVfVVBEQVRFX01FVEFEQVRBXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblVwZGF0ZVR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuLyoqIFBlcm1pc3Npb24gUG9saWN5ICovXG5leHBvcnQgdmFyIFBlcm1pc3Npb25Qb2xpY3lPcHRpb247XG4oZnVuY3Rpb24gKFBlcm1pc3Npb25Qb2xpY3lPcHRpb24pIHtcbiAgICBQZXJtaXNzaW9uUG9saWN5T3B0aW9uW1Blcm1pc3Npb25Qb2xpY3lPcHRpb25bXCJQRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgUGVybWlzc2lvblBvbGljeU9wdGlvbltQZXJtaXNzaW9uUG9saWN5T3B0aW9uW1wiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FMTE9XXCJdID0gMV0gPSBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9BTExPV1wiO1xuICAgIFBlcm1pc3Npb25Qb2xpY3lPcHRpb25bUGVybWlzc2lvblBvbGljeU9wdGlvbltcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9ERU5ZXCJdID0gMl0gPSBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9ERU5ZXCI7XG4gICAgUGVybWlzc2lvblBvbGljeU9wdGlvbltQZXJtaXNzaW9uUG9saWN5T3B0aW9uW1wiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FETUlOX09OTFlcIl0gPSAzXSA9IFwiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FETUlOX09OTFlcIjtcbiAgICBQZXJtaXNzaW9uUG9saWN5T3B0aW9uW1Blcm1pc3Npb25Qb2xpY3lPcHRpb25bXCJQRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fU1VQRVJfQURNSU5fT05MWVwiXSA9IDRdID0gXCJQRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fU1VQRVJfQURNSU5fT05MWVwiO1xuICAgIFBlcm1pc3Npb25Qb2xpY3lPcHRpb25bUGVybWlzc2lvblBvbGljeU9wdGlvbltcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShQZXJtaXNzaW9uUG9saWN5T3B0aW9uIHx8IChQZXJtaXNzaW9uUG9saWN5T3B0aW9uID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBwZXJtaXNzaW9uUG9saWN5T3B0aW9uRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gUGVybWlzc2lvblBvbGljeU9wdGlvbi5QRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9BTExPV1wiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25Qb2xpY3lPcHRpb24uUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FMTE9XO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJQRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fREVOWVwiOlxuICAgICAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25Qb2xpY3lPcHRpb24uUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0RFTlk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9BRE1JTl9PTkxZXCI6XG4gICAgICAgICAgICByZXR1cm4gUGVybWlzc2lvblBvbGljeU9wdGlvbi5QRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fQURNSU5fT05MWTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIFwiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX1NVUEVSX0FETUlOX09OTFlcIjpcbiAgICAgICAgICAgIHJldHVybiBQZXJtaXNzaW9uUG9saWN5T3B0aW9uLlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9TVVBFUl9BRE1JTl9PTkxZO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUGVybWlzc2lvblBvbGljeU9wdGlvbi5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBlcm1pc3Npb25Qb2xpY3lPcHRpb25Ub0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBQZXJtaXNzaW9uUG9saWN5T3B0aW9uLlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIFBlcm1pc3Npb25Qb2xpY3lPcHRpb24uUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FMTE9XOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEVSTUlTU0lPTl9QT0xJQ1lfT1BUSU9OX0FMTE9XXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblBvbGljeU9wdGlvbi5QRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fREVOWTpcbiAgICAgICAgICAgIHJldHVybiBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9ERU5ZXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblBvbGljeU9wdGlvbi5QRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fQURNSU5fT05MWTpcbiAgICAgICAgICAgIHJldHVybiBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9BRE1JTl9PTkxZXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblBvbGljeU9wdGlvbi5QRVJNSVNTSU9OX1BPTElDWV9PUFRJT05fU1VQRVJfQURNSU5fT05MWTpcbiAgICAgICAgICAgIHJldHVybiBcIlBFUk1JU1NJT05fUE9MSUNZX09QVElPTl9TVVBFUl9BRE1JTl9PTkxZXCI7XG4gICAgICAgIGNhc2UgUGVybWlzc2lvblBvbGljeU9wdGlvbi5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTlJFQ09HTklaRURcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VuZE1lc3NhZ2VEYXRhKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBTZW5kTWVzc2FnZURhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgU2VuZE1lc3NhZ2VEYXRhX1YxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZE1lc3NhZ2VEYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFNlbmRNZXNzYWdlRGF0YV9WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKSA/IFNlbmRNZXNzYWdlRGF0YV9WMS5mcm9tSlNPTihvYmplY3QudjEpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjEgPyBTZW5kTWVzc2FnZURhdGFfVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNlbmRNZXNzYWdlRGF0YSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU2VuZE1lc3NhZ2VEYXRhX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VuZE1lc3NhZ2VEYXRhX1YxKCkge1xuICAgIHJldHVybiB7IHBheWxvYWRCeXRlczogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0IGNvbnN0IFNlbmRNZXNzYWdlRGF0YV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnBheWxvYWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZW5kTWVzc2FnZURhdGFfVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWRCeXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkQnl0ZXM6IGlzU2V0KG9iamVjdC5wYXlsb2FkQnl0ZXMpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWRCeXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wYXlsb2FkQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5wYXlsb2FkQnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZE1lc3NhZ2VEYXRhX1YxKCk7XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZEJ5dGVzID0gKF9hID0gb2JqZWN0LnBheWxvYWRCeXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQWNjb3VudEFkZHJlc3NlcygpIHtcbiAgICByZXR1cm4geyBhY2NvdW50QWRkcmVzc2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEFjY291bnRBZGRyZXNzZXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWNjb3VudEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQWNjb3VudEFkZHJlc3NlcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWNjb3VudEFkZHJlc3Nlcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRBZGRyZXNzZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFjY291bnRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuYWNjb3VudEFkZHJlc3Nlcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIG9iai5hY2NvdW50QWRkcmVzc2VzID0gbWVzc2FnZS5hY2NvdW50QWRkcmVzc2VzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouYWNjb3VudEFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFjY291bnRBZGRyZXNzZXMoKTtcbiAgICAgICAgbWVzc2FnZS5hY2NvdW50QWRkcmVzc2VzID0gKChfYSA9IG9iamVjdC5hY2NvdW50QWRkcmVzc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUluc3RhbGxhdGlvbklkcygpIHtcbiAgICByZXR1cm4geyBpbnN0YWxsYXRpb25JZHM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgSW5zdGFsbGF0aW9uSWRzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmluc3RhbGxhdGlvbklkcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnN0YWxsYXRpb25JZHMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSWRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbnN0YWxsYXRpb25JZHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuaW5zdGFsbGF0aW9uSWRzLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRzKSB7XG4gICAgICAgICAgICBvYmouaW5zdGFsbGF0aW9uSWRzID0gbWVzc2FnZS5pbnN0YWxsYXRpb25JZHMubWFwKChlKSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbnN0YWxsYXRpb25JZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbnN0YWxsYXRpb25JZHMoKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25JZHMgPSAoKF9hID0gb2JqZWN0Lmluc3RhbGxhdGlvbklkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcygpIHtcbiAgICByZXR1cm4geyBhY2NvdW50QWRkcmVzc2VzOiB1bmRlZmluZWQsIGluc3RhbGxhdGlvbklkczogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgQWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWNjb3VudEFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBBY2NvdW50QWRkcmVzc2VzLmVuY29kZShtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEluc3RhbGxhdGlvbklkcy5lbmNvZGUobWVzc2FnZS5pbnN0YWxsYXRpb25JZHMsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWNjb3VudEFkZHJlc3NlcyA9IEFjY291bnRBZGRyZXNzZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcyA9IEluc3RhbGxhdGlvbklkcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50QWRkcmVzc2VzOiBpc1NldChvYmplY3QuYWNjb3VudEFkZHJlc3NlcylcbiAgICAgICAgICAgICAgICA/IEFjY291bnRBZGRyZXNzZXMuZnJvbUpTT04ob2JqZWN0LmFjY291bnRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25JZHM6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25JZHMpXG4gICAgICAgICAgICAgICAgPyBJbnN0YWxsYXRpb25JZHMuZnJvbUpTT04ob2JqZWN0Lmluc3RhbGxhdGlvbklkcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hY2NvdW50QWRkcmVzc2VzID0gbWVzc2FnZS5hY2NvdW50QWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgPyBBY2NvdW50QWRkcmVzc2VzLnRvSlNPTihtZXNzYWdlLmFjY291bnRBZGRyZXNzZXMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbGxhdGlvbklkcyA9IG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRzXG4gICAgICAgICAgICAgICAgPyBJbnN0YWxsYXRpb25JZHMudG9KU09OKG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzKCk7XG4gICAgICAgIG1lc3NhZ2UuYWNjb3VudEFkZHJlc3NlcyA9XG4gICAgICAgICAgICBvYmplY3QuYWNjb3VudEFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hY2NvdW50QWRkcmVzc2VzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBBY2NvdW50QWRkcmVzc2VzLmZyb21QYXJ0aWFsKG9iamVjdC5hY2NvdW50QWRkcmVzc2VzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcyA9XG4gICAgICAgICAgICBvYmplY3QuaW5zdGFsbGF0aW9uSWRzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmluc3RhbGxhdGlvbklkcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSW5zdGFsbGF0aW9uSWRzLmZyb21QYXJ0aWFsKG9iamVjdC5pbnN0YWxsYXRpb25JZHMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBBZGRNZW1iZXJzRGF0YSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBBZGRNZW1iZXJzRGF0YV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IEFkZE1lbWJlcnNEYXRhX1YxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpID8gQWRkTWVtYmVyc0RhdGFfVjEuZnJvbUpTT04ob2JqZWN0LnYxKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxID8gQWRkTWVtYmVyc0RhdGFfVjEudG9KU09OKG1lc3NhZ2UudjEpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBBZGRNZW1iZXJzRGF0YV9WMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhX1YxKCkge1xuICAgIHJldHVybiB7IGFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBBZGRNZW1iZXJzRGF0YV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcy5lbmNvZGUobWVzc2FnZS5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcywgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhX1YxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzZXNPckluc3RhbGxhdGlvbklkczogaXNTZXQob2JqZWN0LmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzKVxuICAgICAgICAgICAgICAgID8gQWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMuZnJvbUpTT04ob2JqZWN0LmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcyA9IG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHNcbiAgICAgICAgICAgICAgICA/IEFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzLnRvSlNPTihtZXNzYWdlLmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFkZE1lbWJlcnNEYXRhX1YxKCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgPVxuICAgICAgICAgICAgb2JqZWN0LmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzLmZyb21QYXJ0aWFsKG9iamVjdC5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVtb3ZlTWVtYmVyc0RhdGEoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFJlbW92ZU1lbWJlcnNEYXRhID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFJlbW92ZU1lbWJlcnNEYXRhX1YxLmVuY29kZShtZXNzYWdlLnYxLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVtb3ZlTWVtYmVyc0RhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gUmVtb3ZlTWVtYmVyc0RhdGFfVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA/IFJlbW92ZU1lbWJlcnNEYXRhX1YxLmZyb21KU09OKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudjEgPSBtZXNzYWdlLnYxXG4gICAgICAgICAgICAgICAgPyBSZW1vdmVNZW1iZXJzRGF0YV9WMS50b0pTT04obWVzc2FnZS52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZW1vdmVNZW1iZXJzRGF0YSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUmVtb3ZlTWVtYmVyc0RhdGFfVjEuZnJvbVBhcnRpYWwob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VSZW1vdmVNZW1iZXJzRGF0YV9WMSgpIHtcbiAgICByZXR1cm4geyBhZGRyZXNzZXNPckluc3RhbGxhdGlvbklkczogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUmVtb3ZlTWVtYmVyc0RhdGFfVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMuZW5jb2RlKG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZW1vdmVNZW1iZXJzRGF0YV9WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgQWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHM6IGlzU2V0KG9iamVjdC5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcylcbiAgICAgICAgICAgICAgICA/IEFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzLmZyb21KU09OKG9iamVjdC5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMgPSBtZXNzYWdlLmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzXG4gICAgICAgICAgICAgICAgPyBBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcy50b0pTT04obWVzc2FnZS5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZW1vdmVNZW1iZXJzRGF0YV9WMSgpO1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzID1cbiAgICAgICAgICAgIG9iamVjdC5hZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmFkZHJlc3Nlc09ySW5zdGFsbGF0aW9uSWRzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBBZGRyZXNzZXNPckluc3RhbGxhdGlvbklkcy5mcm9tUGFydGlhbChvYmplY3QuYWRkcmVzc2VzT3JJbnN0YWxsYXRpb25JZHMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGEoKSB7XG4gICAgcmV0dXJuIHsgdjE6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IFVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnYxID0gVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgID8gVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MVxuICAgICAgICAgICAgICAgID8gVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMS50b0pTT04obWVzc2FnZS52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVHcm91cE1lbWJlcnNoaXBEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBVcGRhdGVHcm91cE1lbWJlcnNoaXBEYXRhX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMSgpIHtcbiAgICByZXR1cm4geyBtZW1iZXJzaGlwVXBkYXRlczoge30sIHJlbW92ZWRNZW1iZXJzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGFfVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5tZW1iZXJzaGlwVXBkYXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBVcGRhdGVHcm91cE1lbWJlcnNoaXBEYXRhX1YxX01lbWJlcnNoaXBVcGRhdGVzRW50cnkuZW5jb2RlKHsga2V5OiBrZXksIHZhbHVlIH0sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZW1vdmVkTWVtYmVycykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MSA9IFVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGFfVjFfTWVtYmVyc2hpcFVwZGF0ZXNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkxLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVtYmVyc2hpcFVwZGF0ZXNbZW50cnkxLmtleV0gPSBlbnRyeTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlbW92ZWRNZW1iZXJzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVtYmVyc2hpcFVwZGF0ZXM6IGlzT2JqZWN0KG9iamVjdC5tZW1iZXJzaGlwVXBkYXRlcylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5tZW1iZXJzaGlwVXBkYXRlcykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IExvbmcuZnJvbVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgcmVtb3ZlZE1lbWJlcnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlbW92ZWRNZW1iZXJzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlbW92ZWRNZW1iZXJzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLm1lbWJlcnNoaXBVcGRhdGVzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm1lbWJlcnNoaXBVcGRhdGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLm1lbWJlcnNoaXBVcGRhdGVzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBvYmoubWVtYmVyc2hpcFVwZGF0ZXNba10gPSB2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZW1vdmVkTWVtYmVycykge1xuICAgICAgICAgICAgb2JqLnJlbW92ZWRNZW1iZXJzID0gbWVzc2FnZS5yZW1vdmVkTWVtYmVycy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlbW92ZWRNZW1iZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGFfVjEoKTtcbiAgICAgICAgbWVzc2FnZS5tZW1iZXJzaGlwVXBkYXRlcyA9IE9iamVjdC5lbnRyaWVzKChfYSA9IG9iamVjdC5tZW1iZXJzaGlwVXBkYXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBMb25nLmZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIG1lc3NhZ2UucmVtb3ZlZE1lbWJlcnMgPSAoKF9iID0gb2JqZWN0LnJlbW92ZWRNZW1iZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGFfVjFfTWVtYmVyc2hpcFVwZGF0ZXNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6IFwiXCIsIHZhbHVlOiBMb25nLlVaRVJPIH07XG59XG5leHBvcnQgY29uc3QgVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMV9NZW1iZXJzaGlwVXBkYXRlc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UudmFsdWUuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZUdyb3VwTWVtYmVyc2hpcERhdGFfVjFfTWVtYmVyc2hpcFVwZGF0ZXNFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudmFsdWUpIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsdWUgPSAobWVzc2FnZS52YWx1ZSB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXBkYXRlR3JvdXBNZW1iZXJzaGlwRGF0YV9WMV9NZW1iZXJzaGlwVXBkYXRlc0VudHJ5KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gKF9hID0gb2JqZWN0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZGF0ZU1ldGFkYXRhRGF0YSgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgVXBkYXRlTWV0YWRhdGFEYXRhID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnYxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFVwZGF0ZU1ldGFkYXRhRGF0YV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZU1ldGFkYXRhRGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBVcGRhdGVNZXRhZGF0YURhdGFfVjEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjE6IGlzU2V0KG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA/IFVwZGF0ZU1ldGFkYXRhRGF0YV9WMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MVxuICAgICAgICAgICAgICAgID8gVXBkYXRlTWV0YWRhdGFEYXRhX1YxLnRvSlNPTihtZXNzYWdlLnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZU1ldGFkYXRhRGF0YSgpO1xuICAgICAgICBtZXNzYWdlLnYxID1cbiAgICAgICAgICAgIG9iamVjdC52MSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52MSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gVXBkYXRlTWV0YWRhdGFEYXRhX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVXBkYXRlTWV0YWRhdGFEYXRhX1YxKCkge1xuICAgIHJldHVybiB7IGZpZWxkTmFtZTogXCJcIiwgZmllbGRWYWx1ZTogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IFVwZGF0ZU1ldGFkYXRhRGF0YV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5maWVsZE5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZmllbGRWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVNZXRhZGF0YURhdGFfVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogaXNTZXQob2JqZWN0LmZpZWxkTmFtZSkgPyBTdHJpbmcob2JqZWN0LmZpZWxkTmFtZSkgOiBcIlwiLFxuICAgICAgICAgICAgZmllbGRWYWx1ZTogaXNTZXQob2JqZWN0LmZpZWxkVmFsdWUpID8gU3RyaW5nKG9iamVjdC5maWVsZFZhbHVlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5maWVsZE5hbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmZpZWxkTmFtZSA9IG1lc3NhZ2UuZmllbGROYW1lKTtcbiAgICAgICAgbWVzc2FnZS5maWVsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai5maWVsZFZhbHVlID0gbWVzc2FnZS5maWVsZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZU1ldGFkYXRhRGF0YV9WMSgpO1xuICAgICAgICBtZXNzYWdlLmZpZWxkTmFtZSA9IChfYSA9IG9iamVjdC5maWVsZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZmllbGRWYWx1ZSA9IChfYiA9IG9iamVjdC5maWVsZFZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VVcGRhdGVBZG1pbkxpc3RzRGF0YSgpIHtcbiAgICByZXR1cm4geyB2MTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgVXBkYXRlQWRtaW5MaXN0c0RhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXBkYXRlQWRtaW5MaXN0c0RhdGFfVjEuZW5jb2RlKG1lc3NhZ2UudjEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVBZG1pbkxpc3RzRGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudjEgPSBVcGRhdGVBZG1pbkxpc3RzRGF0YV9WMS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2MTogaXNTZXQob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgID8gVXBkYXRlQWRtaW5MaXN0c0RhdGFfVjEuZnJvbUpTT04ob2JqZWN0LnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjFcbiAgICAgICAgICAgICAgICA/IFVwZGF0ZUFkbWluTGlzdHNEYXRhX1YxLnRvSlNPTihtZXNzYWdlLnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZUFkbWluTGlzdHNEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UudjEgPVxuICAgICAgICAgICAgb2JqZWN0LnYxICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnYxICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBVcGRhdGVBZG1pbkxpc3RzRGF0YV9WMS5mcm9tUGFydGlhbChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZGF0ZUFkbWluTGlzdHNEYXRhX1YxKCkge1xuICAgIHJldHVybiB7IGFkbWluTGlzdFVwZGF0ZVR5cGU6IDAsIGluYm94SWQ6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBVcGRhdGVBZG1pbkxpc3RzRGF0YV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZG1pbkxpc3RVcGRhdGVUeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UuYWRtaW5MaXN0VXBkYXRlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5ib3hJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVBZG1pbkxpc3RzRGF0YV9WMSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRtaW5MaXN0VXBkYXRlVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRtaW5MaXN0VXBkYXRlVHlwZTogaXNTZXQob2JqZWN0LmFkbWluTGlzdFVwZGF0ZVR5cGUpXG4gICAgICAgICAgICAgICAgPyBhZG1pbkxpc3RVcGRhdGVUeXBlRnJvbUpTT04ob2JqZWN0LmFkbWluTGlzdFVwZGF0ZVR5cGUpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaW5ib3hJZDogaXNTZXQob2JqZWN0LmluYm94SWQpID8gU3RyaW5nKG9iamVjdC5pbmJveElkKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hZG1pbkxpc3RVcGRhdGVUeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWRtaW5MaXN0VXBkYXRlVHlwZSA9IGFkbWluTGlzdFVwZGF0ZVR5cGVUb0pTT04obWVzc2FnZS5hZG1pbkxpc3RVcGRhdGVUeXBlKSk7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5ib3hJZCA9IG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVBZG1pbkxpc3RzRGF0YV9WMSgpO1xuICAgICAgICBtZXNzYWdlLmFkbWluTGlzdFVwZGF0ZVR5cGUgPSAoX2EgPSBvYmplY3QuYWRtaW5MaXN0VXBkYXRlVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkID0gKF9iID0gb2JqZWN0LmluYm94SWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZGF0ZVBlcm1pc3Npb25EYXRhKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBVcGRhdGVQZXJtaXNzaW9uRGF0YSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVcGRhdGVQZXJtaXNzaW9uRGF0YV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZVBlcm1pc3Npb25EYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFVwZGF0ZVBlcm1pc3Npb25EYXRhX1YxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgPyBVcGRhdGVQZXJtaXNzaW9uRGF0YV9WMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYxID0gbWVzc2FnZS52MVxuICAgICAgICAgICAgICAgID8gVXBkYXRlUGVybWlzc2lvbkRhdGFfVjEudG9KU09OKG1lc3NhZ2UudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXBkYXRlUGVybWlzc2lvbkRhdGEoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFVwZGF0ZVBlcm1pc3Npb25EYXRhX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVXBkYXRlUGVybWlzc2lvbkRhdGFfVjEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGVybWlzc2lvblVwZGF0ZVR5cGU6IDAsXG4gICAgICAgIHBlcm1pc3Npb25Qb2xpY3lPcHRpb246IDAsXG4gICAgICAgIG1ldGFkYXRhRmllbGROYW1lOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBVcGRhdGVQZXJtaXNzaW9uRGF0YV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wZXJtaXNzaW9uVXBkYXRlVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnBlcm1pc3Npb25VcGRhdGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wZXJtaXNzaW9uUG9saWN5T3B0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQzMihtZXNzYWdlLnBlcm1pc3Npb25Qb2xpY3lPcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhRmllbGROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLm1ldGFkYXRhRmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVwZGF0ZVBlcm1pc3Npb25EYXRhX1YxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZXJtaXNzaW9uVXBkYXRlVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVybWlzc2lvblBvbGljeU9wdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFGaWVsZE5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBlcm1pc3Npb25VcGRhdGVUeXBlOiBpc1NldChvYmplY3QucGVybWlzc2lvblVwZGF0ZVR5cGUpXG4gICAgICAgICAgICAgICAgPyBwZXJtaXNzaW9uVXBkYXRlVHlwZUZyb21KU09OKG9iamVjdC5wZXJtaXNzaW9uVXBkYXRlVHlwZSlcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBwZXJtaXNzaW9uUG9saWN5T3B0aW9uOiBpc1NldChvYmplY3QucGVybWlzc2lvblBvbGljeU9wdGlvbilcbiAgICAgICAgICAgICAgICA/IHBlcm1pc3Npb25Qb2xpY3lPcHRpb25Gcm9tSlNPTihvYmplY3QucGVybWlzc2lvblBvbGljeU9wdGlvbilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBtZXRhZGF0YUZpZWxkTmFtZTogaXNTZXQob2JqZWN0Lm1ldGFkYXRhRmllbGROYW1lKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5tZXRhZGF0YUZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBlcm1pc3Npb25VcGRhdGVUeXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucGVybWlzc2lvblVwZGF0ZVR5cGUgPSBwZXJtaXNzaW9uVXBkYXRlVHlwZVRvSlNPTihtZXNzYWdlLnBlcm1pc3Npb25VcGRhdGVUeXBlKSk7XG4gICAgICAgIG1lc3NhZ2UucGVybWlzc2lvblBvbGljeU9wdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBlcm1pc3Npb25Qb2xpY3lPcHRpb24gPSBwZXJtaXNzaW9uUG9saWN5T3B0aW9uVG9KU09OKG1lc3NhZ2UucGVybWlzc2lvblBvbGljeU9wdGlvbikpO1xuICAgICAgICBtZXNzYWdlLm1ldGFkYXRhRmllbGROYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWV0YWRhdGFGaWVsZE5hbWUgPSBtZXNzYWdlLm1ldGFkYXRhRmllbGROYW1lKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGRhdGVQZXJtaXNzaW9uRGF0YV9WMSgpO1xuICAgICAgICBtZXNzYWdlLnBlcm1pc3Npb25VcGRhdGVUeXBlID0gKF9hID0gb2JqZWN0LnBlcm1pc3Npb25VcGRhdGVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLnBlcm1pc3Npb25Qb2xpY3lPcHRpb24gPSAoX2IgPSBvYmplY3QucGVybWlzc2lvblBvbGljeU9wdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5tZXRhZGF0YUZpZWxkTmFtZSA9IChfYyA9IG9iamVjdC5tZXRhZGF0YUZpZWxkTmFtZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQb3N0Q29tbWl0QWN0aW9uKCkge1xuICAgIHJldHVybiB7IHNlbmRXZWxjb21lczogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgUG9zdENvbW1pdEFjdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kV2VsY29tZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMuZW5jb2RlKG1lc3NhZ2Uuc2VuZFdlbGNvbWVzLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZFdlbGNvbWVzID0gUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZFdlbGNvbWVzOiBpc1NldChvYmplY3Quc2VuZFdlbGNvbWVzKVxuICAgICAgICAgICAgICAgID8gUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMuZnJvbUpTT04ob2JqZWN0LnNlbmRXZWxjb21lcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNlbmRXZWxjb21lcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNlbmRXZWxjb21lcyA9IG1lc3NhZ2Uuc2VuZFdlbGNvbWVzXG4gICAgICAgICAgICAgICAgPyBQb3N0Q29tbWl0QWN0aW9uX1NlbmRXZWxjb21lcy50b0pTT04obWVzc2FnZS5zZW5kV2VsY29tZXMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbigpO1xuICAgICAgICBtZXNzYWdlLnNlbmRXZWxjb21lcyA9XG4gICAgICAgICAgICBvYmplY3Quc2VuZFdlbGNvbWVzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRXZWxjb21lcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMuZnJvbVBhcnRpYWwob2JqZWN0LnNlbmRXZWxjb21lcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbl9JbnN0YWxsYXRpb24oKSB7XG4gICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uS2V5OiBuZXcgVWludDhBcnJheSgpLCBocGtlUHVibGljS2V5OiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnQgY29uc3QgUG9zdENvbW1pdEFjdGlvbl9JbnN0YWxsYXRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uS2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhwa2VQdWJsaWNLZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmhwa2VQdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbl9JbnN0YWxsYXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaHBrZVB1YmxpY0tleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YWxsYXRpb25LZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBocGtlUHVibGljS2V5OiBpc1NldChvYmplY3QuaHBrZVB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaHBrZVB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25LZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25LZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25LZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5ocGtlUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaHBrZVB1YmxpY0tleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmhwa2VQdWJsaWNLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5ocGtlUHVibGljS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQb3N0Q29tbWl0QWN0aW9uX0luc3RhbGxhdGlvbigpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbktleSA9IChfYSA9IG9iamVjdC5pbnN0YWxsYXRpb25LZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaHBrZVB1YmxpY0tleSA9IChfYiA9IG9iamVjdC5ocGtlUHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQb3N0Q29tbWl0QWN0aW9uX1NlbmRXZWxjb21lcygpIHtcbiAgICByZXR1cm4geyBpbnN0YWxsYXRpb25zOiBbXSwgd2VsY29tZU1lc3NhZ2U6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBQb3N0Q29tbWl0QWN0aW9uX1NlbmRXZWxjb21lcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5pbnN0YWxsYXRpb25zKSB7XG4gICAgICAgICAgICBQb3N0Q29tbWl0QWN0aW9uX0luc3RhbGxhdGlvbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS53ZWxjb21lTWVzc2FnZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uud2VsY29tZU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbnMucHVzaChQb3N0Q29tbWl0QWN0aW9uX0luc3RhbGxhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndlbGNvbWVNZXNzYWdlID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lmluc3RhbGxhdGlvbnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuaW5zdGFsbGF0aW9ucy5tYXAoKGUpID0+IFBvc3RDb21taXRBY3Rpb25fSW5zdGFsbGF0aW9uLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICB3ZWxjb21lTWVzc2FnZTogaXNTZXQob2JqZWN0LndlbGNvbWVNZXNzYWdlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC53ZWxjb21lTWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9ucykge1xuICAgICAgICAgICAgb2JqLmluc3RhbGxhdGlvbnMgPSBtZXNzYWdlLmluc3RhbGxhdGlvbnMubWFwKChlKSA9PiBlID8gUG9zdENvbW1pdEFjdGlvbl9JbnN0YWxsYXRpb24udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbnN0YWxsYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS53ZWxjb21lTWVzc2FnZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLndlbGNvbWVNZXNzYWdlID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uud2VsY29tZU1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS53ZWxjb21lTWVzc2FnZVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUG9zdENvbW1pdEFjdGlvbl9TZW5kV2VsY29tZXMoKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25zID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuaW5zdGFsbGF0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gUG9zdENvbW1pdEFjdGlvbl9JbnN0YWxsYXRpb24uZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS53ZWxjb21lTWVzc2FnZSA9IChfYiA9IG9iamVjdC53ZWxjb21lTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlbnRzLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/database/intents.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/content.pb.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/content.pb.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compression: () => (/* binding */ Compression),\n/* harmony export */   ContentTypeId: () => (/* binding */ ContentTypeId),\n/* harmony export */   EncodedContent: () => (/* binding */ EncodedContent),\n/* harmony export */   EncodedContent_ParametersEntry: () => (/* binding */ EncodedContent_ParametersEntry),\n/* harmony export */   MessageHistoryKeyType: () => (/* binding */ MessageHistoryKeyType),\n/* harmony export */   MessageHistoryReply: () => (/* binding */ MessageHistoryReply),\n/* harmony export */   MessageHistoryRequest: () => (/* binding */ MessageHistoryRequest),\n/* harmony export */   PlaintextEnvelope: () => (/* binding */ PlaintextEnvelope),\n/* harmony export */   PlaintextEnvelope_V1: () => (/* binding */ PlaintextEnvelope_V1),\n/* harmony export */   PlaintextEnvelope_V2: () => (/* binding */ PlaintextEnvelope_V2),\n/* harmony export */   compressionFromJSON: () => (/* binding */ compressionFromJSON),\n/* harmony export */   compressionToJSON: () => (/* binding */ compressionToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.message_contents\";\n/**\n * Message content encoding structures\n * Copied from V2 code so that we can eventually retire all V2 message content\n */\n/**\n * Recognized compression algorithms\n * protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH\n */\nvar Compression;\n(function (Compression) {\n    Compression[Compression[\"COMPRESSION_DEFLATE\"] = 0] = \"COMPRESSION_DEFLATE\";\n    Compression[Compression[\"COMPRESSION_GZIP\"] = 1] = \"COMPRESSION_GZIP\";\n    Compression[Compression[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Compression || (Compression = {}));\nfunction compressionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"COMPRESSION_DEFLATE\":\n            return Compression.COMPRESSION_DEFLATE;\n        case 1:\n        case \"COMPRESSION_GZIP\":\n            return Compression.COMPRESSION_GZIP;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Compression.UNRECOGNIZED;\n    }\n}\nfunction compressionToJSON(object) {\n    switch (object) {\n        case Compression.COMPRESSION_DEFLATE:\n            return \"COMPRESSION_DEFLATE\";\n        case Compression.COMPRESSION_GZIP:\n            return \"COMPRESSION_GZIP\";\n        case Compression.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseContentTypeId() {\n    return { authorityId: \"\", typeId: \"\", versionMajor: 0, versionMinor: 0 };\n}\nconst ContentTypeId = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.authorityId !== \"\") {\n            writer.uint32(10).string(message.authorityId);\n        }\n        if (message.typeId !== \"\") {\n            writer.uint32(18).string(message.typeId);\n        }\n        if (message.versionMajor !== 0) {\n            writer.uint32(24).uint32(message.versionMajor);\n        }\n        if (message.versionMinor !== 0) {\n            writer.uint32(32).uint32(message.versionMinor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContentTypeId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authorityId = reader.string();\n                    break;\n                case 2:\n                    message.typeId = reader.string();\n                    break;\n                case 3:\n                    message.versionMajor = reader.uint32();\n                    break;\n                case 4:\n                    message.versionMinor = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            authorityId: isSet(object.authorityId) ? String(object.authorityId) : \"\",\n            typeId: isSet(object.typeId) ? String(object.typeId) : \"\",\n            versionMajor: isSet(object.versionMajor)\n                ? Number(object.versionMajor)\n                : 0,\n            versionMinor: isSet(object.versionMinor)\n                ? Number(object.versionMinor)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authorityId !== undefined &&\n            (obj.authorityId = message.authorityId);\n        message.typeId !== undefined && (obj.typeId = message.typeId);\n        message.versionMajor !== undefined &&\n            (obj.versionMajor = Math.round(message.versionMajor));\n        message.versionMinor !== undefined &&\n            (obj.versionMinor = Math.round(message.versionMinor));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseContentTypeId();\n        message.authorityId = (_a = object.authorityId) !== null && _a !== void 0 ? _a : \"\";\n        message.typeId = (_b = object.typeId) !== null && _b !== void 0 ? _b : \"\";\n        message.versionMajor = (_c = object.versionMajor) !== null && _c !== void 0 ? _c : 0;\n        message.versionMinor = (_d = object.versionMinor) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBaseEncodedContent() {\n    return {\n        type: undefined,\n        parameters: {},\n        fallback: undefined,\n        compression: undefined,\n        content: new Uint8Array(),\n    };\n}\nconst EncodedContent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.type !== undefined) {\n            ContentTypeId.encode(message.type, writer.uint32(10).fork()).ldelim();\n        }\n        Object.entries(message.parameters).forEach(([key, value]) => {\n            EncodedContent_ParametersEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\n        });\n        if (message.fallback !== undefined) {\n            writer.uint32(26).string(message.fallback);\n        }\n        if (message.compression !== undefined) {\n            writer.uint32(40).int32(message.compression);\n        }\n        if (message.content.length !== 0) {\n            writer.uint32(34).bytes(message.content);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = ContentTypeId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    const entry2 = EncodedContent_ParametersEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.parameters[entry2.key] = entry2.value;\n                    }\n                    break;\n                case 3:\n                    message.fallback = reader.string();\n                    break;\n                case 5:\n                    message.compression = reader.int32();\n                    break;\n                case 4:\n                    message.content = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type)\n                ? ContentTypeId.fromJSON(object.type)\n                : undefined,\n            parameters: isObject(object.parameters)\n                ? Object.entries(object.parameters).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n            fallback: isSet(object.fallback) ? String(object.fallback) : undefined,\n            compression: isSet(object.compression)\n                ? compressionFromJSON(object.compression)\n                : undefined,\n            content: isSet(object.content)\n                ? bytesFromBase64(object.content)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined &&\n            (obj.type = message.type\n                ? ContentTypeId.toJSON(message.type)\n                : undefined);\n        obj.parameters = {};\n        if (message.parameters) {\n            Object.entries(message.parameters).forEach(([k, v]) => {\n                obj.parameters[k] = v;\n            });\n        }\n        message.fallback !== undefined && (obj.fallback = message.fallback);\n        message.compression !== undefined &&\n            (obj.compression =\n                message.compression !== undefined\n                    ? compressionToJSON(message.compression)\n                    : undefined);\n        message.content !== undefined &&\n            (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseEncodedContent();\n        message.type =\n            object.type !== undefined && object.type !== null\n                ? ContentTypeId.fromPartial(object.type)\n                : undefined;\n        message.parameters = Object.entries((_a = object.parameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        message.fallback = (_b = object.fallback) !== null && _b !== void 0 ? _b : undefined;\n        message.compression = (_c = object.compression) !== null && _c !== void 0 ? _c : undefined;\n        message.content = (_d = object.content) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseEncodedContent_ParametersEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst EncodedContent_ParametersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEncodedContent_ParametersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEncodedContent_ParametersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePlaintextEnvelope() {\n    return { v1: undefined, v2: undefined };\n}\nconst PlaintextEnvelope = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.v1 !== undefined) {\n            PlaintextEnvelope_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.v2 !== undefined) {\n            PlaintextEnvelope_V2.encode(message.v2, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlaintextEnvelope();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.v1 = PlaintextEnvelope_V1.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.v2 = PlaintextEnvelope_V2.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            v1: isSet(object.v1)\n                ? PlaintextEnvelope_V1.fromJSON(object.v1)\n                : undefined,\n            v2: isSet(object.v2)\n                ? PlaintextEnvelope_V2.fromJSON(object.v2)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.v1 !== undefined &&\n            (obj.v1 = message.v1\n                ? PlaintextEnvelope_V1.toJSON(message.v1)\n                : undefined);\n        message.v2 !== undefined &&\n            (obj.v2 = message.v2\n                ? PlaintextEnvelope_V2.toJSON(message.v2)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePlaintextEnvelope();\n        message.v1 =\n            object.v1 !== undefined && object.v1 !== null\n                ? PlaintextEnvelope_V1.fromPartial(object.v1)\n                : undefined;\n        message.v2 =\n            object.v2 !== undefined && object.v2 !== null\n                ? PlaintextEnvelope_V2.fromPartial(object.v2)\n                : undefined;\n        return message;\n    },\n};\nfunction createBasePlaintextEnvelope_V1() {\n    return { content: new Uint8Array(), idempotencyKey: \"\" };\n}\nconst PlaintextEnvelope_V1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.content.length !== 0) {\n            writer.uint32(10).bytes(message.content);\n        }\n        if (message.idempotencyKey !== \"\") {\n            writer.uint32(18).string(message.idempotencyKey);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlaintextEnvelope_V1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.content = reader.bytes();\n                    break;\n                case 2:\n                    message.idempotencyKey = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            content: isSet(object.content)\n                ? bytesFromBase64(object.content)\n                : new Uint8Array(),\n            idempotencyKey: isSet(object.idempotencyKey)\n                ? String(object.idempotencyKey)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.content !== undefined &&\n            (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));\n        message.idempotencyKey !== undefined &&\n            (obj.idempotencyKey = message.idempotencyKey);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePlaintextEnvelope_V1();\n        message.content = (_a = object.content) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.idempotencyKey = (_b = object.idempotencyKey) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePlaintextEnvelope_V2() {\n    return {\n        idempotencyKey: \"\",\n        content: undefined,\n        request: undefined,\n        reply: undefined,\n    };\n}\nconst PlaintextEnvelope_V2 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.idempotencyKey !== \"\") {\n            writer.uint32(10).string(message.idempotencyKey);\n        }\n        if (message.content !== undefined) {\n            writer.uint32(18).bytes(message.content);\n        }\n        if (message.request !== undefined) {\n            MessageHistoryRequest.encode(message.request, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.reply !== undefined) {\n            MessageHistoryReply.encode(message.reply, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlaintextEnvelope_V2();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.idempotencyKey = reader.string();\n                    break;\n                case 2:\n                    message.content = reader.bytes();\n                    break;\n                case 3:\n                    message.request = MessageHistoryRequest.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.reply = MessageHistoryReply.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            idempotencyKey: isSet(object.idempotencyKey)\n                ? String(object.idempotencyKey)\n                : \"\",\n            content: isSet(object.content)\n                ? bytesFromBase64(object.content)\n                : undefined,\n            request: isSet(object.request)\n                ? MessageHistoryRequest.fromJSON(object.request)\n                : undefined,\n            reply: isSet(object.reply)\n                ? MessageHistoryReply.fromJSON(object.reply)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.idempotencyKey !== undefined &&\n            (obj.idempotencyKey = message.idempotencyKey);\n        message.content !== undefined &&\n            (obj.content =\n                message.content !== undefined\n                    ? base64FromBytes(message.content)\n                    : undefined);\n        message.request !== undefined &&\n            (obj.request = message.request\n                ? MessageHistoryRequest.toJSON(message.request)\n                : undefined);\n        message.reply !== undefined &&\n            (obj.reply = message.reply\n                ? MessageHistoryReply.toJSON(message.reply)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePlaintextEnvelope_V2();\n        message.idempotencyKey = (_a = object.idempotencyKey) !== null && _a !== void 0 ? _a : \"\";\n        message.content = (_b = object.content) !== null && _b !== void 0 ? _b : undefined;\n        message.request =\n            object.request !== undefined && object.request !== null\n                ? MessageHistoryRequest.fromPartial(object.request)\n                : undefined;\n        message.reply =\n            object.reply !== undefined && object.reply !== null\n                ? MessageHistoryReply.fromPartial(object.reply)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMessageHistoryRequest() {\n    return { requestId: \"\", pinCode: \"\" };\n}\nconst MessageHistoryRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.requestId !== \"\") {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.pinCode !== \"\") {\n            writer.uint32(18).string(message.pinCode);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHistoryRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.pinCode = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requestId: isSet(object.requestId) ? String(object.requestId) : \"\",\n            pinCode: isSet(object.pinCode) ? String(object.pinCode) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.pinCode !== undefined && (obj.pinCode = message.pinCode);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMessageHistoryRequest();\n        message.requestId = (_a = object.requestId) !== null && _a !== void 0 ? _a : \"\";\n        message.pinCode = (_b = object.pinCode) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMessageHistoryReply() {\n    return { requestId: \"\", url: \"\", encryptionKey: undefined };\n}\nconst MessageHistoryReply = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.requestId !== \"\") {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.url !== \"\") {\n            writer.uint32(18).string(message.url);\n        }\n        if (message.encryptionKey !== undefined) {\n            MessageHistoryKeyType.encode(message.encryptionKey, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHistoryReply();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.url = reader.string();\n                    break;\n                case 3:\n                    message.encryptionKey = MessageHistoryKeyType.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requestId: isSet(object.requestId) ? String(object.requestId) : \"\",\n            url: isSet(object.url) ? String(object.url) : \"\",\n            encryptionKey: isSet(object.encryptionKey)\n                ? MessageHistoryKeyType.fromJSON(object.encryptionKey)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.url !== undefined && (obj.url = message.url);\n        message.encryptionKey !== undefined &&\n            (obj.encryptionKey = message.encryptionKey\n                ? MessageHistoryKeyType.toJSON(message.encryptionKey)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMessageHistoryReply();\n        message.requestId = (_a = object.requestId) !== null && _a !== void 0 ? _a : \"\";\n        message.url = (_b = object.url) !== null && _b !== void 0 ? _b : \"\";\n        message.encryptionKey =\n            object.encryptionKey !== undefined && object.encryptionKey !== null\n                ? MessageHistoryKeyType.fromPartial(object.encryptionKey)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMessageHistoryKeyType() {\n    return { chacha20Poly1305: undefined };\n}\nconst MessageHistoryKeyType = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.chacha20Poly1305 !== undefined) {\n            writer.uint32(10).bytes(message.chacha20Poly1305);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageHistoryKeyType();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.chacha20Poly1305 = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            chacha20Poly1305: isSet(object.chacha20Poly1305)\n                ? bytesFromBase64(object.chacha20Poly1305)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.chacha20Poly1305 !== undefined &&\n            (obj.chacha20Poly1305 =\n                message.chacha20Poly1305 !== undefined\n                    ? base64FromBytes(message.chacha20Poly1305)\n                    : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageHistoryKeyType();\n        message.chacha20Poly1305 = (_a = object.chacha20Poly1305) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=content.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL21lc3NhZ2VfY29udGVudHMvY29udGVudC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDYTtBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDNUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tbHMvbWVzc2FnZV9jb250ZW50cy9jb250ZW50LnBiLmpzPzY3MzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWxzLm1lc3NhZ2VfY29udGVudHNcIjtcbi8qKlxuICogTWVzc2FnZSBjb250ZW50IGVuY29kaW5nIHN0cnVjdHVyZXNcbiAqIENvcGllZCBmcm9tIFYyIGNvZGUgc28gdGhhdCB3ZSBjYW4gZXZlbnR1YWxseSByZXRpcmUgYWxsIFYyIG1lc3NhZ2UgY29udGVudFxuICovXG4vKipcbiAqIFJlY29nbml6ZWQgY29tcHJlc3Npb24gYWxnb3JpdGhtc1xuICogcHJvdG9saW50OmRpc2FibGUgRU5VTV9GSUVMRF9OQU1FU19aRVJPX1ZBTFVFX0VORF9XSVRIXG4gKi9cbmV4cG9ydCB2YXIgQ29tcHJlc3Npb247XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uKSB7XG4gICAgQ29tcHJlc3Npb25bQ29tcHJlc3Npb25bXCJDT01QUkVTU0lPTl9ERUZMQVRFXCJdID0gMF0gPSBcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIjtcbiAgICBDb21wcmVzc2lvbltDb21wcmVzc2lvbltcIkNPTVBSRVNTSU9OX0daSVBcIl0gPSAxXSA9IFwiQ09NUFJFU1NJT05fR1pJUFwiO1xuICAgIENvbXByZXNzaW9uW0NvbXByZXNzaW9uW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKENvbXByZXNzaW9uIHx8IChDb21wcmVzc2lvbiA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Npb25Gcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJDT01QUkVTU0lPTl9ERUZMQVRFXCI6XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fREVGTEFURTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiQ09NUFJFU1NJT05fR1pJUFwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbXByZXNzaW9uLkNPTVBSRVNTSU9OX0daSVA7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2lvbi5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzaW9uVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fREVGTEFURTpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTVBSRVNTSU9OX0RFRkxBVEVcIjtcbiAgICAgICAgY2FzZSBDb21wcmVzc2lvbi5DT01QUkVTU0lPTl9HWklQOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ09NUFJFU1NJT05fR1pJUFwiO1xuICAgICAgICBjYXNlIENvbXByZXNzaW9uLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOUkVDT0dOSVpFRFwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250ZW50VHlwZUlkKCkge1xuICAgIHJldHVybiB7IGF1dGhvcml0eUlkOiBcIlwiLCB0eXBlSWQ6IFwiXCIsIHZlcnNpb25NYWpvcjogMCwgdmVyc2lvbk1pbm9yOiAwIH07XG59XG5leHBvcnQgY29uc3QgQ29udGVudFR5cGVJZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hdXRob3JpdHlJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuYXV0aG9yaXR5SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGVJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudHlwZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uTWFqb3IgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQzMihtZXNzYWdlLnZlcnNpb25NYWpvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbk1pbm9yICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS51aW50MzIobWVzc2FnZS52ZXJzaW9uTWlub3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGVudFR5cGVJZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aG9yaXR5SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWFqb3IgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWlub3IgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhvcml0eUlkOiBpc1NldChvYmplY3QuYXV0aG9yaXR5SWQpID8gU3RyaW5nKG9iamVjdC5hdXRob3JpdHlJZCkgOiBcIlwiLFxuICAgICAgICAgICAgdHlwZUlkOiBpc1NldChvYmplY3QudHlwZUlkKSA/IFN0cmluZyhvYmplY3QudHlwZUlkKSA6IFwiXCIsXG4gICAgICAgICAgICB2ZXJzaW9uTWFqb3I6IGlzU2V0KG9iamVjdC52ZXJzaW9uTWFqb3IpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnZlcnNpb25NYWpvcilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICB2ZXJzaW9uTWlub3I6IGlzU2V0KG9iamVjdC52ZXJzaW9uTWlub3IpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LnZlcnNpb25NaW5vcilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hdXRob3JpdHlJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmF1dGhvcml0eUlkID0gbWVzc2FnZS5hdXRob3JpdHlJZCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZUlkICE9PSB1bmRlZmluZWQgJiYgKG9iai50eXBlSWQgPSBtZXNzYWdlLnR5cGVJZCk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbk1ham9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmVyc2lvbk1ham9yID0gTWF0aC5yb3VuZChtZXNzYWdlLnZlcnNpb25NYWpvcikpO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb25NaW5vciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZlcnNpb25NaW5vciA9IE1hdGgucm91bmQobWVzc2FnZS52ZXJzaW9uTWlub3IpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGVudFR5cGVJZCgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml0eUlkID0gKF9hID0gb2JqZWN0LmF1dGhvcml0eUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnR5cGVJZCA9IChfYiA9IG9iamVjdC50eXBlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbk1ham9yID0gKF9jID0gb2JqZWN0LnZlcnNpb25NYWpvcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS52ZXJzaW9uTWlub3IgPSAoX2QgPSBvYmplY3QudmVyc2lvbk1pbm9yKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBmYWxsYmFjazogdW5kZWZpbmVkLFxuICAgICAgICBjb21wcmVzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZW50OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgRW5jb2RlZENvbnRlbnQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBDb250ZW50VHlwZUlkLmVuY29kZShtZXNzYWdlLnR5cGUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5wYXJhbWV0ZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS5pbnQzMihtZXNzYWdlLmNvbXByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gQ29udGVudFR5cGVJZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5MiA9IEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkyLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFyYW1ldGVyc1tlbnRyeTIua2V5XSA9IGVudHJ5Mi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmFsbGJhY2sgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2lvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBpc1NldChvYmplY3QudHlwZSlcbiAgICAgICAgICAgICAgICA/IENvbnRlbnRUeXBlSWQuZnJvbUpTT04ob2JqZWN0LnR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBpc09iamVjdChvYmplY3QucGFyYW1ldGVycylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wYXJhbWV0ZXJzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgZmFsbGJhY2s6IGlzU2V0KG9iamVjdC5mYWxsYmFjaykgPyBTdHJpbmcob2JqZWN0LmZhbGxiYWNrKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBpc1NldChvYmplY3QuY29tcHJlc3Npb24pXG4gICAgICAgICAgICAgICAgPyBjb21wcmVzc2lvbkZyb21KU09OKG9iamVjdC5jb21wcmVzc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGlzU2V0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50eXBlID0gbWVzc2FnZS50eXBlXG4gICAgICAgICAgICAgICAgPyBDb250ZW50VHlwZUlkLnRvSlNPTihtZXNzYWdlLnR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBvYmoucGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBhcmFtZXRlcnMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIG9iai5wYXJhbWV0ZXJzW2tdID0gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiAob2JqLmZhbGxiYWNrID0gbWVzc2FnZS5mYWxsYmFjayk7XG4gICAgICAgIG1lc3NhZ2UuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wcmVzc2lvbiA9XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gY29tcHJlc3Npb25Ub0pTT04obWVzc2FnZS5jb21wcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuY29udGVudCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5jb250ZW50IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudCgpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPVxuICAgICAgICAgICAgb2JqZWN0LnR5cGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudHlwZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ29udGVudFR5cGVJZC5mcm9tUGFydGlhbChvYmplY3QudHlwZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5wYXJhbWV0ZXJzID0gT2JqZWN0LmVudHJpZXMoKF9hID0gb2JqZWN0LnBhcmFtZXRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbWVzc2FnZS5mYWxsYmFjayA9IChfYiA9IG9iamVjdC5mYWxsYmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmNvbXByZXNzaW9uID0gKF9jID0gb2JqZWN0LmNvbXByZXNzaW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudCA9IChfZCA9IG9iamVjdC5jb250ZW50KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbmNvZGVkQ29udGVudF9QYXJhbWV0ZXJzRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IEVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBTdHJpbmcob2JqZWN0LnZhbHVlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJiAob2JqLmtleSA9IG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudmFsdWUgPSBtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVuY29kZWRDb250ZW50X1BhcmFtZXRlcnNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPSAoX2IgPSBvYmplY3QudmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBsYWludGV4dEVudmVsb3BlKCkge1xuICAgIHJldHVybiB7IHYxOiB1bmRlZmluZWQsIHYyOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBQbGFpbnRleHRFbnZlbG9wZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQbGFpbnRleHRFbnZlbG9wZV9WMS5lbmNvZGUobWVzc2FnZS52MSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBQbGFpbnRleHRFbnZlbG9wZV9WMi5lbmNvZGUobWVzc2FnZS52Miwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBsYWludGV4dEVudmVsb3BlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MSA9IFBsYWludGV4dEVudmVsb3BlX1YxLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52MiA9IFBsYWludGV4dEVudmVsb3BlX1YyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHYxOiBpc1NldChvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgPyBQbGFpbnRleHRFbnZlbG9wZV9WMS5mcm9tSlNPTihvYmplY3QudjEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2MjogaXNTZXQob2JqZWN0LnYyKVxuICAgICAgICAgICAgICAgID8gUGxhaW50ZXh0RW52ZWxvcGVfVjIuZnJvbUpTT04ob2JqZWN0LnYyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudjEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52MSA9IG1lc3NhZ2UudjFcbiAgICAgICAgICAgICAgICA/IFBsYWludGV4dEVudmVsb3BlX1YxLnRvSlNPTihtZXNzYWdlLnYxKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS52MiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnYyID0gbWVzc2FnZS52MlxuICAgICAgICAgICAgICAgID8gUGxhaW50ZXh0RW52ZWxvcGVfVjIudG9KU09OKG1lc3NhZ2UudjIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGUoKTtcbiAgICAgICAgbWVzc2FnZS52MSA9XG4gICAgICAgICAgICBvYmplY3QudjEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjEgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFBsYWludGV4dEVudmVsb3BlX1YxLmZyb21QYXJ0aWFsKG9iamVjdC52MSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52MiA9XG4gICAgICAgICAgICBvYmplY3QudjIgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudjIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IFBsYWludGV4dEVudmVsb3BlX1YyLmZyb21QYXJ0aWFsKG9iamVjdC52MilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGVfVjEoKSB7XG4gICAgcmV0dXJuIHsgY29udGVudDogbmV3IFVpbnQ4QXJyYXkoKSwgaWRlbXBvdGVuY3lLZXk6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBQbGFpbnRleHRFbnZlbG9wZV9WMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pZGVtcG90ZW5jeUtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaWRlbXBvdGVuY3lLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGVfVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW1wb3RlbmN5S2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBpc1NldChvYmplY3QuY29udGVudClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY29udGVudClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBpZGVtcG90ZW5jeUtleTogaXNTZXQob2JqZWN0LmlkZW1wb3RlbmN5S2V5KVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5pZGVtcG90ZW5jeUtleSlcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGVudCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuY29udGVudCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5pZGVtcG90ZW5jeUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW1wb3RlbmN5S2V5ID0gbWVzc2FnZS5pZGVtcG90ZW5jeUtleSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQbGFpbnRleHRFbnZlbG9wZV9WMSgpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSAoX2EgPSBvYmplY3QuY29udGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVtcG90ZW5jeUtleSA9IChfYiA9IG9iamVjdC5pZGVtcG90ZW5jeUtleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGVfVjIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbXBvdGVuY3lLZXk6IFwiXCIsXG4gICAgICAgIGNvbnRlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVxdWVzdDogdW5kZWZpbmVkLFxuICAgICAgICByZXBseTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgUGxhaW50ZXh0RW52ZWxvcGVfVjIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbXBvdGVuY3lLZXkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmlkZW1wb3RlbmN5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlSGlzdG9yeVJlcXVlc3QuZW5jb2RlKG1lc3NhZ2UucmVxdWVzdCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlSGlzdG9yeVJlcGx5LmVuY29kZShtZXNzYWdlLnJlcGx5LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGVfVjIoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW1wb3RlbmN5S2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdCA9IE1lc3NhZ2VIaXN0b3J5UmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVwbHkgPSBNZXNzYWdlSGlzdG9yeVJlcGx5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW1wb3RlbmN5S2V5OiBpc1NldChvYmplY3QuaWRlbXBvdGVuY3lLZXkpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmlkZW1wb3RlbmN5S2V5KVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGlzU2V0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWVzdDogaXNTZXQob2JqZWN0LnJlcXVlc3QpXG4gICAgICAgICAgICAgICAgPyBNZXNzYWdlSGlzdG9yeVJlcXVlc3QuZnJvbUpTT04ob2JqZWN0LnJlcXVlc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXBseTogaXNTZXQob2JqZWN0LnJlcGx5KVxuICAgICAgICAgICAgICAgID8gTWVzc2FnZUhpc3RvcnlSZXBseS5mcm9tSlNPTihvYmplY3QucmVwbHkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pZGVtcG90ZW5jeUtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlkZW1wb3RlbmN5S2V5ID0gbWVzc2FnZS5pZGVtcG90ZW5jeUtleSk7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnRlbnQgPVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udGVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXF1ZXN0ID0gbWVzc2FnZS5yZXF1ZXN0XG4gICAgICAgICAgICAgICAgPyBNZXNzYWdlSGlzdG9yeVJlcXVlc3QudG9KU09OKG1lc3NhZ2UucmVxdWVzdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UucmVwbHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXBseSA9IG1lc3NhZ2UucmVwbHlcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VIaXN0b3J5UmVwbHkudG9KU09OKG1lc3NhZ2UucmVwbHkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGxhaW50ZXh0RW52ZWxvcGVfVjIoKTtcbiAgICAgICAgbWVzc2FnZS5pZGVtcG90ZW5jeUtleSA9IChfYSA9IG9iamVjdC5pZGVtcG90ZW5jeUtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gKF9iID0gb2JqZWN0LmNvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0ID1cbiAgICAgICAgICAgIG9iamVjdC5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlcXVlc3QgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VIaXN0b3J5UmVxdWVzdC5mcm9tUGFydGlhbChvYmplY3QucmVxdWVzdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5yZXBseSA9XG4gICAgICAgICAgICBvYmplY3QucmVwbHkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVwbHkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VIaXN0b3J5UmVwbHkuZnJvbVBhcnRpYWwob2JqZWN0LnJlcGx5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXNzYWdlSGlzdG9yeVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHsgcmVxdWVzdElkOiBcIlwiLCBwaW5Db2RlOiBcIlwiIH07XG59XG5leHBvcnQgY29uc3QgTWVzc2FnZUhpc3RvcnlSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5waW5Db2RlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5waW5Db2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VIaXN0b3J5UmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGluQ29kZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdElkOiBpc1NldChvYmplY3QucmVxdWVzdElkKSA/IFN0cmluZyhvYmplY3QucmVxdWVzdElkKSA6IFwiXCIsXG4gICAgICAgICAgICBwaW5Db2RlOiBpc1NldChvYmplY3QucGluQ29kZSkgPyBTdHJpbmcob2JqZWN0LnBpbkNvZGUpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkICYmIChvYmoucmVxdWVzdElkID0gbWVzc2FnZS5yZXF1ZXN0SWQpO1xuICAgICAgICBtZXNzYWdlLnBpbkNvZGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnBpbkNvZGUgPSBtZXNzYWdlLnBpbkNvZGUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhpc3RvcnlSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gKF9hID0gb2JqZWN0LnJlcXVlc3RJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5waW5Db2RlID0gKF9iID0gb2JqZWN0LnBpbkNvZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lc3NhZ2VIaXN0b3J5UmVwbHkoKSB7XG4gICAgcmV0dXJuIHsgcmVxdWVzdElkOiBcIlwiLCB1cmw6IFwiXCIsIGVuY3J5cHRpb25LZXk6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VIaXN0b3J5UmVwbHkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVxdWVzdElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5yZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVybCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lbmNyeXB0aW9uS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VIaXN0b3J5S2V5VHlwZS5lbmNvZGUobWVzc2FnZS5lbmNyeXB0aW9uS2V5LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhpc3RvcnlSZXBseSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXJsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5jcnlwdGlvbktleSA9IE1lc3NhZ2VIaXN0b3J5S2V5VHlwZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IGlzU2V0KG9iamVjdC5yZXF1ZXN0SWQpID8gU3RyaW5nKG9iamVjdC5yZXF1ZXN0SWQpIDogXCJcIixcbiAgICAgICAgICAgIHVybDogaXNTZXQob2JqZWN0LnVybCkgPyBTdHJpbmcob2JqZWN0LnVybCkgOiBcIlwiLFxuICAgICAgICAgICAgZW5jcnlwdGlvbktleTogaXNTZXQob2JqZWN0LmVuY3J5cHRpb25LZXkpXG4gICAgICAgICAgICAgICAgPyBNZXNzYWdlSGlzdG9yeUtleVR5cGUuZnJvbUpTT04ob2JqZWN0LmVuY3J5cHRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnJlcXVlc3RJZCA9IG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICAgICAgbWVzc2FnZS51cmwgIT09IHVuZGVmaW5lZCAmJiAob2JqLnVybCA9IG1lc3NhZ2UudXJsKTtcbiAgICAgICAgbWVzc2FnZS5lbmNyeXB0aW9uS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZW5jcnlwdGlvbktleSA9IG1lc3NhZ2UuZW5jcnlwdGlvbktleVxuICAgICAgICAgICAgICAgID8gTWVzc2FnZUhpc3RvcnlLZXlUeXBlLnRvSlNPTihtZXNzYWdlLmVuY3J5cHRpb25LZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZUhpc3RvcnlSZXBseSgpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IChfYSA9IG9iamVjdC5yZXF1ZXN0SWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudXJsID0gKF9iID0gb2JqZWN0LnVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5lbmNyeXB0aW9uS2V5ID1cbiAgICAgICAgICAgIG9iamVjdC5lbmNyeXB0aW9uS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVuY3J5cHRpb25LZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1lc3NhZ2VIaXN0b3J5S2V5VHlwZS5mcm9tUGFydGlhbChvYmplY3QuZW5jcnlwdGlvbktleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTWVzc2FnZUhpc3RvcnlLZXlUeXBlKCkge1xuICAgIHJldHVybiB7IGNoYWNoYTIwUG9seTEzMDU6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VIaXN0b3J5S2V5VHlwZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFjaGEyMFBvbHkxMzA1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuY2hhY2hhMjBQb2x5MTMwNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlSGlzdG9yeUtleVR5cGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYWNoYTIwUG9seTEzMDUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhY2hhMjBQb2x5MTMwNTogaXNTZXQob2JqZWN0LmNoYWNoYTIwUG9seTEzMDUpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmNoYWNoYTIwUG9seTEzMDUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jaGFjaGEyMFBvbHkxMzA1ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY2hhY2hhMjBQb2x5MTMwNSA9XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFjaGEyMFBvbHkxMzA1ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5jaGFjaGEyMFBvbHkxMzA1KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lc3NhZ2VIaXN0b3J5S2V5VHlwZSgpO1xuICAgICAgICBtZXNzYWdlLmNoYWNoYTIwUG9seTEzMDUgPSAoX2EgPSBvYmplY3QuY2hhY2hhMjBQb2x5MTMwNSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICAgIH1cbn1cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRlbnQucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/content.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_membership.pb.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_membership.pb.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupMembership: () => (/* binding */ GroupMembership),\n/* harmony export */   GroupMembership_MembersEntry: () => (/* binding */ GroupMembership_MembersEntry),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.message_contents\";\nfunction createBaseGroupMembership() {\n    return { members: {} };\n}\nconst GroupMembership = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        Object.entries(message.members).forEach(([key, value]) => {\n            GroupMembership_MembersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMembership();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = GroupMembership_MembersEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.members[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            members: isObject(object.members)\n                ? Object.entries(object.members).reduce((acc, [key, value]) => {\n                    acc[key] = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.members = {};\n        if (message.members) {\n            Object.entries(message.members).forEach(([k, v]) => {\n                obj.members[k] = v.toString();\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGroupMembership();\n        message.members = Object.entries((_a = object.members) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseGroupMembership_MembersEntry() {\n    return { key: \"\", value: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO };\n}\nconst GroupMembership_MembersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (!message.value.isZero()) {\n            writer.uint32(16).uint64(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMembership_MembersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.value) : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined &&\n            (obj.value = (message.value || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGroupMembership_MembersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.value)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=group_membership.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL21lc3NhZ2VfY29udGVudHMvZ3JvdXBfbWVtYmVyc2hpcC5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNhO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBLGtEQUFrRCxpQkFBaUI7QUFDbkUsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0Q0FBSTtBQUNuQztBQUNBLGlCQUFpQixJQUFJO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQSwyQkFBMkIsNENBQUk7QUFDL0I7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQiw0Q0FBSTtBQUNqQztBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNENBQUksMkJBQTJCLDRDQUFJO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRDQUFJO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSTtBQUN0QixrQkFBa0IsNENBQUk7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21scy9tZXNzYWdlX2NvbnRlbnRzL2dyb3VwX21lbWJlcnNoaXAucGIuanM/ZjgxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tbHMubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdyb3VwTWVtYmVyc2hpcCgpIHtcbiAgICByZXR1cm4geyBtZW1iZXJzOiB7fSB9O1xufVxuZXhwb3J0IGNvbnN0IEdyb3VwTWVtYmVyc2hpcCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLm1lbWJlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgR3JvdXBNZW1iZXJzaGlwX01lbWJlcnNFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZW1iZXJzaGlwKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkxID0gR3JvdXBNZW1iZXJzaGlwX01lbWJlcnNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkxLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVtYmVyc1tlbnRyeTEua2V5XSA9IGVudHJ5MS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZW1iZXJzOiBpc09iamVjdChvYmplY3QubWVtYmVycylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5tZW1iZXJzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gTG9uZy5mcm9tVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLm1lbWJlcnMgPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVtYmVycykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5tZW1iZXJzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBvYmoubWVtYmVyc1trXSA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTWVtYmVyc2hpcCgpO1xuICAgICAgICBtZXNzYWdlLm1lbWJlcnMgPSBPYmplY3QuZW50cmllcygoX2EgPSBvYmplY3QubWVtYmVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBMb25nLmZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdyb3VwTWVtYmVyc2hpcF9NZW1iZXJzRW50cnkoKSB7XG4gICAgcmV0dXJuIHsga2V5OiBcIlwiLCB2YWx1ZTogTG9uZy5VWkVSTyB9O1xufVxuZXhwb3J0IGNvbnN0IEdyb3VwTWVtYmVyc2hpcF9NZW1iZXJzRW50cnkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZS52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZW1iZXJzaGlwX01lbWJlcnNFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudmFsdWUpIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsdWUgPSAobWVzc2FnZS52YWx1ZSB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZW1iZXJzaGlwX01lbWJlcnNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IChfYSA9IG9iamVjdC5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gICAgX20wLnV0aWwuTG9uZyA9IExvbmc7XG4gICAgX20wLmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwX21lbWJlcnNoaXAucGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_membership.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_metadata.pb.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_metadata.pb.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConversationType: () => (/* binding */ ConversationType),\n/* harmony export */   DmMembers: () => (/* binding */ DmMembers),\n/* harmony export */   GroupMetadataV1: () => (/* binding */ GroupMetadataV1),\n/* harmony export */   Inbox: () => (/* binding */ Inbox),\n/* harmony export */   conversationTypeFromJSON: () => (/* binding */ conversationTypeFromJSON),\n/* harmony export */   conversationTypeToJSON: () => (/* binding */ conversationTypeToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.message_contents\";\n/** Group immutable metadata */\n/** Defines the type of conversation */\nvar ConversationType;\n(function (ConversationType) {\n    ConversationType[ConversationType[\"CONVERSATION_TYPE_UNSPECIFIED\"] = 0] = \"CONVERSATION_TYPE_UNSPECIFIED\";\n    ConversationType[ConversationType[\"CONVERSATION_TYPE_GROUP\"] = 1] = \"CONVERSATION_TYPE_GROUP\";\n    ConversationType[ConversationType[\"CONVERSATION_TYPE_DM\"] = 2] = \"CONVERSATION_TYPE_DM\";\n    ConversationType[ConversationType[\"CONVERSATION_TYPE_SYNC\"] = 3] = \"CONVERSATION_TYPE_SYNC\";\n    ConversationType[ConversationType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ConversationType || (ConversationType = {}));\nfunction conversationTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"CONVERSATION_TYPE_UNSPECIFIED\":\n            return ConversationType.CONVERSATION_TYPE_UNSPECIFIED;\n        case 1:\n        case \"CONVERSATION_TYPE_GROUP\":\n            return ConversationType.CONVERSATION_TYPE_GROUP;\n        case 2:\n        case \"CONVERSATION_TYPE_DM\":\n            return ConversationType.CONVERSATION_TYPE_DM;\n        case 3:\n        case \"CONVERSATION_TYPE_SYNC\":\n            return ConversationType.CONVERSATION_TYPE_SYNC;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ConversationType.UNRECOGNIZED;\n    }\n}\nfunction conversationTypeToJSON(object) {\n    switch (object) {\n        case ConversationType.CONVERSATION_TYPE_UNSPECIFIED:\n            return \"CONVERSATION_TYPE_UNSPECIFIED\";\n        case ConversationType.CONVERSATION_TYPE_GROUP:\n            return \"CONVERSATION_TYPE_GROUP\";\n        case ConversationType.CONVERSATION_TYPE_DM:\n            return \"CONVERSATION_TYPE_DM\";\n        case ConversationType.CONVERSATION_TYPE_SYNC:\n            return \"CONVERSATION_TYPE_SYNC\";\n        case ConversationType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseGroupMetadataV1() {\n    return {\n        conversationType: 0,\n        creatorAccountAddress: \"\",\n        creatorInboxId: \"\",\n        dmMembers: undefined,\n    };\n}\nconst GroupMetadataV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.conversationType !== 0) {\n            writer.uint32(8).int32(message.conversationType);\n        }\n        if (message.creatorAccountAddress !== \"\") {\n            writer.uint32(18).string(message.creatorAccountAddress);\n        }\n        if (message.creatorInboxId !== \"\") {\n            writer.uint32(26).string(message.creatorInboxId);\n        }\n        if (message.dmMembers !== undefined) {\n            DmMembers.encode(message.dmMembers, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMetadataV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.conversationType = reader.int32();\n                    break;\n                case 2:\n                    message.creatorAccountAddress = reader.string();\n                    break;\n                case 3:\n                    message.creatorInboxId = reader.string();\n                    break;\n                case 4:\n                    message.dmMembers = DmMembers.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            conversationType: isSet(object.conversationType)\n                ? conversationTypeFromJSON(object.conversationType)\n                : 0,\n            creatorAccountAddress: isSet(object.creatorAccountAddress)\n                ? String(object.creatorAccountAddress)\n                : \"\",\n            creatorInboxId: isSet(object.creatorInboxId)\n                ? String(object.creatorInboxId)\n                : \"\",\n            dmMembers: isSet(object.dmMembers)\n                ? DmMembers.fromJSON(object.dmMembers)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.conversationType !== undefined &&\n            (obj.conversationType = conversationTypeToJSON(message.conversationType));\n        message.creatorAccountAddress !== undefined &&\n            (obj.creatorAccountAddress = message.creatorAccountAddress);\n        message.creatorInboxId !== undefined &&\n            (obj.creatorInboxId = message.creatorInboxId);\n        message.dmMembers !== undefined &&\n            (obj.dmMembers = message.dmMembers\n                ? DmMembers.toJSON(message.dmMembers)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseGroupMetadataV1();\n        message.conversationType = (_a = object.conversationType) !== null && _a !== void 0 ? _a : 0;\n        message.creatorAccountAddress = (_b = object.creatorAccountAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.creatorInboxId = (_c = object.creatorInboxId) !== null && _c !== void 0 ? _c : \"\";\n        message.dmMembers =\n            object.dmMembers !== undefined && object.dmMembers !== null\n                ? DmMembers.fromPartial(object.dmMembers)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseInbox() {\n    return { inboxId: \"\" };\n}\nconst Inbox = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInbox();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInbox();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseDmMembers() {\n    return { dmMemberOne: undefined, dmMemberTwo: undefined };\n}\nconst DmMembers = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.dmMemberOne !== undefined) {\n            Inbox.encode(message.dmMemberOne, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.dmMemberTwo !== undefined) {\n            Inbox.encode(message.dmMemberTwo, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDmMembers();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dmMemberOne = Inbox.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.dmMemberTwo = Inbox.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            dmMemberOne: isSet(object.dmMemberOne)\n                ? Inbox.fromJSON(object.dmMemberOne)\n                : undefined,\n            dmMemberTwo: isSet(object.dmMemberTwo)\n                ? Inbox.fromJSON(object.dmMemberTwo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.dmMemberOne !== undefined &&\n            (obj.dmMemberOne = message.dmMemberOne\n                ? Inbox.toJSON(message.dmMemberOne)\n                : undefined);\n        message.dmMemberTwo !== undefined &&\n            (obj.dmMemberTwo = message.dmMemberTwo\n                ? Inbox.toJSON(message.dmMemberTwo)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDmMembers();\n        message.dmMemberOne =\n            object.dmMemberOne !== undefined && object.dmMemberOne !== null\n                ? Inbox.fromPartial(object.dmMemberOne)\n                : undefined;\n        message.dmMemberTwo =\n            object.dmMemberTwo !== undefined && object.dmMemberTwo !== null\n                ? Inbox.fromPartial(object.dmMemberTwo)\n                : undefined;\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=group_metadata.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL21lc3NhZ2VfY29udGVudHMvZ3JvdXBfbWV0YWRhdGEucGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ2E7QUFDOUI7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUN0QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msa0VBQVUsZUFBZSxrRUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tbHMvbWVzc2FnZV9jb250ZW50cy9ncm91cF9tZXRhZGF0YS5wYi5qcz8wYzA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1scy5tZXNzYWdlX2NvbnRlbnRzXCI7XG4vKiogR3JvdXAgaW1tdXRhYmxlIG1ldGFkYXRhICovXG4vKiogRGVmaW5lcyB0aGUgdHlwZSBvZiBjb252ZXJzYXRpb24gKi9cbmV4cG9ydCB2YXIgQ29udmVyc2F0aW9uVHlwZTtcbihmdW5jdGlvbiAoQ29udmVyc2F0aW9uVHlwZSkge1xuICAgIENvbnZlcnNhdGlvblR5cGVbQ29udmVyc2F0aW9uVHlwZVtcIkNPTlZFUlNBVElPTl9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkNPTlZFUlNBVElPTl9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgQ29udmVyc2F0aW9uVHlwZVtDb252ZXJzYXRpb25UeXBlW1wiQ09OVkVSU0FUSU9OX1RZUEVfR1JPVVBcIl0gPSAxXSA9IFwiQ09OVkVSU0FUSU9OX1RZUEVfR1JPVVBcIjtcbiAgICBDb252ZXJzYXRpb25UeXBlW0NvbnZlcnNhdGlvblR5cGVbXCJDT05WRVJTQVRJT05fVFlQRV9ETVwiXSA9IDJdID0gXCJDT05WRVJTQVRJT05fVFlQRV9ETVwiO1xuICAgIENvbnZlcnNhdGlvblR5cGVbQ29udmVyc2F0aW9uVHlwZVtcIkNPTlZFUlNBVElPTl9UWVBFX1NZTkNcIl0gPSAzXSA9IFwiQ09OVkVSU0FUSU9OX1RZUEVfU1lOQ1wiO1xuICAgIENvbnZlcnNhdGlvblR5cGVbQ29udmVyc2F0aW9uVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShDb252ZXJzYXRpb25UeXBlIHx8IChDb252ZXJzYXRpb25UeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJzYXRpb25UeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiQ09OVkVSU0FUSU9OX1RZUEVfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBDb252ZXJzYXRpb25UeXBlLkNPTlZFUlNBVElPTl9UWVBFX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJDT05WRVJTQVRJT05fVFlQRV9HUk9VUFwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbnZlcnNhdGlvblR5cGUuQ09OVkVSU0FUSU9OX1RZUEVfR1JPVVA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIkNPTlZFUlNBVElPTl9UWVBFX0RNXCI6XG4gICAgICAgICAgICByZXR1cm4gQ29udmVyc2F0aW9uVHlwZS5DT05WRVJTQVRJT05fVFlQRV9ETTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiQ09OVkVSU0FUSU9OX1RZUEVfU1lOQ1wiOlxuICAgICAgICAgICAgcmV0dXJuIENvbnZlcnNhdGlvblR5cGUuQ09OVkVSU0FUSU9OX1RZUEVfU1lOQztcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENvbnZlcnNhdGlvblR5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJzYXRpb25UeXBlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQ29udmVyc2F0aW9uVHlwZS5DT05WRVJTQVRJT05fVFlQRV9VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlZFUlNBVElPTl9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgQ29udmVyc2F0aW9uVHlwZS5DT05WRVJTQVRJT05fVFlQRV9HUk9VUDpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlZFUlNBVElPTl9UWVBFX0dST1VQXCI7XG4gICAgICAgIGNhc2UgQ29udmVyc2F0aW9uVHlwZS5DT05WRVJTQVRJT05fVFlQRV9ETTpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlZFUlNBVElPTl9UWVBFX0RNXCI7XG4gICAgICAgIGNhc2UgQ29udmVyc2F0aW9uVHlwZS5DT05WRVJTQVRJT05fVFlQRV9TWU5DOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ09OVkVSU0FUSU9OX1RZUEVfU1lOQ1wiO1xuICAgICAgICBjYXNlIENvbnZlcnNhdGlvblR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5SRUNPR05JWkVEXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmFzZUdyb3VwTWV0YWRhdGFWMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb252ZXJzYXRpb25UeXBlOiAwLFxuICAgICAgICBjcmVhdG9yQWNjb3VudEFkZHJlc3M6IFwiXCIsXG4gICAgICAgIGNyZWF0b3JJbmJveElkOiBcIlwiLFxuICAgICAgICBkbU1lbWJlcnM6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IEdyb3VwTWV0YWRhdGFWMSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25UeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UuY29udmVyc2F0aW9uVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRvckFjY291bnRBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5jcmVhdG9yQWNjb3VudEFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNyZWF0b3JJbmJveElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5jcmVhdG9ySW5ib3hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZG1NZW1iZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIERtTWVtYmVycy5lbmNvZGUobWVzc2FnZS5kbU1lbWJlcnMsIHdyaXRlci51aW50MzIoMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cE1ldGFkYXRhVjEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvblR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0b3JBY2NvdW50QWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0b3JJbmJveElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG1NZW1iZXJzID0gRG1NZW1iZXJzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvblR5cGU6IGlzU2V0KG9iamVjdC5jb252ZXJzYXRpb25UeXBlKVxuICAgICAgICAgICAgICAgID8gY29udmVyc2F0aW9uVHlwZUZyb21KU09OKG9iamVjdC5jb252ZXJzYXRpb25UeXBlKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGNyZWF0b3JBY2NvdW50QWRkcmVzczogaXNTZXQob2JqZWN0LmNyZWF0b3JBY2NvdW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuY3JlYXRvckFjY291bnRBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGNyZWF0b3JJbmJveElkOiBpc1NldChvYmplY3QuY3JlYXRvckluYm94SWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNyZWF0b3JJbmJveElkKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGRtTWVtYmVyczogaXNTZXQob2JqZWN0LmRtTWVtYmVycylcbiAgICAgICAgICAgICAgICA/IERtTWVtYmVycy5mcm9tSlNPTihvYmplY3QuZG1NZW1iZXJzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29udmVyc2F0aW9uVHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnZlcnNhdGlvblR5cGUgPSBjb252ZXJzYXRpb25UeXBlVG9KU09OKG1lc3NhZ2UuY29udmVyc2F0aW9uVHlwZSkpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0b3JBY2NvdW50QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0b3JBY2NvdW50QWRkcmVzcyA9IG1lc3NhZ2UuY3JlYXRvckFjY291bnRBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdG9ySW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0b3JJbmJveElkID0gbWVzc2FnZS5jcmVhdG9ySW5ib3hJZCk7XG4gICAgICAgIG1lc3NhZ2UuZG1NZW1iZXJzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZG1NZW1iZXJzID0gbWVzc2FnZS5kbU1lbWJlcnNcbiAgICAgICAgICAgICAgICA/IERtTWVtYmVycy50b0pTT04obWVzc2FnZS5kbU1lbWJlcnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTWV0YWRhdGFWMSgpO1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvblR5cGUgPSAoX2EgPSBvYmplY3QuY29udmVyc2F0aW9uVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS5jcmVhdG9yQWNjb3VudEFkZHJlc3MgPSAoX2IgPSBvYmplY3QuY3JlYXRvckFjY291bnRBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNyZWF0b3JJbmJveElkID0gKF9jID0gb2JqZWN0LmNyZWF0b3JJbmJveElkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmRtTWVtYmVycyA9XG4gICAgICAgICAgICBvYmplY3QuZG1NZW1iZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRtTWVtYmVycyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gRG1NZW1iZXJzLmZyb21QYXJ0aWFsKG9iamVjdC5kbU1lbWJlcnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUluYm94KCkge1xuICAgIHJldHVybiB7IGluYm94SWQ6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBJbmJveCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pbmJveElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5pbmJveElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluYm94KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmJveElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmJveElkOiBpc1NldChvYmplY3QuaW5ib3hJZCkgPyBTdHJpbmcob2JqZWN0LmluYm94SWQpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmluYm94SWQgPSBtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbmJveCgpO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgPSAoX2EgPSBvYmplY3QuaW5ib3hJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRG1NZW1iZXJzKCkge1xuICAgIHJldHVybiB7IGRtTWVtYmVyT25lOiB1bmRlZmluZWQsIGRtTWVtYmVyVHdvOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydCBjb25zdCBEbU1lbWJlcnMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZG1NZW1iZXJPbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW5ib3guZW5jb2RlKG1lc3NhZ2UuZG1NZW1iZXJPbmUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZG1NZW1iZXJUd28gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgSW5ib3guZW5jb2RlKG1lc3NhZ2UuZG1NZW1iZXJUd28sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEbU1lbWJlcnMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRtTWVtYmVyT25lID0gSW5ib3guZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRtTWVtYmVyVHdvID0gSW5ib3guZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG1NZW1iZXJPbmU6IGlzU2V0KG9iamVjdC5kbU1lbWJlck9uZSlcbiAgICAgICAgICAgICAgICA/IEluYm94LmZyb21KU09OKG9iamVjdC5kbU1lbWJlck9uZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRtTWVtYmVyVHdvOiBpc1NldChvYmplY3QuZG1NZW1iZXJUd28pXG4gICAgICAgICAgICAgICAgPyBJbmJveC5mcm9tSlNPTihvYmplY3QuZG1NZW1iZXJUd28pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kbU1lbWJlck9uZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRtTWVtYmVyT25lID0gbWVzc2FnZS5kbU1lbWJlck9uZVxuICAgICAgICAgICAgICAgID8gSW5ib3gudG9KU09OKG1lc3NhZ2UuZG1NZW1iZXJPbmUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmRtTWVtYmVyVHdvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZG1NZW1iZXJUd28gPSBtZXNzYWdlLmRtTWVtYmVyVHdvXG4gICAgICAgICAgICAgICAgPyBJbmJveC50b0pTT04obWVzc2FnZS5kbU1lbWJlclR3bylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEbU1lbWJlcnMoKTtcbiAgICAgICAgbWVzc2FnZS5kbU1lbWJlck9uZSA9XG4gICAgICAgICAgICBvYmplY3QuZG1NZW1iZXJPbmUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZG1NZW1iZXJPbmUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEluYm94LmZyb21QYXJ0aWFsKG9iamVjdC5kbU1lbWJlck9uZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5kbU1lbWJlclR3byA9XG4gICAgICAgICAgICBvYmplY3QuZG1NZW1iZXJUd28gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZG1NZW1iZXJUd28gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEluYm94LmZyb21QYXJ0aWFsKG9iamVjdC5kbU1lbWJlclR3bylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cF9tZXRhZGF0YS5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_metadata.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_mutable_metadata.pb.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_mutable_metadata.pb.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupMutableMetadataV1: () => (/* binding */ GroupMutableMetadataV1),\n/* harmony export */   GroupMutableMetadataV1_AttributesEntry: () => (/* binding */ GroupMutableMetadataV1_AttributesEntry),\n/* harmony export */   Inboxes: () => (/* binding */ Inboxes),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.message_contents\";\nfunction createBaseGroupMutableMetadataV1() {\n    return { attributes: {}, adminList: undefined, superAdminList: undefined };\n}\nconst GroupMutableMetadataV1 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        Object.entries(message.attributes).forEach(([key, value]) => {\n            GroupMutableMetadataV1_AttributesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        if (message.adminList !== undefined) {\n            Inboxes.encode(message.adminList, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.superAdminList !== undefined) {\n            Inboxes.encode(message.superAdminList, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMutableMetadataV1();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = GroupMutableMetadataV1_AttributesEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.attributes[entry1.key] = entry1.value;\n                    }\n                    break;\n                case 2:\n                    message.adminList = Inboxes.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.superAdminList = Inboxes.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            attributes: isObject(object.attributes)\n                ? Object.entries(object.attributes).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n            adminList: isSet(object.adminList)\n                ? Inboxes.fromJSON(object.adminList)\n                : undefined,\n            superAdminList: isSet(object.superAdminList)\n                ? Inboxes.fromJSON(object.superAdminList)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.attributes = {};\n        if (message.attributes) {\n            Object.entries(message.attributes).forEach(([k, v]) => {\n                obj.attributes[k] = v;\n            });\n        }\n        message.adminList !== undefined &&\n            (obj.adminList = message.adminList\n                ? Inboxes.toJSON(message.adminList)\n                : undefined);\n        message.superAdminList !== undefined &&\n            (obj.superAdminList = message.superAdminList\n                ? Inboxes.toJSON(message.superAdminList)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGroupMutableMetadataV1();\n        message.attributes = Object.entries((_a = object.attributes) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        message.adminList =\n            object.adminList !== undefined && object.adminList !== null\n                ? Inboxes.fromPartial(object.adminList)\n                : undefined;\n        message.superAdminList =\n            object.superAdminList !== undefined && object.superAdminList !== null\n                ? Inboxes.fromPartial(object.superAdminList)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseGroupMutableMetadataV1_AttributesEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst GroupMutableMetadataV1_AttributesEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMutableMetadataV1_AttributesEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGroupMutableMetadataV1_AttributesEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseInboxes() {\n    return { inboxIds: [] };\n}\nconst Inboxes = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.inboxIds) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInboxes();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds)\n                ? object.inboxIds.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.inboxIds) {\n            obj.inboxIds = message.inboxIds.map((e) => e);\n        }\n        else {\n            obj.inboxIds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseInboxes();\n        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=group_mutable_metadata.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL21lc3NhZ2VfY29udGVudHMvZ3JvdXBfbXV0YWJsZV9tZXRhZGF0YS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDd0I7QUFDYTtBQUM5QjtBQUNQO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUCw2QkFBNkIsZ0VBQVU7QUFDdkM7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tbHMvbWVzc2FnZV9jb250ZW50cy9ncm91cF9tdXRhYmxlX21ldGFkYXRhLnBiLmpzPzRkOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcInhtdHAubWxzLm1lc3NhZ2VfY29udGVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHcm91cE11dGFibGVNZXRhZGF0YVYxKCkge1xuICAgIHJldHVybiB7IGF0dHJpYnV0ZXM6IHt9LCBhZG1pbkxpc3Q6IHVuZGVmaW5lZCwgc3VwZXJBZG1pbkxpc3Q6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0IGNvbnN0IEdyb3VwTXV0YWJsZU1ldGFkYXRhVjEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIEdyb3VwTXV0YWJsZU1ldGFkYXRhVjFfQXR0cmlidXRlc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRtaW5MaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEluYm94ZXMuZW5jb2RlKG1lc3NhZ2UuYWRtaW5MaXN0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1cGVyQWRtaW5MaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEluYm94ZXMuZW5jb2RlKG1lc3NhZ2Uuc3VwZXJBZG1pbkxpc3QsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cE11dGFibGVNZXRhZGF0YVYxKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkxID0gR3JvdXBNdXRhYmxlTWV0YWRhdGFWMV9BdHRyaWJ1dGVzRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5MS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZXNbZW50cnkxLmtleV0gPSBlbnRyeTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkbWluTGlzdCA9IEluYm94ZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1cGVyQWRtaW5MaXN0ID0gSW5ib3hlcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBpc09iamVjdChvYmplY3QuYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5hdHRyaWJ1dGVzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgYWRtaW5MaXN0OiBpc1NldChvYmplY3QuYWRtaW5MaXN0KVxuICAgICAgICAgICAgICAgID8gSW5ib3hlcy5mcm9tSlNPTihvYmplY3QuYWRtaW5MaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3VwZXJBZG1pbkxpc3Q6IGlzU2V0KG9iamVjdC5zdXBlckFkbWluTGlzdClcbiAgICAgICAgICAgICAgICA/IEluYm94ZXMuZnJvbUpTT04ob2JqZWN0LnN1cGVyQWRtaW5MaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG9iai5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UuYXR0cmlidXRlcykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqLmF0dHJpYnV0ZXNba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5hZG1pbkxpc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hZG1pbkxpc3QgPSBtZXNzYWdlLmFkbWluTGlzdFxuICAgICAgICAgICAgICAgID8gSW5ib3hlcy50b0pTT04obWVzc2FnZS5hZG1pbkxpc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnN1cGVyQWRtaW5MaXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3VwZXJBZG1pbkxpc3QgPSBtZXNzYWdlLnN1cGVyQWRtaW5MaXN0XG4gICAgICAgICAgICAgICAgPyBJbmJveGVzLnRvSlNPTihtZXNzYWdlLnN1cGVyQWRtaW5MaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNdXRhYmxlTWV0YWRhdGFWMSgpO1xuICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcygoX2EgPSBvYmplY3QuYXR0cmlidXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBtZXNzYWdlLmFkbWluTGlzdCA9XG4gICAgICAgICAgICBvYmplY3QuYWRtaW5MaXN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFkbWluTGlzdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSW5ib3hlcy5mcm9tUGFydGlhbChvYmplY3QuYWRtaW5MaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnN1cGVyQWRtaW5MaXN0ID1cbiAgICAgICAgICAgIG9iamVjdC5zdXBlckFkbWluTGlzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zdXBlckFkbWluTGlzdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gSW5ib3hlcy5mcm9tUGFydGlhbChvYmplY3Quc3VwZXJBZG1pbkxpc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdyb3VwTXV0YWJsZU1ldGFkYXRhVjFfQXR0cmlidXRlc0VudHJ5KCkge1xuICAgIHJldHVybiB7IGtleTogXCJcIiwgdmFsdWU6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cE11dGFibGVNZXRhZGF0YVYxX0F0dHJpYnV0ZXNFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTXV0YWJsZU1ldGFkYXRhVjFfQXR0cmlidXRlc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IFN0cmluZyhvYmplY3Qua2V5KSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKSA/IFN0cmluZyhvYmplY3QudmFsdWUpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNdXRhYmxlTWV0YWRhdGFWMV9BdHRyaWJ1dGVzRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2EgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID0gKF9iID0gb2JqZWN0LnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VJbmJveGVzKCkge1xuICAgIHJldHVybiB7IGluYm94SWRzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEluYm94ZXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaW5ib3hJZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluYm94ZXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluYm94SWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5ib3hJZHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmluYm94SWRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmluYm94SWRzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5ib3hJZHMpIHtcbiAgICAgICAgICAgIG9iai5pbmJveElkcyA9IG1lc3NhZ2UuaW5ib3hJZHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbmJveElkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluYm94ZXMoKTtcbiAgICAgICAgbWVzc2FnZS5pbmJveElkcyA9ICgoX2EgPSBvYmplY3QuaW5ib3hJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cF9tdXRhYmxlX21ldGFkYXRhLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/group_mutable_metadata.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/transcript_messages.pb.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/transcript_messages.pb.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupMembershipChanges: () => (/* binding */ GroupMembershipChanges),\n/* harmony export */   GroupUpdated: () => (/* binding */ GroupUpdated),\n/* harmony export */   GroupUpdated_Inbox: () => (/* binding */ GroupUpdated_Inbox),\n/* harmony export */   GroupUpdated_MetadataFieldChange: () => (/* binding */ GroupUpdated_MetadataFieldChange),\n/* harmony export */   MembershipChange: () => (/* binding */ MembershipChange),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\n\n\nconst protobufPackage = \"xmtp.mls.message_contents\";\nfunction createBaseMembershipChange() {\n    return {\n        installationIds: [],\n        accountAddress: \"\",\n        initiatedByAccountAddress: \"\",\n    };\n}\nconst MembershipChange = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.installationIds) {\n            writer.uint32(10).bytes(v);\n        }\n        if (message.accountAddress !== \"\") {\n            writer.uint32(18).string(message.accountAddress);\n        }\n        if (message.initiatedByAccountAddress !== \"\") {\n            writer.uint32(26).string(message.initiatedByAccountAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMembershipChange();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.installationIds.push(reader.bytes());\n                    break;\n                case 2:\n                    message.accountAddress = reader.string();\n                    break;\n                case 3:\n                    message.initiatedByAccountAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            installationIds: Array.isArray(object === null || object === void 0 ? void 0 : object.installationIds)\n                ? object.installationIds.map((e) => bytesFromBase64(e))\n                : [],\n            accountAddress: isSet(object.accountAddress)\n                ? String(object.accountAddress)\n                : \"\",\n            initiatedByAccountAddress: isSet(object.initiatedByAccountAddress)\n                ? String(object.initiatedByAccountAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.installationIds) {\n            obj.installationIds = message.installationIds.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.installationIds = [];\n        }\n        message.accountAddress !== undefined &&\n            (obj.accountAddress = message.accountAddress);\n        message.initiatedByAccountAddress !== undefined &&\n            (obj.initiatedByAccountAddress = message.initiatedByAccountAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMembershipChange();\n        message.installationIds = ((_a = object.installationIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        message.accountAddress = (_b = object.accountAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.initiatedByAccountAddress = (_c = object.initiatedByAccountAddress) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseGroupMembershipChanges() {\n    return {\n        membersAdded: [],\n        membersRemoved: [],\n        installationsAdded: [],\n        installationsRemoved: [],\n    };\n}\nconst GroupMembershipChanges = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        for (const v of message.membersAdded) {\n            MembershipChange.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.membersRemoved) {\n            MembershipChange.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.installationsAdded) {\n            MembershipChange.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.installationsRemoved) {\n            MembershipChange.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupMembershipChanges();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.membersAdded.push(MembershipChange.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.membersRemoved.push(MembershipChange.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.installationsAdded.push(MembershipChange.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.installationsRemoved.push(MembershipChange.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            membersAdded: Array.isArray(object === null || object === void 0 ? void 0 : object.membersAdded)\n                ? object.membersAdded.map((e) => MembershipChange.fromJSON(e))\n                : [],\n            membersRemoved: Array.isArray(object === null || object === void 0 ? void 0 : object.membersRemoved)\n                ? object.membersRemoved.map((e) => MembershipChange.fromJSON(e))\n                : [],\n            installationsAdded: Array.isArray(object === null || object === void 0 ? void 0 : object.installationsAdded)\n                ? object.installationsAdded.map((e) => MembershipChange.fromJSON(e))\n                : [],\n            installationsRemoved: Array.isArray(object === null || object === void 0 ? void 0 : object.installationsRemoved)\n                ? object.installationsRemoved.map((e) => MembershipChange.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.membersAdded) {\n            obj.membersAdded = message.membersAdded.map((e) => e ? MembershipChange.toJSON(e) : undefined);\n        }\n        else {\n            obj.membersAdded = [];\n        }\n        if (message.membersRemoved) {\n            obj.membersRemoved = message.membersRemoved.map((e) => e ? MembershipChange.toJSON(e) : undefined);\n        }\n        else {\n            obj.membersRemoved = [];\n        }\n        if (message.installationsAdded) {\n            obj.installationsAdded = message.installationsAdded.map((e) => e ? MembershipChange.toJSON(e) : undefined);\n        }\n        else {\n            obj.installationsAdded = [];\n        }\n        if (message.installationsRemoved) {\n            obj.installationsRemoved = message.installationsRemoved.map((e) => e ? MembershipChange.toJSON(e) : undefined);\n        }\n        else {\n            obj.installationsRemoved = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseGroupMembershipChanges();\n        message.membersAdded =\n            ((_a = object.membersAdded) === null || _a === void 0 ? void 0 : _a.map((e) => MembershipChange.fromPartial(e))) || [];\n        message.membersRemoved =\n            ((_b = object.membersRemoved) === null || _b === void 0 ? void 0 : _b.map((e) => MembershipChange.fromPartial(e))) || [];\n        message.installationsAdded =\n            ((_c = object.installationsAdded) === null || _c === void 0 ? void 0 : _c.map((e) => MembershipChange.fromPartial(e))) ||\n                [];\n        message.installationsRemoved =\n            ((_d = object.installationsRemoved) === null || _d === void 0 ? void 0 : _d.map((e) => MembershipChange.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGroupUpdated() {\n    return {\n        initiatedByInboxId: \"\",\n        addedInboxes: [],\n        removedInboxes: [],\n        metadataFieldChanges: [],\n    };\n}\nconst GroupUpdated = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.initiatedByInboxId !== \"\") {\n            writer.uint32(10).string(message.initiatedByInboxId);\n        }\n        for (const v of message.addedInboxes) {\n            GroupUpdated_Inbox.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.removedInboxes) {\n            GroupUpdated_Inbox.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.metadataFieldChanges) {\n            GroupUpdated_MetadataFieldChange.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupUpdated();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.initiatedByInboxId = reader.string();\n                    break;\n                case 2:\n                    message.addedInboxes.push(GroupUpdated_Inbox.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.removedInboxes.push(GroupUpdated_Inbox.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.metadataFieldChanges.push(GroupUpdated_MetadataFieldChange.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            initiatedByInboxId: isSet(object.initiatedByInboxId)\n                ? String(object.initiatedByInboxId)\n                : \"\",\n            addedInboxes: Array.isArray(object === null || object === void 0 ? void 0 : object.addedInboxes)\n                ? object.addedInboxes.map((e) => GroupUpdated_Inbox.fromJSON(e))\n                : [],\n            removedInboxes: Array.isArray(object === null || object === void 0 ? void 0 : object.removedInboxes)\n                ? object.removedInboxes.map((e) => GroupUpdated_Inbox.fromJSON(e))\n                : [],\n            metadataFieldChanges: Array.isArray(object === null || object === void 0 ? void 0 : object.metadataFieldChanges)\n                ? object.metadataFieldChanges.map((e) => GroupUpdated_MetadataFieldChange.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.initiatedByInboxId !== undefined &&\n            (obj.initiatedByInboxId = message.initiatedByInboxId);\n        if (message.addedInboxes) {\n            obj.addedInboxes = message.addedInboxes.map((e) => e ? GroupUpdated_Inbox.toJSON(e) : undefined);\n        }\n        else {\n            obj.addedInboxes = [];\n        }\n        if (message.removedInboxes) {\n            obj.removedInboxes = message.removedInboxes.map((e) => e ? GroupUpdated_Inbox.toJSON(e) : undefined);\n        }\n        else {\n            obj.removedInboxes = [];\n        }\n        if (message.metadataFieldChanges) {\n            obj.metadataFieldChanges = message.metadataFieldChanges.map((e) => e ? GroupUpdated_MetadataFieldChange.toJSON(e) : undefined);\n        }\n        else {\n            obj.metadataFieldChanges = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseGroupUpdated();\n        message.initiatedByInboxId = (_a = object.initiatedByInboxId) !== null && _a !== void 0 ? _a : \"\";\n        message.addedInboxes =\n            ((_b = object.addedInboxes) === null || _b === void 0 ? void 0 : _b.map((e) => GroupUpdated_Inbox.fromPartial(e))) || [];\n        message.removedInboxes =\n            ((_c = object.removedInboxes) === null || _c === void 0 ? void 0 : _c.map((e) => GroupUpdated_Inbox.fromPartial(e))) ||\n                [];\n        message.metadataFieldChanges =\n            ((_d = object.metadataFieldChanges) === null || _d === void 0 ? void 0 : _d.map((e) => GroupUpdated_MetadataFieldChange.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGroupUpdated_Inbox() {\n    return { inboxId: \"\" };\n}\nconst GroupUpdated_Inbox = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.inboxId !== \"\") {\n            writer.uint32(10).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupUpdated_Inbox();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGroupUpdated_Inbox();\n        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGroupUpdated_MetadataFieldChange() {\n    return { fieldName: \"\", oldValue: undefined, newValue: undefined };\n}\nconst GroupUpdated_MetadataFieldChange = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\n        if (message.fieldName !== \"\") {\n            writer.uint32(10).string(message.fieldName);\n        }\n        if (message.oldValue !== undefined) {\n            writer.uint32(18).string(message.oldValue);\n        }\n        if (message.newValue !== undefined) {\n            writer.uint32(26).string(message.newValue);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGroupUpdated_MetadataFieldChange();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fieldName = reader.string();\n                    break;\n                case 2:\n                    message.oldValue = reader.string();\n                    break;\n                case 3:\n                    message.newValue = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            fieldName: isSet(object.fieldName) ? String(object.fieldName) : \"\",\n            oldValue: isSet(object.oldValue) ? String(object.oldValue) : undefined,\n            newValue: isSet(object.newValue) ? String(object.newValue) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.fieldName !== undefined && (obj.fieldName = message.fieldName);\n        message.oldValue !== undefined && (obj.oldValue = message.oldValue);\n        message.newValue !== undefined && (obj.newValue = message.newValue);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseGroupUpdated_MetadataFieldChange();\n        message.fieldName = (_a = object.fieldName) !== null && _a !== void 0 ? _a : \"\";\n        message.oldValue = (_b = object.oldValue) !== null && _b !== void 0 ? _b : undefined;\n        message.newValue = (_c = object.newValue) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=transcript_messages.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzL21lc3NhZ2VfY29udGVudHMvdHJhbnNjcmlwdF9tZXNzYWdlcy5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QjtBQUNhO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGtFQUFVLGVBQWUsa0VBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFRLFVBQVUsNENBQUk7QUFDMUIsSUFBSSxnRUFBUSxRQUFRLDRDQUFJO0FBQ3hCLElBQUksbUVBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3Byb3RvL3RzL2Rpc3QvZXNtL21scy9tZXNzYWdlX2NvbnRlbnRzL3RyYW5zY3JpcHRfbWVzc2FnZXMucGIuanM/ZTZkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwieG10cC5tbHMubWVzc2FnZV9jb250ZW50c1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1lbWJlcnNoaXBDaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFsbGF0aW9uSWRzOiBbXSxcbiAgICAgICAgYWNjb3VudEFkZHJlc3M6IFwiXCIsXG4gICAgICAgIGluaXRpYXRlZEJ5QWNjb3VudEFkZHJlc3M6IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBNZW1iZXJzaGlwQ2hhbmdlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmluc3RhbGxhdGlvbklkcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWNjb3VudEFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmFjY291bnRBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbml0aWF0ZWRCeUFjY291bnRBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5pbml0aWF0ZWRCeUFjY291bnRBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1lbWJlcnNoaXBDaGFuZ2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjY291bnRBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSWRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbnN0YWxsYXRpb25JZHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuaW5zdGFsbGF0aW9uSWRzLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBhY2NvdW50QWRkcmVzczogaXNTZXQob2JqZWN0LmFjY291bnRBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5hY2NvdW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBpbml0aWF0ZWRCeUFjY291bnRBZGRyZXNzOiBpc1NldChvYmplY3QuaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRzKSB7XG4gICAgICAgICAgICBvYmouaW5zdGFsbGF0aW9uSWRzID0gbWVzc2FnZS5pbnN0YWxsYXRpb25JZHMubWFwKChlKSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbnN0YWxsYXRpb25JZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmFjY291bnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWNjb3VudEFkZHJlc3MgPSBtZXNzYWdlLmFjY291bnRBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5pbml0aWF0ZWRCeUFjY291bnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcyA9IG1lc3NhZ2UuaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVtYmVyc2hpcENoYW5nZSgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkcyA9ICgoX2EgPSBvYmplY3QuaW5zdGFsbGF0aW9uSWRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UuYWNjb3VudEFkZHJlc3MgPSAoX2IgPSBvYmplY3QuYWNjb3VudEFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaW5pdGlhdGVkQnlBY2NvdW50QWRkcmVzcyA9IChfYyA9IG9iamVjdC5pbml0aWF0ZWRCeUFjY291bnRBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VHcm91cE1lbWJlcnNoaXBDaGFuZ2VzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lbWJlcnNBZGRlZDogW10sXG4gICAgICAgIG1lbWJlcnNSZW1vdmVkOiBbXSxcbiAgICAgICAgaW5zdGFsbGF0aW9uc0FkZGVkOiBbXSxcbiAgICAgICAgaW5zdGFsbGF0aW9uc1JlbW92ZWQ6IFtdLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgR3JvdXBNZW1iZXJzaGlwQ2hhbmdlcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tZW1iZXJzQWRkZWQpIHtcbiAgICAgICAgICAgIE1lbWJlcnNoaXBDaGFuZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVtYmVyc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIE1lbWJlcnNoaXBDaGFuZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaW5zdGFsbGF0aW9uc0FkZGVkKSB7XG4gICAgICAgICAgICBNZW1iZXJzaGlwQ2hhbmdlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmluc3RhbGxhdGlvbnNSZW1vdmVkKSB7XG4gICAgICAgICAgICBNZW1iZXJzaGlwQ2hhbmdlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBNZW1iZXJzaGlwQ2hhbmdlcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVtYmVyc0FkZGVkLnB1c2goTWVtYmVyc2hpcENoYW5nZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lbWJlcnNSZW1vdmVkLnB1c2goTWVtYmVyc2hpcENoYW5nZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbnNBZGRlZC5wdXNoKE1lbWJlcnNoaXBDaGFuZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25zUmVtb3ZlZC5wdXNoKE1lbWJlcnNoaXBDaGFuZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lbWJlcnNBZGRlZDogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QubWVtYmVyc0FkZGVkKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1lbWJlcnNBZGRlZC5tYXAoKGUpID0+IE1lbWJlcnNoaXBDaGFuZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIG1lbWJlcnNSZW1vdmVkOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5tZW1iZXJzUmVtb3ZlZClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5tZW1iZXJzUmVtb3ZlZC5tYXAoKGUpID0+IE1lbWJlcnNoaXBDaGFuZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbnNBZGRlZDogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuaW5zdGFsbGF0aW9uc0FkZGVkKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lmluc3RhbGxhdGlvbnNBZGRlZC5tYXAoKGUpID0+IE1lbWJlcnNoaXBDaGFuZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbnNSZW1vdmVkOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbnN0YWxsYXRpb25zUmVtb3ZlZClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5pbnN0YWxsYXRpb25zUmVtb3ZlZC5tYXAoKGUpID0+IE1lbWJlcnNoaXBDaGFuZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5tZW1iZXJzQWRkZWQpIHtcbiAgICAgICAgICAgIG9iai5tZW1iZXJzQWRkZWQgPSBtZXNzYWdlLm1lbWJlcnNBZGRlZC5tYXAoKGUpID0+IGUgPyBNZW1iZXJzaGlwQ2hhbmdlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubWVtYmVyc0FkZGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWVtYmVyc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIG9iai5tZW1iZXJzUmVtb3ZlZCA9IG1lc3NhZ2UubWVtYmVyc1JlbW92ZWQubWFwKChlKSA9PiBlID8gTWVtYmVyc2hpcENoYW5nZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1lbWJlcnNSZW1vdmVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5zdGFsbGF0aW9uc0FkZGVkKSB7XG4gICAgICAgICAgICBvYmouaW5zdGFsbGF0aW9uc0FkZGVkID0gbWVzc2FnZS5pbnN0YWxsYXRpb25zQWRkZWQubWFwKChlKSA9PiBlID8gTWVtYmVyc2hpcENoYW5nZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmluc3RhbGxhdGlvbnNBZGRlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvbnNSZW1vdmVkKSB7XG4gICAgICAgICAgICBvYmouaW5zdGFsbGF0aW9uc1JlbW92ZWQgPSBtZXNzYWdlLmluc3RhbGxhdGlvbnNSZW1vdmVkLm1hcCgoZSkgPT4gZSA/IE1lbWJlcnNoaXBDaGFuZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbnN0YWxsYXRpb25zUmVtb3ZlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwTWVtYmVyc2hpcENoYW5nZXMoKTtcbiAgICAgICAgbWVzc2FnZS5tZW1iZXJzQWRkZWQgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5tZW1iZXJzQWRkZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IE1lbWJlcnNoaXBDaGFuZ2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5tZW1iZXJzUmVtb3ZlZCA9XG4gICAgICAgICAgICAoKF9iID0gb2JqZWN0Lm1lbWJlcnNSZW1vdmVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBNZW1iZXJzaGlwQ2hhbmdlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uc0FkZGVkID1cbiAgICAgICAgICAgICgoX2MgPSBvYmplY3QuaW5zdGFsbGF0aW9uc0FkZGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWFwKChlKSA9PiBNZW1iZXJzaGlwQ2hhbmdlLmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25zUmVtb3ZlZCA9XG4gICAgICAgICAgICAoKF9kID0gb2JqZWN0Lmluc3RhbGxhdGlvbnNSZW1vdmVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWFwKChlKSA9PiBNZW1iZXJzaGlwQ2hhbmdlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdyb3VwVXBkYXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbml0aWF0ZWRCeUluYm94SWQ6IFwiXCIsXG4gICAgICAgIGFkZGVkSW5ib3hlczogW10sXG4gICAgICAgIHJlbW92ZWRJbmJveGVzOiBbXSxcbiAgICAgICAgbWV0YWRhdGFGaWVsZENoYW5nZXM6IFtdLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgR3JvdXBVcGRhdGVkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmluaXRpYXRlZEJ5SW5ib3hJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaW5pdGlhdGVkQnlJbmJveElkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5hZGRlZEluYm94ZXMpIHtcbiAgICAgICAgICAgIEdyb3VwVXBkYXRlZF9JbmJveC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZW1vdmVkSW5ib3hlcykge1xuICAgICAgICAgICAgR3JvdXBVcGRhdGVkX0luYm94LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1ldGFkYXRhRmllbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICBHcm91cFVwZGF0ZWRfTWV0YWRhdGFGaWVsZENoYW5nZS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwVXBkYXRlZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhdGVkQnlJbmJveElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkZWRJbmJveGVzLnB1c2goR3JvdXBVcGRhdGVkX0luYm94LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVtb3ZlZEluYm94ZXMucHVzaChHcm91cFVwZGF0ZWRfSW5ib3guZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YUZpZWxkQ2hhbmdlcy5wdXNoKEdyb3VwVXBkYXRlZF9NZXRhZGF0YUZpZWxkQ2hhbmdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWF0ZWRCeUluYm94SWQ6IGlzU2V0KG9iamVjdC5pbml0aWF0ZWRCeUluYm94SWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmluaXRpYXRlZEJ5SW5ib3hJZClcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBhZGRlZEluYm94ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFkZGVkSW5ib3hlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hZGRlZEluYm94ZXMubWFwKChlKSA9PiBHcm91cFVwZGF0ZWRfSW5ib3guZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWRJbmJveGVzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZW1vdmVkSW5ib3hlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZW1vdmVkSW5ib3hlcy5tYXAoKGUpID0+IEdyb3VwVXBkYXRlZF9JbmJveC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGFGaWVsZENoYW5nZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm1ldGFkYXRhRmllbGRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1ldGFkYXRhRmllbGRDaGFuZ2VzLm1hcCgoZSkgPT4gR3JvdXBVcGRhdGVkX01ldGFkYXRhRmllbGRDaGFuZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluaXRpYXRlZEJ5SW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluaXRpYXRlZEJ5SW5ib3hJZCA9IG1lc3NhZ2UuaW5pdGlhdGVkQnlJbmJveElkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkZWRJbmJveGVzKSB7XG4gICAgICAgICAgICBvYmouYWRkZWRJbmJveGVzID0gbWVzc2FnZS5hZGRlZEluYm94ZXMubWFwKChlKSA9PiBlID8gR3JvdXBVcGRhdGVkX0luYm94LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouYWRkZWRJbmJveGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVtb3ZlZEluYm94ZXMpIHtcbiAgICAgICAgICAgIG9iai5yZW1vdmVkSW5ib3hlcyA9IG1lc3NhZ2UucmVtb3ZlZEluYm94ZXMubWFwKChlKSA9PiBlID8gR3JvdXBVcGRhdGVkX0luYm94LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVtb3ZlZEluYm94ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRhZGF0YUZpZWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgb2JqLm1ldGFkYXRhRmllbGRDaGFuZ2VzID0gbWVzc2FnZS5tZXRhZGF0YUZpZWxkQ2hhbmdlcy5tYXAoKGUpID0+IGUgPyBHcm91cFVwZGF0ZWRfTWV0YWRhdGFGaWVsZENoYW5nZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1ldGFkYXRhRmllbGRDaGFuZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR3JvdXBVcGRhdGVkKCk7XG4gICAgICAgIG1lc3NhZ2UuaW5pdGlhdGVkQnlJbmJveElkID0gKF9hID0gb2JqZWN0LmluaXRpYXRlZEJ5SW5ib3hJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hZGRlZEluYm94ZXMgPVxuICAgICAgICAgICAgKChfYiA9IG9iamVjdC5hZGRlZEluYm94ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXAoKGUpID0+IEdyb3VwVXBkYXRlZF9JbmJveC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLnJlbW92ZWRJbmJveGVzID1cbiAgICAgICAgICAgICgoX2MgPSBvYmplY3QucmVtb3ZlZEluYm94ZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAoKGUpID0+IEdyb3VwVXBkYXRlZF9JbmJveC5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIG1lc3NhZ2UubWV0YWRhdGFGaWVsZENoYW5nZXMgPVxuICAgICAgICAgICAgKChfZCA9IG9iamVjdC5tZXRhZGF0YUZpZWxkQ2hhbmdlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1hcCgoZSkgPT4gR3JvdXBVcGRhdGVkX01ldGFkYXRhRmllbGRDaGFuZ2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR3JvdXBVcGRhdGVkX0luYm94KCkge1xuICAgIHJldHVybiB7IGluYm94SWQ6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cFVwZGF0ZWRfSW5ib3ggPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5ib3hJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cFVwZGF0ZWRfSW5ib3goKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluYm94SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluYm94SWQ6IGlzU2V0KG9iamVjdC5pbmJveElkKSA/IFN0cmluZyhvYmplY3QuaW5ib3hJZCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5ib3hJZCA9IG1lc3NhZ2UuaW5ib3hJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwVXBkYXRlZF9JbmJveCgpO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgPSAoX2EgPSBvYmplY3QuaW5ib3hJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlR3JvdXBVcGRhdGVkX01ldGFkYXRhRmllbGRDaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHsgZmllbGROYW1lOiBcIlwiLCBvbGRWYWx1ZTogdW5kZWZpbmVkLCBuZXdWYWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgR3JvdXBVcGRhdGVkX01ldGFkYXRhRmllbGRDaGFuZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZmllbGROYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5maWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLm9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5uZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcm91cFVwZGF0ZWRfTWV0YWRhdGFGaWVsZENoYW5nZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmllbGROYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub2xkVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uZXdWYWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGROYW1lOiBpc1NldChvYmplY3QuZmllbGROYW1lKSA/IFN0cmluZyhvYmplY3QuZmllbGROYW1lKSA6IFwiXCIsXG4gICAgICAgICAgICBvbGRWYWx1ZTogaXNTZXQob2JqZWN0Lm9sZFZhbHVlKSA/IFN0cmluZyhvYmplY3Qub2xkVmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmV3VmFsdWU6IGlzU2V0KG9iamVjdC5uZXdWYWx1ZSkgPyBTdHJpbmcob2JqZWN0Lm5ld1ZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmZpZWxkTmFtZSAhPT0gdW5kZWZpbmVkICYmIChvYmouZmllbGROYW1lID0gbWVzc2FnZS5maWVsZE5hbWUpO1xuICAgICAgICBtZXNzYWdlLm9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai5vbGRWYWx1ZSA9IG1lc3NhZ2Uub2xkVmFsdWUpO1xuICAgICAgICBtZXNzYWdlLm5ld1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgKG9iai5uZXdWYWx1ZSA9IG1lc3NhZ2UubmV3VmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdyb3VwVXBkYXRlZF9NZXRhZGF0YUZpZWxkQ2hhbmdlKCk7XG4gICAgICAgIG1lc3NhZ2UuZmllbGROYW1lID0gKF9hID0gb2JqZWN0LmZpZWxkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5vbGRWYWx1ZSA9IChfYiA9IG9iamVjdC5vbGRWYWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLm5ld1ZhbHVlID0gKF9jID0gb2JqZWN0Lm5ld1ZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluID0gZ2xvYmFsVGhpcy5hdG9iKGI2NCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBbXTtcbiAgICAgICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShiaW4uam9pbihcIlwiKSk7XG4gICAgfVxufVxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgICBfbTAudXRpbC5Mb25nID0gTG9uZztcbiAgICBfbTAuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNjcmlwdF9tZXNzYWdlcy5wYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls/message_contents/transcript_messages.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls_validation/v1/service.pb.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/mls_validation/v1/service.pb.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetAssociationStateRequest: () => (/* binding */ GetAssociationStateRequest),\n/* harmony export */   GetAssociationStateResponse: () => (/* binding */ GetAssociationStateResponse),\n/* harmony export */   ValidateGroupMessagesRequest: () => (/* binding */ ValidateGroupMessagesRequest),\n/* harmony export */   ValidateGroupMessagesRequest_GroupMessage: () => (/* binding */ ValidateGroupMessagesRequest_GroupMessage),\n/* harmony export */   ValidateGroupMessagesResponse: () => (/* binding */ ValidateGroupMessagesResponse),\n/* harmony export */   ValidateGroupMessagesResponse_ValidationResponse: () => (/* binding */ ValidateGroupMessagesResponse_ValidationResponse),\n/* harmony export */   ValidateInboxIdKeyPackagesRequest: () => (/* binding */ ValidateInboxIdKeyPackagesRequest),\n/* harmony export */   ValidateInboxIdKeyPackagesRequest_KeyPackage: () => (/* binding */ ValidateInboxIdKeyPackagesRequest_KeyPackage),\n/* harmony export */   ValidateInboxIdKeyPackagesResponse: () => (/* binding */ ValidateInboxIdKeyPackagesResponse),\n/* harmony export */   ValidateInboxIdKeyPackagesResponse_Response: () => (/* binding */ ValidateInboxIdKeyPackagesResponse_Response),\n/* harmony export */   ValidateInboxIdsRequest: () => (/* binding */ ValidateInboxIdsRequest),\n/* harmony export */   ValidateInboxIdsRequest_ValidationRequest: () => (/* binding */ ValidateInboxIdsRequest_ValidationRequest),\n/* harmony export */   ValidateInboxIdsResponse: () => (/* binding */ ValidateInboxIdsResponse),\n/* harmony export */   ValidateInboxIdsResponse_ValidationResponse: () => (/* binding */ ValidateInboxIdsResponse_ValidationResponse),\n/* harmony export */   ValidateKeyPackagesRequest: () => (/* binding */ ValidateKeyPackagesRequest),\n/* harmony export */   ValidateKeyPackagesRequest_KeyPackage: () => (/* binding */ ValidateKeyPackagesRequest_KeyPackage),\n/* harmony export */   ValidateKeyPackagesResponse: () => (/* binding */ ValidateKeyPackagesResponse),\n/* harmony export */   ValidateKeyPackagesResponse_ValidationResponse: () => (/* binding */ ValidateKeyPackagesResponse_ValidationResponse),\n/* harmony export */   ValidationApiClientImpl: () => (/* binding */ ValidationApiClientImpl),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../identity/credential.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/credential.pb.js\");\n/* harmony import */ var _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../identity/associations/association.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/associations/association.pb.js\");\n/* harmony import */ var _identity_api_v1_identity_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../identity/api/v1/identity.pb */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/identity/api/v1/identity.pb.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4__);\n/* eslint-disable */\n\n\n\n\n\nconst protobufPackage = \"xmtp.mls_validation.v1\";\nfunction createBaseValidateInboxIdKeyPackagesRequest() {\n    return { keyPackages: [] };\n}\nconst ValidateInboxIdKeyPackagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.keyPackages) {\n            ValidateInboxIdKeyPackagesRequest_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdKeyPackagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackages.push(ValidateInboxIdKeyPackagesRequest_KeyPackage.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages)\n                ? object.keyPackages.map((e) => ValidateInboxIdKeyPackagesRequest_KeyPackage.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.keyPackages) {\n            obj.keyPackages = message.keyPackages.map((e) => e ? ValidateInboxIdKeyPackagesRequest_KeyPackage.toJSON(e) : undefined);\n        }\n        else {\n            obj.keyPackages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateInboxIdKeyPackagesRequest();\n        message.keyPackages =\n            ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateInboxIdKeyPackagesRequest_KeyPackage.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdKeyPackagesRequest_KeyPackage() {\n    return {\n        keyPackageBytesTlsSerialized: new Uint8Array(),\n        isInboxIdCredential: false,\n    };\n}\nconst ValidateInboxIdKeyPackagesRequest_KeyPackage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.keyPackageBytesTlsSerialized.length !== 0) {\n            writer.uint32(10).bytes(message.keyPackageBytesTlsSerialized);\n        }\n        if (message.isInboxIdCredential === true) {\n            writer.uint32(16).bool(message.isInboxIdCredential);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdKeyPackagesRequest_KeyPackage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackageBytesTlsSerialized = reader.bytes();\n                    break;\n                case 2:\n                    message.isInboxIdCredential = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackageBytesTlsSerialized: isSet(object.keyPackageBytesTlsSerialized)\n                ? bytesFromBase64(object.keyPackageBytesTlsSerialized)\n                : new Uint8Array(),\n            isInboxIdCredential: isSet(object.isInboxIdCredential)\n                ? Boolean(object.isInboxIdCredential)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackageBytesTlsSerialized !== undefined &&\n            (obj.keyPackageBytesTlsSerialized = base64FromBytes(message.keyPackageBytesTlsSerialized !== undefined\n                ? message.keyPackageBytesTlsSerialized\n                : new Uint8Array()));\n        message.isInboxIdCredential !== undefined &&\n            (obj.isInboxIdCredential = message.isInboxIdCredential);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseValidateInboxIdKeyPackagesRequest_KeyPackage();\n        message.keyPackageBytesTlsSerialized =\n            (_a = object.keyPackageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.isInboxIdCredential = (_b = object.isInboxIdCredential) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdKeyPackagesResponse() {\n    return { responses: [] };\n}\nconst ValidateInboxIdKeyPackagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.responses) {\n            ValidateInboxIdKeyPackagesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdKeyPackagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(ValidateInboxIdKeyPackagesResponse_Response.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => ValidateInboxIdKeyPackagesResponse_Response.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? ValidateInboxIdKeyPackagesResponse_Response.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateInboxIdKeyPackagesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateInboxIdKeyPackagesResponse_Response.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdKeyPackagesResponse_Response() {\n    return {\n        isOk: false,\n        errorMessage: \"\",\n        credential: undefined,\n        installationPublicKey: new Uint8Array(),\n        expiration: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n    };\n}\nconst ValidateInboxIdKeyPackagesResponse_Response = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.isOk === true) {\n            writer.uint32(8).bool(message.isOk);\n        }\n        if (message.errorMessage !== \"\") {\n            writer.uint32(18).string(message.errorMessage);\n        }\n        if (message.credential !== undefined) {\n            _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.encode(message.credential, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.installationPublicKey.length !== 0) {\n            writer.uint32(34).bytes(message.installationPublicKey);\n        }\n        if (!message.expiration.isZero()) {\n            writer.uint32(40).uint64(message.expiration);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdKeyPackagesResponse_Response();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isOk = reader.bool();\n                    break;\n                case 2:\n                    message.errorMessage = reader.string();\n                    break;\n                case 3:\n                    message.credential = _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.installationPublicKey = reader.bytes();\n                    break;\n                case 5:\n                    message.expiration = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,\n            errorMessage: isSet(object.errorMessage)\n                ? String(object.errorMessage)\n                : \"\",\n            credential: isSet(object.credential)\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.fromJSON(object.credential)\n                : undefined,\n            installationPublicKey: isSet(object.installationPublicKey)\n                ? bytesFromBase64(object.installationPublicKey)\n                : new Uint8Array(),\n            expiration: isSet(object.expiration)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.expiration)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isOk !== undefined && (obj.isOk = message.isOk);\n        message.errorMessage !== undefined &&\n            (obj.errorMessage = message.errorMessage);\n        message.credential !== undefined &&\n            (obj.credential = message.credential\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.toJSON(message.credential)\n                : undefined);\n        message.installationPublicKey !== undefined &&\n            (obj.installationPublicKey = base64FromBytes(message.installationPublicKey !== undefined\n                ? message.installationPublicKey\n                : new Uint8Array()));\n        message.expiration !== undefined &&\n            (obj.expiration = (message.expiration || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseValidateInboxIdKeyPackagesResponse_Response();\n        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;\n        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : \"\";\n        message.credential =\n            object.credential !== undefined && object.credential !== null\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.fromPartial(object.credential)\n                : undefined;\n        message.installationPublicKey =\n            (_c = object.installationPublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.expiration =\n            object.expiration !== undefined && object.expiration !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.expiration)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseValidateKeyPackagesRequest() {\n    return { keyPackages: [] };\n}\nconst ValidateKeyPackagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.keyPackages) {\n            ValidateKeyPackagesRequest_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateKeyPackagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackages.push(ValidateKeyPackagesRequest_KeyPackage.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages)\n                ? object.keyPackages.map((e) => ValidateKeyPackagesRequest_KeyPackage.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.keyPackages) {\n            obj.keyPackages = message.keyPackages.map((e) => e ? ValidateKeyPackagesRequest_KeyPackage.toJSON(e) : undefined);\n        }\n        else {\n            obj.keyPackages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateKeyPackagesRequest();\n        message.keyPackages =\n            ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateKeyPackagesRequest_KeyPackage.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateKeyPackagesRequest_KeyPackage() {\n    return {\n        keyPackageBytesTlsSerialized: new Uint8Array(),\n        isInboxIdCredential: false,\n    };\n}\nconst ValidateKeyPackagesRequest_KeyPackage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.keyPackageBytesTlsSerialized.length !== 0) {\n            writer.uint32(10).bytes(message.keyPackageBytesTlsSerialized);\n        }\n        if (message.isInboxIdCredential === true) {\n            writer.uint32(16).bool(message.isInboxIdCredential);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateKeyPackagesRequest_KeyPackage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyPackageBytesTlsSerialized = reader.bytes();\n                    break;\n                case 2:\n                    message.isInboxIdCredential = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            keyPackageBytesTlsSerialized: isSet(object.keyPackageBytesTlsSerialized)\n                ? bytesFromBase64(object.keyPackageBytesTlsSerialized)\n                : new Uint8Array(),\n            isInboxIdCredential: isSet(object.isInboxIdCredential)\n                ? Boolean(object.isInboxIdCredential)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.keyPackageBytesTlsSerialized !== undefined &&\n            (obj.keyPackageBytesTlsSerialized = base64FromBytes(message.keyPackageBytesTlsSerialized !== undefined\n                ? message.keyPackageBytesTlsSerialized\n                : new Uint8Array()));\n        message.isInboxIdCredential !== undefined &&\n            (obj.isInboxIdCredential = message.isInboxIdCredential);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseValidateKeyPackagesRequest_KeyPackage();\n        message.keyPackageBytesTlsSerialized =\n            (_a = object.keyPackageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.isInboxIdCredential = (_b = object.isInboxIdCredential) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseValidateKeyPackagesResponse() {\n    return { responses: [] };\n}\nconst ValidateKeyPackagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.responses) {\n            ValidateKeyPackagesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateKeyPackagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(ValidateKeyPackagesResponse_ValidationResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => ValidateKeyPackagesResponse_ValidationResponse.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? ValidateKeyPackagesResponse_ValidationResponse.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateKeyPackagesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateKeyPackagesResponse_ValidationResponse.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateKeyPackagesResponse_ValidationResponse() {\n    return {\n        isOk: false,\n        errorMessage: \"\",\n        installationId: new Uint8Array(),\n        accountAddress: \"\",\n        credentialIdentityBytes: new Uint8Array(),\n        expiration: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n    };\n}\nconst ValidateKeyPackagesResponse_ValidationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.isOk === true) {\n            writer.uint32(8).bool(message.isOk);\n        }\n        if (message.errorMessage !== \"\") {\n            writer.uint32(18).string(message.errorMessage);\n        }\n        if (message.installationId.length !== 0) {\n            writer.uint32(26).bytes(message.installationId);\n        }\n        if (message.accountAddress !== \"\") {\n            writer.uint32(34).string(message.accountAddress);\n        }\n        if (message.credentialIdentityBytes.length !== 0) {\n            writer.uint32(42).bytes(message.credentialIdentityBytes);\n        }\n        if (!message.expiration.isZero()) {\n            writer.uint32(48).uint64(message.expiration);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateKeyPackagesResponse_ValidationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isOk = reader.bool();\n                    break;\n                case 2:\n                    message.errorMessage = reader.string();\n                    break;\n                case 3:\n                    message.installationId = reader.bytes();\n                    break;\n                case 4:\n                    message.accountAddress = reader.string();\n                    break;\n                case 5:\n                    message.credentialIdentityBytes = reader.bytes();\n                    break;\n                case 6:\n                    message.expiration = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,\n            errorMessage: isSet(object.errorMessage)\n                ? String(object.errorMessage)\n                : \"\",\n            installationId: isSet(object.installationId)\n                ? bytesFromBase64(object.installationId)\n                : new Uint8Array(),\n            accountAddress: isSet(object.accountAddress)\n                ? String(object.accountAddress)\n                : \"\",\n            credentialIdentityBytes: isSet(object.credentialIdentityBytes)\n                ? bytesFromBase64(object.credentialIdentityBytes)\n                : new Uint8Array(),\n            expiration: isSet(object.expiration)\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.expiration)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isOk !== undefined && (obj.isOk = message.isOk);\n        message.errorMessage !== undefined &&\n            (obj.errorMessage = message.errorMessage);\n        message.installationId !== undefined &&\n            (obj.installationId = base64FromBytes(message.installationId !== undefined\n                ? message.installationId\n                : new Uint8Array()));\n        message.accountAddress !== undefined &&\n            (obj.accountAddress = message.accountAddress);\n        message.credentialIdentityBytes !== undefined &&\n            (obj.credentialIdentityBytes = base64FromBytes(message.credentialIdentityBytes !== undefined\n                ? message.credentialIdentityBytes\n                : new Uint8Array()));\n        message.expiration !== undefined &&\n            (obj.expiration = (message.expiration || long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseValidateKeyPackagesResponse_ValidationResponse();\n        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;\n        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : \"\";\n        message.installationId = (_c = object.installationId) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.accountAddress = (_d = object.accountAddress) !== null && _d !== void 0 ? _d : \"\";\n        message.credentialIdentityBytes =\n            (_e = object.credentialIdentityBytes) !== null && _e !== void 0 ? _e : new Uint8Array();\n        message.expiration =\n            object.expiration !== undefined && object.expiration !== null\n                ? long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromValue(object.expiration)\n                : long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UZERO;\n        return message;\n    },\n};\nfunction createBaseValidateGroupMessagesRequest() {\n    return { groupMessages: [] };\n}\nconst ValidateGroupMessagesRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.groupMessages) {\n            ValidateGroupMessagesRequest_GroupMessage.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateGroupMessagesRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupMessages.push(ValidateGroupMessagesRequest_GroupMessage.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupMessages: Array.isArray(object === null || object === void 0 ? void 0 : object.groupMessages)\n                ? object.groupMessages.map((e) => ValidateGroupMessagesRequest_GroupMessage.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groupMessages) {\n            obj.groupMessages = message.groupMessages.map((e) => e ? ValidateGroupMessagesRequest_GroupMessage.toJSON(e) : undefined);\n        }\n        else {\n            obj.groupMessages = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateGroupMessagesRequest();\n        message.groupMessages =\n            ((_a = object.groupMessages) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateGroupMessagesRequest_GroupMessage.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateGroupMessagesRequest_GroupMessage() {\n    return { groupMessageBytesTlsSerialized: new Uint8Array() };\n}\nconst ValidateGroupMessagesRequest_GroupMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.groupMessageBytesTlsSerialized.length !== 0) {\n            writer.uint32(10).bytes(message.groupMessageBytesTlsSerialized);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateGroupMessagesRequest_GroupMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupMessageBytesTlsSerialized = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groupMessageBytesTlsSerialized: isSet(object.groupMessageBytesTlsSerialized)\n                ? bytesFromBase64(object.groupMessageBytesTlsSerialized)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.groupMessageBytesTlsSerialized !== undefined &&\n            (obj.groupMessageBytesTlsSerialized = base64FromBytes(message.groupMessageBytesTlsSerialized !== undefined\n                ? message.groupMessageBytesTlsSerialized\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateGroupMessagesRequest_GroupMessage();\n        message.groupMessageBytesTlsSerialized =\n            (_a = object.groupMessageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseValidateGroupMessagesResponse() {\n    return { responses: [] };\n}\nconst ValidateGroupMessagesResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.responses) {\n            ValidateGroupMessagesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateGroupMessagesResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(ValidateGroupMessagesResponse_ValidationResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => ValidateGroupMessagesResponse_ValidationResponse.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e\n                ? ValidateGroupMessagesResponse_ValidationResponse.toJSON(e)\n                : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateGroupMessagesResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateGroupMessagesResponse_ValidationResponse.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateGroupMessagesResponse_ValidationResponse() {\n    return { isOk: false, errorMessage: \"\", groupId: \"\" };\n}\nconst ValidateGroupMessagesResponse_ValidationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.isOk === true) {\n            writer.uint32(8).bool(message.isOk);\n        }\n        if (message.errorMessage !== \"\") {\n            writer.uint32(18).string(message.errorMessage);\n        }\n        if (message.groupId !== \"\") {\n            writer.uint32(26).string(message.groupId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateGroupMessagesResponse_ValidationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isOk = reader.bool();\n                    break;\n                case 2:\n                    message.errorMessage = reader.string();\n                    break;\n                case 3:\n                    message.groupId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,\n            errorMessage: isSet(object.errorMessage)\n                ? String(object.errorMessage)\n                : \"\",\n            groupId: isSet(object.groupId) ? String(object.groupId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isOk !== undefined && (obj.isOk = message.isOk);\n        message.errorMessage !== undefined &&\n            (obj.errorMessage = message.errorMessage);\n        message.groupId !== undefined && (obj.groupId = message.groupId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseValidateGroupMessagesResponse_ValidationResponse();\n        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;\n        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : \"\";\n        message.groupId = (_c = object.groupId) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseGetAssociationStateRequest() {\n    return { oldUpdates: [], newUpdates: [] };\n}\nconst GetAssociationStateRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.oldUpdates) {\n            _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.newUpdates) {\n            _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetAssociationStateRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.oldUpdates.push(_identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.newUpdates.push(_identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            oldUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.oldUpdates)\n                ? object.oldUpdates.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromJSON(e))\n                : [],\n            newUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.newUpdates)\n                ? object.newUpdates.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.oldUpdates) {\n            obj.oldUpdates = message.oldUpdates.map((e) => e ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.toJSON(e) : undefined);\n        }\n        else {\n            obj.oldUpdates = [];\n        }\n        if (message.newUpdates) {\n            obj.newUpdates = message.newUpdates.map((e) => e ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.toJSON(e) : undefined);\n        }\n        else {\n            obj.newUpdates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetAssociationStateRequest();\n        message.oldUpdates =\n            ((_a = object.oldUpdates) === null || _a === void 0 ? void 0 : _a.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromPartial(e))) || [];\n        message.newUpdates =\n            ((_b = object.newUpdates) === null || _b === void 0 ? void 0 : _b.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetAssociationStateResponse() {\n    return { associationState: undefined, stateDiff: undefined };\n}\nconst GetAssociationStateResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.associationState !== undefined) {\n            _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationState.encode(message.associationState, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.stateDiff !== undefined) {\n            _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationStateDiff.encode(message.stateDiff, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetAssociationStateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.associationState = _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationState.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.stateDiff = _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationStateDiff.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            associationState: isSet(object.associationState)\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationState.fromJSON(object.associationState)\n                : undefined,\n            stateDiff: isSet(object.stateDiff)\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationStateDiff.fromJSON(object.stateDiff)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.associationState !== undefined &&\n            (obj.associationState = message.associationState\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationState.toJSON(message.associationState)\n                : undefined);\n        message.stateDiff !== undefined &&\n            (obj.stateDiff = message.stateDiff\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationStateDiff.toJSON(message.stateDiff)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetAssociationStateResponse();\n        message.associationState =\n            object.associationState !== undefined && object.associationState !== null\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationState.fromPartial(object.associationState)\n                : undefined;\n        message.stateDiff =\n            object.stateDiff !== undefined && object.stateDiff !== null\n                ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.AssociationStateDiff.fromPartial(object.stateDiff)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdsRequest() {\n    return { requests: [] };\n}\nconst ValidateInboxIdsRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.requests) {\n            ValidateInboxIdsRequest_ValidationRequest.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdsRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requests.push(ValidateInboxIdsRequest_ValidationRequest.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests)\n                ? object.requests.map((e) => ValidateInboxIdsRequest_ValidationRequest.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.requests) {\n            obj.requests = message.requests.map((e) => e ? ValidateInboxIdsRequest_ValidationRequest.toJSON(e) : undefined);\n        }\n        else {\n            obj.requests = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateInboxIdsRequest();\n        message.requests =\n            ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateInboxIdsRequest_ValidationRequest.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdsRequest_ValidationRequest() {\n    return {\n        credential: undefined,\n        installationPublicKey: new Uint8Array(),\n        identityUpdates: [],\n    };\n}\nconst ValidateInboxIdsRequest_ValidationRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.credential !== undefined) {\n            _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.encode(message.credential, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.installationPublicKey.length !== 0) {\n            writer.uint32(18).bytes(message.installationPublicKey);\n        }\n        for (const v of message.identityUpdates) {\n            _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdsRequest_ValidationRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.credential = _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.installationPublicKey = reader.bytes();\n                    break;\n                case 3:\n                    message.identityUpdates.push(_identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            credential: isSet(object.credential)\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.fromJSON(object.credential)\n                : undefined,\n            installationPublicKey: isSet(object.installationPublicKey)\n                ? bytesFromBase64(object.installationPublicKey)\n                : new Uint8Array(),\n            identityUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.identityUpdates)\n                ? object.identityUpdates.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.credential !== undefined &&\n            (obj.credential = message.credential\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.toJSON(message.credential)\n                : undefined);\n        message.installationPublicKey !== undefined &&\n            (obj.installationPublicKey = base64FromBytes(message.installationPublicKey !== undefined\n                ? message.installationPublicKey\n                : new Uint8Array()));\n        if (message.identityUpdates) {\n            obj.identityUpdates = message.identityUpdates.map((e) => e ? _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.toJSON(e) : undefined);\n        }\n        else {\n            obj.identityUpdates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseValidateInboxIdsRequest_ValidationRequest();\n        message.credential =\n            object.credential !== undefined && object.credential !== null\n                ? _identity_credential_pb__WEBPACK_IMPORTED_MODULE_1__.MlsCredential.fromPartial(object.credential)\n                : undefined;\n        message.installationPublicKey =\n            (_a = object.installationPublicKey) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.identityUpdates =\n            ((_b = object.identityUpdates) === null || _b === void 0 ? void 0 : _b.map((e) => _identity_associations_association_pb__WEBPACK_IMPORTED_MODULE_2__.IdentityUpdate.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdsResponse() {\n    return { responses: [] };\n}\nconst ValidateInboxIdsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        for (const v of message.responses) {\n            ValidateInboxIdsResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.responses.push(ValidateInboxIdsResponse_ValidationResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses)\n                ? object.responses.map((e) => ValidateInboxIdsResponse_ValidationResponse.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.responses) {\n            obj.responses = message.responses.map((e) => e ? ValidateInboxIdsResponse_ValidationResponse.toJSON(e) : undefined);\n        }\n        else {\n            obj.responses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValidateInboxIdsResponse();\n        message.responses =\n            ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e) => ValidateInboxIdsResponse_ValidationResponse.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseValidateInboxIdsResponse_ValidationResponse() {\n    return { isOk: false, errorMessage: \"\", inboxId: \"\" };\n}\nconst ValidateInboxIdsResponse_ValidationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Writer.create()) {\n        if (message.isOk === true) {\n            writer.uint32(8).bool(message.isOk);\n        }\n        if (message.errorMessage !== \"\") {\n            writer.uint32(18).string(message.errorMessage);\n        }\n        if (message.inboxId !== \"\") {\n            writer.uint32(26).string(message.inboxId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidateInboxIdsResponse_ValidationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isOk = reader.bool();\n                    break;\n                case 2:\n                    message.errorMessage = reader.string();\n                    break;\n                case 3:\n                    message.inboxId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,\n            errorMessage: isSet(object.errorMessage)\n                ? String(object.errorMessage)\n                : \"\",\n            inboxId: isSet(object.inboxId) ? String(object.inboxId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isOk !== undefined && (obj.isOk = message.isOk);\n        message.errorMessage !== undefined &&\n            (obj.errorMessage = message.errorMessage);\n        message.inboxId !== undefined && (obj.inboxId = message.inboxId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseValidateInboxIdsResponse_ValidationResponse();\n        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;\n        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : \"\";\n        message.inboxId = (_c = object.inboxId) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nclass ValidationApiClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n        this.ValidateKeyPackages = this.ValidateKeyPackages.bind(this);\n        this.ValidateGroupMessages = this.ValidateGroupMessages.bind(this);\n        this.GetAssociationState = this.GetAssociationState.bind(this);\n        this.ValidateInboxIdKeyPackages =\n            this.ValidateInboxIdKeyPackages.bind(this);\n        this.ValidateInboxIds = this.ValidateInboxIds.bind(this);\n        this.VerifySmartContractWalletSignatures =\n            this.VerifySmartContractWalletSignatures.bind(this);\n    }\n    ValidateKeyPackages(request) {\n        const data = ValidateKeyPackagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"ValidateKeyPackages\", data);\n        return promise.then((data) => ValidateKeyPackagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n    ValidateGroupMessages(request) {\n        const data = ValidateGroupMessagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"ValidateGroupMessages\", data);\n        return promise.then((data) => ValidateGroupMessagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n    GetAssociationState(request) {\n        const data = GetAssociationStateRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"GetAssociationState\", data);\n        return promise.then((data) => GetAssociationStateResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n    ValidateInboxIdKeyPackages(request) {\n        const data = ValidateKeyPackagesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"ValidateInboxIdKeyPackages\", data);\n        return promise.then((data) => ValidateInboxIdKeyPackagesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n    ValidateInboxIds(request) {\n        const data = ValidateInboxIdsRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"ValidateInboxIds\", data);\n        return promise.then((data) => ValidateInboxIdsResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n    VerifySmartContractWalletSignatures(request) {\n        const data = _identity_api_v1_identity_pb__WEBPACK_IMPORTED_MODULE_3__.VerifySmartContractWalletSignaturesRequest.encode(request).finish();\n        const promise = this.rpc.request(\"xmtp.mls_validation.v1.ValidationApi\", \"VerifySmartContractWalletSignatures\", data);\n        return promise.then((data) => _identity_api_v1_identity_pb__WEBPACK_IMPORTED_MODULE_3__.VerifySmartContractWalletSignaturesResponse.decode(new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().Reader)(data)));\n    }\n}\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long !== long__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().util).Long = long__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_4___default().configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=service.pb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbWxzX3ZhbGlkYXRpb24vdjEvc2VydmljZS5wYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dCO0FBQ3FDO0FBQ3dEO0FBQ3dCO0FBQ3hHO0FBQzlCO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixnRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QyxrRUFBVSxlQUFlLGtFQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGtFQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGtFQUFVO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGtFQUFVO0FBQ3BGO0FBQ0E7QUFDQSxxQkFBcUIsb0dBQTBDO0FBQy9EO0FBQ0Esc0NBQXNDLHFHQUEyQyxZQUFZLGtFQUFVO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBUSxVQUFVLDRDQUFJO0FBQzFCLElBQUksZ0VBQVEsUUFBUSw0Q0FBSTtBQUN4QixJQUFJLG1FQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9wcm90by90cy9kaXN0L2VzbS9tbHNfdmFsaWRhdGlvbi92MS9zZXJ2aWNlLnBiLmpzPzBjZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgeyBNbHNDcmVkZW50aWFsIH0gZnJvbSBcIi4uLy4uL2lkZW50aXR5L2NyZWRlbnRpYWwucGJcIjtcbmltcG9ydCB7IElkZW50aXR5VXBkYXRlLCBBc3NvY2lhdGlvblN0YXRlLCBBc3NvY2lhdGlvblN0YXRlRGlmZiwgfSBmcm9tIFwiLi4vLi4vaWRlbnRpdHkvYXNzb2NpYXRpb25zL2Fzc29jaWF0aW9uLnBiXCI7XG5pbXBvcnQgeyBWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1Jlc3BvbnNlLCBWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1JlcXVlc3QsIH0gZnJvbSBcIi4uLy4uL2lkZW50aXR5L2FwaS92MS9pZGVudGl0eS5wYlwiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ4bXRwLm1sc192YWxpZGF0aW9uLnYxXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5rZXlQYWNrYWdlcykge1xuICAgICAgICAgICAgVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VzLnB1c2goVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleVBhY2thZ2VzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5rZXlQYWNrYWdlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5rZXlQYWNrYWdlcy5tYXAoKGUpID0+IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5UGFja2FnZXMpIHtcbiAgICAgICAgICAgIG9iai5rZXlQYWNrYWdlcyA9IG1lc3NhZ2Uua2V5UGFja2FnZXMubWFwKChlKSA9PiBlID8gVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5rZXlQYWNrYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3Qua2V5UGFja2FnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGlzSW5ib3hJZENyZWRlbnRpYWw6IGZhbHNlLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2Uua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuYm9vbChtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkOiBpc1NldChvYmplY3Qua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBpc0luYm94SWRDcmVkZW50aWFsOiBpc1NldChvYmplY3QuaXNJbmJveElkQ3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA/IEJvb2xlYW4ob2JqZWN0LmlzSW5ib3hJZENyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWRcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5pc0luYm94SWRDcmVkZW50aWFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaXNJbmJveElkQ3JlZGVudGlhbCA9IG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZSgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQgPVxuICAgICAgICAgICAgKF9hID0gb2JqZWN0LmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9IChfYiA9IG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVzcG9uc2VfUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1Jlc3BvbnNlX1Jlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1Jlc3BvbnNlX1Jlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXNwb25zZV9SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXNwb25zZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVzcG9uc2VfUmVzcG9uc2UuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXNwb25zZV9SZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc09rOiBmYWxzZSxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBcIlwiLFxuICAgICAgICBjcmVkZW50aWFsOiB1bmRlZmluZWQsXG4gICAgICAgIGluc3RhbGxhdGlvblB1YmxpY0tleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZXhwaXJhdGlvbjogTG9uZy5VWkVSTyxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVzcG9uc2VfUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNPayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5ib29sKG1lc3NhZ2UuaXNPayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3JNZXNzYWdlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5lcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNyZWRlbnRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWxzQ3JlZGVudGlhbC5lbmNvZGUobWVzc2FnZS5jcmVkZW50aWFsLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvblB1YmxpY0tleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuZXhwaXJhdGlvbi5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDY0KG1lc3NhZ2UuZXhwaXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlc1Jlc3BvbnNlX1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc09rID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWwgPSBNbHNDcmVkZW50aWFsLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4cGlyYXRpb24gPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzT2s6IGlzU2V0KG9iamVjdC5pc09rKSA/IEJvb2xlYW4ob2JqZWN0LmlzT2spIDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGlzU2V0KG9iamVjdC5lcnJvck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsOiBpc1NldChvYmplY3QuY3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA/IE1sc0NyZWRlbnRpYWwuZnJvbUpTT04ob2JqZWN0LmNyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25QdWJsaWNLZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25QdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvblB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBleHBpcmF0aW9uOiBpc1NldChvYmplY3QuZXhwaXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5leHBpcmF0aW9uKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmlzT2sgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlzT2sgPSBtZXNzYWdlLmlzT2spO1xuICAgICAgICBtZXNzYWdlLmVycm9yTWVzc2FnZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmVycm9yTWVzc2FnZSA9IG1lc3NhZ2UuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgbWVzc2FnZS5jcmVkZW50aWFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY3JlZGVudGlhbCA9IG1lc3NhZ2UuY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgID8gTWxzQ3JlZGVudGlhbC50b0pTT04obWVzc2FnZS5jcmVkZW50aWFsKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25QdWJsaWNLZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXhwaXJhdGlvbiA9IChtZXNzYWdlLmV4cGlyYXRpb24gfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNSZXNwb25zZV9SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmlzT2sgPSAoX2EgPSBvYmplY3QuaXNPaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlID0gKF9iID0gb2JqZWN0LmVycm9yTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jcmVkZW50aWFsID1cbiAgICAgICAgICAgIG9iamVjdC5jcmVkZW50aWFsICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNyZWRlbnRpYWwgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE1sc0NyZWRlbnRpYWwuZnJvbVBhcnRpYWwob2JqZWN0LmNyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ID1cbiAgICAgICAgICAgIChfYyA9IG9iamVjdC5pbnN0YWxsYXRpb25QdWJsaWNLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZXhwaXJhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QuZXhwaXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5leHBpcmF0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuZXhwaXJhdGlvbilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZhbGlkYXRlS2V5UGFja2FnZXNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IGtleVBhY2thZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlS2V5UGFja2FnZXNSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmtleVBhY2thZ2VzKSB7XG4gICAgICAgICAgICBWYWxpZGF0ZUtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VzLnB1c2goVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5UGFja2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmtleVBhY2thZ2VzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmtleVBhY2thZ2VzLm1hcCgoZSkgPT4gVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmtleVBhY2thZ2VzKSB7XG4gICAgICAgICAgICBvYmoua2V5UGFja2FnZXMgPSBtZXNzYWdlLmtleVBhY2thZ2VzLm1hcCgoZSkgPT4gZSA/IFZhbGlkYXRlS2V5UGFja2FnZXNSZXF1ZXN0X0tleVBhY2thZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5rZXlQYWNrYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlS2V5UGFja2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5UGFja2FnZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5rZXlQYWNrYWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGlzSW5ib3hJZENyZWRlbnRpYWw6IGZhbHNlLFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0luYm94SWRDcmVkZW50aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUtleVBhY2thZ2VzUmVxdWVzdF9LZXlQYWNrYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc0luYm94SWRDcmVkZW50aWFsID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZDogaXNTZXQob2JqZWN0LmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaXNJbmJveElkQ3JlZGVudGlhbDogaXNTZXQob2JqZWN0LmlzSW5ib3hJZENyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgPyBCb29sZWFuKG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoua2V5UGFja2FnZUJ5dGVzVGxzU2VyaWFsaXplZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5rZXlQYWNrYWdlQnl0ZXNUbHNTZXJpYWxpemVkXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmlzSW5ib3hJZENyZWRlbnRpYWwgPSBtZXNzYWdlLmlzSW5ib3hJZENyZWRlbnRpYWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVLZXlQYWNrYWdlc1JlcXVlc3RfS2V5UGFja2FnZSgpO1xuICAgICAgICBtZXNzYWdlLmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQgPVxuICAgICAgICAgICAgKF9hID0gb2JqZWN0LmtleVBhY2thZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuaXNJbmJveElkQ3JlZGVudGlhbCA9IChfYiA9IG9iamVjdC5pc0luYm94SWRDcmVkZW50aWFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVLZXlQYWNrYWdlc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVLZXlQYWNrYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gVmFsaWRhdGVLZXlQYWNrYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlS2V5UGFja2FnZXNSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlc3BvbnNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gVmFsaWRhdGVLZXlQYWNrYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT2s6IGZhbHNlLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IFwiXCIsXG4gICAgICAgIGluc3RhbGxhdGlvbklkOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBhY2NvdW50QWRkcmVzczogXCJcIixcbiAgICAgICAgY3JlZGVudGlhbElkZW50aXR5Qnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGV4cGlyYXRpb246IExvbmcuVVpFUk8sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlzT2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuYm9vbChtZXNzYWdlLmlzT2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yTWVzc2FnZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YWxsYXRpb25JZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFjY291bnRBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5hY2NvdW50QWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlZGVudGlhbElkZW50aXR5Qnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQyKS5ieXRlcyhtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lc3NhZ2UuZXhwaXJhdGlvbi5pc1plcm8oKSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0OCkudWludDY0KG1lc3NhZ2UuZXhwaXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc09rID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY2NvdW50QWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eUJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHBpcmF0aW9uID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc09rOiBpc1NldChvYmplY3QuaXNPaykgPyBCb29sZWFuKG9iamVjdC5pc09rKSA6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBpc1NldChvYmplY3QuZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5lcnJvck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSWQ6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25JZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaW5zdGFsbGF0aW9uSWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgYWNjb3VudEFkZHJlc3M6IGlzU2V0KG9iamVjdC5hY2NvdW50QWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuYWNjb3VudEFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgY3JlZGVudGlhbElkZW50aXR5Qnl0ZXM6IGlzU2V0KG9iamVjdC5jcmVkZW50aWFsSWRlbnRpdHlCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY3JlZGVudGlhbElkZW50aXR5Qnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZXhwaXJhdGlvbjogaXNTZXQob2JqZWN0LmV4cGlyYXRpb24pXG4gICAgICAgICAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuZXhwaXJhdGlvbilcbiAgICAgICAgICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5pc09rICE9PSB1bmRlZmluZWQgJiYgKG9iai5pc09rID0gbWVzc2FnZS5pc09rKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvck1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lcnJvck1lc3NhZ2UgPSBtZXNzYWdlLmVycm9yTWVzc2FnZSk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YWxsYXRpb25JZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmluc3RhbGxhdGlvbklkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaW5zdGFsbGF0aW9uSWRcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5hY2NvdW50QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFjY291bnRBZGRyZXNzID0gbWVzc2FnZS5hY2NvdW50QWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UuY3JlZGVudGlhbElkZW50aXR5Qnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVkZW50aWFsSWRlbnRpdHlCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuY3JlZGVudGlhbElkZW50aXR5Qnl0ZXNcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXhwaXJhdGlvbiA9IChtZXNzYWdlLmV4cGlyYXRpb24gfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUtleVBhY2thZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuaXNPayA9IChfYSA9IG9iamVjdC5pc09rKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5lcnJvck1lc3NhZ2UgPSAoX2IgPSBvYmplY3QuZXJyb3JNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvbklkID0gKF9jID0gb2JqZWN0Lmluc3RhbGxhdGlvbklkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmFjY291bnRBZGRyZXNzID0gKF9kID0gb2JqZWN0LmFjY291bnRBZGRyZXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWxJZGVudGl0eUJ5dGVzID1cbiAgICAgICAgICAgIChfZSA9IG9iamVjdC5jcmVkZW50aWFsSWRlbnRpdHlCeXRlcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5leHBpcmF0aW9uID1cbiAgICAgICAgICAgIG9iamVjdC5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmV4cGlyYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5leHBpcmF0aW9uKVxuICAgICAgICAgICAgICAgIDogTG9uZy5VWkVSTztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyBncm91cE1lc3NhZ2VzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlR3JvdXBNZXNzYWdlc1JlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBNZXNzYWdlcykge1xuICAgICAgICAgICAgVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdF9Hcm91cE1lc3NhZ2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cE1lc3NhZ2VzLnB1c2goVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdF9Hcm91cE1lc3NhZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwTWVzc2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lmdyb3VwTWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZ3JvdXBNZXNzYWdlcy5tYXAoKGUpID0+IFZhbGlkYXRlR3JvdXBNZXNzYWdlc1JlcXVlc3RfR3JvdXBNZXNzYWdlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBNZXNzYWdlcykge1xuICAgICAgICAgICAgb2JqLmdyb3VwTWVzc2FnZXMgPSBtZXNzYWdlLmdyb3VwTWVzc2FnZXMubWFwKChlKSA9PiBlID8gVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdF9Hcm91cE1lc3NhZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5ncm91cE1lc3NhZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdCgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwTWVzc2FnZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5ncm91cE1lc3NhZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0dyb3VwTWVzc2FnZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0dyb3VwTWVzc2FnZSgpIHtcbiAgICByZXR1cm4geyBncm91cE1lc3NhZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQ6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0dyb3VwTWVzc2FnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ncm91cE1lc3NhZ2VCeXRlc1Rsc1NlcmlhbGl6ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0dyb3VwTWVzc2FnZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBNZXNzYWdlQnl0ZXNUbHNTZXJpYWxpemVkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZDogaXNTZXQob2JqZWN0Lmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZ3JvdXBNZXNzYWdlQnl0ZXNUbHNTZXJpYWxpemVkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXF1ZXN0X0dyb3VwTWVzc2FnZSgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwTWVzc2FnZUJ5dGVzVGxzU2VyaWFsaXplZCA9XG4gICAgICAgICAgICAoX2EgPSBvYmplY3QuZ3JvdXBNZXNzYWdlQnl0ZXNUbHNTZXJpYWxpemVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyByZXNwb25zZXM6IFtdIH07XG59XG5leHBvcnQgY29uc3QgVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2VzLnB1c2goVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG9iai5yZXNwb25zZXMgPSBtZXNzYWdlLnJlc3BvbnNlcy5tYXAoKGUpID0+IGVcbiAgICAgICAgICAgICAgICA/IFZhbGlkYXRlR3JvdXBNZXNzYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS50b0pTT04oZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5yZXNwb25zZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IFZhbGlkYXRlR3JvdXBNZXNzYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgaXNPazogZmFsc2UsIGVycm9yTWVzc2FnZTogXCJcIiwgZ3JvdXBJZDogXCJcIiB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlR3JvdXBNZXNzYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pc09rID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmJvb2wobWVzc2FnZS5pc09rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lcnJvck1lc3NhZ2UgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuZ3JvdXBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzT2sgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNPazogaXNTZXQob2JqZWN0LmlzT2spID8gQm9vbGVhbihvYmplY3QuaXNPaykgOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogaXNTZXQob2JqZWN0LmVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlzU2V0KG9iamVjdC5ncm91cElkKSA/IFN0cmluZyhvYmplY3QuZ3JvdXBJZCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaXNPayAhPT0gdW5kZWZpbmVkICYmIChvYmouaXNPayA9IG1lc3NhZ2UuaXNPayk7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJyb3JNZXNzYWdlID0gbWVzc2FnZS5lcnJvck1lc3NhZ2UpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdyb3VwSWQgPSBtZXNzYWdlLmdyb3VwSWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlR3JvdXBNZXNzYWdlc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmlzT2sgPSAoX2EgPSBvYmplY3QuaXNPaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlID0gKF9iID0gb2JqZWN0LmVycm9yTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ncm91cElkID0gKF9jID0gb2JqZWN0Lmdyb3VwSWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldEFzc29jaWF0aW9uU3RhdGVSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IG9sZFVwZGF0ZXM6IFtdLCBuZXdVcGRhdGVzOiBbXSB9O1xufVxuZXhwb3J0IGNvbnN0IEdldEFzc29jaWF0aW9uU3RhdGVSZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm9sZFVwZGF0ZXMpIHtcbiAgICAgICAgICAgIElkZW50aXR5VXBkYXRlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm5ld1VwZGF0ZXMpIHtcbiAgICAgICAgICAgIElkZW50aXR5VXBkYXRlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2V0QXNzb2NpYXRpb25TdGF0ZVJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9sZFVwZGF0ZXMucHVzaChJZGVudGl0eVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5ld1VwZGF0ZXMucHVzaChJZGVudGl0eVVwZGF0ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2xkVXBkYXRlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Qub2xkVXBkYXRlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5vbGRVcGRhdGVzLm1hcCgoZSkgPT4gSWRlbnRpdHlVcGRhdGUuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIG5ld1VwZGF0ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm5ld1VwZGF0ZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QubmV3VXBkYXRlcy5tYXAoKGUpID0+IElkZW50aXR5VXBkYXRlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub2xkVXBkYXRlcykge1xuICAgICAgICAgICAgb2JqLm9sZFVwZGF0ZXMgPSBtZXNzYWdlLm9sZFVwZGF0ZXMubWFwKChlKSA9PiBlID8gSWRlbnRpdHlVcGRhdGUudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5vbGRVcGRhdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmV3VXBkYXRlcykge1xuICAgICAgICAgICAgb2JqLm5ld1VwZGF0ZXMgPSBtZXNzYWdlLm5ld1VwZGF0ZXMubWFwKChlKSA9PiBlID8gSWRlbnRpdHlVcGRhdGUudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5uZXdVcGRhdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUdldEFzc29jaWF0aW9uU3RhdGVSZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2Uub2xkVXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0Lm9sZFVwZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IElkZW50aXR5VXBkYXRlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UubmV3VXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9iID0gb2JqZWN0Lm5ld1VwZGF0ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXAoKGUpID0+IElkZW50aXR5VXBkYXRlLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdldEFzc29jaWF0aW9uU3RhdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBhc3NvY2lhdGlvblN0YXRlOiB1bmRlZmluZWQsIHN0YXRlRGlmZjogdW5kZWZpbmVkIH07XG59XG5leHBvcnQgY29uc3QgR2V0QXNzb2NpYXRpb25TdGF0ZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFzc29jaWF0aW9uU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQXNzb2NpYXRpb25TdGF0ZS5lbmNvZGUobWVzc2FnZS5hc3NvY2lhdGlvblN0YXRlLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXRlRGlmZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBBc3NvY2lhdGlvblN0YXRlRGlmZi5lbmNvZGUobWVzc2FnZS5zdGF0ZURpZmYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRBc3NvY2lhdGlvblN0YXRlUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFzc29jaWF0aW9uU3RhdGUgPSBBc3NvY2lhdGlvblN0YXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGF0ZURpZmYgPSBBc3NvY2lhdGlvblN0YXRlRGlmZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3NvY2lhdGlvblN0YXRlOiBpc1NldChvYmplY3QuYXNzb2NpYXRpb25TdGF0ZSlcbiAgICAgICAgICAgICAgICA/IEFzc29jaWF0aW9uU3RhdGUuZnJvbUpTT04ob2JqZWN0LmFzc29jaWF0aW9uU3RhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGF0ZURpZmY6IGlzU2V0KG9iamVjdC5zdGF0ZURpZmYpXG4gICAgICAgICAgICAgICAgPyBBc3NvY2lhdGlvblN0YXRlRGlmZi5mcm9tSlNPTihvYmplY3Quc3RhdGVEaWZmKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYXNzb2NpYXRpb25TdGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFzc29jaWF0aW9uU3RhdGUgPSBtZXNzYWdlLmFzc29jaWF0aW9uU3RhdGVcbiAgICAgICAgICAgICAgICA/IEFzc29jaWF0aW9uU3RhdGUudG9KU09OKG1lc3NhZ2UuYXNzb2NpYXRpb25TdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdGVEaWZmICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3RhdGVEaWZmID0gbWVzc2FnZS5zdGF0ZURpZmZcbiAgICAgICAgICAgICAgICA/IEFzc29jaWF0aW9uU3RhdGVEaWZmLnRvSlNPTihtZXNzYWdlLnN0YXRlRGlmZilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZXRBc3NvY2lhdGlvblN0YXRlUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5hc3NvY2lhdGlvblN0YXRlID1cbiAgICAgICAgICAgIG9iamVjdC5hc3NvY2lhdGlvblN0YXRlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFzc29jaWF0aW9uU3RhdGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEFzc29jaWF0aW9uU3RhdGUuZnJvbVBhcnRpYWwob2JqZWN0LmFzc29jaWF0aW9uU3RhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdGVEaWZmID1cbiAgICAgICAgICAgIG9iamVjdC5zdGF0ZURpZmYgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3RhdGVEaWZmICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBBc3NvY2lhdGlvblN0YXRlRGlmZi5mcm9tUGFydGlhbChvYmplY3Quc3RhdGVEaWZmKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRzUmVxdWVzdCgpIHtcbiAgICByZXR1cm4geyByZXF1ZXN0czogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUluYm94SWRzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgVmFsaWRhdGVJbmJveElkc1JlcXVlc3RfVmFsaWRhdGlvblJlcXVlc3QuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRzUmVxdWVzdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdHMucHVzaChWYWxpZGF0ZUluYm94SWRzUmVxdWVzdF9WYWxpZGF0aW9uUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlcXVlc3RzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlcXVlc3RzLm1hcCgoZSkgPT4gVmFsaWRhdGVJbmJveElkc1JlcXVlc3RfVmFsaWRhdGlvblJlcXVlc3QuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0cykge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gbWVzc2FnZS5yZXF1ZXN0cy5tYXAoKGUpID0+IGUgPyBWYWxpZGF0ZUluYm94SWRzUmVxdWVzdF9WYWxpZGF0aW9uUmVxdWVzdC50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlcXVlc3RzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkc1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yZXF1ZXN0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlcXVlc3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBWYWxpZGF0ZUluYm94SWRzUmVxdWVzdF9WYWxpZGF0aW9uUmVxdWVzdC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRzUmVxdWVzdF9WYWxpZGF0aW9uUmVxdWVzdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVkZW50aWFsOiB1bmRlZmluZWQsXG4gICAgICAgIGluc3RhbGxhdGlvblB1YmxpY0tleTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgaWRlbnRpdHlVcGRhdGVzOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlSW5ib3hJZHNSZXF1ZXN0X1ZhbGlkYXRpb25SZXF1ZXN0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNyZWRlbnRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTWxzQ3JlZGVudGlhbC5lbmNvZGUobWVzc2FnZS5jcmVkZW50aWFsLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbGxhdGlvblB1YmxpY0tleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5pZGVudGl0eVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIElkZW50aXR5VXBkYXRlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkc1JlcXVlc3RfVmFsaWRhdGlvblJlcXVlc3QoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWRlbnRpYWwgPSBNbHNDcmVkZW50aWFsLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YWxsYXRpb25QdWJsaWNLZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZW50aXR5VXBkYXRlcy5wdXNoKElkZW50aXR5VXBkYXRlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVkZW50aWFsOiBpc1NldChvYmplY3QuY3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA/IE1sc0NyZWRlbnRpYWwuZnJvbUpTT04ob2JqZWN0LmNyZWRlbnRpYWwpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25QdWJsaWNLZXk6IGlzU2V0KG9iamVjdC5pbnN0YWxsYXRpb25QdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmluc3RhbGxhdGlvblB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBpZGVudGl0eVVwZGF0ZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmlkZW50aXR5VXBkYXRlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5pZGVudGl0eVVwZGF0ZXMubWFwKChlKSA9PiBJZGVudGl0eVVwZGF0ZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWRlbnRpYWwgPSBtZXNzYWdlLmNyZWRlbnRpYWxcbiAgICAgICAgICAgICAgICA/IE1sc0NyZWRlbnRpYWwudG9KU09OKG1lc3NhZ2UuY3JlZGVudGlhbClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaW5zdGFsbGF0aW9uUHVibGljS2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuaW5zdGFsbGF0aW9uUHVibGljS2V5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5VXBkYXRlcykge1xuICAgICAgICAgICAgb2JqLmlkZW50aXR5VXBkYXRlcyA9IG1lc3NhZ2UuaWRlbnRpdHlVcGRhdGVzLm1hcCgoZSkgPT4gZSA/IElkZW50aXR5VXBkYXRlLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouaWRlbnRpdHlVcGRhdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZHNSZXF1ZXN0X1ZhbGlkYXRpb25SZXF1ZXN0KCk7XG4gICAgICAgIG1lc3NhZ2UuY3JlZGVudGlhbCA9XG4gICAgICAgICAgICBvYmplY3QuY3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVkZW50aWFsICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBNbHNDcmVkZW50aWFsLmZyb21QYXJ0aWFsKG9iamVjdC5jcmVkZW50aWFsKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluc3RhbGxhdGlvblB1YmxpY0tleSA9XG4gICAgICAgICAgICAoX2EgPSBvYmplY3QuaW5zdGFsbGF0aW9uUHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmlkZW50aXR5VXBkYXRlcyA9XG4gICAgICAgICAgICAoKF9iID0gb2JqZWN0LmlkZW50aXR5VXBkYXRlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoZSkgPT4gSWRlbnRpdHlVcGRhdGUuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlc3BvbnNlczogW10gfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdGVJbmJveElkc1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXNwb25zZXMucHVzaChWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnJlc3BvbnNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5yZXNwb25zZXMubWFwKChlKSA9PiBWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBvYmoucmVzcG9uc2VzID0gbWVzc2FnZS5yZXNwb25zZXMubWFwKChlKSA9PiBlID8gVmFsaWRhdGVJbmJveElkc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZHNSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlcyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnJlc3BvbnNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gVmFsaWRhdGVJbmJveElkc1Jlc3BvbnNlX1ZhbGlkYXRpb25SZXNwb25zZS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IGlzT2s6IGZhbHNlLCBlcnJvck1lc3NhZ2U6IFwiXCIsIGluYm94SWQ6IFwiXCIgfTtcbn1cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZUluYm94SWRzUmVzcG9uc2VfVmFsaWRhdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmlzT2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuYm9vbChtZXNzYWdlLmlzT2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yTWVzc2FnZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbmJveElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5pbmJveElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZHNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzT2sgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNPazogaXNTZXQob2JqZWN0LmlzT2spID8gQm9vbGVhbihvYmplY3QuaXNPaykgOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogaXNTZXQob2JqZWN0LmVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGluYm94SWQ6IGlzU2V0KG9iamVjdC5pbmJveElkKSA/IFN0cmluZyhvYmplY3QuaW5ib3hJZCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaXNPayAhPT0gdW5kZWZpbmVkICYmIChvYmouaXNPayA9IG1lc3NhZ2UuaXNPayk7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3JNZXNzYWdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXJyb3JNZXNzYWdlID0gbWVzc2FnZS5lcnJvck1lc3NhZ2UpO1xuICAgICAgICBtZXNzYWdlLmluYm94SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmluYm94SWQgPSBtZXNzYWdlLmluYm94SWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRlSW5ib3hJZHNSZXNwb25zZV9WYWxpZGF0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5pc09rID0gKF9hID0gb2JqZWN0LmlzT2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmVycm9yTWVzc2FnZSA9IChfYiA9IG9iamVjdC5lcnJvck1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaW5ib3hJZCA9IChfYyA9IG9iamVjdC5pbmJveElkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uQXBpQ2xpZW50SW1wbCB7XG4gICAgY29uc3RydWN0b3IocnBjKSB7XG4gICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICB0aGlzLlZhbGlkYXRlS2V5UGFja2FnZXMgPSB0aGlzLlZhbGlkYXRlS2V5UGFja2FnZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUdyb3VwTWVzc2FnZXMgPSB0aGlzLlZhbGlkYXRlR3JvdXBNZXNzYWdlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLkdldEFzc29jaWF0aW9uU3RhdGUgPSB0aGlzLkdldEFzc29jaWF0aW9uU3RhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5WYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlcyA9XG4gICAgICAgICAgICB0aGlzLlZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuVmFsaWRhdGVJbmJveElkcyA9IHRoaXMuVmFsaWRhdGVJbmJveElkcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLlZlcmlmeVNtYXJ0Q29udHJhY3RXYWxsZXRTaWduYXR1cmVzID1cbiAgICAgICAgICAgIHRoaXMuVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgVmFsaWRhdGVLZXlQYWNrYWdlcyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBWYWxpZGF0ZUtleVBhY2thZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHNfdmFsaWRhdGlvbi52MS5WYWxpZGF0aW9uQXBpXCIsIFwiVmFsaWRhdGVLZXlQYWNrYWdlc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gVmFsaWRhdGVLZXlQYWNrYWdlc1Jlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBWYWxpZGF0ZUdyb3VwTWVzc2FnZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVmFsaWRhdGVHcm91cE1lc3NhZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHNfdmFsaWRhdGlvbi52MS5WYWxpZGF0aW9uQXBpXCIsIFwiVmFsaWRhdGVHcm91cE1lc3NhZ2VzXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChkYXRhKSA9PiBWYWxpZGF0ZUdyb3VwTWVzc2FnZXNSZXNwb25zZS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKTtcbiAgICB9XG4gICAgR2V0QXNzb2NpYXRpb25TdGF0ZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBHZXRBc3NvY2lhdGlvblN0YXRlUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHNfdmFsaWRhdGlvbi52MS5WYWxpZGF0aW9uQXBpXCIsIFwiR2V0QXNzb2NpYXRpb25TdGF0ZVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gR2V0QXNzb2NpYXRpb25TdGF0ZVJlc3BvbnNlLmRlY29kZShuZXcgX20wLlJlYWRlcihkYXRhKSkpO1xuICAgIH1cbiAgICBWYWxpZGF0ZUluYm94SWRLZXlQYWNrYWdlcyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBWYWxpZGF0ZUtleVBhY2thZ2VzUmVxdWVzdC5lbmNvZGUocmVxdWVzdCkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnJwYy5yZXF1ZXN0KFwieG10cC5tbHNfdmFsaWRhdGlvbi52MS5WYWxpZGF0aW9uQXBpXCIsIFwiVmFsaWRhdGVJbmJveElkS2V5UGFja2FnZXNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IFZhbGlkYXRlSW5ib3hJZEtleVBhY2thZ2VzUmVzcG9uc2UuZGVjb2RlKG5ldyBfbTAuUmVhZGVyKGRhdGEpKSk7XG4gICAgfVxuICAgIFZhbGlkYXRlSW5ib3hJZHMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVmFsaWRhdGVJbmJveElkc1JlcXVlc3QuZW5jb2RlKHJlcXVlc3QpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ycGMucmVxdWVzdChcInhtdHAubWxzX3ZhbGlkYXRpb24udjEuVmFsaWRhdGlvbkFwaVwiLCBcIlZhbGlkYXRlSW5ib3hJZHNcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKGRhdGEpID0+IFZhbGlkYXRlSW5ib3hJZHNSZXNwb25zZS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKTtcbiAgICB9XG4gICAgVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXMocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXF1ZXN0LmVuY29kZShyZXF1ZXN0KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucnBjLnJlcXVlc3QoXCJ4bXRwLm1sc192YWxpZGF0aW9uLnYxLlZhbGlkYXRpb25BcGlcIiwgXCJWZXJpZnlTbWFydENvbnRyYWN0V2FsbGV0U2lnbmF0dXJlc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZGF0YSkgPT4gVmVyaWZ5U21hcnRDb250cmFjdFdhbGxldFNpZ25hdHVyZXNSZXNwb25zZS5kZWNvZGUobmV3IF9tMC5SZWFkZXIoZGF0YSkpKTtcbiAgICB9XG59XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBiaW4gPSBnbG9iYWxUaGlzLmF0b2IoYjY0KTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKFwiXCIpKTtcbiAgICB9XG59XG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICAgIF9tMC51dGlsLkxvbmcgPSBMb25nO1xuICAgIF9tMC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLnBiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/mls_validation/v1/service.pb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/node.js":
/*!******************************************************!*\
  !*** ./node_modules/@xmtp/proto/ts/dist/esm/node.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authn: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.authn),\n/* harmony export */   ciphertext: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ciphertext),\n/* harmony export */   composite: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.composite),\n/* harmony export */   contact: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.contact),\n/* harmony export */   content: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.content),\n/* harmony export */   conversationReference: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.conversationReference),\n/* harmony export */   ecies: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ecies),\n/* harmony export */   fetcher: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.fetcher),\n/* harmony export */   frames: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.frames),\n/* harmony export */   invitation: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.invitation),\n/* harmony export */   keystore: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.keystore),\n/* harmony export */   message: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.message),\n/* harmony export */   messageApi: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.messageApi),\n/* harmony export */   mlsApi: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsApi),\n/* harmony export */   mlsContent: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsContent),\n/* harmony export */   mlsDatabaseIntent: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsDatabaseIntent),\n/* harmony export */   mlsGroupMembership: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsGroupMembership),\n/* harmony export */   mlsGroupMetadata: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsGroupMetadata),\n/* harmony export */   mlsGroupMutableMetadata: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsGroupMutableMetadata),\n/* harmony export */   mlsTranscriptMessages: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsTranscriptMessages),\n/* harmony export */   mlsValidationService: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.mlsValidationService),\n/* harmony export */   privateKey: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.privateKey),\n/* harmony export */   privatePreferences: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.privatePreferences),\n/* harmony export */   publicKey: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.publicKey),\n/* harmony export */   signature: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.signature),\n/* harmony export */   signedPayload: () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.signedPayload)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/index.js\");\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    return undefined;\n}\nconst ctx = getGlobal();\nif (typeof ctx.fetch === \"undefined\") {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { fetch, Request, Response, Headers } = __webpack_require__(/*! undici */ \"undici\");\n    ctx.fetch = fetch;\n    ctx.Request = Request;\n    ctx.Response = Response;\n    ctx.Headers = Headers;\n}\nconst streamClasses = [\n    \"TextDecoderStream\",\n    \"TextEncoderStream\",\n    \"TransformStream\",\n    \"ReadableStream\",\n    \"WritableStream\",\n    \"ByteLengthQueuingStrategy\",\n    \"CountQueuingStrategy\",\n];\nfor (const clsName of streamClasses) {\n    if (typeof ctx[clsName] === \"undefined\") {\n        ctx[clsName] = __webpack_require__(/*! stream/web */ \"stream/web\")[clsName];\n    }\n}\n\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4QkFBWTtBQUMzQztBQUNBO0FBQ3dCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvcHJvdG8vdHMvZGlzdC9lc20vbm9kZS5qcz9kMmZjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IGN0eCA9IGdldEdsb2JhbCgpO1xuaWYgKHR5cGVvZiBjdHguZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IHsgZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlLCBIZWFkZXJzIH0gPSByZXF1aXJlKFwidW5kaWNpXCIpO1xuICAgIGN0eC5mZXRjaCA9IGZldGNoO1xuICAgIGN0eC5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBjdHguUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICBjdHguSGVhZGVycyA9IEhlYWRlcnM7XG59XG5jb25zdCBzdHJlYW1DbGFzc2VzID0gW1xuICAgIFwiVGV4dERlY29kZXJTdHJlYW1cIixcbiAgICBcIlRleHRFbmNvZGVyU3RyZWFtXCIsXG4gICAgXCJUcmFuc2Zvcm1TdHJlYW1cIixcbiAgICBcIlJlYWRhYmxlU3RyZWFtXCIsXG4gICAgXCJXcml0YWJsZVN0cmVhbVwiLFxuICAgIFwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiLFxuICAgIFwiQ291bnRRdWV1aW5nU3RyYXRlZ3lcIixcbl07XG5mb3IgKGNvbnN0IGNsc05hbWUgb2Ygc3RyZWFtQ2xhc3Nlcykge1xuICAgIGlmICh0eXBlb2YgY3R4W2Nsc05hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGN0eFtjbHNOYW1lXSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpW2Nsc05hbWVdO1xuICAgIH1cbn1cbmV4cG9ydCAqIGZyb20gXCIuL2luZGV4XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/user-preferences-bindings-wasm/dist/node/user_preferences_bindings_wasm.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@xmtp/user-preferences-bindings-wasm/dist/node/user_preferences_bindings_wasm.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nlet imports = {};\nimports['__wbindgen_placeholder__'] = module.exports;\nlet wasm;\nconst { TextDecoder } = __webpack_require__(/*! util */ \"util\");\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @param {Uint8Array} public_key\n* @param {Uint8Array} private_key\n* @param {Uint8Array} message\n* @returns {Uint8Array}\n*/\nmodule.exports.user_preferences_encrypt = function(public_key, private_key, message) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.user_preferences_encrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v4 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1, 1);\n        return v4;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n};\n\n/**\n* @param {Uint8Array} public_key\n* @param {Uint8Array} private_key\n* @param {Uint8Array} message\n* @returns {Uint8Array}\n*/\nmodule.exports.user_preferences_decrypt = function(public_key, private_key, message) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.user_preferences_decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v4 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1, 1);\n        return v4;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n};\n\n/**\n* @param {Uint8Array} private_key\n* @returns {string}\n*/\nmodule.exports.generate_private_preferences_topic = function(private_key) {\n    let deferred3_0;\n    let deferred3_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.generate_private_preferences_topic(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        var ptr2 = r0;\n        var len2 = r1;\n        if (r3) {\n            ptr2 = 0; len2 = 0;\n            throw takeObject(r2);\n        }\n        deferred3_0 = ptr2;\n        deferred3_1 = len2;\n        return getStringFromWasm0(ptr2, len2);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n    }\n};\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nmodule.exports.__wbindgen_string_new = function(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nmodule.exports.__wbg_crypto_d05b68a3572bb8ca = function(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_is_object = function(arg0) {\n    const val = getObject(arg0);\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nmodule.exports.__wbg_process_b02b3570280d0366 = function(arg0) {\n    const ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_versions_c1cb42213cedf0f5 = function(arg0) {\n    const ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_node_43b1089f407e4ec2 = function(arg0) {\n    const ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_is_string = function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nmodule.exports.__wbg_require_9a7e0f667ead4995 = function() { return handleError(function () {\n    const ret = module.require;\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_msCrypto_10fc94afee92bd76 = function(arg0) {\n    const ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_randomFillSync_b70ccbdf4926a99d = function() { return handleError(function (arg0, arg1) {\n    getObject(arg0).randomFillSync(takeObject(arg1));\n}, arguments) };\n\nmodule.exports.__wbg_getRandomValues_7e42b4fb8779dc6d = function() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nmodule.exports.__wbindgen_is_function = function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nmodule.exports.__wbg_newnoargs_cfecb3965268594c = function(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_call_3f093dd26d5569f8 = function() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_self_05040bd9523805b9 = function() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_window_adc720039f2cb14f = function() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_globalThis_622105db80c1457d = function() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_global_f56b013ed9bcf359 = function() { return handleError(function () {\n    const ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbindgen_is_undefined = function(arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nmodule.exports.__wbg_call_67f2111acd2dfdb6 = function() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nmodule.exports.__wbg_buffer_b914fb8b50ebbc3e = function(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_newwithbyteoffsetandlength_0de9ee56e9f6ee6e = function(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_new_b1f2d6842d615181 = function(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_set_7d988c98e6ced92d = function(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nmodule.exports.__wbg_newwithlength_0d03cef43b68a530 = function(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbg_subarray_adc418253d76e2f1 = function(arg0, arg1, arg2) {\n    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_object_clone_ref = function(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nmodule.exports.__wbindgen_memory = function() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nconst path = (__webpack_require__(/*! path */ \"path\").join)(__dirname, 'user_preferences_bindings_wasm_bg.wasm');\nconst bytes = (__webpack_require__(/*! fs */ \"fs\").readFileSync)(path);\n\nconst wasmModule = new WebAssembly.Module(bytes);\nconst wasmInstance = new WebAssembly.Instance(wasmModule, imports);\nwasm = wasmInstance.exports;\nmodule.exports.__wasm = wasm;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvdXNlci1wcmVmZXJlbmNlcy1iaW5kaW5ncy13YXNtL2Rpc3Qvbm9kZS91c2VyX3ByZWZlcmVuY2VzX2JpbmRpbmdzX3dhc20uanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRXRDLG1EQUFtRCw4QkFBOEI7O0FBRWpGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsWUFBWTtBQUN0QixVQUFVLFlBQVk7QUFDdEIsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLFlBQVk7QUFDdEIsVUFBVSxZQUFZO0FBQ3RCLFlBQVk7QUFDWjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFlBQVk7QUFDdEIsWUFBWTtBQUNaO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQSxDQUFDOztBQUVELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBLENBQUM7O0FBRUQscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBLENBQUM7O0FBRUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBLENBQUM7O0FBRUQsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDhDQUFvQjtBQUNqQyxjQUFjLGtEQUEwQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvdXNlci1wcmVmZXJlbmNlcy1iaW5kaW5ncy13YXNtL2Rpc3Qvbm9kZS91c2VyX3ByZWZlcmVuY2VzX2JpbmRpbmdzX3dhc20uanM/NTRmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgaW1wb3J0cyA9IHt9O1xuaW1wb3J0c1snX193YmluZGdlbl9wbGFjZWhvbGRlcl9fJ10gPSBtb2R1bGUuZXhwb3J0cztcbmxldCB3YXNtO1xuY29uc3QgeyBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZShgdXRpbGApO1xuXG5sZXQgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxubGV0IGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQ4TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OE1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxubGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoO1xuXG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCBpZHggPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdO1xuXG4gICAgaGVhcFtpZHhdID0gb2JqO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5mdW5jdGlvbiBkcm9wT2JqZWN0KGlkeCkge1xuICAgIGlmIChpZHggPCAxMzIpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuZnVuY3Rpb24gcGFzc0FycmF5OFRvV2FzbTAoYXJnLCBtYWxsb2MpIHtcbiAgICBjb25zdCBwdHIgPSBtYWxsb2MoYXJnLmxlbmd0aCAqIDEsIDEpID4+PiAwO1xuICAgIGdldFVpbnQ4TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDEpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkSW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZEludDMyTWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRJbnQzMk1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VThGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDEsIHB0ciAvIDEgKyBsZW4pO1xufVxuLyoqXG4qIEBwYXJhbSB7VWludDhBcnJheX0gcHVibGljX2tleVxuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByaXZhdGVfa2V5XG4qIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5tb2R1bGUuZXhwb3J0cy51c2VyX3ByZWZlcmVuY2VzX2VuY3J5cHQgPSBmdW5jdGlvbihwdWJsaWNfa2V5LCBwcml2YXRlX2tleSwgbWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAocHVibGljX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXk4VG9XYXNtMChwcml2YXRlX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzQXJyYXk4VG9XYXNtMChtZXNzYWdlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS51c2VyX3ByZWZlcmVuY2VzX2VuY3J5cHQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2NCA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgcmV0dXJuIHY0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufTtcblxuLyoqXG4qIEBwYXJhbSB7VWludDhBcnJheX0gcHVibGljX2tleVxuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByaXZhdGVfa2V5XG4qIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5tb2R1bGUuZXhwb3J0cy51c2VyX3ByZWZlcmVuY2VzX2RlY3J5cHQgPSBmdW5jdGlvbihwdWJsaWNfa2V5LCBwcml2YXRlX2tleSwgbWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAocHVibGljX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXk4VG9XYXNtMChwcml2YXRlX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzQXJyYXk4VG9XYXNtMChtZXNzYWdlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS51c2VyX3ByZWZlcmVuY2VzX2RlY3J5cHQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2NCA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgcmV0dXJuIHY0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufTtcblxuLyoqXG4qIEBwYXJhbSB7VWludDhBcnJheX0gcHJpdmF0ZV9rZXlcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZV9wcml2YXRlX3ByZWZlcmVuY2VzX3RvcGljID0gZnVuY3Rpb24ocHJpdmF0ZV9rZXkpIHtcbiAgICBsZXQgZGVmZXJyZWQzXzA7XG4gICAgbGV0IGRlZmVycmVkM18xO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAocHJpdmF0ZV9rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmdlbmVyYXRlX3ByaXZhdGVfcHJlZmVyZW5jZXNfdG9waWMocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkM18wID0gcHRyMjtcbiAgICAgICAgZGVmZXJyZWQzXzEgPSBsZW4yO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkM18wLCBkZWZlcnJlZDNfMSwgMSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4bl9zdG9yZShhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JpbmRnZW5fc3RyaW5nX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIHRha2VPYmplY3QoYXJnMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19jcnlwdG9fZDA1YjY4YTM1NzJiYjhjYSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY3J5cHRvO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diaW5kZ2VuX2lzX29iamVjdCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICBjb25zdCB2YWwgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfcHJvY2Vzc19iMDJiMzU3MDI4MGQwMzY2ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5wcm9jZXNzO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ192ZXJzaW9uc19jMWNiNDIyMTNjZWRmMGY1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52ZXJzaW9ucztcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193Ymdfbm9kZV80M2IxMDg5ZjQwN2U0ZWMyID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ub2RlO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diaW5kZ2VuX2lzX3N0cmluZyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ3N0cmluZyc7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JnX3JlcXVpcmVfOWE3ZTBmNjY3ZWFkNDk5NSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJldCA9IG1vZHVsZS5yZXF1aXJlO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JnX21zQ3J5cHRvXzEwZmM5NGFmZWU5MmJkNzYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19yYW5kb21GaWxsU3luY19iNzBjY2JkZjQ5MjZhOTlkID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgIGdldE9iamVjdChhcmcwKS5yYW5kb21GaWxsU3luYyh0YWtlT2JqZWN0KGFyZzEpKTtcbn0sIGFyZ3VtZW50cykgfTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfZ2V0UmFuZG9tVmFsdWVzXzdlNDJiNGZiODc3OWRjNmQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcyhnZXRPYmplY3QoYXJnMSkpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diaW5kZ2VuX2lzX2Z1bmN0aW9uID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19uZXdub2FyZ3NfY2ZlY2IzOTY1MjY4NTk0YyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgRnVuY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfY2FsbF8zZjA5M2RkMjZkNTU2OWY4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn0sIGFyZ3VtZW50cykgfTtcblxubW9kdWxlLmV4cG9ydHMuX193Ymdfc2VsZl8wNTA0MGJkOTUyMzgwNWI5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcmV0ID0gc2VsZi5zZWxmO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JnX3dpbmRvd19hZGM3MjAwMzlmMmNiMTRmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcmV0ID0gd2luZG93LndpbmRvdztcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19nbG9iYWxUaGlzXzYyMjEwNWRiODBjMTQ1N2QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByZXQgPSBnbG9iYWxUaGlzLmdsb2JhbFRoaXM7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn0sIGFyZ3VtZW50cykgfTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfZ2xvYmFsX2Y1NmIwMTNlZDliY2YzNTkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByZXQgPSBnbG9iYWwuZ2xvYmFsO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JpbmRnZW5faXNfdW5kZWZpbmVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19jYWxsXzY3ZjIxMTFhY2QyZGZkYjYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JnX2J1ZmZlcl9iOTE0ZmI4YjUwZWJiYzNlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5idWZmZXI7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoXzBkZTllZTU2ZTlmNmVlNmUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfbmV3X2IxZjJkNjg0MmQ2MTUxODEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193Ymdfc2V0XzdkOTg4Yzk4ZTZjZWQ5MmQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRPYmplY3QoYXJnMSksIGFyZzIgPj4+IDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmdfbmV3d2l0aGxlbmd0aF8wZDAzY2VmNDNiNjhhNTMwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGFyZzAgPj4+IDApO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3diZ19zdWJhcnJheV9hZGM0MTgyNTNkNzZlMmYxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuX193YmluZGdlbl90aHJvdyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9fd2JpbmRnZW5fbWVtb3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJykuam9pbihfX2Rpcm5hbWUsICd1c2VyX3ByZWZlcmVuY2VzX2JpbmRpbmdzX3dhc21fYmcud2FzbScpO1xuY29uc3QgYnl0ZXMgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhwYXRoKTtcblxuY29uc3Qgd2FzbU1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYnl0ZXMpO1xuY29uc3Qgd2FzbUluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHdhc21Nb2R1bGUsIGltcG9ydHMpO1xud2FzbSA9IHdhc21JbnN0YW5jZS5leHBvcnRzO1xubW9kdWxlLmV4cG9ydHMuX193YXNtID0gd2FzbTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/user-preferences-bindings-wasm/dist/node/user_preferences_bindings_wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/consent-proof-signature/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@xmtp/consent-proof-signature/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createConsentMessage: () => (/* binding */ createConsentMessage),\n/* harmony export */   createConsentProofPayload: () => (/* binding */ createConsentProofPayload)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _xmtp_proto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @xmtp/proto */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/node_modules/@xmtp/proto/ts/dist/esm/node.js\");\n\n\n\n/**\n *\n * @param peerAddress - Ethereum address of the broadcaster\n * @param timestampMs - Timestamp in milliseconds used in the signature\n * @returns\n */\nconst createConsentMessage = (peerAddress, timestampMs) => \"XMTP : Grant inbox consent to sender\\n\" +\n    \"\\n\" +\n    `Current Time: ${new Date(timestampMs).toUTCString()}\\n` +\n    `From Address: ${peerAddress}\\n` +\n    \"\\n\" +\n    \"For more info: https://xmtp.org/signatures/\";\n/**\n *\n * @param signature hex string of the signature\n * @param timestampMs timestamp in milliseconds used in the signature\n * @returns Uint8Array of the consent proof payload\n */\nconst createConsentProofPayload = (signature, timestampMs) => _xmtp_proto__WEBPACK_IMPORTED_MODULE_1__.invitation.ConsentProofPayload.encode({\n    signature,\n    timestamp: long__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromNumber(timestampMs),\n    payloadVersion: _xmtp_proto__WEBPACK_IMPORTED_MODULE_1__.invitation.ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1,\n}).finish();\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0I7QUFDaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DO0FBQ3pELHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUVBQThCO0FBQzVGO0FBQ0EsZUFBZSw0Q0FBSTtBQUNuQixvQkFBb0IsOEVBQXFDO0FBQ3pELENBQUM7O0FBRTBEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29uc2VudC1wcm9vZi1zaWduYXR1cmUvbGliL2luZGV4LmpzP2Y4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgeyBpbnZpdGF0aW9uIH0gZnJvbSAnQHhtdHAvcHJvdG8nO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gcGVlckFkZHJlc3MgLSBFdGhlcmV1bSBhZGRyZXNzIG9mIHRoZSBicm9hZGNhc3RlclxuICogQHBhcmFtIHRpbWVzdGFtcE1zIC0gVGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyB1c2VkIGluIHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGNyZWF0ZUNvbnNlbnRNZXNzYWdlID0gKHBlZXJBZGRyZXNzLCB0aW1lc3RhbXBNcykgPT4gXCJYTVRQIDogR3JhbnQgaW5ib3ggY29uc2VudCB0byBzZW5kZXJcXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgYEN1cnJlbnQgVGltZTogJHtuZXcgRGF0ZSh0aW1lc3RhbXBNcykudG9VVENTdHJpbmcoKX1cXG5gICtcbiAgICBgRnJvbSBBZGRyZXNzOiAke3BlZXJBZGRyZXNzfVxcbmAgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiRm9yIG1vcmUgaW5mbzogaHR0cHM6Ly94bXRwLm9yZy9zaWduYXR1cmVzL1wiO1xuLyoqXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSBoZXggc3RyaW5nIG9mIHRoZSBzaWduYXR1cmVcbiAqIEBwYXJhbSB0aW1lc3RhbXBNcyB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIHVzZWQgaW4gdGhlIHNpZ25hdHVyZVxuICogQHJldHVybnMgVWludDhBcnJheSBvZiB0aGUgY29uc2VudCBwcm9vZiBwYXlsb2FkXG4gKi9cbmNvbnN0IGNyZWF0ZUNvbnNlbnRQcm9vZlBheWxvYWQgPSAoc2lnbmF0dXJlLCB0aW1lc3RhbXBNcykgPT4gaW52aXRhdGlvbi5Db25zZW50UHJvb2ZQYXlsb2FkLmVuY29kZSh7XG4gICAgc2lnbmF0dXJlLFxuICAgIHRpbWVzdGFtcDogTG9uZy5mcm9tTnVtYmVyKHRpbWVzdGFtcE1zKSxcbiAgICBwYXlsb2FkVmVyc2lvbjogaW52aXRhdGlvbi5Db25zZW50UHJvb2ZQYXlsb2FkVmVyc2lvbi5DT05TRU5UX1BST09GX1BBWUxPQURfVkVSU0lPTl8xLFxufSkuZmluaXNoKCk7XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbnNlbnRNZXNzYWdlLCBjcmVhdGVDb25zZW50UHJvb2ZQYXlsb2FkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/consent-proof-signature/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/content-type-primitives/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@xmtp/content-type-primitives/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentTypeId: () => (/* binding */ ContentTypeId)\n/* harmony export */ });\nclass ContentTypeId {\n    authorityId;\n    typeId;\n    versionMajor;\n    versionMinor;\n    constructor(obj) {\n        this.authorityId = obj.authorityId;\n        this.typeId = obj.typeId;\n        this.versionMajor = obj.versionMajor;\n        this.versionMinor = obj.versionMinor;\n    }\n    toString() {\n        return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;\n    }\n    static fromString(contentTypeString) {\n        const [idString, versionString] = contentTypeString.split(\":\");\n        const [authorityId, typeId] = idString.split(\"/\");\n        const [major, minor] = versionString.split(\".\");\n        return new ContentTypeId({\n            authorityId,\n            typeId,\n            versionMajor: Number(major),\n            versionMinor: Number(minor),\n        });\n    }\n    sameAs(id) {\n        return this.authorityId === id.authorityId && this.typeId === id.typeId;\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29udGVudC10eXBlLXByaW1pdGl2ZXMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQixHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb250ZW50LXR5cGUtcHJpbWl0aXZlcy9kaXN0L2luZGV4LmpzPzk4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQ29udGVudFR5cGVJZCB7XG4gICAgYXV0aG9yaXR5SWQ7XG4gICAgdHlwZUlkO1xuICAgIHZlcnNpb25NYWpvcjtcbiAgICB2ZXJzaW9uTWlub3I7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIHRoaXMuYXV0aG9yaXR5SWQgPSBvYmouYXV0aG9yaXR5SWQ7XG4gICAgICAgIHRoaXMudHlwZUlkID0gb2JqLnR5cGVJZDtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFqb3IgPSBvYmoudmVyc2lvbk1ham9yO1xuICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IG9iai52ZXJzaW9uTWlub3I7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5hdXRob3JpdHlJZH0vJHt0aGlzLnR5cGVJZH06JHt0aGlzLnZlcnNpb25NYWpvcn0uJHt0aGlzLnZlcnNpb25NaW5vcn1gO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhjb250ZW50VHlwZVN0cmluZykge1xuICAgICAgICBjb25zdCBbaWRTdHJpbmcsIHZlcnNpb25TdHJpbmddID0gY29udGVudFR5cGVTdHJpbmcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBjb25zdCBbYXV0aG9yaXR5SWQsIHR5cGVJZF0gPSBpZFN0cmluZy5zcGxpdChcIi9cIik7XG4gICAgICAgIGNvbnN0IFttYWpvciwgbWlub3JdID0gdmVyc2lvblN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGVudFR5cGVJZCh7XG4gICAgICAgICAgICBhdXRob3JpdHlJZCxcbiAgICAgICAgICAgIHR5cGVJZCxcbiAgICAgICAgICAgIHZlcnNpb25NYWpvcjogTnVtYmVyKG1ham9yKSxcbiAgICAgICAgICAgIHZlcnNpb25NaW5vcjogTnVtYmVyKG1pbm9yKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhbWVBcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpdHlJZCA9PT0gaWQuYXV0aG9yaXR5SWQgJiYgdGhpcy50eXBlSWQgPT09IGlkLnR5cGVJZDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbnRlbnRUeXBlSWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/content-type-primitives/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/content-type-text/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@xmtp/content-type-text/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentTypeText: () => (/* binding */ ContentTypeText),\n/* harmony export */   Encoding: () => (/* binding */ Encoding),\n/* harmony export */   TextCodec: () => (/* binding */ TextCodec)\n/* harmony export */ });\n/* harmony import */ var _xmtp_content_type_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xmtp/content-type-primitives */ \"(ssr)/./node_modules/@xmtp/content-type-primitives/dist/index.js\");\n\n\nconst ContentTypeText = new _xmtp_content_type_primitives__WEBPACK_IMPORTED_MODULE_0__.ContentTypeId({\n    authorityId: \"xmtp.org\",\n    typeId: \"text\",\n    versionMajor: 1,\n    versionMinor: 0,\n});\nvar Encoding;\n(function (Encoding) {\n    Encoding[\"utf8\"] = \"UTF-8\";\n})(Encoding || (Encoding = {}));\nclass TextCodec {\n    get contentType() {\n        return ContentTypeText;\n    }\n    encode(content) {\n        return {\n            type: ContentTypeText,\n            parameters: { encoding: Encoding.utf8 },\n            content: new TextEncoder().encode(content),\n        };\n    }\n    decode(content) {\n        const { encoding } = content.parameters;\n        if (encoding !== Encoding.utf8) {\n            throw new Error(`unrecognized encoding ${encoding}`);\n        }\n        return new TextDecoder().decode(content.content);\n    }\n    fallback() {\n        return undefined;\n    }\n    shouldPush() {\n        return true;\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAvY29udGVudC10eXBlLXRleHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThEOztBQUU5RCw0QkFBNEIsd0VBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC9jb250ZW50LXR5cGUtdGV4dC9kaXN0L2luZGV4LmpzP2Y3OGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGVudFR5cGVJZCB9IGZyb20gJ0B4bXRwL2NvbnRlbnQtdHlwZS1wcmltaXRpdmVzJztcblxuY29uc3QgQ29udGVudFR5cGVUZXh0ID0gbmV3IENvbnRlbnRUeXBlSWQoe1xuICAgIGF1dGhvcml0eUlkOiBcInhtdHAub3JnXCIsXG4gICAgdHlwZUlkOiBcInRleHRcIixcbiAgICB2ZXJzaW9uTWFqb3I6IDEsXG4gICAgdmVyc2lvbk1pbm9yOiAwLFxufSk7XG52YXIgRW5jb2Rpbmc7XG4oZnVuY3Rpb24gKEVuY29kaW5nKSB7XG4gICAgRW5jb2RpbmdbXCJ1dGY4XCJdID0gXCJVVEYtOFwiO1xufSkoRW5jb2RpbmcgfHwgKEVuY29kaW5nID0ge30pKTtcbmNsYXNzIFRleHRDb2RlYyB7XG4gICAgZ2V0IGNvbnRlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gQ29udGVudFR5cGVUZXh0O1xuICAgIH1cbiAgICBlbmNvZGUoY29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogQ29udGVudFR5cGVUZXh0LFxuICAgICAgICAgICAgcGFyYW1ldGVyczogeyBlbmNvZGluZzogRW5jb2RpbmcudXRmOCB9LFxuICAgICAgICAgICAgY29udGVudDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNvbnRlbnQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWNvZGUoY29udGVudCkge1xuICAgICAgICBjb25zdCB7IGVuY29kaW5nIH0gPSBjb250ZW50LnBhcmFtZXRlcnM7XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gRW5jb2RpbmcudXRmOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgZW5jb2RpbmcgJHtlbmNvZGluZ31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGNvbnRlbnQuY29udGVudCk7XG4gICAgfVxuICAgIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzaG91bGRQdXNoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbnRlbnRUeXBlVGV4dCwgRW5jb2RpbmcsIFRleHRDb2RlYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/content-type-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiUrls: () => (/* binding */ ApiUrls),\n/* harmony export */   AuthCache: () => (/* binding */ AuthCache),\n/* harmony export */   BrowserStoragePersistence: () => (/* binding */ BrowserStoragePersistence),\n/* harmony export */   Ciphertext: () => (/* binding */ Ciphertext),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   Compression: () => (/* binding */ Compression),\n/* harmony export */   ConsentListEntry: () => (/* binding */ ConsentListEntry),\n/* harmony export */   ConversationV1: () => (/* binding */ ConversationV1),\n/* harmony export */   ConversationV2: () => (/* binding */ ConversationV2),\n/* harmony export */   Conversations: () => (/* binding */ Conversations),\n/* harmony export */   DecodedMessage: () => (/* binding */ DecodedMessage),\n/* harmony export */   EncryptedPersistence: () => (/* binding */ EncryptedPersistence),\n/* harmony export */   HttpApiClient: () => (/* binding */ HttpApiClient),\n/* harmony export */   InMemoryKeystore: () => (/* binding */ InMemoryKeystore),\n/* harmony export */   InMemoryPersistence: () => (/* binding */ InMemoryPersistence),\n/* harmony export */   InvitationV1: () => (/* binding */ InvitationV1),\n/* harmony export */   KeyGeneratorKeystoreProvider: () => (/* binding */ KeyGeneratorKeystoreProvider),\n/* harmony export */   LocalAuthenticator: () => (/* binding */ LocalAuthenticator),\n/* harmony export */   MessageV1: () => (/* binding */ MessageV1),\n/* harmony export */   MessageV2: () => (/* binding */ MessageV2),\n/* harmony export */   NetworkKeystoreProvider: () => (/* binding */ NetworkKeystoreProvider),\n/* harmony export */   PrefixedPersistence: () => (/* binding */ PrefixedPersistence),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyBundleV1: () => (/* binding */ PrivateKeyBundleV1),\n/* harmony export */   PrivateKeyBundleV2: () => (/* binding */ PrivateKeyBundleV2),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   PublicKeyBundle: () => (/* binding */ PublicKeyBundle),\n/* harmony export */   SealedInvitation: () => (/* binding */ SealedInvitation),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SignedPublicKey: () => (/* binding */ SignedPublicKey),\n/* harmony export */   SignedPublicKeyBundle: () => (/* binding */ SignedPublicKeyBundle),\n/* harmony export */   SnapProvider: () => (/* binding */ SnapKeystoreProvider),\n/* harmony export */   SortDirection: () => (/* binding */ SortDirection),\n/* harmony export */   StaticKeystoreProvider: () => (/* binding */ StaticKeystoreProvider),\n/* harmony export */   Stream: () => (/* binding */ Stream),\n/* harmony export */   buildContentTopic: () => (/* binding */ buildContentTopic),\n/* harmony export */   buildDirectMessageTopic: () => (/* binding */ buildDirectMessageTopic),\n/* harmony export */   buildDirectMessageTopicV2: () => (/* binding */ buildDirectMessageTopicV2),\n/* harmony export */   buildUserContactTopic: () => (/* binding */ buildUserContactTopic),\n/* harmony export */   buildUserIntroTopic: () => (/* binding */ buildUserIntroTopic),\n/* harmony export */   buildUserInviteTopic: () => (/* binding */ buildUserInviteTopic),\n/* harmony export */   buildUserPrivateStoreTopic: () => (/* binding */ buildUserPrivateStoreTopic),\n/* harmony export */   dateToNs: () => (/* binding */ dateToNs),\n/* harmony export */   decodeContactBundle: () => (/* binding */ decodeContactBundle),\n/* harmony export */   decodeContent: () => (/* binding */ decodeContent),\n/* harmony export */   decrypt: () => (/* binding */ decrypt$1),\n/* harmony export */   defaultKeystoreProviders: () => (/* binding */ defaultKeystoreProviders),\n/* harmony export */   encrypt: () => (/* binding */ encrypt$1),\n/* harmony export */   exportHmacKey: () => (/* binding */ exportHmacKey),\n/* harmony export */   fromNanoString: () => (/* binding */ fromNanoString),\n/* harmony export */   generateHmacSignature: () => (/* binding */ generateHmacSignature),\n/* harmony export */   hkdfHmacKey: () => (/* binding */ hkdfHmacKey),\n/* harmony export */   importHmacKey: () => (/* binding */ importHmacKey),\n/* harmony export */   keystoreApiDefs: () => (/* binding */ apiDefs),\n/* harmony export */   mapPaginatedStream: () => (/* binding */ mapPaginatedStream),\n/* harmony export */   nsToDate: () => (/* binding */ nsToDate),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   snapKeystoreApiDefs: () => (/* binding */ snapApiDefs),\n/* harmony export */   toNanoString: () => (/* binding */ toNanoString),\n/* harmony export */   verifyHmacSignature: () => (/* binding */ verifyHmacSignature)\n/* harmony export */ });\n/* harmony import */ var _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xmtp/proto */ \"(ssr)/./node_modules/@xmtp/proto/ts/dist/esm/node.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/index.js\");\n/* harmony import */ var _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/secp256k1 */ \"(ssr)/./node_modules/@noble/secp256k1/lib/esm/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hexToSignature.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hashMessage.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/verifyMessage.js\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @xmtp/content-type-text */ \"(ssr)/./node_modules/@xmtp/content-type-text/dist/index.js\");\n/* harmony import */ var _xmtp_content_type_primitives__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @xmtp/content-type-primitives */ \"(ssr)/./node_modules/@xmtp/content-type-primitives/dist/index.js\");\n/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! async-mutex */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/async-mutex/index.mjs\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var _xmtp_user_preferences_bindings_wasm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @xmtp/user-preferences-bindings-wasm */ \"(ssr)/./node_modules/@xmtp/user-preferences-bindings-wasm/dist/node/user_preferences_bindings_wasm.js\");\n/* harmony import */ var _xmtp_consent_proof_signature__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @xmtp/consent-proof-signature */ \"(ssr)/./node_modules/@xmtp/consent-proof-signature/lib/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst KDFSaltSize = 32; // bytes\n// AES-GCM defaults from https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\nconst AESGCMNonceSize = 12; // property iv\nconst AESGCMTagLength = 16; // property tagLength\n// Ciphertext packages the encrypted ciphertext with the salt and nonce used to produce it.\n// salt and nonce are not secret, and should be transmitted/stored along with the encrypted ciphertext.\nclass Ciphertext {\n    constructor(obj) {\n        if (!obj.aes256GcmHkdfSha256) {\n            throw new Error(\"invalid ciphertext\");\n        }\n        if (obj.aes256GcmHkdfSha256.payload.length < AESGCMTagLength) {\n            throw new Error(`invalid ciphertext ciphertext length: ${obj.aes256GcmHkdfSha256.payload.length}`);\n        }\n        if (obj.aes256GcmHkdfSha256.hkdfSalt.length !== KDFSaltSize) {\n            throw new Error(`invalid ciphertext salt length: ${obj.aes256GcmHkdfSha256.hkdfSalt.length}`);\n        }\n        if (obj.aes256GcmHkdfSha256.gcmNonce.length !== AESGCMNonceSize) {\n            throw new Error(`invalid ciphertext nonce length: ${obj.aes256GcmHkdfSha256.gcmNonce.length}`);\n        }\n        this.aes256GcmHkdfSha256 = obj.aes256GcmHkdfSha256;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.Ciphertext.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new Ciphertext(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.Ciphertext.decode(bytes));\n    }\n}\n\nconst crypto = node_crypto__WEBPACK_IMPORTED_MODULE_3__.webcrypto;\n\nconst hkdfNoInfo = new Uint8Array().buffer;\nconst hkdfNoSalt = new Uint8Array().buffer;\n// This is a variation of https://github.com/paulmillr/noble-secp256k1/blob/main/index.ts#L1378-L1388\n// that uses `digest('SHA-256', bytes)` instead of `digest('SHA-256', bytes.buffer)`\n// which seems to produce different results.\nasync function sha256(bytes) {\n    return new Uint8Array(await crypto.subtle.digest(\"SHA-256\", bytes));\n}\n// symmetric authenticated encryption of plaintext using the secret;\n// additionalData is used to protect un-encrypted parts of the message (header)\n// in the authentication scope of the encryption.\nasync function encrypt$1(plain, secret, additionalData) {\n    const salt = crypto.getRandomValues(new Uint8Array(KDFSaltSize));\n    const nonce = crypto.getRandomValues(new Uint8Array(AESGCMNonceSize));\n    const key = await hkdf(secret, salt);\n    const encrypted = await crypto.subtle.encrypt(aesGcmParams(nonce, additionalData), key, plain);\n    return new Ciphertext({\n        aes256GcmHkdfSha256: {\n            payload: new Uint8Array(encrypted),\n            hkdfSalt: salt,\n            gcmNonce: nonce,\n        },\n    });\n}\n// symmetric authenticated decryption of the encrypted ciphertext using the secret and additionalData\nasync function decrypt$1(encrypted, secret, additionalData) {\n    if (!encrypted.aes256GcmHkdfSha256) {\n        throw new Error(\"invalid payload ciphertext\");\n    }\n    const key = await hkdf(secret, encrypted.aes256GcmHkdfSha256.hkdfSalt);\n    const decrypted = await crypto.subtle.decrypt(aesGcmParams(encrypted.aes256GcmHkdfSha256.gcmNonce, additionalData), key, encrypted.aes256GcmHkdfSha256.payload);\n    return new Uint8Array(decrypted);\n}\n// helper for building Web Crypto API encryption parameter structure\nfunction aesGcmParams(nonce, additionalData) {\n    const spec = {\n        name: \"AES-GCM\",\n        iv: nonce,\n    };\n    if (additionalData) {\n        spec.additionalData = additionalData;\n    }\n    return spec;\n}\n// Derive AES-256-GCM key from a shared secret and salt.\n// Returns crypto.CryptoKey suitable for the encrypt/decrypt API\nasync function hkdf(secret, salt) {\n    const key = await crypto.subtle.importKey(\"raw\", secret, \"HKDF\", false, [\n        \"deriveKey\",\n    ]);\n    return crypto.subtle.deriveKey({ name: \"HKDF\", hash: \"SHA-256\", salt, info: hkdfNoInfo }, key, { name: \"AES-GCM\", length: 256 }, false, [\"encrypt\", \"decrypt\"]);\n}\nasync function hkdfHmacKey(secret, info) {\n    const key = await crypto.subtle.importKey(\"raw\", secret, \"HKDF\", false, [\n        \"deriveKey\",\n    ]);\n    return crypto.subtle.deriveKey({ name: \"HKDF\", hash: \"SHA-256\", salt: hkdfNoSalt, info }, key, { name: \"HMAC\", hash: \"SHA-256\", length: 256 }, true, [\"sign\", \"verify\"]);\n}\nasync function generateHmacSignature(secret, info, message) {\n    const key = await hkdfHmacKey(secret, info);\n    const signed = await crypto.subtle.sign(\"HMAC\", key, message);\n    return new Uint8Array(signed);\n}\nasync function verifyHmacSignature(key, signature, message) {\n    return await crypto.subtle.verify(\"HMAC\", key, signature, message);\n}\nasync function exportHmacKey(key) {\n    const exported = await crypto.subtle.exportKey(\"raw\", key);\n    return new Uint8Array(exported);\n}\nasync function importHmacKey(key) {\n    return crypto.subtle.importKey(\"raw\", key, { name: \"HMAC\", hash: \"SHA-256\", length: 256 }, true, [\"sign\", \"verify\"]);\n}\n\nconst bytesToHex = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.utils.bytesToHex;\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Compute the Ethereum address from uncompressed PublicKey bytes\n */\nfunction computeAddress(bytes) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    const publicKey = (0,viem__WEBPACK_IMPORTED_MODULE_7__.bytesToHex)(bytes.slice(1));\n    const hash = (0,viem__WEBPACK_IMPORTED_MODULE_8__.keccak256)(publicKey);\n    const address = hash.substring(hash.length - 40);\n    return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(`0x${address}`);\n}\n/**\n * Split an Ethereum signature hex string into bytes and a recovery bit\n */\nfunction splitSignature(signature) {\n    const eSig = (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToSignature)(signature);\n    const r = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)(eSig.r);\n    const s = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)(eSig.s);\n    let v = Number(eSig.v);\n    if (v === 0 || v === 1) {\n        v += 27;\n    }\n    const recovery = 1 - (v % 2);\n    const bytes = new Uint8Array(64);\n    bytes.set(r);\n    bytes.set(s, r.length);\n    return { bytes, recovery };\n}\n\n// Validate SECP256k1 private key\nfunction secp256k1Check(key) {\n    if (key.bytes.length !== 32) {\n        throw new Error(`invalid private key length: ${key.bytes.length}`);\n    }\n}\n// A private key signed with another key pair or a wallet.\nclass SignedPrivateKey {\n    constructor(obj) {\n        if (!obj.secp256k1) {\n            throw new Error(\"invalid private key\");\n        }\n        secp256k1Check(obj.secp256k1);\n        this.secp256k1 = obj.secp256k1;\n        this.createdNs = obj.createdNs;\n        if (!obj.publicKey) {\n            throw new Error(\"missing public key\");\n        }\n        this.publicKey = new SignedPublicKey(obj.publicKey);\n    }\n    // Create a random key pair signed by the signer.\n    static async generate(signer) {\n        const secp256k1 = {\n            bytes: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey(),\n        };\n        const createdNs = long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(new Date().getTime()).mul(1000000);\n        const unsigned = new UnsignedPublicKey({\n            secp256k1Uncompressed: {\n                bytes: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getPublicKey(secp256k1.bytes),\n            },\n            createdNs,\n        });\n        const signed = await signer.signKey(unsigned);\n        return new SignedPrivateKey({\n            secp256k1,\n            createdNs,\n            publicKey: signed,\n        });\n    }\n    // Time the key was generated.\n    generated() {\n        return new Date(this.createdNs.div(1000000).toNumber());\n    }\n    // Sign provided digest.\n    async sign(digest) {\n        const [signature, recovery] = await _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.sign(digest, this.secp256k1.bytes, {\n            recovered: true,\n            der: false,\n        });\n        return new Signature({\n            ecdsaCompact: { bytes: signature, recovery },\n        });\n    }\n    // Sign provided public key.\n    async signKey(pub) {\n        const keyBytes = pub.toBytes();\n        const digest = await sha256(keyBytes);\n        const signature = await this.sign(digest);\n        return new SignedPublicKey({\n            keyBytes,\n            signature,\n        });\n    }\n    // Return public key of the signer of the provided signed key.\n    static async signerKey(key, signature) {\n        const digest = await sha256(key.bytesToSign());\n        return ecdsaSignerKey(digest, signature);\n    }\n    // Derive shared secret from peer's PublicKey;\n    // the peer can derive the same secret using their private key and our public key.\n    sharedSecret(peer) {\n        return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getSharedSecret(this.secp256k1.bytes, peer.secp256k1Uncompressed.bytes, false);\n    }\n    // encrypt plain bytes using a shared secret derived from peer's PublicKey;\n    // additionalData allows including unencrypted parts of a Message in the authentication\n    // protection provided by the encrypted part (to make the whole Message tamper evident)\n    encrypt(plain, peer, additionalData) {\n        const secret = this.sharedSecret(peer);\n        return encrypt$1(plain, secret, additionalData);\n    }\n    // decrypt Ciphertext using a shared secret derived from peer's PublicKey;\n    // throws if any part of Ciphertext or additionalData was tampered with\n    decrypt(encrypted, peer, additionalData) {\n        const secret = this.sharedSecret(peer);\n        return decrypt$1(encrypted, secret, additionalData);\n    }\n    // Does the provided PublicKey correspond to this PrivateKey?\n    matches(key) {\n        return this.publicKey.equals(key);\n    }\n    // Is other the same/equivalent key?\n    equals(other) {\n        return (equalBytes(this.secp256k1.bytes, other.secp256k1.bytes) &&\n            this.publicKey.equals(other.publicKey));\n    }\n    // Encode this key into bytes.\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.SignedPrivateKey.encode(this).finish();\n    }\n    validatePublicKey() {\n        const generatedPublicKey = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getPublicKey(this.secp256k1.bytes);\n        return equalBytes(generatedPublicKey, this.publicKey.secp256k1Uncompressed.bytes);\n    }\n    // Decode key from bytes.\n    static fromBytes(bytes) {\n        return new SignedPrivateKey(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.SignedPrivateKey.decode(bytes));\n    }\n    static fromLegacyKey(key, signedByWallet) {\n        return new SignedPrivateKey({\n            createdNs: key.timestamp.mul(1000000),\n            secp256k1: key.secp256k1,\n            publicKey: SignedPublicKey.fromLegacyKey(key.publicKey, signedByWallet),\n        });\n    }\n}\n// LEGACY: PrivateKey represents a secp256k1 private key.\nclass PrivateKey {\n    constructor(obj) {\n        if (!obj.secp256k1) {\n            throw new Error(\"invalid private key\");\n        }\n        secp256k1Check(obj.secp256k1);\n        this.timestamp = obj.timestamp;\n        this.secp256k1 = obj.secp256k1;\n        if (!obj.publicKey) {\n            throw new Error(\"missing public key\");\n        }\n        this.publicKey = new PublicKey(obj.publicKey);\n    }\n    // create a random PrivateKey/PublicKey pair.\n    static generate() {\n        const secp256k1 = {\n            bytes: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey(),\n        };\n        const timestamp = long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(new Date().getTime());\n        return new PrivateKey({\n            secp256k1,\n            timestamp,\n            publicKey: new PublicKey({\n                secp256k1Uncompressed: {\n                    bytes: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getPublicKey(secp256k1.bytes),\n                },\n                timestamp,\n            }),\n        });\n    }\n    generated() {\n        return new Date(this.timestamp.toNumber());\n    }\n    // sign provided digest\n    async sign(digest) {\n        const [signature, recovery] = await _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.sign(digest, this.secp256k1.bytes, {\n            recovered: true,\n            der: false,\n        });\n        return new Signature({\n            ecdsaCompact: { bytes: signature, recovery },\n        });\n    }\n    // sign provided public key\n    async signKey(pub) {\n        const digest = await sha256(pub.bytesToSign());\n        pub.signature = await this.sign(digest);\n        return pub;\n    }\n    // derive shared secret from peer's PublicKey;\n    // the peer can derive the same secret using their PrivateKey and our PublicKey\n    sharedSecret(peer) {\n        return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getSharedSecret(this.secp256k1.bytes, peer.secp256k1Uncompressed.bytes, false);\n    }\n    // encrypt plain bytes using a shared secret derived from peer's PublicKey;\n    // additionalData allows including unencrypted parts of a Message in the authentication\n    // protection provided by the encrypted part (to make the whole Message tamper evident)\n    encrypt(plain, peer, additionalData) {\n        const secret = this.sharedSecret(peer);\n        return encrypt$1(plain, secret, additionalData);\n    }\n    // decrypt Ciphertext using a shared secret derived from peer's PublicKey;\n    // throws if any part of Ciphertext or additionalData was tampered with\n    decrypt(encrypted, peer, additionalData) {\n        const secret = this.sharedSecret(peer);\n        return decrypt$1(encrypted, secret, additionalData);\n    }\n    // Does the provided PublicKey correspond to this PrivateKey?\n    matches(key) {\n        return this.publicKey.equals(key);\n    }\n    validatePublicKey() {\n        const generatedPublicKey = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.getPublicKey(this.secp256k1.bytes);\n        return equalBytes(generatedPublicKey, this.publicKey.secp256k1Uncompressed.bytes);\n    }\n    // Encode this key into bytes.\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKey.encode(this).finish();\n    }\n    // Decode key from bytes.\n    static fromBytes(bytes) {\n        return new PrivateKey(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKey.decode(bytes));\n    }\n}\n\n// Validate signature.\nfunction ecdsaCheck(sig) {\n    if (sig.bytes.length !== 64) {\n        throw new Error(`invalid signature length: ${sig.bytes.length}`);\n    }\n    if (sig.recovery !== 0 && sig.recovery !== 1) {\n        throw new Error(`invalid recovery bit: ${sig.recovery}`);\n    }\n}\n// Compare signatures.\nfunction ecdsaEqual(a, b) {\n    return a.recovery === b.recovery && equalBytes(a.bytes, b.bytes);\n}\n// Derive public key of the signer from the digest and the signature.\nfunction ecdsaSignerKey(digest, signature) {\n    const bytes = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.recoverPublicKey(digest, signature.bytes, signature.recovery);\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return bytes\n        ? new UnsignedPublicKey({\n            secp256k1Uncompressed: { bytes },\n            createdNs: long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(0),\n        })\n        : undefined;\n}\nclass Signature {\n    constructor(obj) {\n        if (obj.ecdsaCompact) {\n            ecdsaCheck(obj.ecdsaCompact);\n            this.ecdsaCompact = obj.ecdsaCompact;\n        }\n        else if (obj.walletEcdsaCompact) {\n            ecdsaCheck(obj.walletEcdsaCompact);\n            this.walletEcdsaCompact = obj.walletEcdsaCompact;\n        }\n        else {\n            throw new Error(\"invalid signature\");\n        }\n    }\n    // Return the public key that validates provided key's signature.\n    async signerKey(key) {\n        if (this.ecdsaCompact) {\n            return SignedPrivateKey.signerKey(key, this.ecdsaCompact);\n        }\n        else if (this.walletEcdsaCompact) {\n            return WalletSigner.signerKey(key, this.walletEcdsaCompact);\n        }\n        else {\n            return undefined;\n        }\n    }\n    // LEGACY: Return the public key that validates this signature given the provided digest.\n    // Return undefined if the signature is malformed.\n    getPublicKey(digest) {\n        let bytes;\n        if (this.ecdsaCompact) {\n            bytes = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.recoverPublicKey(digest, this.ecdsaCompact.bytes, this.ecdsaCompact.recovery);\n        }\n        else if (this.walletEcdsaCompact) {\n            bytes = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.recoverPublicKey(digest, this.walletEcdsaCompact.bytes, this.walletEcdsaCompact.recovery);\n        }\n        else {\n            throw new Error(\"invalid v1 signature\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        return bytes\n            ? new PublicKey({\n                secp256k1Uncompressed: { bytes },\n                timestamp: long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(0),\n            })\n            : undefined;\n    }\n    // Is this the same/equivalent signature as other?\n    equals(other) {\n        if (this.ecdsaCompact && other.ecdsaCompact) {\n            return ecdsaEqual(this.ecdsaCompact, other.ecdsaCompact);\n        }\n        if (this.walletEcdsaCompact && other.walletEcdsaCompact) {\n            return ecdsaEqual(this.walletEcdsaCompact, other.walletEcdsaCompact);\n        }\n        return false;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.signature.Signature.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new Signature(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.signature.Signature.decode(bytes));\n    }\n}\nvar AccountLinkedRole;\n(function (AccountLinkedRole) {\n    AccountLinkedRole[AccountLinkedRole[\"INBOX_KEY\"] = 0] = \"INBOX_KEY\";\n    AccountLinkedRole[AccountLinkedRole[\"SEND_KEY\"] = 1] = \"SEND_KEY\";\n})(AccountLinkedRole || (AccountLinkedRole = {}));\n// A wallet based KeySigner.\nclass WalletSigner {\n    constructor(wallet) {\n        this.wallet = wallet;\n    }\n    static identitySigRequestText(keyBytes) {\n        // Note that an update to this signature request text will require\n        // addition of backward compatibility for existing signatures\n        // and/or a migration; otherwise clients will fail to verify previously\n        // signed keys.\n        return (\"XMTP : Create Identity\\n\" +\n            `${bytesToHex(keyBytes)}\\n` +\n            \"\\n\" +\n            \"For more info: https://xmtp.org/signatures/\");\n    }\n    static signerKey(key, signature) {\n        const digest = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)((0,viem__WEBPACK_IMPORTED_MODULE_12__.hashMessage)(this.identitySigRequestText(key.bytesToSign())));\n        return ecdsaSignerKey(digest, signature);\n    }\n    async signKey(key) {\n        const keyBytes = key.toBytes();\n        const sigString = await this.wallet.signMessage(WalletSigner.identitySigRequestText(keyBytes));\n        const { bytes, recovery } = splitSignature(sigString);\n        const signature = new Signature({\n            walletEcdsaCompact: {\n                bytes,\n                recovery,\n            },\n        });\n        return new SignedPublicKey({ keyBytes, signature });\n    }\n}\n\n// Validate a key.\nfunction secp256k1UncompressedCheck(key) {\n    if (key.bytes.length !== 65) {\n        throw new Error(`invalid public key length: ${key.bytes.length}`);\n    }\n    if (key.bytes[0] !== 4) {\n        throw new Error(`unrecognized public key prefix: ${key.bytes[0]}`);\n    }\n}\nconst MS_NS_TIMESTAMP_THRESHOLD = new long__WEBPACK_IMPORTED_MODULE_1__[\"default\"](10 ** 9).mul(10 ** 9);\n// Basic public key without a signature.\nclass UnsignedPublicKey {\n    constructor(obj) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!obj?.secp256k1Uncompressed) {\n            throw new Error(\"invalid public key\");\n        }\n        secp256k1UncompressedCheck(obj.secp256k1Uncompressed);\n        this.secp256k1Uncompressed = obj.secp256k1Uncompressed;\n        this.createdNs = obj.createdNs.toUnsigned();\n    }\n    // The time the key was generated.\n    generated() {\n        return new Date(this.timestamp.toNumber());\n    }\n    isFromLegacyKey() {\n        return this.createdNs.lessThan(MS_NS_TIMESTAMP_THRESHOLD);\n    }\n    // creation time in milliseconds\n    get timestamp() {\n        return (this.isFromLegacyKey() ? this.createdNs : this.createdNs.div(1000000)).toUnsigned();\n    }\n    // Verify that signature was created from the digest using matching private key.\n    verify(signature, digest) {\n        if (!signature.ecdsaCompact) {\n            return false;\n        }\n        return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_2__.verify(signature.ecdsaCompact.bytes, digest, this.secp256k1Uncompressed.bytes);\n    }\n    // Verify that the provided public key was signed by matching private key.\n    async verifyKey(pub) {\n        if (!pub.signature) {\n            return false;\n        }\n        const digest = await sha256(pub.bytesToSign());\n        return this.verify(pub.signature, digest);\n    }\n    // Is other the same/equivalent public key?\n    equals(other) {\n        return equalBytes(this.secp256k1Uncompressed.bytes, other.secp256k1Uncompressed.bytes);\n    }\n    // Derive Ethereum address from this public key.\n    getEthereumAddress() {\n        return computeAddress(this.secp256k1Uncompressed.bytes);\n    }\n    // Encode public key into bytes.\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.UnsignedPublicKey.encode(this).finish();\n    }\n    // Decode public key from bytes.\n    static fromBytes(bytes) {\n        return new UnsignedPublicKey(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.UnsignedPublicKey.decode(bytes));\n    }\n}\n// Public key signed by another key pair or a wallet.\nclass SignedPublicKey extends UnsignedPublicKey {\n    constructor(obj) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!obj.keyBytes) {\n            throw new Error(\"missing key bytes\");\n        }\n        super(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.UnsignedPublicKey.decode(obj.keyBytes));\n        this.keyBytes = obj.keyBytes;\n        if (!obj.signature) {\n            throw new Error(\"missing key signature\");\n        }\n        this.signature = new Signature(obj.signature);\n    }\n    // Return the key without the signature.\n    get unsignedKey() {\n        return new UnsignedPublicKey({\n            createdNs: this.createdNs,\n            secp256k1Uncompressed: this.secp256k1Uncompressed,\n        });\n    }\n    // Return public key of the signer of this key.\n    signerKey() {\n        return this.signature.signerKey(this);\n    }\n    // Assume the key was signed by a wallet and\n    // return the wallet address that validates\n    // the signature of this key.\n    async walletSignatureAddress() {\n        if (!this.signature.walletEcdsaCompact) {\n            throw new Error(\"key was not signed by a wallet\");\n        }\n        const pk = await this.signerKey();\n        if (!pk) {\n            throw new Error(\"key signature not valid\");\n        }\n        return pk.getEthereumAddress();\n    }\n    // Is other the same/equivalent public key?\n    equals(other) {\n        return (this.unsignedKey.equals(other.unsignedKey) &&\n            this.signature.equals(other.signature));\n    }\n    // Return bytes of the encoded unsigned key.\n    bytesToSign() {\n        return this.keyBytes;\n    }\n    // Encode signed key into bytes.\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.SignedPublicKey.encode(this).finish();\n    }\n    // Decode signed key from bytes.\n    static fromBytes(bytes) {\n        return new SignedPublicKey(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.SignedPublicKey.decode(bytes));\n    }\n    toLegacyKey() {\n        if (!this.isFromLegacyKey()) {\n            throw new Error(\"cannot be converted to legacy key\");\n        }\n        let signature = this.signature;\n        if (signature.walletEcdsaCompact) {\n            signature = new Signature({\n                ecdsaCompact: signature.walletEcdsaCompact,\n            });\n        }\n        return new PublicKey({\n            timestamp: this.timestamp,\n            secp256k1Uncompressed: this.secp256k1Uncompressed,\n            signature,\n        });\n    }\n    static fromLegacyKey(legacyKey, signedByWallet) {\n        if (!legacyKey.signature) {\n            throw new Error(\"key is not signed\");\n        }\n        let signature = legacyKey.signature;\n        if (signedByWallet) {\n            signature = new Signature({\n                walletEcdsaCompact: signature.ecdsaCompact,\n            });\n        }\n        return new SignedPublicKey({\n            keyBytes: legacyKey.bytesToSign(),\n            signature,\n        });\n    }\n}\n// LEGACY: PublicKey optionally signed with another trusted key pair or a wallet.\n// PublicKeys can be generated through PrivateKey.generate()\nclass PublicKey extends UnsignedPublicKey {\n    constructor(obj) {\n        super({\n            createdNs: obj.timestamp.mul(1000000),\n            secp256k1Uncompressed: obj.secp256k1Uncompressed,\n        });\n        if (obj.signature) {\n            // Handle a case where Flutter was publishing signatures with walletEcdsaCompact\n            // instead of ecdsaCompact for v1 keys.\n            if (!obj.signature.ecdsaCompact && obj.signature.walletEcdsaCompact) {\n                this.signature = new Signature({\n                    ecdsaCompact: {\n                        bytes: obj.signature.walletEcdsaCompact.bytes,\n                        recovery: obj.signature.walletEcdsaCompact.recovery,\n                    },\n                });\n            }\n            else {\n                this.signature = new Signature(obj.signature);\n            }\n        }\n    }\n    get timestamp() {\n        return this.createdNs.div(1000000);\n    }\n    bytesToSign() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKey.encode({\n            timestamp: this.timestamp,\n            secp256k1Uncompressed: this.secp256k1Uncompressed,\n        }).finish();\n    }\n    // sign the key using a wallet\n    async signWithWallet(wallet) {\n        const sigString = await wallet.signMessage(WalletSigner.identitySigRequestText(this.bytesToSign()));\n        const { bytes, recovery } = splitSignature(sigString);\n        this.signature = new Signature({\n            ecdsaCompact: {\n                bytes,\n                recovery,\n            },\n        });\n    }\n    // Assume the key was signed by a wallet and\n    // return the wallet address that validates\n    // the signature for this key.\n    walletSignatureAddress() {\n        if (!this.signature) {\n            throw new Error(\"key is not signed\");\n        }\n        const digest = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)((0,viem__WEBPACK_IMPORTED_MODULE_12__.hashMessage)(WalletSigner.identitySigRequestText(this.bytesToSign())));\n        const pk = this.signature.getPublicKey(digest);\n        if (!pk) {\n            throw new Error(\"key signature is malformed\");\n        }\n        return pk.getEthereumAddress();\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKey.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new PublicKey(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKey.decode(bytes));\n    }\n}\n\n// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.\n// The PreKey must be signed by the IdentityKey.\n// The IdentityKey must be signed by the wallet to authenticate it.\nclass SignedPublicKeyBundle {\n    constructor(bundle) {\n        if (!bundle.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        if (!bundle.preKey) {\n            throw new Error(\"missing pre-key\");\n        }\n        this.identityKey = new SignedPublicKey(bundle.identityKey);\n        this.preKey = new SignedPublicKey(bundle.preKey);\n    }\n    walletSignatureAddress() {\n        return this.identityKey.walletSignatureAddress();\n    }\n    equals(other) {\n        return (this.identityKey.equals(other.identityKey) &&\n            this.preKey.equals(other.preKey));\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.SignedPublicKeyBundle.encode(this).finish();\n    }\n    isFromLegacyBundle() {\n        return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey();\n    }\n    toLegacyBundle() {\n        return new PublicKeyBundle({\n            identityKey: this.identityKey.toLegacyKey(),\n            preKey: this.preKey.toLegacyKey(),\n        });\n    }\n    static fromBytes(bytes) {\n        const decoded = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.SignedPublicKeyBundle.decode(bytes);\n        return new SignedPublicKeyBundle(decoded);\n    }\n    static fromLegacyBundle(bundle) {\n        return new SignedPublicKeyBundle({\n            // Note: I am assuming all PublicKeyBundles passed into this have had their identity keys signed by a wallet\n            // Maybe that is not universally true in the future\n            identityKey: SignedPublicKey.fromLegacyKey(bundle.identityKey, true),\n            preKey: SignedPublicKey.fromLegacyKey(bundle.preKey),\n        });\n    }\n}\n// LEGACY: PublicKeyBundle packages all the keys that a participant should advertise.\n// The PreKey must be signed by the IdentityKey.\n// The IdentityKey can be signed by the wallet to authenticate it.\nclass PublicKeyBundle {\n    constructor(bundle) {\n        if (!bundle.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        if (!bundle.preKey) {\n            throw new Error(\"missing pre-key\");\n        }\n        this.identityKey = new PublicKey(bundle.identityKey);\n        this.preKey = new PublicKey(bundle.preKey);\n    }\n    equals(other) {\n        return (this.identityKey.equals(other.identityKey) &&\n            this.preKey.equals(other.preKey));\n    }\n    walletSignatureAddress() {\n        return this.identityKey.walletSignatureAddress();\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKeyBundle.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        const decoded = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKeyBundle.decode(bytes);\n        return new PublicKeyBundle(decoded);\n    }\n}\n\nclass PreparedMessage {\n    constructor(messageEnvelope, onSend) {\n        this.messageEnvelope = messageEnvelope;\n        this.onSend = onSend;\n    }\n    async messageID() {\n        if (!this.messageEnvelope.message) {\n            throw new Error(\"no envelope message\");\n        }\n        return bytesToHex(await sha256(this.messageEnvelope.message));\n    }\n    async send() {\n        return this.onSend();\n    }\n}\n\n/**\n * Stream implements an Asynchronous Iterable over messages received from a topic.\n * As such can be used with constructs like for-await-of, yield*, array destructing, etc.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass Stream {\n    constructor(client, topics, decoder, contentTopicUpdater, onConnectionLost) {\n        this.messages = [];\n        this.resolvers = [];\n        this.topics = topics;\n        this.client = client;\n        this.callback = this.newMessageCallback(decoder, contentTopicUpdater);\n        this.onConnectionLost = onConnectionLost;\n    }\n    // returns new closure to handle incoming messages\n    newMessageCallback(decoder, contentTopicUpdater) {\n        return async (env) => {\n            if (!env.message) {\n                return;\n            }\n            try {\n                const msg = await decoder(env);\n                // decoder can return undefined to signal a message to ignore/skip.\n                if (!msg) {\n                    return;\n                }\n                // Check to see if we should update the stream's content topic subscription\n                if (contentTopicUpdater) {\n                    const topics = contentTopicUpdater(msg);\n                    if (topics) {\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        this.resubscribeToTopics(topics);\n                    }\n                }\n                // is there a Promise already pending?\n                const resolver = this.resolvers.pop();\n                if (resolver) {\n                    // yes, resolve it\n                    resolver({ value: msg });\n                }\n                else {\n                    // no, push the message into the queue\n                    this.messages.unshift(msg);\n                }\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async start() {\n        if (!this.callback) {\n            throw new Error(\"Missing callback for stream\");\n        }\n        this.subscriptionManager = this.client.apiClient.subscribe({\n            contentTopics: this.topics,\n        }, \n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        async (env) => {\n            if (!this.callback)\n                return;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            await this?.callback(env);\n        }, this.onConnectionLost);\n    }\n    static async create(client, topics, decoder, contentTopicUpdater, onConnectionLost) {\n        const stream = new Stream(client, topics, decoder, contentTopicUpdater, onConnectionLost);\n        await stream.start();\n        return stream;\n    }\n    // To make Stream proper Async Iterable\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // return should be called if the interpreter detects that the stream won't be used anymore,\n    // e.g. a for/of loop was exited via a break. It can also be called explicitly.\n    // https://tc39.es/ecma262/#table-iterator-interface-optional-properties\n    // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.\n    async return() {\n        if (this.subscriptionManager) {\n            await this.subscriptionManager.unsubscribe();\n        }\n        if (!this.callback) {\n            return { value: undefined, done: true };\n        }\n        this.callback = undefined;\n        this.resolvers.forEach((resolve) => \n        // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n        resolve({ value: undefined, done: true }));\n        return { value: undefined, done: true };\n    }\n    // To make Stream proper Async Iterator\n    // Note that next() will still provide whatever messages were already pending\n    // even after the stream was closed via return().\n    next() {\n        // Is there a message already pending?\n        const msg = this.messages.pop();\n        if (msg) {\n            // yes, return resolved promise\n            return Promise.resolve({ value: msg });\n        }\n        if (!this.callback) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        // otherwise return empty Promise and queue its resolver\n        return new Promise((resolve) => this.resolvers.unshift(resolve));\n    }\n    // Unsubscribe from the existing content topics and resubscribe to the given topics.\n    async resubscribeToTopics(topics) {\n        if (!this.callback || !this.subscriptionManager) {\n            throw new Error(\"Missing callback for stream\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (typeof this.subscriptionManager?.updateContentTopics === \"function\") {\n            return this.subscriptionManager.updateContentTopics(topics);\n        }\n        await this.subscriptionManager.unsubscribe();\n        this.topics = topics;\n        this.subscriptionManager = this.client.apiClient.subscribe({\n            contentTopics: this.topics,\n        }, \n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        async (env) => {\n            if (!this.callback)\n                return;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            await this?.callback(env);\n        }, this.onConnectionLost);\n    }\n}\n\nconst { b64Decode, b64Encode } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.fetcher;\nfunction concat(a, b) {\n    const ab = new Uint8Array(a.length + b.length);\n    ab.set(a);\n    ab.set(b, a.length);\n    return ab;\n}\nfunction numberToUint8Array(num) {\n    // Create a buffer for a 32-bit integer\n    const buffer = new ArrayBuffer(4);\n    const view = new DataView(buffer);\n    // Set the number in the buffer\n    view.setInt32(0, num, true); // true for little-endian\n    // Create Uint8Array from buffer\n    return new Uint8Array(buffer);\n}\nfunction uint8ArrayToNumber(arr) {\n    const buffer = arr.buffer;\n    const view = new DataView(buffer);\n    // Read the number from the buffer\n    return view.getInt32(0, true); // true for little-endian\n}\n\nfunction dateToNs(date) {\n    return long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(date.valueOf()).multiply(1_000_000);\n}\nfunction nsToDate(ns) {\n    return new Date(ns.divide(1_000_000).toNumber());\n}\nconst toNanoString = (d) => {\n    return d && dateToNs(d).toString();\n};\nconst fromNanoString = (s) => {\n    if (!s) {\n        return undefined;\n    }\n    return nsToDate(long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromString(s));\n};\n\nclass KeystoreError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n    }\n}\n\n// Validates the Keystore response. Throws on errors or missing fields.\n// Returns a type with all possibly undefined fields required to be defined\nconst getResultOrThrow = (response) => {\n    if (response.error) {\n        throw new KeystoreError(response.error.code, response.error.message);\n    }\n    if (!response.result) {\n        throw new KeystoreError(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED, \"No result from Keystore\");\n    }\n    if (\"encrypted\" in response.result && !response.result.encrypted) {\n        throw new Error(\"Missing ciphertext\");\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (\"decrypted\" in response.result && !response.result.decrypted) {\n        throw new Error(\"Missing decrypted result\");\n    }\n    return response.result;\n};\nconst buildDecryptV1Request = (messages, myPublicKeyBundle) => {\n    return {\n        requests: messages.map((m) => {\n            const sender = new PublicKeyBundle({\n                identityKey: m.header.sender?.identityKey,\n                preKey: m.header.sender?.preKey,\n            });\n            const isSender = myPublicKeyBundle.equals(sender);\n            return {\n                payload: m.ciphertext,\n                peerKeys: isSender\n                    ? new PublicKeyBundle({\n                        identityKey: m.header.recipient?.identityKey,\n                        preKey: m.header.recipient?.preKey,\n                    })\n                    : sender,\n                headerBytes: m.headerBytes,\n                isSender,\n            };\n        }),\n    };\n};\n\nconst buildContentTopic = (name) => `/xmtp/0/${name}/proto`;\nconst buildDirectMessageTopic = (sender, recipient) => {\n    // EIP55 normalize the address case.\n    const members = [(0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(sender), (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(recipient)];\n    members.sort();\n    return buildContentTopic(`dm-${members.join(\"-\")}`);\n};\nconst buildDirectMessageTopicV2 = (randomString) => {\n    return buildContentTopic(`m-${randomString}`);\n};\nconst buildUserContactTopic = (walletAddr) => {\n    // EIP55 normalize the address case.\n    return buildContentTopic(`contact-${(0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(walletAddr)}`);\n};\nconst buildUserIntroTopic = (walletAddr) => {\n    // EIP55 normalize the address case.\n    return buildContentTopic(`intro-${(0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(walletAddr)}`);\n};\nconst buildUserInviteTopic = (walletAddr) => {\n    // EIP55 normalize the address case.\n    return buildContentTopic(`invite-${(0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(walletAddr)}`);\n};\nconst buildUserPrivateStoreTopic = (addrPrefixedKey) => {\n    // e.g. \"0x1111111111222222222233333333334444444444/key_bundle\"\n    return buildContentTopic(`privatestore-${addrPrefixedKey}`);\n};\nconst buildUserPrivatePreferencesTopic = (identifier) => buildContentTopic(`userpreferences-${identifier}`);\n// validate that a topic only contains ASCII characters 33-127\nconst isValidTopic = (topic) => {\n    const regex = /^[\\x21-\\x7F]+$/;\n    const index = topic.indexOf(\"0/\");\n    if (index !== -1) {\n        const unwrappedTopic = topic.substring(index + 2, topic.lastIndexOf(\"/proto\"));\n        return regex.test(unwrappedTopic);\n    }\n    return false;\n};\n\n/**\n * ConversationV1 allows you to view, stream, and send messages to/from a peer address\n */\nclass ConversationV1 {\n    constructor(client, address, createdAt) {\n        this.conversationVersion = \"v1\";\n        this.context = undefined;\n        this.peerAddress = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(address);\n        this.client = client;\n        this.createdAt = createdAt;\n    }\n    get clientAddress() {\n        return this.client.address;\n    }\n    async allow() {\n        await this.client.contacts.allow([this.peerAddress]);\n    }\n    async deny() {\n        await this.client.contacts.deny([this.peerAddress]);\n    }\n    get isAllowed() {\n        return this.client.contacts.isAllowed(this.peerAddress);\n    }\n    get isDenied() {\n        return this.client.contacts.isDenied(this.peerAddress);\n    }\n    get consentState() {\n        return this.client.contacts.consentState(this.peerAddress);\n    }\n    get topic() {\n        return buildDirectMessageTopic(this.peerAddress, this.client.address);\n    }\n    get ephemeralTopic() {\n        return buildDirectMessageTopic(this.peerAddress, this.client.address).replace(\"/xmtp/0/dm-\", \"/xmtp/0/dmE-\");\n    }\n    /**\n     * Returns a list of all messages to/from the peerAddress\n     */\n    async messages(opts) {\n        const topic = buildDirectMessageTopic(this.peerAddress, this.client.address);\n        const messages = await this.client.listEnvelopes(topic, this.processEnvelope.bind(this), opts);\n        return this.decryptBatch(messages, topic, false);\n    }\n    messagesPaginated(opts) {\n        return this.client.listEnvelopesPaginated(this.topic, \n        // This won't be performant once we start supporting a remote keystore\n        // TODO: Either better batch support or we ditch this under-utilized feature\n        this.decodeMessage.bind(this), opts);\n    }\n    // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs\n    async decodeMessage(env) {\n        if (!env.contentTopic) {\n            throw new Error(\"Missing content topic\");\n        }\n        const msg = await this.processEnvelope(env);\n        const decryptResults = await this.decryptBatch([msg], env.contentTopic, true);\n        if (!decryptResults.length) {\n            throw new Error(\"No results\");\n        }\n        return decryptResults[0];\n    }\n    async prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any\n    options) {\n        let topics;\n        let recipient = await this.client.getUserContact(this.peerAddress);\n        if (!recipient) {\n            throw new Error(`recipient ${this.peerAddress} is not registered`);\n        }\n        if (!(recipient instanceof PublicKeyBundle)) {\n            recipient = recipient.toLegacyBundle();\n        }\n        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;\n        if (!this.client.contacts.addresses.has(this.peerAddress)) {\n            topics = [\n                buildUserIntroTopic(this.peerAddress),\n                buildUserIntroTopic(this.client.address),\n                topic,\n            ];\n            this.client.contacts.addresses.add(this.peerAddress);\n        }\n        else {\n            topics = [topic];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        const { payload } = await this.client.encodeContent(content, options);\n        const msg = await this.createMessage(payload, recipient, options?.timestamp);\n        const msgBytes = msg.toBytes();\n        const env = {\n            contentTopic: topic,\n            message: msgBytes,\n            timestampNs: toNanoString(msg.sent),\n        };\n        return new PreparedMessage(env, async () => {\n            await this.client.publishEnvelopes(topics.map((topic) => ({\n                contentTopic: topic,\n                message: msgBytes,\n                timestamp: msg.sent,\n            })));\n            return DecodedMessage.fromV1Message(msg, content, options?.contentType || _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.ContentTypeText, payload, topic, this);\n        });\n    }\n    /**\n     * Returns a Stream of any new messages to/from the peerAddress\n     */\n    streamMessages(onConnectionLost) {\n        return Stream.create(this.client, [this.topic], async (env) => this.decodeMessage(env), undefined, onConnectionLost);\n    }\n    async processEnvelope({ message, contentTopic, }) {\n        if (!message || !message.length) {\n            throw new Error(\"empty envelope\");\n        }\n        const decoded = await MessageV1.fromBytes(message);\n        const { senderAddress, recipientAddress } = decoded;\n        // Filter for topics\n        if (!senderAddress ||\n            !recipientAddress ||\n            !contentTopic ||\n            buildDirectMessageTopic(senderAddress, recipientAddress) !== this.topic) {\n            throw new Error(\"Headers do not match intended recipient\");\n        }\n        return decoded;\n    }\n    streamEphemeral(onConnectionLost) {\n        return Stream.create(this.client, [this.ephemeralTopic], this.decodeMessage.bind(this), undefined, onConnectionLost);\n    }\n    /**\n     * Send a message into the conversation.\n     */\n    async send(content, options) {\n        let topics;\n        let recipient = await this.client.getUserContact(this.peerAddress);\n        if (!recipient) {\n            throw new Error(`recipient ${this.peerAddress} is not registered`);\n        }\n        if (!(recipient instanceof PublicKeyBundle)) {\n            recipient = recipient.toLegacyBundle();\n        }\n        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;\n        if (!this.client.contacts.addresses.has(this.peerAddress)) {\n            topics = [\n                buildUserIntroTopic(this.peerAddress),\n                buildUserIntroTopic(this.client.address),\n                topic,\n            ];\n            this.client.contacts.addresses.add(this.peerAddress);\n        }\n        else {\n            topics = [topic];\n        }\n        const contentType = options?.contentType || _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.ContentTypeText;\n        const { payload } = await this.client.encodeContent(content, options);\n        const msg = await this.createMessage(payload, recipient, options?.timestamp);\n        await this.client.publishEnvelopes(topics.map((topic) => ({\n            contentTopic: topic,\n            message: msg.toBytes(),\n            timestamp: msg.sent,\n        })));\n        // if the conversation consent state is unknown, we assume the user has\n        // consented to the conversation by sending a message into it\n        if (this.consentState === \"unknown\") {\n            // add conversation to the allow list\n            await this.allow();\n        }\n        return DecodedMessage.fromV1Message(msg, content, contentType, payload, topic, this);\n    }\n    async decryptBatch(messages, topic, throwOnError = false) {\n        const responses = (await this.client.keystore.decryptV1(buildDecryptV1Request(messages, this.client.publicKeyBundle))).responses;\n        const out = [];\n        for (let i = 0; i < responses.length; i++) {\n            const result = responses[i];\n            const message = messages[i];\n            try {\n                const { decrypted } = getResultOrThrow(result);\n                out.push(await this.buildDecodedMessage(message, decrypted, topic));\n            }\n            catch (e) {\n                if (throwOnError) {\n                    throw e;\n                }\n                console.warn(\"Error decoding content\", e);\n            }\n        }\n        return out;\n    }\n    async buildDecodedMessage(message, decrypted, topic) {\n        const { content, contentType, error, contentFallback } = await this.client.decodeContent(decrypted);\n        return DecodedMessage.fromV1Message(message, content, contentType, decrypted, topic, this, error, contentFallback);\n    }\n    async createMessage(\n    // Payload is expected to be the output of `client.encodeContent`\n    payload, recipient, timestamp) {\n        timestamp = timestamp || new Date();\n        return MessageV1.encode(this.client.keystore, payload, this.client.publicKeyBundle, recipient, timestamp);\n    }\n}\n/**\n * ConversationV2\n */\nclass ConversationV2 {\n    constructor(client, topic, peerAddress, createdAt, context, consentProof) {\n        this.conversationVersion = \"v2\";\n        this.topic = topic;\n        this.createdAt = createdAt;\n        this.context = context;\n        this.client = client;\n        this.peerAddress = peerAddress;\n        this.consentProof = consentProof;\n    }\n    get clientAddress() {\n        return this.client.address;\n    }\n    async allow() {\n        await this.client.contacts.allow([this.peerAddress]);\n    }\n    async deny() {\n        await this.client.contacts.deny([this.peerAddress]);\n    }\n    get isAllowed() {\n        return this.client.contacts.isAllowed(this.peerAddress);\n    }\n    get isDenied() {\n        return this.client.contacts.isDenied(this.peerAddress);\n    }\n    get consentState() {\n        return this.client.contacts.consentState(this.peerAddress);\n    }\n    get consentProofPayload() {\n        return this.consentProof;\n    }\n    /**\n     * Returns a list of all messages to/from the peerAddress\n     */\n    async messages(opts) {\n        const messages = await this.client.listEnvelopes(this.topic, this.processEnvelope.bind(this), opts);\n        return this.decryptBatch(messages, false);\n    }\n    messagesPaginated(opts) {\n        return this.client.listEnvelopesPaginated(this.topic, this.decodeMessage.bind(this), opts);\n    }\n    get ephemeralTopic() {\n        return this.topic.replace(\"/xmtp/0/m\", \"/xmtp/0/mE\");\n    }\n    streamEphemeral(onConnectionLost) {\n        return Stream.create(this.client, [this.ephemeralTopic], this.decodeMessage.bind(this), undefined, onConnectionLost);\n    }\n    /**\n     * Returns a Stream of any new messages to/from the peerAddress\n     */\n    streamMessages(onConnectionLost) {\n        return Stream.create(this.client, [this.topic], this.decodeMessage.bind(this), undefined, onConnectionLost);\n    }\n    /**\n     * Send a message into the conversation\n     */\n    async send(content, options) {\n        const { payload, shouldPush } = await this.client.encodeContent(content, options);\n        const msg = await this.createMessage(payload, shouldPush, options?.timestamp);\n        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;\n        await this.client.publishEnvelopes([\n            {\n                contentTopic: topic,\n                message: msg.toBytes(),\n                timestamp: msg.sent,\n            },\n        ]);\n        const contentType = options?.contentType || _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.ContentTypeText;\n        // if the conversation consent state is unknown, we assume the user has\n        // consented to the conversation by sending a message into it\n        if (this.consentState === \"unknown\") {\n            // add conversation to the allow list\n            await this.allow();\n        }\n        return DecodedMessage.fromV2Message(msg, content, contentType, topic, payload, this, this.client.address);\n    }\n    async createMessage(\n    // Payload is expected to have already gone through `client.encodeContent`\n    payload, shouldPush, timestamp) {\n        const header = {\n            topic: this.topic,\n            createdNs: dateToNs(timestamp || new Date()),\n        };\n        const headerBytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.MessageHeaderV2.encode(header).finish();\n        const digest = await sha256(concat(headerBytes, payload));\n        const signed = {\n            payload,\n            sender: this.client.signedPublicKeyBundle,\n            signature: await this.client.keystore.signDigest({\n                digest,\n                prekeyIndex: 0,\n                identityKey: undefined,\n            }),\n        };\n        const signedBytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.SignedContent.encode(signed).finish();\n        const { encrypted: ciphertext, senderHmac } = await this.encryptMessage(signedBytes, headerBytes);\n        const protoMsg = {\n            v1: undefined,\n            v2: { headerBytes, ciphertext, senderHmac, shouldPush },\n        };\n        const bytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.Message.encode(protoMsg).finish();\n        return MessageV2.create(protoMsg, header, bytes, senderHmac, shouldPush);\n    }\n    async decryptBatch(messages, throwOnError = false) {\n        const responses = (await this.client.keystore.decryptV2(this.buildDecryptRequest(messages))).responses;\n        const out = [];\n        for (let i = 0; i < responses.length; i++) {\n            const result = responses[i];\n            const message = messages[i];\n            try {\n                const { decrypted } = getResultOrThrow(result);\n                out.push(await this.buildDecodedMessage(message, decrypted));\n            }\n            catch (e) {\n                if (throwOnError) {\n                    throw e;\n                }\n                console.warn(\"Error decoding content\", e);\n            }\n        }\n        return out;\n    }\n    buildDecryptRequest(messages) {\n        return {\n            requests: messages.map((m) => {\n                return {\n                    payload: m.ciphertext,\n                    headerBytes: m.headerBytes,\n                    contentTopic: this.topic,\n                };\n            }),\n        };\n    }\n    async encryptMessage(payload, headerBytes) {\n        const { responses } = await this.client.keystore.encryptV2({\n            requests: [\n                {\n                    payload,\n                    headerBytes,\n                    contentTopic: this.topic,\n                },\n            ],\n        });\n        if (responses.length !== 1) {\n            throw new Error(\"Invalid response length\");\n        }\n        const { encrypted, senderHmac } = getResultOrThrow(responses[0]);\n        return { encrypted, senderHmac };\n    }\n    async buildDecodedMessage(msg, decrypted) {\n        // Decode the decrypted bytes into SignedContent\n        const signed = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.SignedContent.decode(decrypted);\n        if (!signed.sender?.identityKey ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            !signed.sender?.preKey ||\n            !signed.signature) {\n            throw new Error(\"incomplete signed content\");\n        }\n        await validatePrekeys(signed);\n        // Verify the signature\n        const digest = await sha256(concat(msg.headerBytes, signed.payload));\n        if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        !new SignedPublicKey(signed.sender?.preKey).verify(new Signature(signed.signature), digest)) {\n            throw new Error(\"invalid signature\");\n        }\n        // Derive the sender address from the valid signature\n        const senderAddress = await new SignedPublicKeyBundle(signed.sender).walletSignatureAddress();\n        const { content: content$1, contentType, error, contentFallback } = await this.client.decodeContent(signed.payload);\n        return DecodedMessage.fromV2Message(msg, content$1, contentType, this.topic, signed.payload, this, senderAddress, error, contentFallback);\n    }\n    async prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any\n    options) {\n        const { payload, shouldPush } = await this.client.encodeContent(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        content, options);\n        const msg = await this.createMessage(payload, shouldPush, options?.timestamp);\n        const msgBytes = msg.toBytes();\n        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;\n        const env = {\n            contentTopic: topic,\n            message: msgBytes,\n            timestampNs: toNanoString(msg.sent),\n        };\n        return new PreparedMessage(env, async () => {\n            await this.client.publishEnvelopes([\n                {\n                    contentTopic: topic,\n                    message: msgBytes,\n                    timestamp: msg.sent,\n                },\n            ]);\n            return DecodedMessage.fromV2Message(msg, content, options?.contentType || _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.ContentTypeText, topic, payload, this, this.client.address);\n        });\n    }\n    async processEnvelope(env) {\n        if (!env.message || !env.contentTopic) {\n            throw new Error(\"empty envelope\");\n        }\n        const msg = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.Message.decode(env.message);\n        if (!msg.v2) {\n            throw new Error(\"unknown message version\");\n        }\n        const header = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.MessageHeaderV2.decode(msg.v2.headerBytes);\n        if (header.topic !== this.topic) {\n            throw new Error(\"topic mismatch\");\n        }\n        return MessageV2.create(msg, header, env.message, msg.v2.senderHmac, msg.v2.shouldPush);\n    }\n    async decodeMessage(env) {\n        if (!env.contentTopic) {\n            throw new Error(\"Missing content topic\");\n        }\n        const msg = await this.processEnvelope(env);\n        const decryptResults = await this.decryptBatch([msg], true);\n        if (!decryptResults.length) {\n            throw new Error(\"No results\");\n        }\n        return decryptResults[0];\n    }\n}\nasync function validatePrekeys(signed) {\n    // Check that the pre key is signed by the identity key\n    // this is required to chain the prekey-signed message to the identity key\n    // and finally to the user's wallet address\n    const senderPreKey = signed.sender?.preKey;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {\n        throw new Error(\"missing pre-key or pre-key signature\");\n    }\n    const senderIdentityKey = signed.sender?.identityKey;\n    if (!senderIdentityKey) {\n        throw new Error(\"missing identity key in bundle\");\n    }\n    const isValidPrekey = await new SignedPublicKey(senderIdentityKey).verifyKey(new SignedPublicKey(senderPreKey));\n    if (!isValidPrekey) {\n        throw new Error(\"pre key not signed by identity key\");\n    }\n}\n\nconst headerBytesAndCiphertext = (msg) => {\n    if (msg.v1?.ciphertext) {\n        return [msg.v1.headerBytes, new Ciphertext(msg.v1.ciphertext)];\n    }\n    if (msg.v2?.ciphertext) {\n        return [msg.v2.headerBytes, new Ciphertext(msg.v2.ciphertext)];\n    }\n    throw new Error(\"unknown message version\");\n};\n// Message is basic unit of communication on the network.\n// Message timestamp is set by the sender.\nclass MessageBase {\n    constructor(id, bytes, obj) {\n        [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);\n        this.id = id;\n        this.bytes = bytes;\n    }\n    toBytes() {\n        return this.bytes;\n    }\n}\n// Message header carries the sender and recipient keys used to protect message.\n// Message timestamp is set by the sender.\nclass MessageV1 extends MessageBase {\n    constructor(id, bytes, obj, header, senderAddress) {\n        super(id, bytes, obj);\n        this.conversation = undefined;\n        this.senderAddress = senderAddress;\n        this.header = header;\n    }\n    static async create(obj, header, bytes) {\n        if (!header.sender) {\n            throw new Error(\"missing message sender\");\n        }\n        const senderAddress = new PublicKeyBundle(header.sender).walletSignatureAddress();\n        const id = bytesToHex(await sha256(bytes));\n        return new MessageV1(id, bytes, obj, header, senderAddress);\n    }\n    get sent() {\n        return new Date(this.header.timestamp.toNumber());\n    }\n    // wallet address derived from the signature of the message recipient\n    get recipientAddress() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!this.header?.recipient?.identityKey) {\n            return undefined;\n        }\n        return new PublicKey(this.header.recipient.identityKey).walletSignatureAddress();\n    }\n    async decrypt(keystore, myPublicKeyBundle) {\n        const responses = (await keystore.decryptV1(buildDecryptV1Request([this], myPublicKeyBundle))).responses;\n        if (!responses.length) {\n            throw new Error(\"No response from Keystore\");\n        }\n        const { decrypted } = getResultOrThrow(responses[0]);\n        return decrypted;\n    }\n    static fromBytes(bytes) {\n        const message$1 = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.Message.decode(bytes);\n        const [headerBytes] = headerBytesAndCiphertext(message$1);\n        const header = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.MessageHeaderV1.decode(headerBytes);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!header) {\n            throw new Error(\"missing message header\");\n        }\n        if (!header.sender) {\n            throw new Error(\"missing message sender\");\n        }\n        if (!header.sender.identityKey) {\n            throw new Error(\"missing message sender identity key\");\n        }\n        if (!header.sender.preKey) {\n            throw new Error(\"missing message sender pre-key\");\n        }\n        if (!header.recipient) {\n            throw new Error(\"missing message recipient\");\n        }\n        if (!header.recipient.identityKey) {\n            throw new Error(\"missing message recipient identity-key\");\n        }\n        if (!header.recipient.preKey) {\n            throw new Error(\"missing message recipient pre-key\");\n        }\n        return MessageV1.create(message$1, header, bytes);\n    }\n    static async encode(keystore, payload, sender, recipient, timestamp) {\n        const header = {\n            sender,\n            recipient,\n            timestamp: long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(timestamp.getTime()),\n        };\n        const headerBytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.MessageHeaderV1.encode(header).finish();\n        const results = await keystore.encryptV1({\n            requests: [\n                {\n                    recipient,\n                    headerBytes,\n                    payload,\n                },\n            ],\n        });\n        if (!results.responses.length) {\n            throw new Error(\"No response from Keystore\");\n        }\n        const { encrypted: ciphertext } = getResultOrThrow(results.responses[0]);\n        const protoMsg = {\n            v1: { headerBytes, ciphertext },\n            v2: undefined,\n        };\n        const bytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.Message.encode(protoMsg).finish();\n        return MessageV1.create(protoMsg, header, bytes);\n    }\n}\nclass MessageV2 extends MessageBase {\n    constructor(id, bytes, obj, header, senderHmac, shouldPush) {\n        super(id, bytes, obj);\n        this.header = header;\n        this.senderHmac = senderHmac;\n        this.shouldPush = shouldPush;\n    }\n    static async create(obj, header, bytes, senderHmac, shouldPush) {\n        const id = bytesToHex(await sha256(bytes));\n        return new MessageV2(id, bytes, obj, header, senderHmac, shouldPush);\n    }\n    get sent() {\n        return nsToDate(this.header.createdNs);\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass DecodedMessage {\n    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, contentFallback, }) {\n        this.id = id;\n        this.messageVersion = messageVersion;\n        this.senderAddress = senderAddress;\n        this.recipientAddress = recipientAddress;\n        this.conversation = conversation;\n        this.contentType = contentType;\n        this.sent = sent;\n        this.error = error;\n        this.content = content;\n        this.contentTopic = contentTopic;\n        this.contentBytes = contentBytes;\n        this.contentFallback = contentFallback;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.DecodedMessage.encode({\n            ...this,\n            conversation: {\n                topic: this.conversation.topic,\n                context: this.conversation.context ?? undefined,\n                createdNs: dateToNs(this.conversation.createdAt),\n                peerAddress: this.conversation.peerAddress,\n                consentProofPayload: this.conversation.consentProof ?? undefined,\n            },\n            sentNs: dateToNs(this.sent),\n        }).finish();\n    }\n    static async fromBytes(data, client) {\n        const protoVal = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.message.DecodedMessage.decode(data);\n        const messageVersion = protoVal.messageVersion;\n        if (messageVersion !== \"v1\" && messageVersion !== \"v2\") {\n            throw new Error(\"Invalid message version\");\n        }\n        if (!protoVal.conversation) {\n            throw new Error(\"No conversation reference found\");\n        }\n        const { content, contentType, error, contentFallback } = await client.decodeContent(protoVal.contentBytes);\n        return new DecodedMessage({\n            ...protoVal,\n            content,\n            contentType,\n            error,\n            messageVersion,\n            sent: nsToDate(protoVal.sentNs),\n            conversation: conversationReferenceToConversation(protoVal.conversation, client, messageVersion),\n            contentFallback,\n        });\n    }\n    static fromV1Message(message, content, contentType, contentBytes, contentTopic, conversation, error, contentFallback) {\n        const { id, senderAddress, recipientAddress, sent } = message;\n        if (!senderAddress) {\n            throw new Error(\"Sender address is required\");\n        }\n        return new DecodedMessage({\n            id,\n            messageVersion: \"v1\",\n            senderAddress,\n            recipientAddress,\n            sent,\n            content,\n            contentBytes,\n            contentType,\n            contentTopic,\n            conversation,\n            error,\n            contentFallback,\n        });\n    }\n    static fromV2Message(message, content, contentType, contentTopic, contentBytes, conversation, senderAddress, error, contentFallback) {\n        const { id, sent } = message;\n        return new DecodedMessage({\n            id,\n            messageVersion: \"v2\",\n            senderAddress,\n            sent,\n            content,\n            contentBytes,\n            contentType,\n            contentTopic,\n            conversation,\n            error,\n            contentFallback,\n        });\n    }\n}\nfunction conversationReferenceToConversation(reference, client, version) {\n    if (version === \"v1\") {\n        return new ConversationV1(client, reference.peerAddress, nsToDate(reference.createdNs));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (version === \"v2\") {\n        return new ConversationV2(client, reference.topic, reference.peerAddress, nsToDate(reference.createdNs), reference.context, reference.consentProofPayload);\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unknown conversation version ${version}`);\n}\nfunction decodeContent(contentBytes, client) {\n    return client.decodeContent(contentBytes);\n}\n\nclass NoMatchingPreKeyError extends Error {\n    constructor(preKey) {\n        super(`no pre-key matches: ${bytesToHex(preKey.secp256k1Uncompressed.bytes)}`);\n    }\n}\n\n// PrivateKeyBundle bundles the private keys corresponding to a PublicKeyBundle for convenience.\n// This bundle must not be shared with anyone, although will have to be persisted\n// somehow so that older messages can be decrypted again.\nclass PrivateKeyBundleV2 {\n    constructor(bundle) {\n        this.version = 2;\n        if (!bundle.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        this.identityKey = new SignedPrivateKey(bundle.identityKey);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.preKeys = (bundle.preKeys || []).map((k) => new SignedPrivateKey(k));\n    }\n    // Generate a new key bundle with the preKey signed byt the identityKey.\n    // Optionally sign the identityKey with the provided wallet as well.\n    static async generate(wallet) {\n        const identityKey = await SignedPrivateKey.generate(new WalletSigner(wallet));\n        const bundle = new PrivateKeyBundleV2({\n            identityKey,\n            preKeys: [],\n        });\n        await bundle.addPreKey();\n        return bundle;\n    }\n    // Return the current (latest) pre-key (to be advertised).\n    getCurrentPreKey() {\n        return this.preKeys[0];\n    }\n    // Find pre-key matching the provided public key.\n    findPreKey(which) {\n        const preKey = this.preKeys.find((key) => key.matches(which));\n        if (!preKey) {\n            throw new NoMatchingPreKeyError(which);\n        }\n        return preKey;\n    }\n    // Generate a new pre-key to be used as the current pre-key.\n    async addPreKey() {\n        this._publicKeyBundle = undefined;\n        const preKey = await SignedPrivateKey.generate(this.identityKey);\n        this.preKeys.unshift(preKey);\n    }\n    // Return a key bundle with the current pre-key.\n    getPublicKeyBundle() {\n        if (!this._publicKeyBundle) {\n            this._publicKeyBundle = new SignedPublicKeyBundle({\n                identityKey: this.identityKey.publicKey,\n                preKey: this.getCurrentPreKey().publicKey,\n            });\n        }\n        return this._publicKeyBundle;\n    }\n    // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol\n    // where the sender's ephemeral key pair is replaced by the sender's pre-key.\n    // @peer is the peer's public key bundle\n    // @myPreKey indicates which of my preKeys should be used to derive the secret\n    // @recipient indicates if this is the sending or receiving side.\n    async sharedSecret(peer, myPreKey, isRecipient) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!peer.identityKey || !peer.preKey) {\n            throw new Error(\"invalid peer key bundle\");\n        }\n        if (!(await peer.identityKey.verifyKey(peer.preKey))) {\n            throw new Error(\"peer preKey signature invalid\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!this.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        let dh1, dh2, preKey;\n        if (isRecipient) {\n            preKey = this.findPreKey(myPreKey);\n            dh1 = preKey.sharedSecret(peer.identityKey);\n            dh2 = this.identityKey.sharedSecret(peer.preKey);\n        }\n        else {\n            preKey = this.findPreKey(myPreKey);\n            dh1 = this.identityKey.sharedSecret(peer.preKey);\n            dh2 = preKey.sharedSecret(peer.identityKey);\n        }\n        const dh3 = preKey.sharedSecret(peer.preKey);\n        const secret = new Uint8Array(dh1.length + dh2.length + dh3.length);\n        secret.set(dh1, 0);\n        secret.set(dh2, dh1.length);\n        secret.set(dh3, dh1.length + dh2.length);\n        return secret;\n    }\n    encode() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKeyBundle.encode({\n            v1: undefined,\n            v2: this,\n        }).finish();\n    }\n    validatePublicKeys() {\n        if (!this.identityKey.validatePublicKey()) {\n            return false;\n        }\n        return this.preKeys.every((key) => key.validatePublicKey());\n    }\n    equals(other) {\n        if (this.preKeys.length !== other.preKeys.length) {\n            return false;\n        }\n        for (let i = 0; i < this.preKeys.length; i++) {\n            if (!this.preKeys[i].equals(other.preKeys[i])) {\n                return false;\n            }\n        }\n        return this.identityKey.equals(other.identityKey);\n    }\n    static fromLegacyBundle(bundle) {\n        return new PrivateKeyBundleV2({\n            identityKey: SignedPrivateKey.fromLegacyKey(bundle.identityKey, true),\n            preKeys: bundle.preKeys.map((k) => SignedPrivateKey.fromLegacyKey(k)),\n        });\n    }\n}\n// PrivateKeyBundle bundles the private keys corresponding to a PublicKeyBundle for convenience.\n// This bundle must not be shared with anyone, although will have to be persisted\n// somehow so that older messages can be decrypted again.\nclass PrivateKeyBundleV1 {\n    constructor(bundle) {\n        this.version = 1;\n        if (!bundle.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        this.identityKey = new PrivateKey(bundle.identityKey);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.preKeys = (bundle.preKeys || []).map((k) => new PrivateKey(k));\n    }\n    // Generate a new key bundle with the preKey signed byt the identityKey.\n    // Optionally sign the identityKey with the provided wallet as well.\n    static async generate(wallet) {\n        const identityKey = PrivateKey.generate();\n        if (wallet) {\n            await identityKey.publicKey.signWithWallet(wallet);\n        }\n        const bundle = new PrivateKeyBundleV1({\n            identityKey,\n            preKeys: [],\n        });\n        await bundle.addPreKey();\n        return bundle;\n    }\n    // Return the current (latest) pre-key (to be advertised).\n    getCurrentPreKey() {\n        return this.preKeys[0];\n    }\n    // Find pre-key matching the provided public key.\n    findPreKey(which) {\n        const preKey = this.preKeys.find((key) => key.matches(which));\n        if (!preKey) {\n            throw new NoMatchingPreKeyError(which);\n        }\n        return preKey;\n    }\n    // Generate a new pre-key to be used as the current pre-key.\n    async addPreKey() {\n        this._publicKeyBundle = undefined;\n        const preKey = PrivateKey.generate();\n        await this.identityKey.signKey(preKey.publicKey);\n        this.preKeys.unshift(preKey);\n    }\n    // Return a key bundle with the current pre-key.\n    getPublicKeyBundle() {\n        if (!this._publicKeyBundle) {\n            this._publicKeyBundle = new PublicKeyBundle({\n                identityKey: this.identityKey.publicKey,\n                preKey: this.getCurrentPreKey().publicKey,\n            });\n        }\n        return this._publicKeyBundle;\n    }\n    validatePublicKeys() {\n        if (!this.identityKey.validatePublicKey()) {\n            return false;\n        }\n        return this.preKeys.every((key) => key.validatePublicKey());\n    }\n    // sharedSecret derives a secret from peer's key bundles using a variation of X3DH protocol\n    // where the sender's ephemeral key pair is replaced by the sender's pre-key.\n    // @peer is the peer's public key bundle\n    // @myPreKey indicates which of my preKeys should be used to derive the secret\n    // @recipient indicates if this is the sending or receiving side.\n    async sharedSecret(peer, myPreKey, isRecipient) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!peer.identityKey || !peer.preKey) {\n            throw new Error(\"invalid peer key bundle\");\n        }\n        if (!(await peer.identityKey.verifyKey(peer.preKey))) {\n            throw new Error(\"peer preKey signature invalid\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!this.identityKey) {\n            throw new Error(\"missing identity key\");\n        }\n        let dh1, dh2, preKey;\n        if (isRecipient) {\n            preKey = this.findPreKey(myPreKey);\n            dh1 = preKey.sharedSecret(peer.identityKey);\n            dh2 = this.identityKey.sharedSecret(peer.preKey);\n        }\n        else {\n            preKey = this.findPreKey(myPreKey);\n            dh1 = this.identityKey.sharedSecret(peer.preKey);\n            dh2 = preKey.sharedSecret(peer.identityKey);\n        }\n        const dh3 = preKey.sharedSecret(peer.preKey);\n        const secret = new Uint8Array(dh1.length + dh2.length + dh3.length);\n        secret.set(dh1, 0);\n        secret.set(dh2, dh1.length);\n        secret.set(dh3, dh1.length + dh2.length);\n        return secret;\n    }\n    encode() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKeyBundle.encode({\n            v1: this,\n            v2: undefined,\n        }).finish();\n    }\n}\nfunction decodePrivateKeyBundle(bytes) {\n    const b = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKeyBundle.decode(bytes);\n    if (b.v1) {\n        return new PrivateKeyBundleV1(b.v1);\n    }\n    if (b.v2) {\n        return new PrivateKeyBundleV2(b.v2);\n    }\n    throw new Error(\"unknown private key bundle version\");\n}\n\nclass AuthData {\n    constructor({ walletAddr, createdNs }) {\n        this.walletAddr = walletAddr;\n        this.createdNs = createdNs;\n    }\n    static create(walletAddr, timestamp) {\n        timestamp = timestamp || new Date();\n        return new AuthData({\n            walletAddr,\n            createdNs: dateToNs(timestamp),\n        });\n    }\n    static fromBytes(bytes) {\n        const res = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.AuthData.decode(bytes);\n        return new AuthData(res);\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.AuthData.encode(this).finish();\n    }\n}\n\nclass Token {\n    constructor({ identityKey, authDataBytes, authDataSignature }) {\n        if (!identityKey) {\n            throw new Error(\"Missing identity key in token\");\n        }\n        if (!authDataSignature) {\n            throw new Error(\"Missing authDataSignature in token\");\n        }\n        this.identityKey = identityKey;\n        this.authDataBytes = authDataBytes;\n        this.authDataSignature = authDataSignature;\n    }\n    // Get AuthData, generating from bytes and cacheing the first time it is accessed\n    get authData() {\n        if (!this._authData) {\n            this._authData = AuthData.fromBytes(this.authDataBytes);\n        }\n        return this._authData;\n    }\n    get ageMs() {\n        const now = new Date().valueOf();\n        const authData = this.authData;\n        const createdAt = authData.createdNs.div(1_000_000).toNumber();\n        return now - createdAt;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.Token.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new Token(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.Token.decode(bytes));\n    }\n    toBase64() {\n        return Buffer.from(this.toBytes()).toString(\"base64\");\n    }\n}\n\nconst wrapToken = (token) => {\n    if (token instanceof Token) {\n        return token;\n    }\n    return new Token(token);\n};\nclass KeystoreAuthenticator {\n    constructor(keystore) {\n        this.keystore = keystore;\n    }\n    async createToken(timestamp) {\n        const token = await this.keystore.createAuthToken({\n            timestampNs: timestamp ? dateToNs(timestamp) : undefined,\n        });\n        return wrapToken(token);\n    }\n}\n\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst defaultIsRetryableFn = (err) => !!err;\n// Implements type safe retries of arbitrary async functions\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function retry(fn, args, maxRetries, sleepTime, isRetryableFn = defaultIsRetryableFn, retryCount = 1) {\n    const currRetry = typeof retryCount === \"number\" ? retryCount : 1;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const result = await fn(...args);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    }\n    catch (e) {\n        if (!isRetryableFn(e) || currRetry > maxRetries) {\n            throw e;\n        }\n        await sleep(sleepTime);\n        return retry(fn, args, maxRetries, sleepTime, isRetryableFn, currRetry + 1);\n    }\n}\n// Takes an async generator returning pages of envelopes and converts to an async\n// generator returning pages of an arbitrary type using a mapper function\nasync function* mapPaginatedStream(gen, mapper) {\n    for await (const page of gen) {\n        const results = await Promise.allSettled(page.map(mapper));\n        const out = [];\n        for (const result of results) {\n            if (result.status === \"fulfilled\") {\n                out.push(result.value);\n            }\n            else {\n                console.warn(\"Failed to process envelope due to reason: \", result.reason);\n            }\n        }\n        yield out;\n    }\n}\n\nconst version$1 = \"13.0.2\";\n\n// Default to 10 seconds less than expected expiry to give some wiggle room near the end\n// https://github.com/xmtp/xmtp-node-go/blob/main/pkg/api/authentication.go#L18\nconst DEFAULT_MAX_AGE_SECONDS = 60 * 60 - 10;\nclass AuthCache {\n    constructor(authenticator, cacheExpirySeconds = DEFAULT_MAX_AGE_SECONDS) {\n        this.authenticator = authenticator;\n        this.maxAgeMs = cacheExpirySeconds * 1000;\n    }\n    async getToken() {\n        if (!this.token || this.token.ageMs > this.maxAgeMs) {\n            await this.refresh();\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.token.toBase64();\n    }\n    async refresh() {\n        this.token = await this.authenticator.createToken();\n    }\n}\n\nconst XMTP_DEV_WARNING = `\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n`;\n\nconst { MessageApi, SortDirection } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.messageApi;\nconst RETRY_SLEEP_TIME = 100;\nconst ERR_CODE_UNAUTHENTICATED = 16;\nconst clientVersionHeaderKey = \"X-Client-Version\";\nconst appVersionHeaderKey = \"X-App-Version\";\nconst ApiUrls = {\n    local: \"http://localhost:5555\",\n    dev: \"https://dev.xmtp.network\",\n    production: \"https://production.xmtp.network\",\n};\nvar GrpcStatus;\n(function (GrpcStatus) {\n    GrpcStatus[GrpcStatus[\"OK\"] = 0] = \"OK\";\n    GrpcStatus[GrpcStatus[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    GrpcStatus[GrpcStatus[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    GrpcStatus[GrpcStatus[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    GrpcStatus[GrpcStatus[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    GrpcStatus[GrpcStatus[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    GrpcStatus[GrpcStatus[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    GrpcStatus[GrpcStatus[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    GrpcStatus[GrpcStatus[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    GrpcStatus[GrpcStatus[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    GrpcStatus[GrpcStatus[\"ABORTED\"] = 10] = \"ABORTED\";\n    GrpcStatus[GrpcStatus[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    GrpcStatus[GrpcStatus[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    GrpcStatus[GrpcStatus[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    GrpcStatus[GrpcStatus[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    GrpcStatus[GrpcStatus[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    GrpcStatus[GrpcStatus[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(GrpcStatus || (GrpcStatus = {}));\nclass GrpcError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n    static fromObject(err) {\n        return new GrpcError(err.message, err.code);\n    }\n}\nconst isAbortError = (err) => {\n    if (!err) {\n        return false;\n    }\n    if (err.name === \"AbortError\" || err.message.includes(\"aborted\")) {\n        return true;\n    }\n    return false;\n};\nconst isAuthError = (err) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (err && \"code\" in err && err.code === ERR_CODE_UNAUTHENTICATED) {\n        return true;\n    }\n    return false;\n};\nconst isNotAuthError = (err) => !isAuthError(err);\nconst normalizeEnvelope = (env) => {\n    if (!env.message || !env.message.length) {\n        return env;\n    }\n    if (typeof env.message === \"string\") {\n        env.message = b64Decode(env.message);\n    }\n    return env;\n};\n/**\n * ApiClient provides a wrapper for calling the GRPC Gateway generated code.\n * It adds some helpers for dealing with paginated data and automatically retries idempotent calls\n */\nclass HttpApiClient {\n    constructor(pathPrefix, opts) {\n        this.pathPrefix = pathPrefix;\n        this.maxRetries = opts?.maxRetries || 5;\n        this.appVersion = opts?.appVersion;\n        this.version = \"xmtp-js/\" + version$1;\n        if (pathPrefix === ApiUrls.dev) {\n            console.info(XMTP_DEV_WARNING);\n        }\n    }\n    // Raw method for querying the API\n    async _query(req) {\n        try {\n            return await retry(\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            MessageApi.Query, [\n                req,\n                {\n                    pathPrefix: this.pathPrefix,\n                    mode: \"cors\",\n                    headers: this.headers(),\n                },\n            ], this.maxRetries, RETRY_SLEEP_TIME);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            throw GrpcError.fromObject(e);\n        }\n    }\n    // Raw method for batch-querying the API\n    _batchQuery(req) {\n        return retry(\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        MessageApi.BatchQuery, [\n            req,\n            {\n                pathPrefix: this.pathPrefix,\n                mode: \"cors\",\n                headers: this.headers(),\n            },\n        ], this.maxRetries, RETRY_SLEEP_TIME);\n    }\n    // Raw method for publishing to the API\n    async _publish(req, attemptNumber = 0) {\n        const authToken = await this.getToken();\n        const headers = this.headers();\n        headers.set(\"Authorization\", `Bearer ${authToken}`);\n        try {\n            return await retry(\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            MessageApi.Publish, [\n                req,\n                {\n                    pathPrefix: this.pathPrefix,\n                    mode: \"cors\",\n                    headers,\n                },\n            ], this.maxRetries, RETRY_SLEEP_TIME, \n            // Do not retry UnauthenticatedErrors\n            isNotAuthError);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            // Try at most 2X. If refreshing the auth token doesn't work the first time, it won't work the second time\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            if (isNotAuthError(e) || attemptNumber >= 1) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                throw GrpcError.fromObject(e);\n            }\n            await this.authCache?.refresh();\n            return this._publish(req, attemptNumber + 1);\n        }\n    }\n    // Raw method for subscribing\n    _subscribe(req, cb, onConnectionLost) {\n        const abortController = new AbortController();\n        const doSubscribe = async () => {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            while (true) {\n                const startTime = new Date().getTime();\n                try {\n                    await MessageApi.Subscribe(req, cb, {\n                        pathPrefix: this.pathPrefix,\n                        signal: abortController.signal,\n                        mode: \"cors\",\n                        headers: this.headers(),\n                    });\n                    if (abortController.signal.aborted) {\n                        return;\n                    }\n                    console.info(\"Stream connection closed. Resubscribing\");\n                    if (new Date().getTime() - startTime < 1000) {\n                        await sleep(1000);\n                    }\n                    onConnectionLost?.();\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (err) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    if (isAbortError(err) || abortController.signal.aborted) {\n                        return;\n                    }\n                    console.info(\"Stream connection closed. Resubscribing\");\n                    if (new Date().getTime() - startTime < 1000) {\n                        await sleep(1000);\n                    }\n                    onConnectionLost?.();\n                }\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        doSubscribe();\n        return {\n            // eslint-disable-next-line @typescript-eslint/require-await\n            unsubscribe: async () => {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                abortController?.abort();\n            },\n        };\n    }\n    // Use the Query API to return the full contents of any specified topics\n    async query(params, { direction = SortDirection.SORT_DIRECTION_ASCENDING, limit, pageSize, }) {\n        const out = [];\n        const maxPageSize = params.contentTopic.startsWith(\"userpreferences-\")\n            ? 500\n            : 100;\n        // Use queryIteratePages for better performance. 1/100th the number of Promises to resolve compared to queryStream\n        for await (const page of this.queryIteratePages(params, {\n            direction,\n            // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.\n            pageSize: pageSize ? Math.min(pageSize, maxPageSize) : maxPageSize,\n        })) {\n            for (const envelope of page) {\n                out.push(envelope);\n                if (limit && out.length === limit) {\n                    return out;\n                }\n            }\n        }\n        return out;\n    }\n    // Will produce an AsyncGenerator of Envelopes\n    // Uses queryStreamPages under the hood\n    async *queryIterator(params, options) {\n        for await (const page of this.queryIteratePages(params, options)) {\n            for (const envelope of page) {\n                yield envelope;\n            }\n        }\n    }\n    // Creates an async generator that will paginate through the Query API until it reaches the end\n    // Will yield each page of results as needed\n    async *queryIteratePages({ contentTopic, startTime, endTime }, { direction, pageSize = 10 }) {\n        if (!contentTopic || !contentTopic.length) {\n            throw new Error(\"Must specify content topics\");\n        }\n        const startTimeNs = toNanoString(startTime);\n        const endTimeNs = toNanoString(endTime);\n        let cursor;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n            const pagingInfo = {\n                limit: pageSize,\n                direction,\n                cursor,\n            };\n            const result = await this._query({\n                contentTopics: [contentTopic],\n                startTimeNs,\n                endTimeNs,\n                pagingInfo,\n            });\n            if (result.envelopes?.length) {\n                yield result.envelopes.map(normalizeEnvelope);\n            }\n            else {\n                return;\n            }\n            if (result.pagingInfo?.cursor) {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                cursor = result.pagingInfo?.cursor;\n            }\n            else {\n                return;\n            }\n        }\n    }\n    // Take a list of queries and execute them in batches\n    async batchQuery(queries) {\n        // Group queries into batches of 50 (implicit server-side limit) and then perform BatchQueries\n        const BATCH_SIZE = 50;\n        // Keep a list of BatchQueryRequests to execute all at once later\n        const batchRequests = [];\n        // Assemble batches\n        for (let i = 0; i < queries.length; i += BATCH_SIZE) {\n            const queriesInBatch = queries.slice(i, i + BATCH_SIZE);\n            // Perform batch query by first compiling a list of repeated individual QueryRequests\n            // then populating a BatchQueryRequest with that list\n            const constructedQueries = [];\n            for (const queryParams of queriesInBatch) {\n                constructedQueries.push({\n                    contentTopics: [queryParams.contentTopic],\n                    startTimeNs: toNanoString(queryParams.startTime),\n                    endTimeNs: toNanoString(queryParams.endTime),\n                    pagingInfo: {\n                        limit: queryParams.pageSize || 10,\n                        direction: queryParams.direction || SortDirection.SORT_DIRECTION_ASCENDING,\n                    },\n                });\n            }\n            const batchQueryRequest = {\n                requests: constructedQueries,\n            };\n            batchRequests.push(batchQueryRequest);\n        }\n        // Execute batches\n        const batchQueryResponses = await Promise.all(batchRequests.map(async (batch) => this._batchQuery(batch)));\n        // For every batch, read all responses within the batch, and add to a list of lists of envelopes\n        // one top-level list for every original query\n        const allEnvelopes = [];\n        for (const batchResponse of batchQueryResponses) {\n            if (!batchResponse.responses) {\n                // An error on any of the batch query is propagated to the caller\n                // for simplicity, rather than trying to return partial results\n                throw new Error(\"BatchQueryResponse missing responses\");\n            }\n            for (const queryResponse of batchResponse.responses) {\n                if (queryResponse.envelopes) {\n                    allEnvelopes.push(queryResponse.envelopes.map(normalizeEnvelope));\n                }\n                else {\n                    // If no envelopes provided, then add an empty list\n                    allEnvelopes.push([]);\n                }\n            }\n        }\n        return allEnvelopes;\n    }\n    // Publish a message to the network\n    // Will convert timestamps to the appropriate format expected by the network\n    async publish(messages) {\n        const toSend = [];\n        for (const { contentTopic, message, timestamp } of messages) {\n            if (!contentTopic.length) {\n                throw new Error(\"Content topic cannot be empty string\");\n            }\n            if (!message.length) {\n                throw new Error(\"0 length messages not allowed\");\n            }\n            const dt = timestamp || new Date();\n            toSend.push({\n                contentTopic,\n                timestampNs: toNanoString(dt),\n                message: Uint8Array.from(message),\n            });\n        }\n        return this._publish({ envelopes: toSend });\n    }\n    // Subscribe to a list of topics.\n    // Provided callback function will be called on each new message\n    // Returns an unsubscribe function that can be used to end the subscription\n    subscribe(params, callback, onConnectionLost) {\n        if (!params.contentTopics.length) {\n            throw new Error(\"Must provide list of contentTopics to subscribe to\");\n        }\n        return this._subscribe(params, \n        // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n        (env) => callback(normalizeEnvelope(env)), onConnectionLost);\n    }\n    getToken() {\n        if (!this.authCache) {\n            throw new Error(\"AuthCache is not set on API Client\");\n        }\n        return this.authCache.getToken();\n    }\n    setAuthenticator(authenticator, cacheExpirySeconds) {\n        this.authCache = new AuthCache(authenticator, cacheExpirySeconds);\n    }\n    headers() {\n        const headers = new Headers();\n        headers.set(clientVersionHeaderKey, this.version);\n        if (this.appVersion) {\n            headers.set(appVersionHeaderKey, this.appVersion);\n        }\n        return headers;\n    }\n}\n\nconst CLOCK_SKEW_OFFSET_MS = 10000;\nclass JobRunner {\n    constructor(jobType, keystore) {\n        this.disableOffset = false;\n        this.jobType = jobType;\n        this.mutex = new async_mutex__WEBPACK_IMPORTED_MODULE_4__.Mutex();\n        this.keystore = keystore;\n    }\n    get protoJobType() {\n        return getProtoJobType(this.jobType);\n    }\n    async run(callback) {\n        return this.mutex.runExclusive(async () => {\n            const lastRun = await this.getLastRunTime();\n            const startTime = new Date();\n            const result = await callback(lastRun\n                ? !this.disableOffset\n                    ? new Date(lastRun.getTime() - CLOCK_SKEW_OFFSET_MS)\n                    : lastRun\n                : undefined);\n            await this.setLastRunTime(startTime);\n            return result;\n        });\n    }\n    async resetLastRunTime() {\n        await this.keystore.setRefreshJob({\n            jobType: this.protoJobType,\n            lastRunNs: dateToNs(new Date(0)),\n        });\n    }\n    async getLastRunTime() {\n        const { lastRunNs } = await this.keystore.getRefreshJob(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetRefreshJobRequest.fromPartial({\n            jobType: this.protoJobType,\n        }));\n        if (lastRunNs.equals(long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(0))) {\n            return undefined;\n        }\n        return nsToDate(lastRunNs);\n    }\n    async setLastRunTime(lastRun) {\n        await this.keystore.setRefreshJob({\n            jobType: this.protoJobType,\n            lastRunNs: dateToNs(lastRun),\n        });\n    }\n}\nfunction getProtoJobType(jobType) {\n    const protoJobType = {\n        v1: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.JobType.JOB_TYPE_REFRESH_V1,\n        v2: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.JobType.JOB_TYPE_REFRESH_V2,\n        \"user-preferences\": _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.JobType.JOB_TYPE_REFRESH_PPPP,\n    }[jobType];\n    if (!protoJobType) {\n        throw new Error(`unknown job type: ${jobType}`);\n    }\n    return protoJobType;\n}\n\nconst messageHasHeaders = (msg) => {\n    return Boolean(msg.recipientAddress && msg.senderAddress);\n};\n/**\n * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass Conversations {\n    constructor(client) {\n        this.client = client;\n        this.v1JobRunner = new JobRunner(\"v1\", client.keystore);\n        this.v2JobRunner = new JobRunner(\"v2\", client.keystore);\n    }\n    /**\n     * List all conversations with the current wallet found in the network.\n     */\n    async list() {\n        const [v1Convos, v2Convos] = await Promise.all([\n            this.listV1Conversations(),\n            this.listV2Conversations(),\n        ]);\n        const conversations = v1Convos.concat(v2Convos);\n        conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n        return conversations;\n    }\n    /**\n     * List all conversations stored in the client cache, which may not include\n     * conversations on the network.\n     */\n    async listFromCache() {\n        const [v1Convos, v2Convos] = await Promise.all([\n            this.getV1ConversationsFromKeystore(),\n            this.getV2ConversationsFromKeystore(),\n        ]);\n        const conversations = v1Convos.concat(v2Convos);\n        conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n        return conversations;\n    }\n    async listV1Conversations() {\n        return this.v1JobRunner.run(async (latestSeen) => {\n            const seenPeers = await this.getIntroductionPeers({\n                startTime: latestSeen,\n                direction: SortDirection.SORT_DIRECTION_ASCENDING,\n            });\n            await this.client.keystore.saveV1Conversations({\n                conversations: Array.from(seenPeers)\n                    .map(([peerAddress, createdAt]) => ({\n                    peerAddress,\n                    createdNs: dateToNs(createdAt),\n                    topic: buildDirectMessageTopic(peerAddress, this.client.address),\n                    context: undefined,\n                    consentProofPayload: undefined,\n                }))\n                    .filter((c) => isValidTopic(c.topic)),\n            });\n            return (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this));\n        });\n    }\n    /**\n     * List all V2 conversations\n     */\n    async listV2Conversations() {\n        return this.v2JobRunner.run(async (lastRun) => {\n            // Get all conversations already in the KeyStore\n            const existing = await this.getV2ConversationsFromKeystore();\n            // Load all conversations started after the newest conversation found\n            const newConversations = await this.updateV2Conversations(lastRun);\n            // Create a Set of all the existing topics to ensure no duplicates are added\n            const existingTopics = new Set(existing.map((c) => c.topic));\n            // Add all new conversations to the existing list\n            for (const convo of newConversations) {\n                if (!existingTopics.has(convo.topic)) {\n                    existing.push(convo);\n                    existingTopics.add(convo.topic);\n                }\n            }\n            // Sort the result set by creation time in ascending order\n            existing.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n            return existing;\n        });\n    }\n    async getV2ConversationsFromKeystore() {\n        return (await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this));\n    }\n    async getV1ConversationsFromKeystore() {\n        return (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this));\n    }\n    // Called in listV2Conversations and in newConversation\n    async updateV2Conversations(startTime) {\n        const envelopes = await this.client.listInvitations({\n            startTime,\n            direction: SortDirection.SORT_DIRECTION_ASCENDING,\n        });\n        return this.decodeInvites(envelopes);\n    }\n    async decodeInvites(envelopes, shouldThrow = false) {\n        const { responses } = await this.client.keystore.saveInvites({\n            requests: envelopes\n                .map((env) => ({\n                payload: env.message,\n                timestampNs: long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromString(env.timestampNs),\n                contentTopic: env.contentTopic,\n            }))\n                .filter((req) => isValidTopic(req.contentTopic)),\n        });\n        const out = [];\n        for (const response of responses) {\n            try {\n                out.push(this.saveInviteResponseToConversation(response));\n            }\n            catch (e) {\n                console.warn(\"Error saving invite response to conversation: \", e);\n                if (shouldThrow) {\n                    throw e;\n                }\n            }\n        }\n        return out;\n    }\n    saveInviteResponseToConversation({ result, error, }) {\n        if (error || !result || !result.conversation) {\n            throw new Error(`Error from keystore: ${error?.code} ${error?.message}}`);\n        }\n        return this.conversationReferenceToV2(result.conversation);\n    }\n    conversationReferenceToV2(convoRef) {\n        return new ConversationV2(this.client, convoRef.topic, convoRef.peerAddress, nsToDate(convoRef.createdNs), convoRef.context, convoRef.consentProofPayload);\n    }\n    conversationReferenceToV1(convoRef) {\n        return new ConversationV1(this.client, convoRef.peerAddress, nsToDate(convoRef.createdNs));\n    }\n    /**\n     * Returns a stream of any newly created conversations.\n     * Will dedupe to not return the same conversation twice in the same stream.\n     * Does not dedupe any other previously seen conversations\n     */\n    async stream(onConnectionLost) {\n        const seenPeers = new Set();\n        const introTopic = buildUserIntroTopic(this.client.address);\n        const inviteTopic = buildUserInviteTopic(this.client.address);\n        const newPeer = (peerAddress) => {\n            // Check if we have seen the peer already in this stream\n            if (seenPeers.has(peerAddress)) {\n                return false;\n            }\n            seenPeers.add(peerAddress);\n            return true;\n        };\n        const decodeConversation = async (env) => {\n            if (env.contentTopic === introTopic) {\n                if (!env.message) {\n                    throw new Error(\"empty envelope\");\n                }\n                const msg = await MessageV1.fromBytes(env.message);\n                const peerAddress = this.getPeerAddress(msg);\n                if (!newPeer(peerAddress)) {\n                    return undefined;\n                }\n                await msg.decrypt(this.client.keystore, this.client.publicKeyBundle);\n                return new ConversationV1(this.client, peerAddress, msg.sent);\n            }\n            if (env.contentTopic === inviteTopic) {\n                const results = await this.decodeInvites([env], true);\n                if (results.length) {\n                    return results[0];\n                }\n            }\n            throw new Error(\"unrecognized invite topic\");\n        };\n        const topics = [introTopic, inviteTopic];\n        return Stream.create(this.client, topics, decodeConversation.bind(this), undefined, onConnectionLost);\n    }\n    /**\n     * Streams messages from all conversations.\n     *\n     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.\n     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.\n     *\n     */\n    async streamAllMessages(onConnectionLost) {\n        const introTopic = buildUserIntroTopic(this.client.address);\n        const inviteTopic = buildUserInviteTopic(this.client.address);\n        const topics = new Set([introTopic, inviteTopic]);\n        const convoMap = new Map();\n        for (const conversation of await this.list()) {\n            topics.add(conversation.topic);\n            convoMap.set(conversation.topic, conversation);\n        }\n        const decodeMessage = async (env) => {\n            const contentTopic = env.contentTopic;\n            if (!contentTopic || !env.message) {\n                return null;\n            }\n            if (contentTopic === introTopic) {\n                const msg = await MessageV1.fromBytes(env.message);\n                if (!messageHasHeaders(msg)) {\n                    return null;\n                }\n                const peerAddress = this.getPeerAddress(msg);\n                // Temporarily create a convo to decrypt the message\n                const convo = new ConversationV1(this.client, \n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                peerAddress, msg.sent);\n                // TODO: This duplicates the proto deserialization unnecessarily\n                // Refactor to avoid duplicate work\n                return convo.decodeMessage(env);\n            }\n            // Decode as an invite and return the envelope\n            // This gives the contentTopicUpdater everything it needs to add to the topic list\n            if (contentTopic === inviteTopic) {\n                const results = await this.decodeInvites([env], true);\n                return results[0];\n            }\n            const convo = convoMap.get(contentTopic);\n            // Decode as a V1 message if the topic matches a V1 convo\n            if (convo instanceof ConversationV1) {\n                return convo.decodeMessage(env);\n            }\n            // Decode as a V2 message if the topic matches a V2 convo\n            if (convo instanceof ConversationV2) {\n                return convo.decodeMessage(env);\n            }\n            console.log(\"Unknown topic\");\n            throw new Error(\"Unknown topic\");\n        };\n        const addConvo = (topic, conversation) => {\n            if (topics.has(topic)) {\n                return false;\n            }\n            convoMap.set(topic, conversation);\n            topics.add(topic);\n            return true;\n        };\n        const contentTopicUpdater = (msg) => {\n            // If we have a V1 message from the introTopic, store the conversation in our mapping\n            if (msg instanceof DecodedMessage && msg.contentTopic === introTopic) {\n                const convo = new ConversationV1(this.client, msg.recipientAddress?.toLowerCase() ===\n                    this.client.address.toLowerCase()\n                    ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                        msg.senderAddress\n                    : msg.recipientAddress, msg.sent);\n                const isNew = addConvo(convo.topic, convo);\n                return isNew ? Array.from(topics.values()) : undefined;\n            }\n            if (msg instanceof ConversationV2) {\n                const isNew = addConvo(msg.topic, msg);\n                return isNew ? Array.from(topics.values()) : undefined;\n            }\n            return undefined;\n        };\n        const str = await Stream.create(this.client, Array.from(topics.values()), decodeMessage, contentTopicUpdater, onConnectionLost);\n        const gen = (async function* generate() {\n            for await (const val of str) {\n                if (val instanceof DecodedMessage) {\n                    yield val;\n                }\n                // For conversation V2, we may have messages in the new topic before we started streaming.\n                // To be safe, we fetch all messages\n                if (val instanceof ConversationV2) {\n                    for (const convoMessage of await val.messages()) {\n                        yield convoMessage;\n                    }\n                }\n            }\n        })();\n        // Overwrite the generator's return method to close the underlying stream\n        // Generators by default need to wait until the next yield to return.\n        // In this case, that's only when the next message arrives...which could be a long time\n        gen.return = async () => {\n            // Returning the stream will cause the iteration to end inside the generator\n            // The generator will then return on its own\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            await str?.return();\n            return { value: undefined, done: true };\n        };\n        return gen;\n    }\n    async getIntroductionPeers(opts) {\n        const topic = buildUserIntroTopic(this.client.address);\n        const messages = await this.client.listEnvelopes(topic, (env) => {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!env.message) {\n                throw new Error(\"empty envelope\");\n            }\n            return MessageV1.fromBytes(env.message);\n        }, opts);\n        const seenPeers = new Map();\n        for (const message of messages) {\n            // Ignore all messages without sender or recipient address headers\n            // Makes getPeerAddress safe\n            if (!messageHasHeaders(message)) {\n                continue;\n            }\n            const peerAddress = this.getPeerAddress(message);\n            if (peerAddress) {\n                const have = seenPeers.get(peerAddress);\n                if (!have || have > message.sent) {\n                    try {\n                        // Verify that the message can be decrypted before treating the intro as valid\n                        await message.decrypt(this.client.keystore, this.client.publicKeyBundle);\n                        seenPeers.set(peerAddress, message.sent);\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    }\n                    catch (e) {\n                        continue;\n                    }\n                }\n            }\n        }\n        return seenPeers;\n    }\n    /**\n     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network\n     */\n    async newConversation(peerAddress, context, consentProof) {\n        // Define a function for matching V2 conversations\n        const matcherFn = (convo) => convo.peerAddress.toLowerCase() === peerAddress.toLowerCase() &&\n            isMatchingContext(context, convo.context ?? undefined);\n        // Check if we already have a V2 conversation with the peer in keystore\n        const existing = await this.getV2ConversationsFromKeystore();\n        const existingMatch = existing.find(matcherFn);\n        if (existingMatch) {\n            return existingMatch;\n        }\n        let contact = await this.client.getUserContact(peerAddress);\n        if (!contact) {\n            throw new Error(`Recipient ${peerAddress} is not on the XMTP network`);\n        }\n        if (peerAddress.toLowerCase() === this.client.address.toLowerCase()) {\n            throw new Error(\"self messaging not supported\");\n        }\n        // If this is a V1 conversation continuation\n        if (contact instanceof PublicKeyBundle && !context?.conversationId) {\n            return new ConversationV1(this.client, peerAddress, new Date());\n        }\n        // If no conversationId, check and see if we have an existing V1 conversation\n        if (!context?.conversationId) {\n            const v1Convos = await this.listV1Conversations();\n            const matchingConvo = v1Convos.find((convo) => convo.peerAddress.toLowerCase() === peerAddress.toLowerCase());\n            // If intro already exists, return V1 conversation\n            // if both peers have V1 compatible key bundles\n            if (matchingConvo) {\n                if (!this.client.signedPublicKeyBundle.isFromLegacyBundle()) {\n                    throw new Error(\"cannot resume pre-existing V1 conversation; client keys not compatible\");\n                }\n                if (!(contact instanceof PublicKeyBundle) &&\n                    !contact.isFromLegacyBundle()) {\n                    throw new Error(\"cannot resume pre-existing V1 conversation; peer keys not compatible\");\n                }\n                return matchingConvo;\n            }\n        }\n        // Coerce the contact into a V2 bundle\n        if (contact instanceof PublicKeyBundle) {\n            contact = SignedPublicKeyBundle.fromLegacyBundle(contact);\n        }\n        return this.v2JobRunner.run(async (lastRun) => {\n            const newItems = await this.updateV2Conversations(lastRun);\n            const newItemMatch = newItems.find(matcherFn);\n            // If one of those matches, return it to update the cache\n            if (newItemMatch) {\n                return newItemMatch;\n            }\n            return this.createV2Convo(\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            contact, context, consentProof);\n        });\n    }\n    async createV2Convo(recipient, context, consentProof) {\n        const timestamp = new Date();\n        const { payload, conversation } = await this.client.keystore.createInvite({\n            recipient,\n            context,\n            createdNs: dateToNs(timestamp),\n            consentProof,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!payload || !conversation) {\n            throw new Error(\"Required field not returned from Keystore\");\n        }\n        const peerAddress = await recipient.walletSignatureAddress();\n        await this.client.publishEnvelopes([\n            {\n                contentTopic: buildUserInviteTopic(peerAddress),\n                message: payload,\n                timestamp,\n            },\n            {\n                contentTopic: buildUserInviteTopic(this.client.address),\n                message: payload,\n                timestamp,\n            },\n        ]);\n        // add peer address to allow list\n        await this.client.contacts.allow([peerAddress]);\n        return this.conversationReferenceToV2(conversation);\n    }\n    getPeerAddress(message) {\n        const peerAddress = message.recipientAddress?.toLowerCase() ===\n            this.client.address.toLowerCase()\n            ? message.senderAddress\n            : message.recipientAddress;\n        // This assertion is safe, so long as messages have been through the filter\n        return peerAddress;\n    }\n}\nfunction isMatchingContext(contextA, contextB) {\n    // Use == to allow null and undefined to be equivalent\n    return contextA?.conversationId === contextB?.conversationId;\n}\n\nclass BrowserStoragePersistence {\n    constructor(storage) {\n        this.storage = storage;\n    }\n    static create() {\n        if (typeof localStorage === \"undefined\") {\n            throw new Error(\"Missing LocalStorage. Use ephemeralPersistence instead\");\n        }\n        return new BrowserStoragePersistence(localStorage);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getItem(key) {\n        const value = this.storage.getItem(key);\n        if (value === null) {\n            return null;\n        }\n        return Uint8Array.from(Buffer.from(value, \"binary\"));\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async setItem(key, value) {\n        this.storage.setItem(key, Buffer.from(value).toString(\"binary\"));\n    }\n}\n\n// Fully in-memory polyfill for the browser storage API.\n// Borrowed from https://github.com/MitchellCash/node-storage-polyfill but implemented as a ponyfill instead of a polyfill\nclass LocalStoragePonyfill {\n    constructor() {\n        this.store = new Map();\n    }\n    get length() {\n        return this.store.size;\n    }\n    clear() {\n        this.store = new Map();\n    }\n    getItem(key) {\n        this.validateString(key);\n        if (this.store.has(key)) {\n            return String(this.store.get(key));\n        }\n        return null;\n    }\n    key(index) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (index === undefined) {\n            // This is the TypeError implemented in Chrome, Firefox throws \"Storage.key: At least 1\n            // argument required, but only 0 passed\".\n            throw new TypeError(\"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\");\n        }\n        const keys = [...this.store.keys()];\n        if (index >= keys.length) {\n            return null;\n        }\n        return keys[index];\n    }\n    removeItem(key) {\n        this.validateString(key);\n        this.store.delete(key);\n    }\n    setItem(key, value) {\n        this.validateString(key);\n        this.validateString(value);\n        this.store.set(String(key), String(value));\n    }\n    validateString(val) {\n        if (!(typeof val === \"string\")) {\n            throw new TypeError(\"Key must be a string\");\n        }\n    }\n}\n\nclass InMemoryPersistence extends BrowserStoragePersistence {\n    static create() {\n        return new BrowserStoragePersistence(new LocalStoragePonyfill());\n    }\n}\n\nclass KeystoreProviderUnavailableError extends Error {\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass LocalAuthenticator {\n    constructor(identityKey) {\n        if (!identityKey.publicKey.signature) {\n            throw new Error(\"Provided public key is not signed\");\n        }\n        this.identityKey = identityKey;\n    }\n    async createToken(timestamp) {\n        const authData = AuthData.create(this.identityKey.publicKey.walletSignatureAddress(), timestamp || new Date());\n        const authDataBytes = authData.toBytes();\n        const digest = (0,viem__WEBPACK_IMPORTED_MODULE_8__.keccak256)(authDataBytes);\n        const authSig = await this.identityKey.sign((0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)(digest));\n        return new Token(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.Token.fromPartial({\n            identityKey: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKey.fromPartial(\n            // The generated types are overly strict and don't like our additional methods\n            // eslint-disable-next-line\n            // @ts-ignore\n            this.identityKey.publicKey),\n            authDataBytes,\n            // The generated types are overly strict and don't like our additional methods\n            // eslint-disable-next-line\n            // @ts-ignore\n            authDataSignature: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.signature.Signature.fromPartial(authSig),\n        }));\n    }\n}\n\n// This file is taken from `bitchan/eccrypto` and ported to TS. All references to `nodeCrypto` have been replaced with `browserCrypto`\n/**\n * `elliptic` is a CommonJS module and has issues with named imports\n * DO NOT CHANGE THIS TO A NAMED IMPORT\n */\nconst EC = elliptic__WEBPACK_IMPORTED_MODULE_5__.ec;\nconst ec = new EC(\"secp256k1\");\nconst subtle = crypto.subtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nfunction isScalar(x) {\n    return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n    if (!isScalar(privateKey)) {\n        return false;\n    }\n    return (privateKey.compare(ZERO32) > 0 && // > 0\n        privateKey.compare(EC_GROUP_ORDER) < 0); // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for (let i = 0; i < b1.length; i++) {\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\nfunction randomBytes(size) {\n    const arr = new Uint8Array(size);\n    crypto.getRandomValues(arr);\n    return Buffer.from(arr);\n}\nasync function sha512(msg) {\n    const digest = await subtle.digest(\"SHA-512\", msg);\n    return Buffer.from(digest);\n}\nfunction getAes(op) {\n    return function (iv, key, data) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return new Promise(function (resolve) {\n            const importAlgorithm = { name: \"AES-CBC\" };\n            const keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n            return keyp\n                .then(function (cryptoKey) {\n                const encAlgorithm = { name: \"AES-CBC\", iv };\n                return subtle[op](encAlgorithm, cryptoKey, data);\n            })\n                .then(function (result) {\n                resolve(Buffer.from(new Uint8Array(result)));\n            });\n        });\n    };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n    const newKey = await subtle.importKey(\"raw\", key, { name: \"HMAC\", hash: { name: \"SHA-256\" } }, false, [\"sign\"]);\n    return Buffer.from(await subtle.sign({ name: \"HMAC\", hash: \"SHA-256\" }, newKey, msg));\n}\nasync function hmacSha256Verify(key, msg, sig) {\n    const expectedSig = await hmacSha256Sign(key, msg);\n    return equalConstTime(expectedSig, sig);\n}\nfunction getPublic(privateKey) {\n    // This function has sync API so we throw an error immediately.\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // XXX(Kagami): `elliptic.utils.encode` returns array for every\n    // encoding except `hex`.\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n}\nfunction derive(privateKeyA, publicKeyB) {\n    return new Promise(function (resolve) {\n        assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n        assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n        assert(privateKeyA.length === 32, \"Bad private key\");\n        assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n        assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n        if (publicKeyB.length === 65) {\n            assert(publicKeyB[0] === 4, \"Bad public key\");\n        }\n        if (publicKeyB.length === 33) {\n            assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n        }\n        const keyA = ec.keyFromPrivate(privateKeyA);\n        const keyB = ec.keyFromPublic(publicKeyB);\n        const Px = keyA.derive(keyB.getPublic()); // BN instance\n        resolve(Buffer.from(Px.toArray()));\n    });\n}\nasync function encrypt(publicKeyTo, msg, \n// eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\nopts) {\n    opts = opts || {};\n    // Take IV from opts or generate randomly\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const iv = opts?.iv || randomBytes(16);\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    let ephemPrivateKey = opts?.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while (!isValidPrivateKey(ephemPrivateKey)) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (opts?.ephemPrivateKey) {\n            throw new Error(\"ephemPrivateKey is not valid\");\n        }\n        ephemPrivateKey = randomBytes(32);\n    }\n    // Get the public key from the ephemeral private key\n    const ephemeralPublicKey = getPublic(ephemPrivateKey);\n    const hash = await sha512(await derive(ephemPrivateKey, publicKeyTo));\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const ciphertext = await aesCbcEncrypt(iv, encryptionKey, msg);\n    // Get a MAC\n    const dataToMac = Buffer.concat([iv, ephemeralPublicKey, ciphertext]);\n    const mac = await hmacSha256Sign(macKey, dataToMac);\n    // Return the payload\n    return {\n        iv,\n        ephemeralPublicKey,\n        ciphertext,\n        mac,\n    };\n}\nasync function decrypt(privateKey, opts) {\n    const px = await derive(privateKey, opts.ephemeralPublicKey);\n    const hash = await sha512(px);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const dataToMac = Buffer.concat([\n        opts.iv,\n        opts.ephemeralPublicKey,\n        opts.ciphertext,\n    ]);\n    assert(await hmacSha256Verify(macKey, dataToMac, opts.mac), \"Bad mac\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function userPreferencesEncrypt(identityKey, payload) {\n    const publicKey = identityKey.publicKey.secp256k1Uncompressed.bytes;\n    const privateKey = identityKey.secp256k1.bytes;\n    return (0,_xmtp_user_preferences_bindings_wasm__WEBPACK_IMPORTED_MODULE_6__.user_preferences_encrypt)(publicKey, privateKey, payload);\n}\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function userPreferencesDecrypt(identityKey, payload) {\n    const publicKey = identityKey.publicKey.secp256k1Uncompressed.bytes;\n    const privateKey = identityKey.secp256k1.bytes;\n    return (0,_xmtp_user_preferences_bindings_wasm__WEBPACK_IMPORTED_MODULE_6__.user_preferences_decrypt)(publicKey, privateKey, payload);\n}\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function generateUserPreferencesTopic(identityKey) {\n    const privateKey = identityKey.secp256k1.bytes;\n    return (0,_xmtp_user_preferences_bindings_wasm__WEBPACK_IMPORTED_MODULE_6__.generate_private_preferences_topic)(privateKey);\n}\n\n/**\n * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message\n */\nclass InvitationV1 {\n    constructor({ topic, context, aes256GcmHkdfSha256, consentProof, }) {\n        if (!topic || !topic.length) {\n            throw new Error(\"Missing topic\");\n        }\n        if (!aes256GcmHkdfSha256 ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            !aes256GcmHkdfSha256.keyMaterial ||\n            !aes256GcmHkdfSha256.keyMaterial.length) {\n            throw new Error(\"Missing key material\");\n        }\n        this.topic = topic;\n        this.context = context;\n        this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256;\n        this.consentProof = consentProof;\n    }\n    static createRandom(context, consentProof) {\n        const topic = buildDirectMessageTopicV2(Buffer.from(crypto.getRandomValues(new Uint8Array(32)))\n            .toString(\"base64\")\n            .replace(/=*$/g, \"\")\n            // Replace slashes with dashes so that the topic is still easily split by /\n            // We do not treat this as needing to be valid Base64 anywhere\n            .replace(/\\//g, \"-\"));\n        const keyMaterial = crypto.getRandomValues(new Uint8Array(32));\n        return new InvitationV1({\n            topic,\n            aes256GcmHkdfSha256: { keyMaterial },\n            context,\n            consentProof,\n        });\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.InvitationV1.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new InvitationV1(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.InvitationV1.decode(bytes));\n    }\n}\n/**\n * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1\n */\nclass SealedInvitationHeaderV1 {\n    constructor({ sender, recipient, createdNs, }) {\n        if (!sender) {\n            throw new Error(\"Missing sender\");\n        }\n        if (!recipient) {\n            throw new Error(\"Missing recipient\");\n        }\n        this.sender = new SignedPublicKeyBundle(sender);\n        this.recipient = new SignedPublicKeyBundle(recipient);\n        this.createdNs = createdNs;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitationHeaderV1.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new SealedInvitationHeaderV1(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitationHeaderV1.decode(bytes));\n    }\n}\nclass SealedInvitationV1 {\n    constructor({ headerBytes, ciphertext }) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!headerBytes || !headerBytes.length) {\n            throw new Error(\"Missing header bytes\");\n        }\n        if (!ciphertext) {\n            throw new Error(\"Missing ciphertext\");\n        }\n        this.headerBytes = headerBytes;\n        this.ciphertext = new Ciphertext(ciphertext);\n    }\n    /**\n     * Accessor method for the full header object\n     */\n    get header() {\n        // Use cached value if already exists\n        if (this._header) {\n            return this._header;\n        }\n        this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes);\n        return this._header;\n    }\n    /**\n     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation\n     */\n    async getInvitation(viewer) {\n        // Use cached value if already exists\n        if (this._invitation) {\n            return this._invitation;\n        }\n        // The constructors for child classes will validate that this is complete\n        const header = this.header;\n        let secret;\n        if (viewer.identityKey.matches(this.header.sender.identityKey)) {\n            secret = await viewer.sharedSecret(header.recipient, header.sender.preKey, false);\n        }\n        else {\n            secret = await viewer.sharedSecret(header.sender, header.recipient.preKey, true);\n        }\n        const decryptedBytes = await decrypt$1(this.ciphertext, secret, this.headerBytes);\n        this._invitation = InvitationV1.fromBytes(decryptedBytes);\n        return this._invitation;\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitationV1.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new SealedInvitationV1(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitationV1.decode(bytes));\n    }\n}\n/**\n * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation\n */\nclass SealedInvitation {\n    constructor({ v1 }) {\n        if (v1) {\n            this.v1 = new SealedInvitationV1(v1);\n        }\n        else {\n            throw new Error(\"Missing v1 or v2 invitation\");\n        }\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitation.encode(this).finish();\n    }\n    static fromBytes(bytes) {\n        return new SealedInvitation(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.invitation.SealedInvitation.decode(bytes));\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    static async fromEnvelope(env) {\n        if (!env.message || !env.timestampNs) {\n            throw new Error(\"invalid invitation envelope\");\n        }\n        const sealed = SealedInvitation.fromBytes(env.message);\n        const envelopeTime = long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromString(env.timestampNs);\n        const headerTime = sealed.v1?.header.createdNs;\n        if (!headerTime || !headerTime.equals(envelopeTime)) {\n            throw new Error(\"envelope and header timestamp mistmatch\");\n        }\n        return sealed;\n    }\n    /**\n     * Create a SealedInvitation with a SealedInvitationV1 payload\n     * Will encrypt all contents and validate inputs\n     */\n    static async createV1({ sender, recipient, created, invitation, }) {\n        const headerBytes = new SealedInvitationHeaderV1({\n            sender: sender.getPublicKeyBundle(),\n            recipient,\n            createdNs: dateToNs(created),\n        }).toBytes();\n        const secret = await sender.sharedSecret(recipient, sender.getCurrentPreKey().publicKey, false);\n        const invitationBytes = invitation.toBytes();\n        const ciphertext = await encrypt$1(invitationBytes, secret, headerBytes);\n        return new SealedInvitation({\n            v1: { headerBytes, ciphertext },\n        });\n    }\n}\n\nvar _PrivatePreferencesStore_instances, _PrivatePreferencesStore_persistence, _PrivatePreferencesStore_persistenceKey, _PrivatePreferencesStore_mutex, _PrivatePreferencesStore_revision, _PrivatePreferencesStore_toBytes;\nconst PRIVATE_PREFERENCES_ACTIONS_STORAGE_KEY = \"private-preferences/actions\";\n/**\n * PrivatePreferencesStore holds a mapping of message timestamp -> private\n * preference action and writes to the persistence layer on changes\n */\nclass PrivatePreferencesStore {\n    constructor(persistence, persistenceKey, initialData = new Map()) {\n        _PrivatePreferencesStore_instances.add(this);\n        _PrivatePreferencesStore_persistence.set(this, void 0);\n        _PrivatePreferencesStore_persistenceKey.set(this, void 0);\n        _PrivatePreferencesStore_mutex.set(this, void 0);\n        _PrivatePreferencesStore_revision.set(this, void 0);\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_persistenceKey, persistenceKey, \"f\");\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_persistence, persistence, \"f\");\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_revision, 0, \"f\");\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_mutex, new async_mutex__WEBPACK_IMPORTED_MODULE_4__.Mutex(), \"f\");\n        this.actionsMap = initialData;\n    }\n    get revisionKey() {\n        return __classPrivateFieldGet(this, _PrivatePreferencesStore_persistenceKey, \"f\") + \"/revision\";\n    }\n    static async create(persistence) {\n        const store = new PrivatePreferencesStore(persistence, PRIVATE_PREFERENCES_ACTIONS_STORAGE_KEY);\n        await store.refresh();\n        return store;\n    }\n    async refresh() {\n        const currentRevision = await this.getRevision();\n        if (currentRevision > __classPrivateFieldGet(this, _PrivatePreferencesStore_revision, \"f\")) {\n            this.actionsMap = await this.loadFromPersistence();\n        }\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_revision, currentRevision, \"f\");\n    }\n    async getRevision() {\n        const data = await __classPrivateFieldGet(this, _PrivatePreferencesStore_persistence, \"f\").getItem(this.revisionKey);\n        if (!data) {\n            return 0;\n        }\n        return uint8ArrayToNumber(data);\n    }\n    async setRevision(number) {\n        await __classPrivateFieldGet(this, _PrivatePreferencesStore_persistence, \"f\").setItem(this.revisionKey, numberToUint8Array(number));\n    }\n    async loadFromPersistence() {\n        const rawData = await __classPrivateFieldGet(this, _PrivatePreferencesStore_persistence, \"f\").getItem(__classPrivateFieldGet(this, _PrivatePreferencesStore_persistenceKey, \"f\"));\n        if (!rawData) {\n            return new Map();\n        }\n        const data = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.PrivatePreferencesActionMap.decode(rawData);\n        const actionsMap = new Map();\n        const entries = Object.entries(data.actions);\n        for (let i = 0; i < entries.length; i++) {\n            actionsMap.set(entries[i][0], entries[i][1]);\n        }\n        return actionsMap;\n    }\n    async store() {\n        var _a;\n        await __classPrivateFieldGet(this, _PrivatePreferencesStore_persistence, \"f\").setItem(__classPrivateFieldGet(this, _PrivatePreferencesStore_persistenceKey, \"f\"), __classPrivateFieldGet(this, _PrivatePreferencesStore_instances, \"m\", _PrivatePreferencesStore_toBytes).call(this));\n        __classPrivateFieldSet(this, _PrivatePreferencesStore_revision, (_a = __classPrivateFieldGet(this, _PrivatePreferencesStore_revision, \"f\"), _a++, _a), \"f\");\n        await this.setRevision(__classPrivateFieldGet(this, _PrivatePreferencesStore_revision, \"f\"));\n    }\n    async add(actionsMap) {\n        await __classPrivateFieldGet(this, _PrivatePreferencesStore_mutex, \"f\").runExclusive(async () => {\n            await this.refresh();\n            let isDirty = false;\n            const keys = Array.from(actionsMap.keys());\n            for (let i = 0; i < keys.length; i++) {\n                // ignore duplicate actions\n                if (!this.actionsMap.has(keys[i])) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.actionsMap.set(keys[i], actionsMap.get(keys[i]));\n                    // indicate new value added\n                    isDirty = true;\n                }\n            }\n            // only write to persistence if new values were added\n            if (isDirty) {\n                await this.store();\n            }\n        });\n    }\n    get actions() {\n        // sort actions by their keys (timestamps) in ascending order\n        const sortedActions = new Map([...this.actionsMap.entries()].sort((a, b) => \n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        fromNanoString(a[0]).getTime() - fromNanoString(b[0]).getTime()));\n        return sortedActions;\n    }\n    lookup(key) {\n        return this.actionsMap.get(key);\n    }\n}\n_PrivatePreferencesStore_persistence = new WeakMap(), _PrivatePreferencesStore_persistenceKey = new WeakMap(), _PrivatePreferencesStore_mutex = new WeakMap(), _PrivatePreferencesStore_revision = new WeakMap(), _PrivatePreferencesStore_instances = new WeakSet(), _PrivatePreferencesStore_toBytes = function _PrivatePreferencesStore_toBytes() {\n    return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.PrivatePreferencesActionMap.encode({\n        actions: Object.fromEntries(this.actionsMap),\n    }).finish();\n};\n\nconst convertError = (e, \n// Default error code to apply to errors that don't have one\nerrorCode) => {\n    if (e instanceof KeystoreError) {\n        return e;\n    }\n    return new KeystoreError(errorCode, e.message);\n};\nconst wrapResult = (result) => ({ result });\n// Map an array of items to an array of results or errors\n// Transform any errors thrown into `KeystoreError`s\nconst mapAndConvertErrors = (input, mapper, \n// Default error code to apply to errors that don't have one\nerrorCode) => {\n    return Promise.all(input.map(async (item) => {\n        try {\n            // Be sure to await mapper result to catch errors\n            return wrapResult(await mapper(item));\n        }\n        catch (e) {\n            return { error: convertError(e, errorCode) };\n        }\n    }));\n};\n// Wrap the bundle in our class if not already wrapped\nconst toPublicKeyBundle = (bundle) => {\n    if (bundle instanceof PublicKeyBundle) {\n        return bundle;\n    }\n    return new PublicKeyBundle(bundle);\n};\n// Wrap the bundle in our class if not already wrapped\nconst toSignedPublicKeyBundle = (bundle) => {\n    if (bundle instanceof SignedPublicKeyBundle) {\n        return bundle;\n    }\n    return new SignedPublicKeyBundle(bundle);\n};\n// Takes object and returns true if none of the `objectFields` are null or undefined and none of the `arrayFields` are empty\nconst validateObject = (obj, objectFields, arrayFields) => {\n    for (const field of objectFields) {\n        if (!obj[field]) {\n            throw new KeystoreError(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);\n        }\n    }\n    for (const field of arrayFields) {\n        const val = obj[field];\n        // @ts-expect-error does not know it's an array\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!val || !val?.length) {\n            throw new KeystoreError(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(field)}`);\n        }\n    }\n    return true;\n};\nconst getKeyMaterial = (invite) => {\n    if (!invite?.aes256GcmHkdfSha256?.keyMaterial) {\n        throw new KeystoreError(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, \"Missing key material\");\n    }\n    return invite.aes256GcmHkdfSha256.keyMaterial;\n};\nconst topicDataToV2ConversationReference = ({ invitation, createdNs, peerAddress, }) => ({\n    context: invitation.context,\n    topic: invitation.topic,\n    peerAddress,\n    createdNs,\n    consentProofPayload: invitation.consentProof,\n});\nconst isCompleteTopicData = (obj) => !!obj.invitation;\nconst topicDataToMap = (topicMap) => {\n    const out = new Map();\n    for (const [k, v] of Object.entries(topicMap.topics)) {\n        out.set(k, v);\n    }\n    return out;\n};\nconst buildPersistenceKey = (env, walletAddress) => `xmtp/${env}/${walletAddress}/`;\n\nconst INVITE_STORAGE_KEY = \"invitations/v1\";\nconst V1_STORAGE_KEY = \"conversation-v1/v1\";\n/**\n * V2Store holds a simple map of topic -> TopicData and writes to the persistence layer on changes\n */\nclass V2Store {\n    constructor(persistence, persistenceKey, initialData = new Map()) {\n        this.persistenceKey = persistenceKey;\n        this.persistence = persistence;\n        this.revision = 0;\n        this.mutex = new async_mutex__WEBPACK_IMPORTED_MODULE_4__.Mutex();\n        this.topicMap = initialData;\n    }\n    get revisionKey() {\n        return this.persistenceKey + \"/revision\";\n    }\n    static async create(persistence) {\n        const persistenceKey = INVITE_STORAGE_KEY;\n        const v2Store = new V2Store(persistence, persistenceKey);\n        await v2Store.refresh();\n        return v2Store;\n    }\n    validate(topicData) {\n        return (!!topicData.topic &&\n            topicData.topic.length > 0 &&\n            isCompleteTopicData(topicData));\n    }\n    async refresh() {\n        const currentRevision = await this.getRevision();\n        if (currentRevision > this.revision) {\n            for (const [topic, data] of await this.loadFromPersistence()) {\n                this.topicMap.set(topic, data);\n            }\n        }\n        this.revision = currentRevision;\n    }\n    async getRevision() {\n        const data = await this.persistence.getItem(this.revisionKey);\n        if (!data) {\n            return 0;\n        }\n        return uint8ArrayToNumber(data);\n    }\n    async setRevision(number) {\n        await this.persistence.setItem(this.revisionKey, numberToUint8Array(number));\n    }\n    async loadFromPersistence() {\n        const rawData = await this.persistence.getItem(this.persistenceKey);\n        if (!rawData) {\n            return new Map();\n        }\n        return topicDataToMap(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.TopicMap.decode(rawData));\n    }\n    async store() {\n        await this.persistence.setItem(this.persistenceKey, this.toBytes());\n        this.revision++;\n        await this.setRevision(this.revision);\n    }\n    async add(topicData) {\n        await this.mutex.runExclusive(async () => {\n            await this.refresh();\n            let isDirty = false;\n            for (const row of topicData) {\n                if (!this.validate(row)) {\n                    console.warn(\"Invalid topic data\", row.topic);\n                    continue;\n                }\n                const { topic, ...data } = row;\n                // This will not overwrite any existing values. First invite found in the store for a given topic will always be used\n                // Duplicates do not throw errors\n                if (!this.topicMap.has(topic)) {\n                    this.topicMap.set(topic, data);\n                    isDirty = true;\n                }\n            }\n            // Only write to persistence once, and only if we have added new invites\n            if (isDirty) {\n                await this.store();\n            }\n        });\n    }\n    get topics() {\n        return [...this.topicMap.values()];\n    }\n    lookup(topic) {\n        return this.topicMap.get(topic);\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.TopicMap.encode({\n            topics: Object.fromEntries(this.topicMap),\n        }).finish();\n    }\n}\nclass V1Store extends V2Store {\n    static async create(persistence) {\n        const persistenceKey = V1_STORAGE_KEY;\n        const v1Store = new V1Store(persistence, persistenceKey);\n        await v1Store.refresh();\n        return v1Store;\n    }\n    validate(topicData) {\n        return !!(topicData.topic &&\n            topicData.topic.length &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            topicData.peerAddress?.length > 0);\n    }\n}\n\nconst decryptV1 = async (myKeys, peerKeys, ciphertext, headerBytes, isSender) => {\n    const secret = await myKeys.sharedSecret(peerKeys, myKeys.getCurrentPreKey().publicKey, // assumes that the current preKey is what was used to encrypt\n    !isSender);\n    return decrypt$1(ciphertext, secret, headerBytes);\n};\nconst encryptV1 = async (keys, recipient, message, headerBytes) => {\n    const secret = await keys.sharedSecret(recipient, keys.getCurrentPreKey().publicKey, false);\n    return encrypt$1(message, secret, headerBytes);\n};\nconst decryptV2 = (ciphertext, secret, headerBytes) => decrypt$1(ciphertext, secret, headerBytes);\nconst encryptV2 = (payload, secret, headerBytes) => encrypt$1(payload, secret, headerBytes);\n\nvar _InMemoryKeystore_privatePreferencesTopic;\nconst { ErrorCode } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore;\n// Constant, 32 byte salt\n// DO NOT CHANGE\nconst INVITE_SALT = new TextEncoder().encode(\"__XMTP__INVITATION__SALT__XMTP__\");\nasync function deriveKey(secret, info) {\n    const key = await crypto.subtle.importKey(\"raw\", secret, \"HKDF\", false, [\n        \"deriveKey\",\n    ]);\n    return crypto.subtle.deriveKey({ name: \"HKDF\", hash: \"SHA-256\", salt: INVITE_SALT, info }, key, { name: \"AES-GCM\", length: 256 }, true, [\"encrypt\", \"decrypt\"]);\n}\nclass InMemoryKeystore {\n    constructor(keys, v1Store, v2Store, privatePreferencesStore, persistence) {\n        _InMemoryKeystore_privatePreferencesTopic.set(this, void 0);\n        this.v1Keys = keys;\n        this.v2Keys = PrivateKeyBundleV2.fromLegacyBundle(keys);\n        this.v1Store = v1Store;\n        this.v2Store = v2Store;\n        this.privatePreferencesStore = privatePreferencesStore;\n        this.authenticator = new LocalAuthenticator(keys.identityKey);\n        this.jobStatePersistence = persistence;\n    }\n    static async create(keys, persistence) {\n        return new InMemoryKeystore(keys, await V1Store.create(persistence), await V2Store.create(persistence), await PrivatePreferencesStore.create(persistence), persistence);\n    }\n    get walletAddress() {\n        return this.v1Keys.identityKey.publicKey.walletSignatureAddress();\n    }\n    async decryptV1(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            if (!validateObject(req, [\"payload\", \"peerKeys\"], [\"headerBytes\"])) ;\n            const { payload, peerKeys, headerBytes, isSender } = req;\n            const decrypted = await decryptV1(this.v1Keys, toPublicKeyBundle(peerKeys), payload, headerBytes, isSender);\n            return {\n                decrypted,\n            };\n        }, _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async decryptV2(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            if (!validateObject(req, [\"payload\"], [\"headerBytes\"])) ;\n            const { payload, headerBytes, contentTopic } = req;\n            const topicData = this.v2Store.lookup(contentTopic);\n            if (!topicData) {\n                // This is the wrong error type. Will add to the proto repo later\n                throw new KeystoreError(_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, \"no topic key\");\n            }\n            const decrypted = await decryptV2(payload, getKeyMaterial(topicData.invitation), headerBytes);\n            return { decrypted };\n        }, ErrorCode.ERROR_CODE_UNSPECIFIED);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async encryptV1(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            if (!validateObject(req, [\"payload\", \"recipient\"], [\"headerBytes\"])) ;\n            const { recipient, payload, headerBytes } = req;\n            return {\n                encrypted: await encryptV1(this.v1Keys, toPublicKeyBundle(recipient), payload, headerBytes),\n            };\n        }, ErrorCode.ERROR_CODE_UNSPECIFIED);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async createAuthToken({ timestampNs, }) {\n        return this.authenticator.createToken(timestampNs ? nsToDate(timestampNs) : undefined);\n    }\n    async selfEncrypt(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            const { payload } = req;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!payload) {\n                throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, \"Missing field payload\");\n            }\n            return {\n                encrypted: await userPreferencesEncrypt(this.v1Keys.identityKey, payload),\n            };\n        }, ErrorCode.ERROR_CODE_INVALID_INPUT);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SelfEncryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async selfDecrypt(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            const { payload } = req;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!payload) {\n                throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, \"Missing field payload\");\n            }\n            return {\n                decrypted: await userPreferencesDecrypt(this.v1Keys.identityKey, payload),\n            };\n        }, ErrorCode.ERROR_CODE_INVALID_INPUT);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async getPrivatePreferencesTopicIdentifier() {\n        const identifier = await generateUserPreferencesTopic(this.v1Keys.identityKey);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({\n            identifier,\n        });\n    }\n    async encryptV2(req) {\n        const responses = await mapAndConvertErrors(req.requests, async (req) => {\n            if (!validateObject(req, [\"payload\"], [\"headerBytes\"])) ;\n            const { payload, headerBytes, contentTopic } = req;\n            const topicData = this.v2Store.lookup(contentTopic);\n            if (!topicData) {\n                throw new KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, \"no topic key\");\n            }\n            const keyMaterial = getKeyMaterial(topicData.invitation);\n            const ciphertext = await encryptV2(payload, keyMaterial, headerBytes);\n            const thirtyDayPeriodsSinceEpoch = Math.floor(Date.now() / 1000 / 60 / 60 / 24 / 30);\n            const info = `${thirtyDayPeriodsSinceEpoch}-${await this.getAccountAddress()}`;\n            const hmac = await generateHmacSignature(keyMaterial, new TextEncoder().encode(info), headerBytes);\n            return {\n                encrypted: ciphertext,\n                senderHmac: hmac,\n            };\n        }, ErrorCode.ERROR_CODE_INVALID_INPUT);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptResponse.fromPartial({\n            responses,\n        });\n    }\n    async saveInvites(req) {\n        const toAdd = [];\n        const responses = await mapAndConvertErrors(req.requests, async ({ payload, timestampNs }) => {\n            const sealed = SealedInvitation.fromBytes(payload);\n            if (sealed.v1) {\n                const headerTime = sealed.v1.header.createdNs;\n                if (!headerTime.equals(timestampNs)) {\n                    throw new Error(\"envelope and header timestamp mismatch\");\n                }\n                const isSender = sealed.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle());\n                const invitation = await sealed.v1.getInvitation(this.v2Keys);\n                const topicData = {\n                    invitation,\n                    createdNs: sealed.v1.header.createdNs,\n                    peerAddress: isSender\n                        ? await sealed.v1.header.recipient.walletSignatureAddress()\n                        : await sealed.v1.header.sender.walletSignatureAddress(),\n                };\n                toAdd.push({ ...topicData, topic: invitation.topic });\n                return {\n                    conversation: topicDataToV2ConversationReference(topicData),\n                };\n            }\n        }, ErrorCode.ERROR_CODE_INVALID_INPUT);\n        await this.v2Store.add(toAdd);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SaveInvitesResponse.fromPartial({\n            responses,\n        });\n    }\n    async createInvite(req) {\n        try {\n            if (!validateObject(req, [\"recipient\"], [])) ;\n            const created = nsToDate(req.createdNs);\n            const recipient = toSignedPublicKeyBundle(req.recipient);\n            const myAddress = await this.getAccountAddress();\n            const theirAddress = await recipient.walletSignatureAddress();\n            const secret = await this.v2Keys.sharedSecret(recipient, this.v2Keys.getCurrentPreKey().publicKey, myAddress < theirAddress);\n            const sortedAddresses = [myAddress, theirAddress].sort();\n            const msgString = \n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            (req.context?.conversationId || \"\") + sortedAddresses.join();\n            const msgBytes = new TextEncoder().encode(msgString);\n            const topic = bytesToHex(await hmacSha256Sign(Buffer.from(secret), Buffer.from(msgBytes)));\n            const infoString = [\n                \"0\", // sequence number\n                ...sortedAddresses,\n            ].join(\"|\");\n            const info = new TextEncoder().encode(infoString);\n            const derivedKey = await deriveKey(secret, info);\n            const keyMaterial = new Uint8Array(await crypto.subtle.exportKey(\"raw\", derivedKey));\n            const invitation = new InvitationV1({\n                topic: buildDirectMessageTopicV2(topic),\n                aes256GcmHkdfSha256: { keyMaterial },\n                context: req.context,\n                consentProof: req.consentProof,\n            });\n            const sealed = await SealedInvitation.createV1({\n                sender: this.v2Keys,\n                recipient,\n                created,\n                invitation,\n            });\n            const topicData = {\n                invitation,\n                topic: invitation.topic,\n                createdNs: req.createdNs,\n                peerAddress: await recipient.walletSignatureAddress(),\n            };\n            await this.v2Store.add([topicData]);\n            return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.CreateInviteResponse.fromPartial({\n                conversation: topicDataToV2ConversationReference(topicData),\n                payload: sealed.toBytes(),\n            });\n        }\n        catch (e) {\n            throw convertError(e, ErrorCode.ERROR_CODE_INVALID_INPUT);\n        }\n    }\n    async signDigest(req) {\n        if (!validateObject(req, [\"digest\"], [])) ;\n        const { digest, identityKey, prekeyIndex } = req;\n        let key;\n        if (identityKey) {\n            key = this.v1Keys.identityKey;\n        }\n        else if (typeof prekeyIndex !== \"undefined\" &&\n            Number.isInteger(prekeyIndex)) {\n            key = this.v1Keys.preKeys[prekeyIndex];\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!key) {\n                throw new KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, \"no prekey found\");\n            }\n        }\n        else {\n            throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, \"must specifify identityKey or prekeyIndex\");\n        }\n        return key.sign(digest);\n    }\n    async saveV1Conversations({ conversations, }) {\n        await this.v1Store.add(conversations.map((convo) => ({\n            topic: buildDirectMessageTopic(convo.peerAddress, this.walletAddress),\n            peerAddress: convo.peerAddress,\n            createdNs: convo.createdNs,\n            invitation: undefined,\n        })));\n        return {};\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getV1Conversations() {\n        const convos = this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this));\n        return { conversations: convos };\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getV2Conversations() {\n        const convos = this.v2Store.topics.map((invite) => topicDataToV2ConversationReference(invite));\n        convos.sort((a, b) => a.createdNs.div(1_000_000).sub(b.createdNs.div(1_000_000)).toNumber());\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetConversationsResponse.fromPartial({\n            conversations: convos,\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getPublicKeyBundle() {\n        return this.v1Keys.getPublicKeyBundle();\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async getPrivateKeyBundle() {\n        return this.v1Keys;\n    }\n    async getAccountAddress() {\n        if (!this.accountAddress) {\n            this.accountAddress = await this.v2Keys\n                .getPublicKeyBundle()\n                .walletSignatureAddress();\n        }\n        return this.accountAddress;\n    }\n    async getRefreshJob({ jobType, }) {\n        if (jobType === _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.JobType.JOB_TYPE_UNSPECIFIED) {\n            throw new KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, \"invalid job type\");\n        }\n        const lastRunTime = await this.getLastRunTime(jobType);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetRefreshJobResponse.fromPartial({\n            lastRunNs: lastRunTime || long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromNumber(0),\n        });\n    }\n    async setRefreshJob({ jobType, lastRunNs, }) {\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        const key = await this.buildJobStorageKey(jobType);\n        await this.jobStatePersistence.setItem(key, Uint8Array.from(lastRunNs.toBytes()));\n        return {};\n    }\n    topicDataToV1ConversationReference(data) {\n        return {\n            peerAddress: data.peerAddress,\n            createdNs: data.createdNs,\n            topic: buildDirectMessageTopic(data.peerAddress, this.walletAddress),\n            context: undefined,\n            consentProofPayload: undefined,\n        };\n    }\n    buildJobStorageKey(jobType) {\n        return `refreshJob/${jobType.toString()}`;\n    }\n    async getLastRunTime(jobType) {\n        const bytes = await this.jobStatePersistence.getItem(this.buildJobStorageKey(jobType));\n        if (!bytes || !bytes.length) {\n            return;\n        }\n        return long__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBytes([...bytes]);\n    }\n    // This method is not defined as part of the standard Keystore API, but is available\n    // on the InMemoryKeystore to support legacy use-cases.\n    lookupTopic(topic) {\n        return this.v2Store.lookup(topic);\n    }\n    async getV2ConversationHmacKeys(req) {\n        const thirtyDayPeriodsSinceEpoch = Math.floor(Date.now() / 1000 / 60 / 60 / 24 / 30);\n        const hmacKeys = {};\n        let topics = this.v2Store.topics;\n        // if specific topics are requested, only include those topics\n        if (req?.topics) {\n            topics = topics.filter((topicData) => topicData.invitation !== undefined &&\n                req.topics.includes(topicData.invitation.topic));\n        }\n        await Promise.all(topics.map(async (topicData) => {\n            if (topicData.invitation?.topic) {\n                const keyMaterial = getKeyMaterial(topicData.invitation);\n                const values = await Promise.all([\n                    thirtyDayPeriodsSinceEpoch - 1,\n                    thirtyDayPeriodsSinceEpoch,\n                    thirtyDayPeriodsSinceEpoch + 1,\n                ].map(async (value) => {\n                    const info = `${value}-${await this.getAccountAddress()}`;\n                    const hmacKey = await hkdfHmacKey(keyMaterial, new TextEncoder().encode(info));\n                    return {\n                        thirtyDayPeriodsSinceEpoch: value,\n                        // convert CryptoKey to Uint8Array to match the proto\n                        hmacKey: await exportHmacKey(hmacKey),\n                    };\n                }));\n                hmacKeys[topicData.invitation.topic] = {\n                    values,\n                };\n            }\n        }));\n        return { hmacKeys };\n    }\n    async getPrivatePreferencesTopic() {\n        if (!__classPrivateFieldGet(this, _InMemoryKeystore_privatePreferencesTopic, \"f\")) {\n            const { identifier } = await this.getPrivatePreferencesTopicIdentifier();\n            __classPrivateFieldSet(this, _InMemoryKeystore_privatePreferencesTopic, buildUserPrivatePreferencesTopic(identifier), \"f\");\n        }\n        return __classPrivateFieldGet(this, _InMemoryKeystore_privatePreferencesTopic, \"f\");\n    }\n    async createPrivatePreference(action) {\n        // encrypt action payload\n        // there should only be one response\n        const { responses } = await this.selfEncrypt({\n            requests: [\n                {\n                    payload: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privatePreferences.PrivatePreferencesAction.encode(action).finish(),\n                },\n            ],\n        });\n        // encrypted message\n        const messages = responses.reduce((result, response) => {\n            return response.result?.encrypted\n                ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                    result.concat(response.result?.encrypted)\n                : result;\n            // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n        }, []);\n        const contentTopic = await this.getPrivatePreferencesTopic();\n        const timestamp = new Date();\n        // return envelopes to publish\n        return messages.map((message) => ({\n            contentTopic,\n            message,\n            timestamp,\n        }));\n    }\n    getPrivatePreferences() {\n        return this.privatePreferencesStore.actions;\n    }\n    savePrivatePreferences(data) {\n        return this.privatePreferencesStore.add(data);\n    }\n}\n_InMemoryKeystore_privatePreferencesTopic = new WeakMap();\n\nclass TopicPersistence {\n    constructor(apiClient) {\n        this.apiClient = apiClient;\n    }\n    // Returns the first record in a topic if it is present.\n    async getItem(key) {\n        for await (const env of this.apiClient.queryIterator({ contentTopic: this.buildTopic(key) }, {\n            pageSize: 1,\n            direction: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.messageApi.SortDirection.SORT_DIRECTION_DESCENDING,\n        })) {\n            if (!env.message)\n                continue;\n            try {\n                return Uint8Array.from(env.message);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n        return null;\n    }\n    async setItem(key, value) {\n        const keys = Uint8Array.from(value);\n        await this.apiClient.publish([\n            {\n                contentTopic: this.buildTopic(key),\n                message: keys,\n            },\n        ]);\n    }\n    setAuthenticator(authenticator) {\n        this.apiClient.setAuthenticator(authenticator);\n    }\n    buildTopic(key) {\n        return buildUserPrivateStoreTopic(key);\n    }\n}\n\nconst IV_LENGTH = 16;\nconst EPHEMERAL_PUBLIC_KEY_LENGTH = 65;\nconst MAC_LENGTH = 32;\nconst AES_BLOCK_SIZE = 16;\nconst assertEciesLengths = (ecies) => {\n    if (ecies.iv.length !== IV_LENGTH) {\n        throw new Error(\"Invalid iv length\");\n    }\n    if (ecies.ephemeralPublicKey.length !== EPHEMERAL_PUBLIC_KEY_LENGTH) {\n        throw new Error(\"Invalid ephemPublicKey length\");\n    }\n    if (ecies.ciphertext.length < 1 ||\n        ecies.ciphertext.length % AES_BLOCK_SIZE !== 0) {\n        throw new Error(\"Invalid ciphertext length\");\n    }\n    if (ecies.mac.length !== MAC_LENGTH) {\n        throw new Error(\"Invalid mac length\");\n    }\n};\nclass SignedEciesCiphertext {\n    constructor({ eciesBytes, signature }) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!eciesBytes || !eciesBytes.length) {\n            throw new Error(\"eciesBytes is empty\");\n        }\n        if (!signature) {\n            throw new Error(\"signature is undefined\");\n        }\n        this.eciesBytes = eciesBytes;\n        this.signature = new Signature(signature);\n        this.ciphertext = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.SignedEciesCiphertext_Ecies.decode(eciesBytes);\n    }\n    toBytes() {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.SignedEciesCiphertext.encode(this).finish();\n    }\n    async verify(pubKey) {\n        return pubKey.verify(this.signature, await sha256(this.eciesBytes));\n    }\n    static fromBytes(data) {\n        const obj = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.SignedEciesCiphertext.decode(data);\n        return new SignedEciesCiphertext(obj);\n    }\n    static async create(ecies, signer) {\n        assertEciesLengths(ecies);\n        const eciesBytes = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.ciphertext.SignedEciesCiphertext_Ecies.encode(ecies).finish();\n        const signature = await signer.sign(await sha256(eciesBytes));\n        return new SignedEciesCiphertext({ eciesBytes, signature });\n    }\n}\n\n/**\n * EncryptedPersistence is a Persistence implementation that uses ECIES to encrypt all values\n * ECIES encryption protects against unauthorized reads, but not unauthorized writes.\n * A third party with access to the underlying store could write malicious data using the public key of the owner\n */\nclass EncryptedPersistence {\n    constructor(persistence, privateKey) {\n        this.persistence = persistence;\n        this.privateKey = privateKey;\n        this.privateKeyBytes = Buffer.from(privateKey.secp256k1.bytes);\n        this.publicKey = getPublic(this.privateKeyBytes);\n    }\n    async getItem(key) {\n        const encrypted = await this.persistence.getItem(key);\n        if (encrypted) {\n            return this.decrypt(encrypted);\n        }\n        return null;\n    }\n    async setItem(key, value) {\n        const encrypted = await this.encrypt(value);\n        await this.persistence.setItem(key, encrypted);\n    }\n    async encrypt(value) {\n        const ecies = await encrypt(this.publicKey, Buffer.from(value));\n        return this.serializeEcies(ecies);\n    }\n    async decrypt(value) {\n        const ecies = await this.deserializeEcies(value);\n        const result = await decrypt(this.privateKeyBytes, ecies);\n        return Uint8Array.from(result);\n    }\n    async serializeEcies(data) {\n        // This will create and sign a `SignedEciesCiphertext` payload based on the provided data\n        const protoVal = await SignedEciesCiphertext.create(data, this.privateKey);\n        return protoVal.toBytes();\n    }\n    async deserializeEcies(data) {\n        const protoVal = SignedEciesCiphertext.fromBytes(data);\n        // Verify the signature upon deserializing\n        if (!(await protoVal.verify(this.privateKey.publicKey))) {\n            throw new Error(\"signature validation failed\");\n        }\n        const ecies = protoVal.ciphertext;\n        return {\n            ciphertext: Buffer.from(ecies.ciphertext),\n            mac: Buffer.from(ecies.mac),\n            iv: Buffer.from(ecies.iv),\n            ephemeralPublicKey: Buffer.from(ecies.ephemeralPublicKey),\n        };\n    }\n}\n\nclass PrefixedPersistence {\n    constructor(prefix, persistence) {\n        this.prefix = prefix;\n        this.persistence = persistence;\n    }\n    getItem(key) {\n        return this.persistence.getItem(this.buildKey(key));\n    }\n    setItem(key, value) {\n        return this.persistence.setItem(this.buildKey(key), value);\n    }\n    buildKey(key) {\n        return this.prefix + key;\n    }\n}\n\nconst buildPersistenceFromOptions = async (opts, keys) => {\n    if (!opts.persistConversations) {\n        return InMemoryPersistence.create();\n    }\n    const address = await keys.identityKey.publicKey.walletSignatureAddress();\n    const prefix = buildPersistenceKey(opts.env, address);\n    const basePersistence = opts.basePersistence;\n    const shouldEncrypt = !opts.disablePersistenceEncryption;\n    return new PrefixedPersistence(prefix, shouldEncrypt\n        ? new EncryptedPersistence(basePersistence, keys.identityKey)\n        : basePersistence);\n};\n\nconst KEY_BUNDLE_NAME = \"key_bundle\";\n/**\n * EncryptedKeyStore wraps Store to enable encryption of private key bundles\n * using a wallet signature.\n */\nclass NetworkKeyManager {\n    constructor(signer, persistence, preEnableIdentityCallback) {\n        this.signer = signer;\n        this.persistence = persistence;\n        this.preEnableIdentityCallback = preEnableIdentityCallback;\n    }\n    async getStorageAddress(name) {\n        // I think we want to namespace the storage address by wallet\n        // This will allow us to support switching between multiple wallets in the same browser\n        let walletAddress = await this.signer.getAddress();\n        walletAddress = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(walletAddress);\n        return `${walletAddress}/${name}`;\n    }\n    // Retrieve a private key bundle for the active wallet address in the signer\n    async loadPrivateKeyBundle() {\n        const storageBuffer = await this.persistence.getItem(await this.getStorageAddress(KEY_BUNDLE_NAME));\n        if (!storageBuffer) {\n            return null;\n        }\n        const [bundle, needsUpdate] = await this.fromEncryptedBytes(this.signer, Uint8Array.from(storageBuffer));\n        // If a versioned bundle is not found, the legacy bundle needs to be resaved to the store in\n        // the new format. Once all bundles have been upgraded, this migration code can be removed.\n        if (needsUpdate) {\n            await this.storePrivateKeyBundle(bundle);\n        }\n        return bundle;\n    }\n    // Store the private key bundle at an address generated based on the active wallet in the signer\n    async storePrivateKeyBundle(bundle) {\n        const keyAddress = await this.getStorageAddress(KEY_BUNDLE_NAME);\n        const encodedBundle = await this.toEncryptedBytes(bundle, this.signer);\n        // We need to setup the Authenticator so that the underlying store can publish messages without error\n        if (typeof this.persistence.setAuthenticator === \"function\") {\n            this.persistence.setAuthenticator(new LocalAuthenticator(bundle.identityKey));\n        }\n        await this.persistence.setItem(keyAddress, encodedBundle);\n    }\n    // encrypts/serializes the bundle for storage\n    async toEncryptedBytes(bundle, wallet) {\n        // serialize the contents\n        const bytes = bundle.encode();\n        const wPreKey = crypto.getRandomValues(new Uint8Array(32));\n        const input = storageSigRequestText(wPreKey);\n        const walletAddr = await wallet.getAddress();\n        if (this.preEnableIdentityCallback) {\n            await this.preEnableIdentityCallback();\n        }\n        const sig = await wallet.signMessage(input);\n        // Check that the signature is correct, was created using the expected\n        // input, and retry if not. This mitigates a bug in interacting with\n        // LedgerLive for iOS, where the previous signature response is\n        // returned in some cases.\n        const valid = (0,viem__WEBPACK_IMPORTED_MODULE_14__.verifyMessage)({\n            address: walletAddr,\n            message: input,\n            signature: sig,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-misused-promises\n        if (!valid) {\n            throw new Error(\"invalid signature\");\n        }\n        const secret = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)(sig);\n        const ciphertext = await encrypt$1(bytes, secret);\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.EncryptedPrivateKeyBundle.encode({\n            v1: {\n                walletPreKey: wPreKey,\n                ciphertext,\n            },\n        }).finish();\n    }\n    // decrypts/deserializes the bundle from storage bytes\n    async fromEncryptedBytes(wallet, bytes) {\n        const [eBundle, needsUpdate] = getEncryptedBundle(bytes);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!eBundle.walletPreKey) {\n            throw new Error(\"missing wallet pre-key\");\n        }\n        if (!eBundle.ciphertext?.aes256GcmHkdfSha256) {\n            throw new Error(\"missing bundle ciphertext\");\n        }\n        if (this.preEnableIdentityCallback) {\n            await this.preEnableIdentityCallback();\n        }\n        const secret = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)((await wallet.signMessage(storageSigRequestText(eBundle.walletPreKey))));\n        // Ledger uses the last byte = v=[0,1,...] but Metamask and other wallets generate with\n        // v+27 as the last byte. We need to support both for interoperability. Doing this\n        // on the decryption side provides an immediate retroactive fix.\n        // Ledger is using the canonical way, whereas Ethereum adds 27 due to some legacy stuff\n        // https://github.com/ethereum/go-ethereum/issues/19751#issuecomment-504900739\n        try {\n            // Try the original version of the signature first\n            const ciphertext = new Ciphertext(eBundle.ciphertext);\n            const decrypted = await decrypt$1(ciphertext, secret);\n            const [bundle, needsUpdate2] = getPrivateBundle(decrypted);\n            return [bundle, needsUpdate || needsUpdate2];\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (e) {\n            // Assert that the secret is length 65 (encoded signature + recovery byte)\n            if (secret.length !== 65) {\n                throw new Error(\"Expected 65 bytes before trying a different recovery byte\");\n            }\n            // Try the other version of recovery byte, either +27 or -27\n            const lastByte = secret[secret.length - 1];\n            let newSecret = secret.slice(0, secret.length - 1);\n            if (lastByte < 27) {\n                // This is a canonical signature, so we need to add 27 to the recovery byte and try again\n                newSecret = new Uint8Array([...newSecret, lastByte + 27]);\n            }\n            else {\n                // This canocalizes v to 0 or 1 (or maybe 2 or 3 but very unlikely)\n                newSecret = new Uint8Array([...newSecret, lastByte - 27]);\n            }\n            const ciphertext = new Ciphertext(eBundle.ciphertext);\n            const decrypted = await decrypt$1(ciphertext, newSecret);\n            const [bundle, needsUpdate2] = getPrivateBundle(decrypted);\n            return [bundle, needsUpdate || needsUpdate2];\n        }\n    }\n}\n// getEncryptedV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts\n// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.\nfunction getEncryptedBundle(bytes) {\n    try {\n        const b = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.EncryptedPrivateKeyBundle.decode(bytes);\n        if (b.v1) {\n            return [b.v1, false];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    }\n    catch (e) {\n        return [_xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.EncryptedPrivateKeyBundleV1.decode(bytes), true];\n    }\n    throw new Error(\"unrecognized encrypted private key bundle version\");\n}\n// getPrivateV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts\n// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.\nfunction getPrivateBundle(bytes) {\n    try {\n        // TODO: add support for V2\n        const b = decodePrivateKeyBundle(bytes);\n        if (b instanceof PrivateKeyBundleV2) {\n            throw new Error(\"V2 bundles not supported yet\");\n        }\n        return [b, false];\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    }\n    catch (e) {\n        // Adds a default fallback for older versions of the proto\n        const b = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKeyBundleV1.decode(bytes);\n        return [new PrivateKeyBundleV1(b), true];\n    }\n}\nfunction storageSigRequestText(preKey) {\n    // Note that an update to this signature request text will require\n    // addition of backward compatibility for existing encrypted bundles\n    // and/or a migration; otherwise clients will no longer be able to\n    // decrypt those bundles.\n    return (\"XMTP : Enable Identity\\n\" +\n        `${bytesToHex(preKey)}\\n` +\n        \"\\n\" +\n        \"For more info: https://xmtp.org/signatures/\");\n}\n\n/**\n * KeyGeneratorKeystoreProvider will create a new XMTP `PrivateKeyBundle` and persist it to the network\n * This provider should always be specified last in the list of `keystoreProviders` on client creation,\n * as it will overwrite any XMTP identities already on the network\n */\nclass KeyGeneratorKeystoreProvider {\n    async newKeystore(opts, apiClient, wallet) {\n        if (!wallet) {\n            throw new KeystoreProviderUnavailableError(\"Wallet required to generate new keys\");\n        }\n        if (opts.preCreateIdentityCallback) {\n            await opts.preCreateIdentityCallback();\n        }\n        const bundle = await PrivateKeyBundleV1.generate(wallet);\n        const manager = new NetworkKeyManager(wallet, new TopicPersistence(apiClient), opts.preEnableIdentityCallback);\n        await manager.storePrivateKeyBundle(bundle);\n        return InMemoryKeystore.create(bundle, await buildPersistenceFromOptions(opts, bundle));\n    }\n}\n\n/**\n * NetworkKeystoreProvider will look on the XMTP network for an `EncryptedPrivateKeyBundle`\n * on the user's private storage topic. If found, will decrypt the bundle using a wallet\n * signature and instantiate a Keystore instance using the decrypted value.\n */\nclass NetworkKeystoreProvider {\n    async newKeystore(opts, apiClient, wallet) {\n        if (!wallet) {\n            throw new KeystoreProviderUnavailableError(\"No wallet provided\");\n        }\n        const loader = new NetworkKeyManager(wallet, new TopicPersistence(apiClient), opts.preEnableIdentityCallback);\n        const keys = await loader.loadPrivateKeyBundle();\n        if (!keys) {\n            throw new KeystoreProviderUnavailableError(\"No keys found\");\n        }\n        return InMemoryKeystore.create(keys, await buildPersistenceFromOptions(opts, keys));\n    }\n}\n\nfunction getEthereum() {\n    return window.ethereum;\n}\n\nfunction semverParse(version) {\n    const [major, minor, ...patch] = version.split(\".\");\n    return {\n        major: Number(major),\n        minor: Number(minor),\n        // Keep patch as a string so that it can support prerelease versions\n        patch: patch.join(\".\"),\n    };\n}\nfunction isSameMajorVersion(a, b) {\n    // If no version is provided, assume it is the same\n    if (!a || !b) {\n        return true;\n    }\n    return semverParse(a).major === semverParse(b).major;\n}\n// Checks if A semver is greater than B semver\nfunction semverGreaterThan(a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    const aSemver = semverParse(a);\n    const bSemver = semverParse(b);\n    if (aSemver.major !== bSemver.major) {\n        return aSemver.major > bSemver.major;\n    }\n    if (aSemver.minor !== bSemver.minor) {\n        return aSemver.minor > bSemver.minor;\n    }\n    if (!aSemver.patch || !bSemver.patch) {\n        return false;\n    }\n    return patchGreaterThan(aSemver.patch, bSemver.patch);\n}\n// Home-brewed attempt at comparing patch versions so we don't have to import semver package.\n// Example full version might be \"2.0.1-alpha.1\", and this will be operating on the \"1-alpha.1\" portion\nfunction patchGreaterThan(a, b) {\n    const [aVersion, aExtra] = a.split(\"-\");\n    const [bVersion, bExtra] = b.split(\"-\");\n    if (Number(aVersion) !== Number(bVersion)) {\n        return Number(aVersion) > Number(bVersion);\n    }\n    if (!aExtra || !bExtra) {\n        return false;\n    }\n    const [aTag, aTagVersion] = aExtra.split(\".\");\n    const [bTag, bTagVersion] = bExtra.split(\".\");\n    if (aTag !== bTag) {\n        return true;\n    }\n    return Number(aTagVersion) > Number(bTagVersion);\n}\n\nconst { GetKeystoreStatusResponse_KeystoreStatus: KeystoreStatus$1, InitKeystoreRequest, InitKeystoreResponse, GetKeystoreStatusRequest, GetKeystoreStatusResponse, } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore;\nasync function snapRPC(method, rpc, req, meta, snapId) {\n    let reqParam = null;\n    if (rpc.req) {\n        const encoder = rpc.req.encode;\n        const reqBytes = encoder(req).finish();\n        reqParam = b64Encode(reqBytes, 0, reqBytes.length);\n    }\n    const responseString = await snapRequest(method, reqParam, meta, snapId);\n    if (Array.isArray(responseString)) {\n        throw new Error(\"Unexpected array response\");\n    }\n    return rpc.res.decode(b64Decode(responseString));\n}\nasync function snapRequest(method, req, meta, snapId) {\n    const params = { meta };\n    if (typeof req === \"string\") {\n        params.req = req;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const response = await getEthereum()?.request({\n        method: \"wallet_invokeSnap\",\n        params: {\n            snapId,\n            request: {\n                method,\n                params,\n            },\n        },\n    });\n    if (!response || typeof response !== \"object\") {\n        throw new Error(\"No response value\");\n    }\n    return response.res;\n}\n// If a browser has multiple providers, but one of them supports MetaMask flask\n// this function will ensure that Flask is being used and return true.\n// Designed to be resistant to provider clobbering by Phantom and CBW\n// Inspired by https://github.com/Montoya/snap-connect-test/blob/main/index.html\nasync function hasMetamaskWithSnaps() {\n    const ethereum = getEthereum();\n    // Naive way of detecting snaps support\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (ethereum?.isMetaMask) {\n        try {\n            await ethereum.request({\n                method: \"wallet_getSnaps\",\n            });\n            return true;\n        }\n        catch {\n            // no-op\n        }\n    }\n    if (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    typeof ethereum?.detected !== \"undefined\" &&\n        Array.isArray(ethereum.detected)) {\n        for (const provider of ethereum.detected) {\n            try {\n                // Detect snaps support\n                await provider.request({\n                    method: \"wallet_getSnaps\",\n                });\n                // enforces MetaMask as provider\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ethereum?.setProvider?.(provider);\n                return true;\n            }\n            catch {\n                // no-op\n            }\n        }\n    }\n    if (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    typeof ethereum?.providers !== \"undefined\" &&\n        Array.isArray(ethereum.providers)) {\n        for (const provider of ethereum.providers) {\n            try {\n                // Detect snaps support\n                await provider.request({\n                    method: \"wallet_getSnaps\",\n                });\n                window.ethereum = provider;\n                return true;\n            }\n            catch {\n                // no-op\n            }\n        }\n    }\n    return false;\n}\nasync function getSnaps() {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return await getEthereum()?.request({\n        method: \"wallet_getSnaps\",\n    });\n}\nasync function getSnap(snapId, version) {\n    try {\n        const snaps = await getSnaps();\n        if (snaps) {\n            return Object.values(snaps).find((snap) => snap &&\n                snap.id === snapId &&\n                (!version || isSameMajorVersion(snap.version, version)));\n        }\n        return undefined;\n    }\n    catch (e) {\n        console.warn(\"Failed to obtain installed snap\", e);\n        return undefined;\n    }\n}\nasync function connectSnap(snapId, \n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nparams = {}) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    await getEthereum()?.request({\n        method: \"wallet_requestSnaps\",\n        params: {\n            [snapId]: params,\n        },\n    });\n}\nconst getWalletStatusCodec = {\n    req: GetKeystoreStatusRequest,\n    res: GetKeystoreStatusResponse,\n};\nasync function getWalletStatus(meta, snapId) {\n    const response = await snapRPC(\"getKeystoreStatus\", getWalletStatusCodec, {\n        walletAddress: meta.walletAddress,\n    }, meta, snapId);\n    if ([\n        KeystoreStatus$1.KEYSTORE_STATUS_UNSPECIFIED,\n        KeystoreStatus$1.UNRECOGNIZED,\n    ].includes(response.status)) {\n        throw new Error(\"No status specified in response\");\n    }\n    return response.status;\n}\nconst initKeystoreCodec = {\n    req: InitKeystoreRequest,\n    res: InitKeystoreResponse,\n};\nasync function initSnap(bundle, env, snapId) {\n    const walletAddress = bundle.identityKey.publicKey.walletSignatureAddress();\n    const response = await snapRPC(\"initKeystore\", initKeystoreCodec, {\n        v1: bundle,\n    }, { walletAddress, env }, snapId);\n    if (response.error) {\n        throw new KeystoreError(response.error.code, response.error.message);\n    }\n}\n\nconst apiDefs = {\n    /**\n     * Decrypt a batch of V1 messages\n     */\n    decryptV1: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptV1Request,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse,\n    },\n    /**\n     * Decrypt a batch of V2 messages\n     */\n    decryptV2: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptV2Request,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse,\n    },\n    /**\n     * Encrypt a batch of V1 messages\n     */\n    encryptV1: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptV1Request,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptResponse,\n    },\n    /**\n     * Encrypt a batch of V2 messages\n     */\n    encryptV2: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptV2Request,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.EncryptResponse,\n    },\n    /**\n     * Take a batch of invite messages and store the `TopicKeys` for later use in\n     * decrypting messages\n     */\n    saveInvites: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SaveInvitesRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SaveInvitesResponse,\n    },\n    /**\n     * Create a sealed/encrypted invite and store the Topic keys in the Keystore\n     * for later use. The returned invite payload must be sent to the network for\n     * the other party to be able to communicate.\n     */\n    createInvite: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.CreateInviteRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.CreateInviteResponse,\n    },\n    /**\n     * Create an XMTP auth token to be used as a header on XMTP API requests\n     */\n    createAuthToken: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.CreateAuthTokenRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.authn.Token,\n    },\n    /**\n     * Sign the provided digest with either the `IdentityKey` or a specified\n     * `PreKey`\n     */\n    signDigest: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SignDigestRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.signature.Signature,\n    },\n    /**\n     * Get the `PublicKeyBundle` associated with the Keystore's private keys\n     */\n    getPublicKeyBundle: {\n        req: null,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKeyBundle,\n    },\n    /**\n     * Export the private keys. May throw an error if the keystore implementation\n     * does not allow this operation\n     */\n    getPrivateKeyBundle: {\n        req: null,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privateKey.PrivateKeyBundleV1,\n    },\n    /**\n     * Save V1 Conversations\n     */\n    saveV1Conversations: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SaveV1ConversationsRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SaveV1ConversationsResponse,\n    },\n    /**\n     * Get a list of V1 conversations\n     */\n    getV1Conversations: {\n        req: null,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetConversationsResponse,\n    },\n    /**\n     * Get a list of V2 conversations\n     */\n    getV2Conversations: {\n        req: null,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetConversationsResponse,\n    },\n    /**\n     * Get a refresh job from the persistence\n     */\n    getRefreshJob: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetRefreshJobRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetRefreshJobResponse,\n    },\n    /**\n     * Sets the time of a refresh job\n     */\n    setRefreshJob: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SetRefeshJobRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SetRefreshJobResponse,\n    },\n    /**\n     * Encrypt a batch of messages to yourself\n     */\n    selfEncrypt: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SelfEncryptRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SelfEncryptResponse,\n    },\n    /**\n     * Decrypt a batch of messages to yourself\n     */\n    selfDecrypt: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.SelfDecryptRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.DecryptResponse,\n    },\n    /**\n     * Get the private preferences topic identifier\n     */\n    getPrivatePreferencesTopicIdentifier: {\n        req: null,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetPrivatePreferencesTopicIdentifierResponse,\n    },\n    /**\n     * Returns the conversation HMAC keys for the current, previous, and next\n     * 30 day periods since the epoch\n     */\n    getV2ConversationHmacKeys: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetConversationHmacKeysRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetConversationHmacKeysResponse,\n    },\n};\nconst snapApiDefs = {\n    getKeystoreStatus: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetKeystoreStatusRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.GetKeystoreStatusResponse,\n    },\n    initKeystore: {\n        req: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.InitKeystoreRequest,\n        res: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore.InitKeystoreResponse,\n    },\n};\n\nfunction SnapKeystore(walletAddress, env, snapId) {\n    const generatedMethods = {};\n    const snapMeta = {\n        walletAddress,\n        env,\n    };\n    for (const [method, rpc] of Object.entries(snapApiDefs)) {\n        // eslint-disable-next-line @typescript-eslint/require-await\n        generatedMethods[method] = async (req) => {\n            if (!rpc.req) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return snapRPC(method, rpc, undefined, snapMeta, snapId);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-argument\n            return snapRPC(method, rpc, req, snapMeta, snapId);\n        };\n    }\n    return {\n        ...generatedMethods,\n        // Don't bother calling the keystore, since we already have the wallet address\n        // eslint-disable-next-line @typescript-eslint/require-await\n        async getAccountAddress() {\n            return walletAddress;\n        },\n    };\n}\n\nconst { GetKeystoreStatusResponse_KeystoreStatus: KeystoreStatus } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.keystore;\nconst SNAP_LOCAL_ORIGIN = \"local:http://localhost:8080\";\n/**\n * The Snap keystore provider will:\n * 1. Check if the user is capable of using Snaps\n * 2. Check if the user has already setup the Snap with the appropriate keys\n * 3. If not, will get keys from the network or create new keys and store them in the Snap\n */\nclass SnapKeystoreProvider {\n    constructor(snapId = SNAP_LOCAL_ORIGIN, snapVersion) {\n        this.snapId = snapId;\n        this.snapVersion = snapVersion;\n    }\n    async newKeystore(opts, apiClient, wallet) {\n        if (!wallet) {\n            throw new KeystoreProviderUnavailableError(\"No wallet provided\");\n        }\n        if (!(await hasMetamaskWithSnaps())) {\n            throw new KeystoreProviderUnavailableError(\"MetaMask with Snaps not detected\");\n        }\n        const walletAddress = await wallet.getAddress();\n        const env = opts.env;\n        const hasSnap = await getSnap(this.snapId, this.snapVersion);\n        if (!hasSnap || semverGreaterThan(this.snapVersion, hasSnap.version)) {\n            await connectSnap(this.snapId, this.snapVersion ? { version: this.snapVersion } : {});\n        }\n        if (!(await checkSnapLoaded(walletAddress, env, this.snapId))) {\n            const bundle = await bundleFromOptions(opts, apiClient, wallet);\n            await initSnap(bundle, env, this.snapId);\n        }\n        return SnapKeystore(walletAddress, env, this.snapId);\n    }\n}\nasync function createBundle(opts, apiClient, wallet) {\n    const tmpProvider = new KeyGeneratorKeystoreProvider();\n    const tmpKeystore = await tmpProvider.newKeystore(opts, apiClient, wallet);\n    return new PrivateKeyBundleV1(await tmpKeystore.getPrivateKeyBundle());\n}\nasync function bundleFromOptions(opts, apiClient, wallet) {\n    if (opts.privateKeyOverride) {\n        const bundle = decodePrivateKeyBundle(opts.privateKeyOverride);\n        if (!(bundle instanceof PrivateKeyBundleV1)) {\n            throw new Error(\"Unsupported private key bundle version\");\n        }\n        return bundle;\n    }\n    if (!wallet) {\n        throw new Error(\"No privateKeyOverride or wallet\");\n    }\n    return getOrCreateBundle(opts, apiClient, wallet);\n}\nasync function getOrCreateBundle(opts, apiClient, wallet) {\n    // I really don't love using other providers inside a provider. Feels like too much indirection\n    // TODO: Refactor keystore providers to better support the weird Snap flow\n    const networkProvider = new NetworkKeystoreProvider();\n    try {\n        const tmpKeystore = await networkProvider.newKeystore(opts, apiClient, wallet);\n        return new PrivateKeyBundleV1(await tmpKeystore.getPrivateKeyBundle());\n    }\n    catch (e) {\n        if (e instanceof KeystoreProviderUnavailableError) {\n            return createBundle(opts, apiClient, wallet);\n        }\n        throw e;\n    }\n}\nasync function checkSnapLoaded(walletAddress, env, snapId) {\n    const status = await getWalletStatus({ walletAddress, env }, snapId);\n    if (status === KeystoreStatus.KEYSTORE_STATUS_INITIALIZED) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * StaticKeystoreProvider will look for a `privateKeyOverride` in the provided options,\n * and bootstrap a Keystore using those options if provided.\n *\n * If no `privateKeyOverride` is supplied will throw a `KeystoreProviderUnavailableError` causing\n * the client to continue iterating through the `KeystoreProviders` list.\n */\nclass StaticKeystoreProvider {\n    async newKeystore(opts) {\n        const { privateKeyOverride } = opts;\n        if (!privateKeyOverride) {\n            throw new KeystoreProviderUnavailableError(\"No private key override provided\");\n        }\n        const bundle = decodePrivateKeyBundle(privateKeyOverride);\n        if (bundle instanceof PrivateKeyBundleV2) {\n            throw new Error(\"V2 private key bundle found. Only V1 supported\");\n        }\n        return InMemoryKeystore.create(bundle, await buildPersistenceFromOptions(opts, bundle));\n    }\n}\n\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nfunction getSigner(wallet) {\n    if (!wallet) {\n        return null;\n    }\n    if (isWalletClient(wallet)) {\n        return convertWalletClientToSigner(wallet);\n    }\n    if (typeof wallet.getAddress !== \"function\") {\n        throw new Error(\"Unknown wallet type\");\n    }\n    return wallet;\n}\nfunction isWalletClient(wallet) {\n    return (\"type\" in wallet &&\n        (wallet.type === \"walletClient\" || wallet.type === \"base\"));\n}\nfunction convertWalletClientToSigner(walletClient) {\n    const { account } = walletClient;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!account || !account.address) {\n        throw new Error(\"WalletClient is not configured\");\n    }\n    return {\n        // eslint-disable-next-line @typescript-eslint/require-await\n        getAddress: async () => account.address,\n        signMessage: async (message) => walletClient.signMessage({\n            message: typeof message === \"string\" ? message : { raw: message },\n            account,\n        }),\n    };\n}\n\n// This import has to come first so that the polyfills are registered before the stream polyfills\n//\n// Compression\n//\nasync function decompress(encoded, maxSize) {\n    if (encoded.compression === undefined) {\n        return;\n    }\n    const sink = { bytes: new Uint8Array(encoded.content.length) };\n    await readStreamFromBytes(encoded.content)\n        .pipeThrough(new DecompressionStream(compressionIdFromCode(encoded.compression)))\n        .pipeTo(writeStreamToBytes(sink, maxSize));\n    encoded.content = sink.bytes;\n}\nasync function compress(encoded) {\n    if (encoded.compression === undefined) {\n        return;\n    }\n    const sink = { bytes: new Uint8Array(encoded.content.length / 10) };\n    await readStreamFromBytes(encoded.content)\n        .pipeThrough(new CompressionStream(compressionIdFromCode(encoded.compression)))\n        .pipeTo(writeStreamToBytes(sink, encoded.content.length + 1000));\n    encoded.content = sink.bytes;\n}\nfunction compressionIdFromCode(code) {\n    if (code === _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.Compression.COMPRESSION_GZIP) {\n        return \"gzip\";\n    }\n    if (code === _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.Compression.COMPRESSION_DEFLATE) {\n        return \"deflate\";\n    }\n    throw new Error(\"unrecognized compression algorithm\");\n}\nfunction readStreamFromBytes(bytes, chunkSize = 1024) {\n    let position = 0;\n    return new ReadableStream({\n        pull(controller) {\n            if (position >= bytes.length) {\n                // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n                return controller.close();\n            }\n            let end = position + chunkSize;\n            end = end <= bytes.length ? end : bytes.length;\n            controller.enqueue(bytes.subarray(position, end));\n            position = end;\n        },\n    });\n}\nfunction writeStreamToBytes(sink, maxSize) {\n    let position = 0;\n    return new WritableStream({\n        write(chunk) {\n            const end = position + chunk.length;\n            if (end > maxSize) {\n                throw new Error(\"maximum output size exceeded\");\n            }\n            while (sink.bytes.length < end) {\n                sink.bytes = growBytes(sink.bytes, maxSize);\n            }\n            sink.bytes.set(chunk, position);\n            position = end;\n        },\n        close() {\n            if (position < sink.bytes.length) {\n                sink.bytes = sink.bytes.subarray(0, position);\n            }\n        },\n    });\n}\nfunction growBytes(bytes, maxSize) {\n    let newSize = bytes.length * 2;\n    if (newSize > maxSize) {\n        newSize = maxSize;\n    }\n    const bigger = new Uint8Array(newSize);\n    bigger.set(bytes);\n    return bigger;\n}\n\n// Decodes contact bundles from the contact topic.\nfunction decodeContactBundle(bytes) {\n    let cb;\n    try {\n        cb = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.contact.ContactBundle.decode(bytes);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    }\n    catch (e) {\n        const pb = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.publicKey.PublicKeyBundle.decode(bytes);\n        cb = { v1: { keyBundle: new PublicKeyBundle(pb) }, v2: undefined };\n    }\n    if (cb.v1?.keyBundle) {\n        return new PublicKeyBundle(cb.v1.keyBundle);\n    }\n    if (cb.v2?.keyBundle) {\n        return new SignedPublicKeyBundle(cb.v2.keyBundle);\n    }\n    throw new Error(\"unknown or invalid contact bundle\");\n}\n// Encodes public key bundle for the contact topic.\nfunction encodeContactBundle(bundle) {\n    if (bundle instanceof PublicKeyBundle) {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.contact.ContactBundle.encode({\n            v1: { keyBundle: bundle },\n            v2: undefined,\n        }).finish();\n    }\n    else {\n        return _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.contact.ContactBundle.encode({\n            v1: undefined,\n            v2: { keyBundle: bundle },\n        }).finish();\n    }\n}\n\nvar _Contacts_instances, _Contacts_consentList, _Contacts_jobRunner, _Contacts_validateConsentSignature;\nclass ConsentListEntry {\n    constructor(value, entryType, permissionType) {\n        this.value = value;\n        this.entryType = entryType;\n        this.permissionType = permissionType;\n    }\n    get key() {\n        return `${this.entryType}-${this.value}`;\n    }\n    static fromAddress(address, permissionType = \"unknown\") {\n        return new ConsentListEntry(address, \"address\", permissionType);\n    }\n    static fromGroupId(groupId, permissionType = \"unknown\") {\n        return new ConsentListEntry(groupId, \"groupId\", permissionType);\n    }\n    static fromInboxId(inboxId, permissionType = \"unknown\") {\n        return new ConsentListEntry(inboxId, \"inboxId\", permissionType);\n    }\n}\nclass ConsentList {\n    constructor(client) {\n        this.entries = new Map();\n        this.client = client;\n    }\n    allow(address) {\n        const entry = ConsentListEntry.fromAddress(address, \"allowed\");\n        this.entries.set(entry.key, \"allowed\");\n        return entry;\n    }\n    deny(address) {\n        const entry = ConsentListEntry.fromAddress(address, \"denied\");\n        this.entries.set(entry.key, \"denied\");\n        return entry;\n    }\n    allowGroup(groupId) {\n        const entry = ConsentListEntry.fromGroupId(groupId, \"allowed\");\n        this.entries.set(entry.key, \"allowed\");\n        return entry;\n    }\n    denyGroup(groupId) {\n        const entry = ConsentListEntry.fromGroupId(groupId, \"denied\");\n        this.entries.set(entry.key, \"denied\");\n        return entry;\n    }\n    allowInboxId(inboxId) {\n        const entry = ConsentListEntry.fromInboxId(inboxId, \"allowed\");\n        this.entries.set(entry.key, \"allowed\");\n        return entry;\n    }\n    denyInboxId(inboxId) {\n        const entry = ConsentListEntry.fromInboxId(inboxId, \"denied\");\n        this.entries.set(entry.key, \"denied\");\n        return entry;\n    }\n    state(address) {\n        const entry = ConsentListEntry.fromAddress(address);\n        return this.entries.get(entry.key) ?? \"unknown\";\n    }\n    groupState(groupId) {\n        const entry = ConsentListEntry.fromGroupId(groupId);\n        return this.entries.get(entry.key) ?? \"unknown\";\n    }\n    inboxIdState(inboxId) {\n        const entry = ConsentListEntry.fromInboxId(inboxId);\n        return this.entries.get(entry.key) ?? \"unknown\";\n    }\n    /**\n     * Decode messages and save them to the keystore\n     */\n    async decodeMessages(messageMap) {\n        const messages = Array.from(messageMap.values());\n        // decrypt messages\n        const { responses } = await this.client.keystore.selfDecrypt({\n            requests: messages.map((message) => ({ payload: message })),\n        });\n        const decryptedMessageEntries = Array.from(messageMap.keys()).map((key, index) => [key, responses[index]]);\n        // decode decrypted messages into actions, convert to map\n        const actionsMap = decryptedMessageEntries.reduce((result, [key, response]) => {\n            if (response.result?.decrypted) {\n                const action = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.privatePreferences.PrivatePreferencesAction.decode(response.result.decrypted);\n                result.set(key, action);\n            }\n            return result;\n        }, new Map());\n        // save actions to keystore\n        await this.client.keystore.savePrivatePreferences(actionsMap);\n        return actionsMap;\n    }\n    /*\n     * Process actions and update internal consent list\n     */\n    processActions(actionsMap) {\n        // actions to process\n        const actions = Array.from(actionsMap.values());\n        // update the consent list\n        actions.forEach((action) => {\n            action.allowAddress?.walletAddresses.forEach((address) => {\n                this.allow(address);\n            });\n            action.denyAddress?.walletAddresses.forEach((address) => {\n                this.deny(address);\n            });\n            action.allowGroup?.groupIds.forEach((groupId) => {\n                this.allowGroup(groupId);\n            });\n            action.denyGroup?.groupIds.forEach((groupId) => {\n                this.denyGroup(groupId);\n            });\n            action.allowInboxId?.inboxIds.forEach((inboxId) => {\n                this.allowInboxId(inboxId);\n            });\n            action.denyInboxId?.inboxIds.forEach((inboxId) => {\n                this.denyInboxId(inboxId);\n            });\n        });\n    }\n    async stream(onConnectionLost) {\n        const contentTopic = await this.client.keystore.getPrivatePreferencesTopic();\n        return Stream.create(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.client, [contentTopic], async (envelope) => {\n            // ignore envelopes without message or timestamp\n            if (!envelope.message || !envelope.timestampNs) {\n                return undefined;\n            }\n            // decode message and save to keystore\n            const actionsMap = await this.decodeMessages(new Map([[envelope.timestampNs, envelope.message]]));\n            // update consent list\n            this.processActions(actionsMap);\n            // return the action\n            return actionsMap.get(envelope.timestampNs);\n        }, undefined, onConnectionLost);\n    }\n    reset() {\n        // clear existing entries\n        this.entries.clear();\n    }\n    async load(startTime) {\n        const contentTopic = await this.client.keystore.getPrivatePreferencesTopic();\n        // get private preferences from the network\n        const messageEntries = (await this.client.listEnvelopes(contentTopic, \n        // eslint-disable-next-line @typescript-eslint/require-await\n        async ({ message, timestampNs }) => [timestampNs, message], {\n            // special exception for private preferences topic\n            pageSize: 500,\n            // ensure messages are in ascending order\n            direction: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.messageApi.SortDirection.SORT_DIRECTION_ASCENDING,\n            startTime,\n        }))\n            // filter out messages with no timestamp\n            .filter(([timestampNs]) => Boolean(timestampNs));\n        // decode messages and save them to keystore\n        await this.decodeMessages(new Map(messageEntries));\n        // get all actions from keystore\n        const actionsMap = this.client.keystore.getPrivatePreferences();\n        // reset consent list\n        this.reset();\n        // process actions and update consent list\n        this.processActions(actionsMap);\n        return this.entries;\n    }\n    async publish(entries) {\n        // this reduce is purposefully verbose for type safety\n        const action = entries.reduce((result, entry) => {\n            let actionKey;\n            let valueKey;\n            let values;\n            // ignore unknown permission types\n            if (entry.permissionType === \"unknown\") {\n                return result;\n            }\n            switch (entry.entryType) {\n                case \"address\": {\n                    actionKey =\n                        entry.permissionType === \"allowed\" ? \"allowAddress\" : \"denyAddress\";\n                    valueKey = \"walletAddresses\";\n                    values = result[actionKey]?.[valueKey] ?? [];\n                    break;\n                }\n                case \"groupId\": {\n                    actionKey =\n                        entry.permissionType === \"allowed\" ? \"allowGroup\" : \"denyGroup\";\n                    valueKey = \"groupIds\";\n                    values = result[actionKey]?.[valueKey] ?? [];\n                    break;\n                }\n                case \"inboxId\": {\n                    actionKey =\n                        entry.permissionType === \"allowed\" ? \"allowInboxId\" : \"denyInboxId\";\n                    valueKey = \"inboxIds\";\n                    values = result[actionKey]?.[valueKey] ?? [];\n                    break;\n                }\n                default:\n                    return result;\n            }\n            return {\n                ...result,\n                [actionKey]: {\n                    [valueKey]: [...values, entry.value],\n                },\n            };\n            // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n        }, {});\n        // get envelopes to publish (there should only be one)\n        const envelopes = await this.client.keystore.createPrivatePreference(action);\n        // publish private preferences update\n        await this.client.publishEnvelopes(envelopes);\n        // persist newly published private preference to keystore\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.client.keystore.savePrivatePreferences(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        new Map([[envelopes[0].timestamp.getTime().toString(), action]]));\n        // update local entries after publishing\n        entries.forEach((entry) => {\n            this.entries.set(entry.key, entry.permissionType);\n        });\n    }\n}\nclass Contacts {\n    constructor(client) {\n        _Contacts_instances.add(this);\n        _Contacts_consentList.set(this, void 0);\n        _Contacts_jobRunner.set(this, void 0);\n        this.addresses = new Set();\n        this.client = client;\n        __classPrivateFieldSet(this, _Contacts_consentList, new ConsentList(client), \"f\");\n        __classPrivateFieldSet(this, _Contacts_jobRunner, new JobRunner(\"user-preferences\", client.keystore), \"f\");\n    }\n    async loadConsentList(startTime) {\n        return __classPrivateFieldGet(this, _Contacts_jobRunner, \"f\").run(async (lastRun) => {\n            // allow for override of startTime\n            const entries = await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").load(startTime ?? lastRun);\n            try {\n                const conversations = await this.client.conversations.list();\n                const validConsentProofAddresses = conversations.reduce((result, conversation) => {\n                    if (conversation.consentProof &&\n                        this.consentState(conversation.peerAddress) === \"unknown\" &&\n                        __classPrivateFieldGet(this, _Contacts_instances, \"m\", _Contacts_validateConsentSignature).call(this, conversation.consentProof, conversation.peerAddress)) {\n                        return result.concat(conversation.peerAddress);\n                    }\n                    else {\n                        return result;\n                    }\n                }, \n                // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n                []);\n                if (validConsentProofAddresses.length) {\n                    await this.client.contacts.allow(validConsentProofAddresses);\n                }\n            }\n            catch (err) {\n                console.log(err);\n            }\n            return entries;\n        });\n    }\n    async refreshConsentList() {\n        // clear existing consent list\n        __classPrivateFieldGet(this, _Contacts_consentList, \"f\").reset();\n        // reset last run time to the epoch\n        await __classPrivateFieldGet(this, _Contacts_jobRunner, \"f\").resetLastRunTime();\n        // reload the consent list\n        return this.loadConsentList();\n    }\n    async streamConsentList(onConnectionLost) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").stream(onConnectionLost);\n    }\n    setConsentListEntries(entries) {\n        if (!entries.length) {\n            return;\n        }\n        __classPrivateFieldGet(this, _Contacts_consentList, \"f\").reset();\n        entries.forEach((entry) => {\n            if (entry.permissionType === \"allowed\") {\n                __classPrivateFieldGet(this, _Contacts_consentList, \"f\").allow(entry.value);\n            }\n            if (entry.permissionType === \"denied\") {\n                __classPrivateFieldGet(this, _Contacts_consentList, \"f\").deny(entry.value);\n            }\n        });\n    }\n    isAllowed(address) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").state(address) === \"allowed\";\n    }\n    isDenied(address) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").state(address) === \"denied\";\n    }\n    isGroupAllowed(groupId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").groupState(groupId) === \"allowed\";\n    }\n    isGroupDenied(groupId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").groupState(groupId) === \"denied\";\n    }\n    isInboxAllowed(inboxId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").inboxIdState(inboxId) === \"allowed\";\n    }\n    isInboxDenied(inboxId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").inboxIdState(inboxId) === \"denied\";\n    }\n    consentState(address) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").state(address);\n    }\n    groupConsentState(groupId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").groupState(groupId);\n    }\n    inboxConsentState(inboxId) {\n        return __classPrivateFieldGet(this, _Contacts_consentList, \"f\").inboxIdState(inboxId);\n    }\n    async allow(addresses) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(addresses.map((address) => ConsentListEntry.fromAddress(address, \"allowed\")));\n    }\n    async deny(addresses) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(addresses.map((address) => ConsentListEntry.fromAddress(address, \"denied\")));\n    }\n    async allowGroups(groupIds) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(groupIds.map((groupId) => ConsentListEntry.fromGroupId(groupId, \"allowed\")));\n    }\n    async denyGroups(groupIds) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(groupIds.map((groupId) => ConsentListEntry.fromGroupId(groupId, \"denied\")));\n    }\n    async allowInboxes(inboxIds) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(inboxIds.map((inboxId) => ConsentListEntry.fromInboxId(inboxId, \"allowed\")));\n    }\n    async denyInboxes(inboxIds) {\n        await __classPrivateFieldGet(this, _Contacts_consentList, \"f\").publish(inboxIds.map((inboxId) => ConsentListEntry.fromInboxId(inboxId, \"denied\")));\n    }\n}\n_Contacts_consentList = new WeakMap(), _Contacts_jobRunner = new WeakMap(), _Contacts_instances = new WeakSet(), _Contacts_validateConsentSignature = function _Contacts_validateConsentSignature({ signature, timestamp }, peerAddress) {\n    const timestampMs = Number(timestamp);\n    if (!signature || !timestampMs) {\n        return false;\n    }\n    // timestamp should be in the past\n    if (timestampMs > Date.now()) {\n        return false;\n    }\n    // timestamp should be within the last 30 days\n    if (timestampMs < Date.now() - 1000 * 60 * 60 * 24 * 30) {\n        return false;\n    }\n    const signatureData = splitSignature(signature);\n    const message = (0,_xmtp_consent_proof_signature__WEBPACK_IMPORTED_MODULE_15__.createConsentMessage)(peerAddress, timestampMs);\n    const digest = (0,viem__WEBPACK_IMPORTED_MODULE_11__.hexToBytes)((0,viem__WEBPACK_IMPORTED_MODULE_12__.hashMessage)(message));\n    // Recover public key\n    const publicKey = ecdsaSignerKey(digest, signatureData);\n    return publicKey?.getEthereumAddress() === this.client.address;\n};\n\n/**\n * Where message backups should be stored\n */\nvar BackupType;\n(function (BackupType) {\n    BackupType[BackupType[\"none\"] = 0] = \"none\";\n    BackupType[BackupType[\"xmtpTopicStore\"] = 1] = \"xmtpTopicStore\";\n})(BackupType || (BackupType = {}));\n\nconst BACKUP_TYPE$1 = BackupType.none;\nclass NoBackupClient {\n    static createConfiguration() {\n        return {\n            type: BACKUP_TYPE$1,\n            version: 0,\n        };\n    }\n    constructor(configuration) {\n        this.configuration = configuration;\n    }\n    get backupType() {\n        return BACKUP_TYPE$1;\n    }\n}\n\nconst BACKUP_TYPE = BackupType.xmtpTopicStore;\nclass TopicStoreBackupClient {\n    static createConfiguration(walletAddress) {\n        // TODO: randomly generate topic and encryption key\n        return {\n            type: BACKUP_TYPE,\n            version: 0,\n            topic: \"history-v0:\" + walletAddress,\n        };\n    }\n    constructor(configuration) {\n        this.configuration = configuration;\n    }\n    get backupType() {\n        return BACKUP_TYPE;\n    }\n}\n\n/**\n * Creates a backup client of the correct provider type (e.g. xmtp backup, no backup, etc).\n * Uses an existing user preference from the backend if it exists, else prompts for a new\n * one using the `providerSelector`\n * @param walletAddress The public address of the user's wallet\n * @param selectBackupProvider A callback for determining the provider to use, in the event there is no\n * existing user preference. The app can define the policy to use here (e.g. prompt the user,\n * or default to a certain provider type).\n * @returns {Promise<BackupClient>} A backup client of the correct type\n */\nasync function createBackupClient(walletAddress, selectBackupProvider) {\n    const configuration = await fetchOrCreateConfiguration(walletAddress, selectBackupProvider);\n    switch (configuration.type) {\n        case BackupType.none:\n            return new NoBackupClient(configuration);\n        case BackupType.xmtpTopicStore:\n            return new TopicStoreBackupClient(configuration);\n    }\n}\nasync function fetchOrCreateConfiguration(walletAddress, selectBackupProvider) {\n    // TODO: return existing configuration from the backend if it exists\n    let backupConfiguration;\n    const provider = await selectBackupProvider();\n    switch (provider.type) {\n        case BackupType.none:\n            backupConfiguration = NoBackupClient.createConfiguration();\n            break;\n        case BackupType.xmtpTopicStore:\n            backupConfiguration =\n                TopicStoreBackupClient.createConfiguration(walletAddress);\n            break;\n    }\n    // TODO: Persist new configuration to backend\n    return backupConfiguration;\n}\n\nconst version = \"1.3.6\";\nconst packageName = \"@xmtp/snap\";\n\nconst { Compression } = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content;\n// eslint-disable @typescript-eslint/explicit-module-boundary-types\n// eslint-disable @typescript-eslint/no-explicit-any\n// Default maximum allowed content size\nconst MaxContentSize = 100 * 1024 * 1024; // 100M\n/**\n * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations\n * @param opts additional options to override the default settings\n */\nfunction defaultOptions(opts) {\n    const _defaultOptions = {\n        privateKeyOverride: undefined,\n        env: \"dev\",\n        apiUrl: undefined,\n        codecs: [new _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.TextCodec()],\n        maxContentSize: MaxContentSize,\n        persistConversations: true,\n        skipContactPublishing: false,\n        useSnaps: false,\n        basePersistence: isBrowser()\n            ? BrowserStoragePersistence.create()\n            : InMemoryPersistence.create(),\n        disablePersistenceEncryption: false,\n        keystoreProviders: defaultKeystoreProviders(),\n        apiClientFactory: createHttpApiClientFromOptions,\n    };\n    if (opts?.codecs) {\n        opts.codecs = _defaultOptions.codecs.concat(opts.codecs);\n    }\n    if (opts?.useSnaps) {\n        opts.keystoreProviders = [\n            new SnapKeystoreProvider(`npm:${packageName}`, version),\n            ..._defaultOptions.keystoreProviders,\n        ];\n    }\n    return { ..._defaultOptions, ...opts };\n}\n/**\n * Client class initiates connection to the XMTP network.\n * Should be created with `await Client.create(options)`\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass Client {\n    constructor(publicKeyBundle, apiClient, backupClient, keystore) {\n        this.knownPublicKeyBundles = new Map();\n        // TODO: Remove keys and legacyKeys\n        this.keystore = keystore;\n        this.publicKeyBundle = publicKeyBundle;\n        this.address = publicKeyBundle.walletSignatureAddress();\n        this._conversations = new Conversations(this);\n        this._codecs = new Map();\n        this._maxContentSize = MaxContentSize;\n        this.apiClient = apiClient;\n        this._backupClient = backupClient;\n        this.contacts = new Contacts(this);\n    }\n    /**\n     * @type {Conversations}\n     */\n    get conversations() {\n        return this._conversations;\n    }\n    get backupType() {\n        return this._backupClient.backupType;\n    }\n    get signedPublicKeyBundle() {\n        return SignedPublicKeyBundle.fromLegacyBundle(this.publicKeyBundle);\n    }\n    /**\n     * Create and start a client associated with given wallet.\n     * @param wallet the wallet as a Signer instance\n     * @param opts specify how to to connect to the network\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-arguments\n    static async create(wallet, opts) {\n        const signer = getSigner(wallet);\n        const options = defaultOptions(opts);\n        const apiClient = options.apiClientFactory(options);\n        const keystore = await bootstrapKeystore(options, apiClient, signer);\n        const publicKeyBundle = new PublicKeyBundle(await keystore.getPublicKeyBundle());\n        const address = publicKeyBundle.walletSignatureAddress();\n        apiClient.setAuthenticator(new KeystoreAuthenticator(keystore));\n        const backupClient = await Client.setupBackupClient(address, options.env);\n        const client = new Client(publicKeyBundle, apiClient, backupClient, keystore);\n        await client.init(options);\n        return client;\n    }\n    /**\n     * Export the XMTP PrivateKeyBundle from the SDK as a `Uint8Array`.\n     *\n     * This bundle can then be provided as `privateKeyOverride` in a\n     * subsequent call to `Client.create(...)`\n     *\n     * Be very careful with these keys, as they can be used to\n     * impersonate a user on the XMTP network and read the user's\n     * messages.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\n    static async getKeys(wallet, opts) {\n        const client = await Client.create(getSigner(wallet), opts);\n        const keys = await client.keystore.getPrivateKeyBundle();\n        return new PrivateKeyBundleV1(keys).encode();\n    }\n    /**\n     * Tells the caller whether the browser has a Snaps-compatible version of MetaMask installed\n     */\n    static isSnapsReady() {\n        return hasMetamaskWithSnaps();\n    }\n    static async setupBackupClient(walletAddress, env) {\n        // Hard-code the provider to use for now\n        const selectBackupProvider = async () => {\n            return Promise.resolve({\n                type: env === \"local\" ? BackupType.xmtpTopicStore : BackupType.none,\n            });\n        };\n        return createBackupClient(walletAddress, selectBackupProvider);\n    }\n    async init(options) {\n        options.codecs.forEach((codec) => {\n            this.registerCodec(codec);\n        });\n        this._maxContentSize = options.maxContentSize;\n        if (!options.skipContactPublishing) {\n            await this.ensureUserContactPublished(options.publishLegacyContact);\n        }\n    }\n    // gracefully shut down the client\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async close() {\n        return undefined;\n    }\n    async ensureUserContactPublished(legacy = false) {\n        const bundle = await getUserContactFromNetwork(this.apiClient, this.address);\n        if (bundle &&\n            bundle instanceof SignedPublicKeyBundle &&\n            this.signedPublicKeyBundle.equals(bundle)) {\n            return;\n        }\n        // TEMPORARY: publish V1 contact to make sure there is one in the topic\n        // in order to preserve compatibility with pre-v7 clients.\n        // Remove when pre-v7 clients are deprecated\n        await this.publishUserContact(true);\n        if (!legacy) {\n            await this.publishUserContact(legacy);\n        }\n    }\n    // PRIVATE: publish the key bundle into the contact topic\n    // left public for testing purposes\n    async publishUserContact(legacy = false) {\n        const bundle = legacy ? this.publicKeyBundle : this.signedPublicKeyBundle;\n        await this.publishEnvelopes([\n            {\n                contentTopic: buildUserContactTopic(this.address),\n                message: encodeContactBundle(bundle),\n            },\n        ]);\n    }\n    /**\n     * Returns the cached PublicKeyBundle if one is known for the given address or fetches\n     * one from the network\n     *\n     * This throws if either the address is invalid or the contact is not published.\n     * See also [#canMessage].\n     */\n    async getUserContact(peerAddress) {\n        peerAddress = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(peerAddress); // EIP55 normalize the address case.\n        const existingBundle = this.knownPublicKeyBundles.get(peerAddress);\n        if (existingBundle) {\n            return existingBundle;\n        }\n        const newBundle = await getUserContactFromNetwork(this.apiClient, peerAddress);\n        if (newBundle) {\n            this.knownPublicKeyBundles.set(peerAddress, newBundle);\n        }\n        return newBundle;\n    }\n    /**\n     * Identical to getUserContact but for multiple peer addresses\n     */\n    async getUserContacts(peerAddresses) {\n        // EIP55 normalize all peer addresses\n        const normalizedAddresses = peerAddresses.map((address) => (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(address));\n        // The logic here is tricky because we need to do a batch query for any uncached bundles,\n        // then interleave back into an ordered array. So we create a map<string, keybundle|undefined>\n        // and fill it with cached values, then take any undefined entries and form a BatchQuery from those.\n        const addressToBundle = new Map();\n        const uncachedAddresses = [];\n        for (const address of normalizedAddresses) {\n            const existingBundle = this.knownPublicKeyBundles.get(address);\n            if (existingBundle) {\n                addressToBundle.set(address, existingBundle);\n            }\n            else {\n                addressToBundle.set(address, undefined);\n                uncachedAddresses.push(address);\n            }\n        }\n        // Now do a getUserContactsFromNetwork call\n        const newBundles = await getUserContactsFromNetwork(this.apiClient, uncachedAddresses);\n        // Now merge the newBundles into the addressToBundle map\n        for (let i = 0; i < newBundles.length; i++) {\n            const address = uncachedAddresses[i];\n            const bundle = newBundles[i];\n            addressToBundle.set(address, bundle);\n            // If the bundle is not undefined, cache it\n            if (bundle) {\n                this.knownPublicKeyBundles.set(address, bundle);\n            }\n        }\n        // Finally return the bundles in the same order as the input addresses\n        return normalizedAddresses.map((address) => addressToBundle.get(address));\n    }\n    /**\n     * Used to force getUserContact fetch contact from the network.\n     */\n    forgetContact(peerAddress) {\n        peerAddress = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(peerAddress); // EIP55 normalize the address case.\n        this.knownPublicKeyBundles.delete(peerAddress);\n    }\n    /**\n     * Check if @peerAddress can be messaged, specifically\n     * it checks that a PublicKeyBundle can be found for the given address\n     */\n    async canMessage(peerAddress) {\n        try {\n            if (Array.isArray(peerAddress)) {\n                const contacts = await this.getUserContacts(peerAddress);\n                return contacts.map((contact) => !!contact);\n            }\n            // Else do the single address case\n            const keyBundle = await this.getUserContact(peerAddress);\n            return keyBundle !== undefined;\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (e) {\n            // Instead of throwing, a bad address should just return false.\n            return false;\n        }\n    }\n    static async canMessage(peerAddress, opts) {\n        const apiUrl = opts?.apiUrl || ApiUrls[opts?.env || \"dev\"];\n        const apiClient = new HttpApiClient(apiUrl, {\n            appVersion: opts?.appVersion,\n        });\n        if (Array.isArray(peerAddress)) {\n            const rawPeerAddresses = peerAddress;\n            // Try to normalize each of the peer addresses\n            const normalizedPeerAddresses = rawPeerAddresses.map((address) => (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(address));\n            // The getUserContactsFromNetwork will return false instead of throwing\n            // on invalid envelopes\n            const contacts = await getUserContactsFromNetwork(apiClient, normalizedPeerAddresses);\n            return contacts.map((contact) => !!contact);\n        }\n        try {\n            peerAddress = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(peerAddress); // EIP55 normalize the address case.\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (e) {\n            return false;\n        }\n        const keyBundle = await getUserContactFromNetwork(apiClient, peerAddress);\n        return keyBundle !== undefined;\n    }\n    validateEnvelope(env) {\n        const bytes = env.message;\n        if (!env.contentTopic) {\n            throw new Error(\"Missing content topic\");\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!bytes || !bytes.length) {\n            throw new Error(\"Cannot publish empty message\");\n        }\n    }\n    /**\n     * Low level method for publishing envelopes to the XMTP network with\n     * no pre-processing or encryption applied.\n     *\n     * Primarily used internally\n     * @param envelopes PublishParams[]\n     */\n    async publishEnvelopes(envelopes) {\n        for (const env of envelopes) {\n            this.validateEnvelope(env);\n        }\n        await this.apiClient.publish(envelopes);\n    }\n    /**\n     * Register a codec to be automatically used for encoding/decoding\n     * messages of the given Content Type\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-arguments\n    registerCodec(codec) {\n        const id = codec.contentType;\n        const key = `${id.authorityId}/${id.typeId}`;\n        this._codecs.set(key, codec);\n        return this;\n    }\n    /**\n     * Find a matching codec for a given `ContentTypeId` from the\n     * client's codec registry\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unnecessary-type-arguments\n    codecFor(contentType) {\n        const key = `${contentType.authorityId}/${contentType.typeId}`;\n        const codec = this._codecs.get(key);\n        if (!codec) {\n            return undefined;\n        }\n        if (contentType.versionMajor > codec.contentType.versionMajor) {\n            return undefined;\n        }\n        return codec;\n    }\n    /**\n     * Convert arbitrary content into a serialized `EncodedContent` instance\n     * with the given options\n     */\n    async encodeContent(content$1, options) {\n        const contentType = options?.contentType || _xmtp_content_type_text__WEBPACK_IMPORTED_MODULE_13__.ContentTypeText;\n        const codec = this.codecFor(contentType);\n        if (!codec) {\n            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n            throw new Error(\"unknown content type \" + contentType);\n        }\n        const encoded = codec.encode(content$1, this);\n        const fallback = codec.fallback(content$1);\n        if (fallback) {\n            encoded.fallback = fallback;\n        }\n        if (typeof options?.compression === \"number\" &&\n            // do not compress content less than 10 bytes\n            encoded.content.length >= 10) {\n            encoded.compression = options.compression;\n        }\n        await compress(encoded);\n        return {\n            payload: _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.EncodedContent.encode(encoded).finish(),\n            shouldPush: codec.shouldPush(content$1),\n        };\n    }\n    async decodeContent(contentBytes) {\n        const encodedContent = _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.content.EncodedContent.decode(contentBytes);\n        if (!encodedContent.type) {\n            throw new Error(\"missing content type\");\n        }\n        let content$1; // eslint-disable-line @typescript-eslint/no-explicit-any\n        const contentType = new _xmtp_content_type_primitives__WEBPACK_IMPORTED_MODULE_16__.ContentTypeId(encodedContent.type);\n        let error;\n        await decompress(encodedContent, 1000);\n        const codec = this.codecFor(contentType);\n        if (codec) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            content$1 = codec.decode(encodedContent, this);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n            error = new Error(\"unknown content type \" + contentType);\n        }\n        return {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            content: content$1,\n            contentType,\n            error,\n            contentFallback: encodedContent.fallback,\n        };\n    }\n    listInvitations(opts) {\n        return this.listEnvelopes(buildUserInviteTopic(this.address), \n        // eslint-disable-next-line @typescript-eslint/require-await\n        async (env) => env, opts);\n    }\n    /**\n     * List stored messages from the specified topic.\n     *\n     * A specified mapper function will be applied to each envelope.\n     * If the mapper function throws an error during processing, the\n     * envelope will be discarded.\n     */\n    async listEnvelopes(topic, mapper, opts) {\n        if (!opts) {\n            opts = {};\n        }\n        const { startTime, endTime, limit, pageSize } = opts;\n        const envelopes = await this.apiClient.query({ contentTopic: topic, startTime, endTime }, {\n            direction: opts.direction || _xmtp_proto__WEBPACK_IMPORTED_MODULE_0__.messageApi.SortDirection.SORT_DIRECTION_ASCENDING,\n            limit,\n            pageSize,\n        });\n        const results = [];\n        for (const env of envelopes) {\n            if (!env.message)\n                continue;\n            try {\n                const res = await mapper(env);\n                results.push(res);\n            }\n            catch (e) {\n                console.warn(\"Error in listEnvelopes mapper\", e);\n            }\n        }\n        return results;\n    }\n    /**\n     * List messages on a given set of content topics, yielding one page at a time\n     */\n    listEnvelopesPaginated(contentTopic, mapper, opts) {\n        return mapPaginatedStream(this.apiClient.queryIteratePages({\n            contentTopic,\n            startTime: opts?.startTime,\n            endTime: opts?.endTime,\n        }, { direction: opts?.direction, pageSize: opts?.pageSize || 100 }), mapper);\n    }\n}\nfunction createHttpApiClientFromOptions(options) {\n    const apiUrl = options.apiUrl || ApiUrls[options.env];\n    return new HttpApiClient(apiUrl, { appVersion: options.appVersion });\n}\n/**\n * Retrieve a key bundle from given user's contact topic\n */\nasync function getUserContactFromNetwork(apiClient, peerAddress) {\n    const stream = apiClient.queryIterator({ contentTopic: buildUserContactTopic(peerAddress) }, { pageSize: 5, direction: SortDirection.SORT_DIRECTION_DESCENDING });\n    for await (const env of stream) {\n        if (!env.message)\n            continue;\n        const keyBundle = decodeContactBundle(env.message);\n        let address;\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            address = await keyBundle?.walletSignatureAddress();\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (e) {\n            address = undefined;\n        }\n        if (address?.toLowerCase() === peerAddress.toLowerCase()) {\n            return keyBundle;\n        }\n    }\n    return undefined;\n}\n/**\n * Retrieve a list of key bundles given a list of user addresses\n */\nasync function getUserContactsFromNetwork(apiClient, peerAddresses) {\n    const userContactTopics = peerAddresses.map(buildUserContactTopic);\n    const topicToEnvelopes = await apiClient.batchQuery(userContactTopics.map((topic) => ({\n        contentTopic: topic,\n        pageSize: 5,\n        direction: SortDirection.SORT_DIRECTION_DESCENDING,\n    })));\n    // Transform topicToEnvelopes into a list of PublicKeyBundles or undefined\n    // by going through each message and attempting to decode\n    return Promise.all(peerAddresses.map(async (address, index) => {\n        const envelopes = topicToEnvelopes[index];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!envelopes) {\n            return undefined;\n        }\n        for (const env of envelopes) {\n            if (!env.message)\n                continue;\n            try {\n                const keyBundle = decodeContactBundle(env.message);\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                const signingAddress = await keyBundle?.walletSignatureAddress();\n                if (address.toLowerCase() === signingAddress.toLowerCase()) {\n                    return keyBundle;\n                }\n                else {\n                    console.info(\"Received contact bundle with incorrect address\");\n                }\n            }\n            catch (e) {\n                console.info(\"Invalid contact bundle\", e);\n            }\n        }\n        return undefined;\n    }));\n}\n/**\n * Get the default list of `KeystoreProviders` used in the SDK\n *\n * Particularly useful if a developer wants to add their own\n * provider to the head of the list while falling back to the\n * default functionality\n */\nfunction defaultKeystoreProviders() {\n    return [\n        // First check to see if a `privateKeyOverride` is provided and use that\n        new StaticKeystoreProvider(),\n        // Next check to see if a EncryptedPrivateKeyBundle exists on the network for the wallet\n        new NetworkKeystoreProvider(),\n        // If the first two failed with `KeystoreProviderUnavailableError`, then generate a new key and write it to the network\n        new KeyGeneratorKeystoreProvider(),\n    ];\n}\n/**\n * Take an array of KeystoreProviders from the options and try them until one succeeds\n */\nasync function bootstrapKeystore(opts, apiClient, wallet) {\n    for (const provider of opts.keystoreProviders) {\n        try {\n            return await provider.newKeystore(opts, apiClient, wallet ?? undefined);\n        }\n        catch (err) {\n            if (err instanceof KeystoreProviderUnavailableError) {\n                continue;\n            }\n            throw err;\n        }\n    }\n    throw new Error(\"No keystore providers available\");\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRLO0FBQ3BKO0FBQ2lCO0FBQ3dGO0FBQ3pGO0FBQzZCO0FBQ1A7QUFDMUI7QUFDSjtBQUM4RztBQUN6RTs7QUFFckUsd0JBQXdCO0FBQ3hCO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVDQUF1QztBQUM1RztBQUNBO0FBQ0EsK0RBQStELHdDQUF3QztBQUN2RztBQUNBO0FBQ0EsZ0VBQWdFLHdDQUF3QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQXFCO0FBQ3BDO0FBQ0E7QUFDQSw4QkFBOEIsOERBQXFCO0FBQ25EO0FBQ0E7O0FBRUEsZUFBZSxrREFBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVELFNBQVMsOEJBQThCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVELFNBQVMsNENBQTRDO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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VztBQUMxQjtBQUNBO0FBQ0EseUJBQXlCLG9EQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw0QkFBNEIsRUFBRSxtREFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsOEpBQThKLEVBQUUsaURBQVE7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGNBQWMsRUFBRSxnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSw2REFBNkQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0RBQWtELElBQUksaUVBQWlFO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3bEM7QUFDeGxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9kaXN0L2luZGV4LmpzP2M2YjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2lwaGVydGV4dCwgcHJpdmF0ZUtleSwgc2lnbmF0dXJlLCBwdWJsaWNLZXksIGZldGNoZXIsIGtleXN0b3JlLCBtZXNzYWdlLCBjb250ZW50LCBhdXRobiwgbWVzc2FnZUFwaSwgaW52aXRhdGlvbiwgcHJpdmF0ZVByZWZlcmVuY2VzLCBjb250YWN0IH0gZnJvbSAnQHhtdHAvcHJvdG8nO1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgKiBhcyBzZWNwIGZyb20gJ0Bub2JsZS9zZWNwMjU2azEnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4JDEsIGtlY2NhazI1NiwgZ2V0QWRkcmVzcywgaGV4VG9TaWduYXR1cmUsIGhleFRvQnl0ZXMsIGhhc2hNZXNzYWdlLCB2ZXJpZnlNZXNzYWdlIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyB3ZWJjcnlwdG8gfSBmcm9tICdub2RlOmNyeXB0byc7XG5pbXBvcnQgeyBDb250ZW50VHlwZVRleHQsIFRleHRDb2RlYyB9IGZyb20gJ0B4bXRwL2NvbnRlbnQtdHlwZS10ZXh0JztcbmltcG9ydCB7IENvbnRlbnRUeXBlSWQgfSBmcm9tICdAeG10cC9jb250ZW50LXR5cGUtcHJpbWl0aXZlcyc7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2FzeW5jLW11dGV4JztcbmltcG9ydCBlbGxpcHRpYyBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgeyB1c2VyX3ByZWZlcmVuY2VzX2VuY3J5cHQsIHVzZXJfcHJlZmVyZW5jZXNfZGVjcnlwdCwgZ2VuZXJhdGVfcHJpdmF0ZV9wcmVmZXJlbmNlc190b3BpYyB9IGZyb20gJ0B4bXRwL3VzZXItcHJlZmVyZW5jZXMtYmluZGluZ3Mtd2FzbSc7XG5pbXBvcnQgeyBjcmVhdGVDb25zZW50TWVzc2FnZSB9IGZyb20gJ0B4bXRwL2NvbnNlbnQtcHJvb2Ytc2lnbmF0dXJlJztcblxuY29uc3QgS0RGU2FsdFNpemUgPSAzMjsgLy8gYnl0ZXNcbi8vIEFFUy1HQ00gZGVmYXVsdHMgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWVzR2NtUGFyYW1zXG5jb25zdCBBRVNHQ01Ob25jZVNpemUgPSAxMjsgLy8gcHJvcGVydHkgaXZcbmNvbnN0IEFFU0dDTVRhZ0xlbmd0aCA9IDE2OyAvLyBwcm9wZXJ0eSB0YWdMZW5ndGhcbi8vIENpcGhlcnRleHQgcGFja2FnZXMgdGhlIGVuY3J5cHRlZCBjaXBoZXJ0ZXh0IHdpdGggdGhlIHNhbHQgYW5kIG5vbmNlIHVzZWQgdG8gcHJvZHVjZSBpdC5cbi8vIHNhbHQgYW5kIG5vbmNlIGFyZSBub3Qgc2VjcmV0LCBhbmQgc2hvdWxkIGJlIHRyYW5zbWl0dGVkL3N0b3JlZCBhbG9uZyB3aXRoIHRoZSBlbmNyeXB0ZWQgY2lwaGVydGV4dC5cbmNsYXNzIENpcGhlcnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBpZiAoIW9iai5hZXMyNTZHY21Ia2RmU2hhMjU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5hZXMyNTZHY21Ia2RmU2hhMjU2LnBheWxvYWQubGVuZ3RoIDwgQUVTR0NNVGFnTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2lwaGVydGV4dCBjaXBoZXJ0ZXh0IGxlbmd0aDogJHtvYmouYWVzMjU2R2NtSGtkZlNoYTI1Ni5wYXlsb2FkLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmFlczI1NkdjbUhrZGZTaGEyNTYuaGtkZlNhbHQubGVuZ3RoICE9PSBLREZTYWx0U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNpcGhlcnRleHQgc2FsdCBsZW5ndGg6ICR7b2JqLmFlczI1NkdjbUhrZGZTaGEyNTYuaGtkZlNhbHQubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouYWVzMjU2R2NtSGtkZlNoYTI1Ni5nY21Ob25jZS5sZW5ndGggIT09IEFFU0dDTU5vbmNlU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNpcGhlcnRleHQgbm9uY2UgbGVuZ3RoOiAke29iai5hZXMyNTZHY21Ia2RmU2hhMjU2LmdjbU5vbmNlLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFlczI1NkdjbUhrZGZTaGEyNTYgPSBvYmouYWVzMjU2R2NtSGtkZlNoYTI1NjtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQuQ2lwaGVydGV4dC5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaXBoZXJ0ZXh0KGNpcGhlcnRleHQuQ2lwaGVydGV4dC5kZWNvZGUoYnl0ZXMpKTtcbiAgICB9XG59XG5cbmNvbnN0IGNyeXB0byA9IHdlYmNyeXB0bztcblxuY29uc3QgaGtkZk5vSW5mbyA9IG5ldyBVaW50OEFycmF5KCkuYnVmZmVyO1xuY29uc3QgaGtkZk5vU2FsdCA9IG5ldyBVaW50OEFycmF5KCkuYnVmZmVyO1xuLy8gVGhpcyBpcyBhIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iL21haW4vaW5kZXgudHMjTDEzNzgtTDEzODhcbi8vIHRoYXQgdXNlcyBgZGlnZXN0KCdTSEEtMjU2JywgYnl0ZXMpYCBpbnN0ZWFkIG9mIGBkaWdlc3QoJ1NIQS0yNTYnLCBieXRlcy5idWZmZXIpYFxuLy8gd2hpY2ggc2VlbXMgdG8gcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0cy5cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NihieXRlcykge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgYnl0ZXMpKTtcbn1cbi8vIHN5bW1ldHJpYyBhdXRoZW50aWNhdGVkIGVuY3J5cHRpb24gb2YgcGxhaW50ZXh0IHVzaW5nIHRoZSBzZWNyZXQ7XG4vLyBhZGRpdGlvbmFsRGF0YSBpcyB1c2VkIHRvIHByb3RlY3QgdW4tZW5jcnlwdGVkIHBhcnRzIG9mIHRoZSBtZXNzYWdlIChoZWFkZXIpXG4vLyBpbiB0aGUgYXV0aGVudGljYXRpb24gc2NvcGUgb2YgdGhlIGVuY3J5cHRpb24uXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0JDEocGxhaW4sIHNlY3JldCwgYWRkaXRpb25hbERhdGEpIHtcbiAgICBjb25zdCBzYWx0ID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShLREZTYWx0U2l6ZSkpO1xuICAgIGNvbnN0IG5vbmNlID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShBRVNHQ01Ob25jZVNpemUpKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBoa2RmKHNlY3JldCwgc2FsdCk7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGFlc0djbVBhcmFtcyhub25jZSwgYWRkaXRpb25hbERhdGEpLCBrZXksIHBsYWluKTtcbiAgICByZXR1cm4gbmV3IENpcGhlcnRleHQoe1xuICAgICAgICBhZXMyNTZHY21Ia2RmU2hhMjU2OiB7XG4gICAgICAgICAgICBwYXlsb2FkOiBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpLFxuICAgICAgICAgICAgaGtkZlNhbHQ6IHNhbHQsXG4gICAgICAgICAgICBnY21Ob25jZTogbm9uY2UsXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyBzeW1tZXRyaWMgYXV0aGVudGljYXRlZCBkZWNyeXB0aW9uIG9mIHRoZSBlbmNyeXB0ZWQgY2lwaGVydGV4dCB1c2luZyB0aGUgc2VjcmV0IGFuZCBhZGRpdGlvbmFsRGF0YVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdCQxKGVuY3J5cHRlZCwgc2VjcmV0LCBhZGRpdGlvbmFsRGF0YSkge1xuICAgIGlmICghZW5jcnlwdGVkLmFlczI1NkdjbUhrZGZTaGEyNTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXlsb2FkIGNpcGhlcnRleHRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGhrZGYoc2VjcmV0LCBlbmNyeXB0ZWQuYWVzMjU2R2NtSGtkZlNoYTI1Ni5oa2RmU2FsdCk7XG4gICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KGFlc0djbVBhcmFtcyhlbmNyeXB0ZWQuYWVzMjU2R2NtSGtkZlNoYTI1Ni5nY21Ob25jZSwgYWRkaXRpb25hbERhdGEpLCBrZXksIGVuY3J5cHRlZC5hZXMyNTZHY21Ia2RmU2hhMjU2LnBheWxvYWQpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWNyeXB0ZWQpO1xufVxuLy8gaGVscGVyIGZvciBidWlsZGluZyBXZWIgQ3J5cHRvIEFQSSBlbmNyeXB0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmVcbmZ1bmN0aW9uIGFlc0djbVBhcmFtcyhub25jZSwgYWRkaXRpb25hbERhdGEpIHtcbiAgICBjb25zdCBzcGVjID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1HQ01cIixcbiAgICAgICAgaXY6IG5vbmNlLFxuICAgIH07XG4gICAgaWYgKGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgICAgIHNwZWMuYWRkaXRpb25hbERhdGEgPSBhZGRpdGlvbmFsRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWM7XG59XG4vLyBEZXJpdmUgQUVTLTI1Ni1HQ00ga2V5IGZyb20gYSBzaGFyZWQgc2VjcmV0IGFuZCBzYWx0LlxuLy8gUmV0dXJucyBjcnlwdG8uQ3J5cHRvS2V5IHN1aXRhYmxlIGZvciB0aGUgZW5jcnlwdC9kZWNyeXB0IEFQSVxuYXN5bmMgZnVuY3Rpb24gaGtkZihzZWNyZXQsIHNhbHQpIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXQsIFwiSEtERlwiLCBmYWxzZSwgW1xuICAgICAgICBcImRlcml2ZUtleVwiLFxuICAgIF0pO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7IG5hbWU6IFwiSEtERlwiLCBoYXNoOiBcIlNIQS0yNTZcIiwgc2FsdCwgaW5mbzogaGtkZk5vSW5mbyB9LCBrZXksIHsgbmFtZTogXCJBRVMtR0NNXCIsIGxlbmd0aDogMjU2IH0sIGZhbHNlLCBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSk7XG59XG5hc3luYyBmdW5jdGlvbiBoa2RmSG1hY0tleShzZWNyZXQsIGluZm8pIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXQsIFwiSEtERlwiLCBmYWxzZSwgW1xuICAgICAgICBcImRlcml2ZUtleVwiLFxuICAgIF0pO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7IG5hbWU6IFwiSEtERlwiLCBoYXNoOiBcIlNIQS0yNTZcIiwgc2FsdDogaGtkZk5vU2FsdCwgaW5mbyB9LCBrZXksIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiLCBsZW5ndGg6IDI1NiB9LCB0cnVlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSG1hY1NpZ25hdHVyZShzZWNyZXQsIGluZm8sIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBoa2RmSG1hY0tleShzZWNyZXQsIGluZm8pO1xuICAgIGNvbnN0IHNpZ25lZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihcIkhNQUNcIiwga2V5LCBtZXNzYWdlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2lnbmVkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUhtYWNTaWduYXR1cmUoa2V5LCBzaWduYXR1cmUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoXCJITUFDXCIsIGtleSwgc2lnbmF0dXJlLCBtZXNzYWdlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEhtYWNLZXkoa2V5KSB7XG4gICAgY29uc3QgZXhwb3J0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInJhd1wiLCBrZXkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShleHBvcnRlZCk7XG59XG5hc3luYyBmdW5jdGlvbiBpbXBvcnRIbWFjS2V5KGtleSkge1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBrZXksIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiLCBsZW5ndGg6IDI1NiB9LCB0cnVlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbn1cblxuY29uc3QgYnl0ZXNUb0hleCA9IHNlY3AudXRpbHMuYnl0ZXNUb0hleDtcbmZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIEV0aGVyZXVtIGFkZHJlc3MgZnJvbSB1bmNvbXByZXNzZWQgUHVibGljS2V5IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGJ5dGVzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGJ5dGVzVG9IZXgkMShieXRlcy5zbGljZSgxKSk7XG4gICAgY29uc3QgaGFzaCA9IGtlY2NhazI1NihwdWJsaWNLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSBoYXNoLnN1YnN0cmluZyhoYXNoLmxlbmd0aCAtIDQwKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhgMHgke2FkZHJlc3N9YCk7XG59XG4vKipcbiAqIFNwbGl0IGFuIEV0aGVyZXVtIHNpZ25hdHVyZSBoZXggc3RyaW5nIGludG8gYnl0ZXMgYW5kIGEgcmVjb3ZlcnkgYml0XG4gKi9cbmZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGVTaWcgPSBoZXhUb1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGNvbnN0IHIgPSBoZXhUb0J5dGVzKGVTaWcucik7XG4gICAgY29uc3QgcyA9IGhleFRvQnl0ZXMoZVNpZy5zKTtcbiAgICBsZXQgdiA9IE51bWJlcihlU2lnLnYpO1xuICAgIGlmICh2ID09PSAwIHx8IHYgPT09IDEpIHtcbiAgICAgICAgdiArPSAyNztcbiAgICB9XG4gICAgY29uc3QgcmVjb3ZlcnkgPSAxIC0gKHYgJSAyKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBieXRlcy5zZXQocik7XG4gICAgYnl0ZXMuc2V0KHMsIHIubGVuZ3RoKTtcbiAgICByZXR1cm4geyBieXRlcywgcmVjb3ZlcnkgfTtcbn1cblxuLy8gVmFsaWRhdGUgU0VDUDI1NmsxIHByaXZhdGUga2V5XG5mdW5jdGlvbiBzZWNwMjU2azFDaGVjayhrZXkpIHtcbiAgICBpZiAoa2V5LmJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHByaXZhdGUga2V5IGxlbmd0aDogJHtrZXkuYnl0ZXMubGVuZ3RofWApO1xuICAgIH1cbn1cbi8vIEEgcHJpdmF0ZSBrZXkgc2lnbmVkIHdpdGggYW5vdGhlciBrZXkgcGFpciBvciBhIHdhbGxldC5cbmNsYXNzIFNpZ25lZFByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBpZiAoIW9iai5zZWNwMjU2azEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2VjcDI1NmsxQ2hlY2sob2JqLnNlY3AyNTZrMSk7XG4gICAgICAgIHRoaXMuc2VjcDI1NmsxID0gb2JqLnNlY3AyNTZrMTtcbiAgICAgICAgdGhpcy5jcmVhdGVkTnMgPSBvYmouY3JlYXRlZE5zO1xuICAgICAgICBpZiAoIW9iai5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcHVibGljIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IG5ldyBTaWduZWRQdWJsaWNLZXkob2JqLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHJhbmRvbSBrZXkgcGFpciBzaWduZWQgYnkgdGhlIHNpZ25lci5cbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGUoc2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IHtcbiAgICAgICAgICAgIGJ5dGVzOiBzZWNwLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3JlYXRlZE5zID0gTG9uZy5mcm9tTnVtYmVyKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS5tdWwoMTAwMDAwMCk7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkID0gbmV3IFVuc2lnbmVkUHVibGljS2V5KHtcbiAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDoge1xuICAgICAgICAgICAgICAgIGJ5dGVzOiBzZWNwLmdldFB1YmxpY0tleShzZWNwMjU2azEuYnl0ZXMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyZWF0ZWROcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IGF3YWl0IHNpZ25lci5zaWduS2V5KHVuc2lnbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZWRQcml2YXRlS2V5KHtcbiAgICAgICAgICAgIHNlY3AyNTZrMSxcbiAgICAgICAgICAgIGNyZWF0ZWROcyxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2lnbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGltZSB0aGUga2V5IHdhcyBnZW5lcmF0ZWQuXG4gICAgZ2VuZXJhdGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5jcmVhdGVkTnMuZGl2KDEwMDAwMDApLnRvTnVtYmVyKCkpO1xuICAgIH1cbiAgICAvLyBTaWduIHByb3ZpZGVkIGRpZ2VzdC5cbiAgICBhc3luYyBzaWduKGRpZ2VzdCkge1xuICAgICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeV0gPSBhd2FpdCBzZWNwLnNpZ24oZGlnZXN0LCB0aGlzLnNlY3AyNTZrMS5ieXRlcywge1xuICAgICAgICAgICAgcmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICAgICAgZGVyOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHtcbiAgICAgICAgICAgIGVjZHNhQ29tcGFjdDogeyBieXRlczogc2lnbmF0dXJlLCByZWNvdmVyeSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2lnbiBwcm92aWRlZCBwdWJsaWMga2V5LlxuICAgIGFzeW5jIHNpZ25LZXkocHViKSB7XG4gICAgICAgIGNvbnN0IGtleUJ5dGVzID0gcHViLnRvQnl0ZXMoKTtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gYXdhaXQgc2hhMjU2KGtleUJ5dGVzKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduKGRpZ2VzdCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVkUHVibGljS2V5KHtcbiAgICAgICAgICAgIGtleUJ5dGVzLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHB1YmxpYyBrZXkgb2YgdGhlIHNpZ25lciBvZiB0aGUgcHJvdmlkZWQgc2lnbmVkIGtleS5cbiAgICBzdGF0aWMgYXN5bmMgc2lnbmVyS2V5KGtleSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHNoYTI1NihrZXkuYnl0ZXNUb1NpZ24oKSk7XG4gICAgICAgIHJldHVybiBlY2RzYVNpZ25lcktleShkaWdlc3QsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIERlcml2ZSBzaGFyZWQgc2VjcmV0IGZyb20gcGVlcidzIFB1YmxpY0tleTtcbiAgICAvLyB0aGUgcGVlciBjYW4gZGVyaXZlIHRoZSBzYW1lIHNlY3JldCB1c2luZyB0aGVpciBwcml2YXRlIGtleSBhbmQgb3VyIHB1YmxpYyBrZXkuXG4gICAgc2hhcmVkU2VjcmV0KHBlZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlY3AuZ2V0U2hhcmVkU2VjcmV0KHRoaXMuc2VjcDI1NmsxLmJ5dGVzLCBwZWVyLnNlY3AyNTZrMVVuY29tcHJlc3NlZC5ieXRlcywgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBlbmNyeXB0IHBsYWluIGJ5dGVzIHVzaW5nIGEgc2hhcmVkIHNlY3JldCBkZXJpdmVkIGZyb20gcGVlcidzIFB1YmxpY0tleTtcbiAgICAvLyBhZGRpdGlvbmFsRGF0YSBhbGxvd3MgaW5jbHVkaW5nIHVuZW5jcnlwdGVkIHBhcnRzIG9mIGEgTWVzc2FnZSBpbiB0aGUgYXV0aGVudGljYXRpb25cbiAgICAvLyBwcm90ZWN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBlbmNyeXB0ZWQgcGFydCAodG8gbWFrZSB0aGUgd2hvbGUgTWVzc2FnZSB0YW1wZXIgZXZpZGVudClcbiAgICBlbmNyeXB0KHBsYWluLCBwZWVyLCBhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICBjb25zdCBzZWNyZXQgPSB0aGlzLnNoYXJlZFNlY3JldChwZWVyKTtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHQkMShwbGFpbiwgc2VjcmV0LCBhZGRpdGlvbmFsRGF0YSk7XG4gICAgfVxuICAgIC8vIGRlY3J5cHQgQ2lwaGVydGV4dCB1c2luZyBhIHNoYXJlZCBzZWNyZXQgZGVyaXZlZCBmcm9tIHBlZXIncyBQdWJsaWNLZXk7XG4gICAgLy8gdGhyb3dzIGlmIGFueSBwYXJ0IG9mIENpcGhlcnRleHQgb3IgYWRkaXRpb25hbERhdGEgd2FzIHRhbXBlcmVkIHdpdGhcbiAgICBkZWNyeXB0KGVuY3J5cHRlZCwgcGVlciwgYWRkaXRpb25hbERhdGEpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gdGhpcy5zaGFyZWRTZWNyZXQocGVlcik7XG4gICAgICAgIHJldHVybiBkZWNyeXB0JDEoZW5jcnlwdGVkLCBzZWNyZXQsIGFkZGl0aW9uYWxEYXRhKTtcbiAgICB9XG4gICAgLy8gRG9lcyB0aGUgcHJvdmlkZWQgUHVibGljS2V5IGNvcnJlc3BvbmQgdG8gdGhpcyBQcml2YXRlS2V5P1xuICAgIG1hdGNoZXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0tleS5lcXVhbHMoa2V5KTtcbiAgICB9XG4gICAgLy8gSXMgb3RoZXIgdGhlIHNhbWUvZXF1aXZhbGVudCBrZXk/XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoZXF1YWxCeXRlcyh0aGlzLnNlY3AyNTZrMS5ieXRlcywgb3RoZXIuc2VjcDI1NmsxLmJ5dGVzKSAmJlxuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkuZXF1YWxzKG90aGVyLnB1YmxpY0tleSkpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhpcyBrZXkgaW50byBieXRlcy5cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleS5TaWduZWRQcml2YXRlS2V5LmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQdWJsaWNLZXkoKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZFB1YmxpY0tleSA9IHNlY3AuZ2V0UHVibGljS2V5KHRoaXMuc2VjcDI1NmsxLmJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGVxdWFsQnl0ZXMoZ2VuZXJhdGVkUHVibGljS2V5LCB0aGlzLnB1YmxpY0tleS5zZWNwMjU2azFVbmNvbXByZXNzZWQuYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUga2V5IGZyb20gYnl0ZXMuXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lZFByaXZhdGVLZXkocHJpdmF0ZUtleS5TaWduZWRQcml2YXRlS2V5LmRlY29kZShieXRlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUxlZ2FjeUtleShrZXksIHNpZ25lZEJ5V2FsbGV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVkUHJpdmF0ZUtleSh7XG4gICAgICAgICAgICBjcmVhdGVkTnM6IGtleS50aW1lc3RhbXAubXVsKDEwMDAwMDApLFxuICAgICAgICAgICAgc2VjcDI1NmsxOiBrZXkuc2VjcDI1NmsxLFxuICAgICAgICAgICAgcHVibGljS2V5OiBTaWduZWRQdWJsaWNLZXkuZnJvbUxlZ2FjeUtleShrZXkucHVibGljS2V5LCBzaWduZWRCeVdhbGxldCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIExFR0FDWTogUHJpdmF0ZUtleSByZXByZXNlbnRzIGEgc2VjcDI1NmsxIHByaXZhdGUga2V5LlxuY2xhc3MgUHJpdmF0ZUtleSB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIGlmICghb2JqLnNlY3AyNTZrMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzZWNwMjU2azFDaGVjayhvYmouc2VjcDI1NmsxKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBvYmoudGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlY3AyNTZrMSA9IG9iai5zZWNwMjU2azE7XG4gICAgICAgIGlmICghb2JqLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwdWJsaWMga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShvYmoucHVibGljS2V5KTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgcmFuZG9tIFByaXZhdGVLZXkvUHVibGljS2V5IHBhaXIuXG4gICAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgICAgICBjb25zdCBzZWNwMjU2azEgPSB7XG4gICAgICAgICAgICBieXRlczogc2VjcC51dGlscy5yYW5kb21Qcml2YXRlS2V5KCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IExvbmcuZnJvbU51bWJlcihuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleSh7XG4gICAgICAgICAgICBzZWNwMjU2azEsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IG5ldyBQdWJsaWNLZXkoe1xuICAgICAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDoge1xuICAgICAgICAgICAgICAgICAgICBieXRlczogc2VjcC5nZXRQdWJsaWNLZXkoc2VjcDI1NmsxLmJ5dGVzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIC8vIHNpZ24gcHJvdmlkZWQgZGlnZXN0XG4gICAgYXN5bmMgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgY29uc3QgW3NpZ25hdHVyZSwgcmVjb3ZlcnldID0gYXdhaXQgc2VjcC5zaWduKGRpZ2VzdCwgdGhpcy5zZWNwMjU2azEuYnl0ZXMsIHtcbiAgICAgICAgICAgIHJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRlcjogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7XG4gICAgICAgICAgICBlY2RzYUNvbXBhY3Q6IHsgYnl0ZXM6IHNpZ25hdHVyZSwgcmVjb3ZlcnkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNpZ24gcHJvdmlkZWQgcHVibGljIGtleVxuICAgIGFzeW5jIHNpZ25LZXkocHViKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHNoYTI1NihwdWIuYnl0ZXNUb1NpZ24oKSk7XG4gICAgICAgIHB1Yi5zaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ24oZGlnZXN0KTtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICB9XG4gICAgLy8gZGVyaXZlIHNoYXJlZCBzZWNyZXQgZnJvbSBwZWVyJ3MgUHVibGljS2V5O1xuICAgIC8vIHRoZSBwZWVyIGNhbiBkZXJpdmUgdGhlIHNhbWUgc2VjcmV0IHVzaW5nIHRoZWlyIFByaXZhdGVLZXkgYW5kIG91ciBQdWJsaWNLZXlcbiAgICBzaGFyZWRTZWNyZXQocGVlcikge1xuICAgICAgICByZXR1cm4gc2VjcC5nZXRTaGFyZWRTZWNyZXQodGhpcy5zZWNwMjU2azEuYnl0ZXMsIHBlZXIuc2VjcDI1NmsxVW5jb21wcmVzc2VkLmJ5dGVzLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIGVuY3J5cHQgcGxhaW4gYnl0ZXMgdXNpbmcgYSBzaGFyZWQgc2VjcmV0IGRlcml2ZWQgZnJvbSBwZWVyJ3MgUHVibGljS2V5O1xuICAgIC8vIGFkZGl0aW9uYWxEYXRhIGFsbG93cyBpbmNsdWRpbmcgdW5lbmNyeXB0ZWQgcGFydHMgb2YgYSBNZXNzYWdlIGluIHRoZSBhdXRoZW50aWNhdGlvblxuICAgIC8vIHByb3RlY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGVuY3J5cHRlZCBwYXJ0ICh0byBtYWtlIHRoZSB3aG9sZSBNZXNzYWdlIHRhbXBlciBldmlkZW50KVxuICAgIGVuY3J5cHQocGxhaW4sIHBlZXIsIGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHRoaXMuc2hhcmVkU2VjcmV0KHBlZXIpO1xuICAgICAgICByZXR1cm4gZW5jcnlwdCQxKHBsYWluLCBzZWNyZXQsIGFkZGl0aW9uYWxEYXRhKTtcbiAgICB9XG4gICAgLy8gZGVjcnlwdCBDaXBoZXJ0ZXh0IHVzaW5nIGEgc2hhcmVkIHNlY3JldCBkZXJpdmVkIGZyb20gcGVlcidzIFB1YmxpY0tleTtcbiAgICAvLyB0aHJvd3MgaWYgYW55IHBhcnQgb2YgQ2lwaGVydGV4dCBvciBhZGRpdGlvbmFsRGF0YSB3YXMgdGFtcGVyZWQgd2l0aFxuICAgIGRlY3J5cHQoZW5jcnlwdGVkLCBwZWVyLCBhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICBjb25zdCBzZWNyZXQgPSB0aGlzLnNoYXJlZFNlY3JldChwZWVyKTtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHQkMShlbmNyeXB0ZWQsIHNlY3JldCwgYWRkaXRpb25hbERhdGEpO1xuICAgIH1cbiAgICAvLyBEb2VzIHRoZSBwcm92aWRlZCBQdWJsaWNLZXkgY29ycmVzcG9uZCB0byB0aGlzIFByaXZhdGVLZXk/XG4gICAgbWF0Y2hlcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5LmVxdWFscyhrZXkpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVB1YmxpY0tleSgpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHVibGljS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkodGhpcy5zZWNwMjU2azEuYnl0ZXMpO1xuICAgICAgICByZXR1cm4gZXF1YWxCeXRlcyhnZW5lcmF0ZWRQdWJsaWNLZXksIHRoaXMucHVibGljS2V5LnNlY3AyNTZrMVVuY29tcHJlc3NlZC5ieXRlcyk7XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGlzIGtleSBpbnRvIGJ5dGVzLlxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5LlByaXZhdGVLZXkuZW5jb2RlKHRoaXMpLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUga2V5IGZyb20gYnl0ZXMuXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkocHJpdmF0ZUtleS5Qcml2YXRlS2V5LmRlY29kZShieXRlcykpO1xuICAgIH1cbn1cblxuLy8gVmFsaWRhdGUgc2lnbmF0dXJlLlxuZnVuY3Rpb24gZWNkc2FDaGVjayhzaWcpIHtcbiAgICBpZiAoc2lnLmJ5dGVzLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGg6ICR7c2lnLmJ5dGVzLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKHNpZy5yZWNvdmVyeSAhPT0gMCAmJiBzaWcucmVjb3ZlcnkgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHJlY292ZXJ5IGJpdDogJHtzaWcucmVjb3Zlcnl9YCk7XG4gICAgfVxufVxuLy8gQ29tcGFyZSBzaWduYXR1cmVzLlxuZnVuY3Rpb24gZWNkc2FFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEucmVjb3ZlcnkgPT09IGIucmVjb3ZlcnkgJiYgZXF1YWxCeXRlcyhhLmJ5dGVzLCBiLmJ5dGVzKTtcbn1cbi8vIERlcml2ZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIgZnJvbSB0aGUgZGlnZXN0IGFuZCB0aGUgc2lnbmF0dXJlLlxuZnVuY3Rpb24gZWNkc2FTaWduZXJLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBieXRlcyA9IHNlY3AucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZS5ieXRlcywgc2lnbmF0dXJlLnJlY292ZXJ5KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIHJldHVybiBieXRlc1xuICAgICAgICA/IG5ldyBVbnNpZ25lZFB1YmxpY0tleSh7XG4gICAgICAgICAgICBzZWNwMjU2azFVbmNvbXByZXNzZWQ6IHsgYnl0ZXMgfSxcbiAgICAgICAgICAgIGNyZWF0ZWROczogTG9uZy5mcm9tTnVtYmVyKDApLFxuICAgICAgICB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmNsYXNzIFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIGlmIChvYmouZWNkc2FDb21wYWN0KSB7XG4gICAgICAgICAgICBlY2RzYUNoZWNrKG9iai5lY2RzYUNvbXBhY3QpO1xuICAgICAgICAgICAgdGhpcy5lY2RzYUNvbXBhY3QgPSBvYmouZWNkc2FDb21wYWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai53YWxsZXRFY2RzYUNvbXBhY3QpIHtcbiAgICAgICAgICAgIGVjZHNhQ2hlY2sob2JqLndhbGxldEVjZHNhQ29tcGFjdCk7XG4gICAgICAgICAgICB0aGlzLndhbGxldEVjZHNhQ29tcGFjdCA9IG9iai53YWxsZXRFY2RzYUNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIHB1YmxpYyBrZXkgdGhhdCB2YWxpZGF0ZXMgcHJvdmlkZWQga2V5J3Mgc2lnbmF0dXJlLlxuICAgIGFzeW5jIHNpZ25lcktleShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWNkc2FDb21wYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmVkUHJpdmF0ZUtleS5zaWduZXJLZXkoa2V5LCB0aGlzLmVjZHNhQ29tcGFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53YWxsZXRFY2RzYUNvbXBhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBXYWxsZXRTaWduZXIuc2lnbmVyS2V5KGtleSwgdGhpcy53YWxsZXRFY2RzYUNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMRUdBQ1k6IFJldHVybiB0aGUgcHVibGljIGtleSB0aGF0IHZhbGlkYXRlcyB0aGlzIHNpZ25hdHVyZSBnaXZlbiB0aGUgcHJvdmlkZWQgZGlnZXN0LlxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHNpZ25hdHVyZSBpcyBtYWxmb3JtZWQuXG4gICAgZ2V0UHVibGljS2V5KGRpZ2VzdCkge1xuICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgIGlmICh0aGlzLmVjZHNhQ29tcGFjdCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBzZWNwLnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCB0aGlzLmVjZHNhQ29tcGFjdC5ieXRlcywgdGhpcy5lY2RzYUNvbXBhY3QucmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud2FsbGV0RWNkc2FDb21wYWN0KSB7XG4gICAgICAgICAgICBieXRlcyA9IHNlY3AucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHRoaXMud2FsbGV0RWNkc2FDb21wYWN0LmJ5dGVzLCB0aGlzLndhbGxldEVjZHNhQ29tcGFjdC5yZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHYxIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICByZXR1cm4gYnl0ZXNcbiAgICAgICAgICAgID8gbmV3IFB1YmxpY0tleSh7XG4gICAgICAgICAgICAgICAgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiB7IGJ5dGVzIH0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBMb25nLmZyb21OdW1iZXIoMCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIElzIHRoaXMgdGhlIHNhbWUvZXF1aXZhbGVudCBzaWduYXR1cmUgYXMgb3RoZXI/XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmVjZHNhQ29tcGFjdCAmJiBvdGhlci5lY2RzYUNvbXBhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBlY2RzYUVxdWFsKHRoaXMuZWNkc2FDb21wYWN0LCBvdGhlci5lY2RzYUNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndhbGxldEVjZHNhQ29tcGFjdCAmJiBvdGhlci53YWxsZXRFY2RzYUNvbXBhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBlY2RzYUVxdWFsKHRoaXMud2FsbGV0RWNkc2FDb21wYWN0LCBvdGhlci53YWxsZXRFY2RzYUNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZS5TaWduYXR1cmUuZW5jb2RlKHRoaXMpLmZpbmlzaCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZS5TaWduYXR1cmUuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxufVxudmFyIEFjY291bnRMaW5rZWRSb2xlO1xuKGZ1bmN0aW9uIChBY2NvdW50TGlua2VkUm9sZSkge1xuICAgIEFjY291bnRMaW5rZWRSb2xlW0FjY291bnRMaW5rZWRSb2xlW1wiSU5CT1hfS0VZXCJdID0gMF0gPSBcIklOQk9YX0tFWVwiO1xuICAgIEFjY291bnRMaW5rZWRSb2xlW0FjY291bnRMaW5rZWRSb2xlW1wiU0VORF9LRVlcIl0gPSAxXSA9IFwiU0VORF9LRVlcIjtcbn0pKEFjY291bnRMaW5rZWRSb2xlIHx8IChBY2NvdW50TGlua2VkUm9sZSA9IHt9KSk7XG4vLyBBIHdhbGxldCBiYXNlZCBLZXlTaWduZXIuXG5jbGFzcyBXYWxsZXRTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKHdhbGxldCkge1xuICAgICAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgICB9XG4gICAgc3RhdGljIGlkZW50aXR5U2lnUmVxdWVzdFRleHQoa2V5Qnl0ZXMpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGFuIHVwZGF0ZSB0byB0aGlzIHNpZ25hdHVyZSByZXF1ZXN0IHRleHQgd2lsbCByZXF1aXJlXG4gICAgICAgIC8vIGFkZGl0aW9uIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGV4aXN0aW5nIHNpZ25hdHVyZXNcbiAgICAgICAgLy8gYW5kL29yIGEgbWlncmF0aW9uOyBvdGhlcndpc2UgY2xpZW50cyB3aWxsIGZhaWwgdG8gdmVyaWZ5IHByZXZpb3VzbHlcbiAgICAgICAgLy8gc2lnbmVkIGtleXMuXG4gICAgICAgIHJldHVybiAoXCJYTVRQIDogQ3JlYXRlIElkZW50aXR5XFxuXCIgK1xuICAgICAgICAgICAgYCR7Ynl0ZXNUb0hleChrZXlCeXRlcyl9XFxuYCArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIFwiRm9yIG1vcmUgaW5mbzogaHR0cHM6Ly94bXRwLm9yZy9zaWduYXR1cmVzL1wiKTtcbiAgICB9XG4gICAgc3RhdGljIHNpZ25lcktleShrZXksIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBoZXhUb0J5dGVzKGhhc2hNZXNzYWdlKHRoaXMuaWRlbnRpdHlTaWdSZXF1ZXN0VGV4dChrZXkuYnl0ZXNUb1NpZ24oKSkpKTtcbiAgICAgICAgcmV0dXJuIGVjZHNhU2lnbmVyS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbktleShrZXkpIHtcbiAgICAgICAgY29uc3Qga2V5Qnl0ZXMgPSBrZXkudG9CeXRlcygpO1xuICAgICAgICBjb25zdCBzaWdTdHJpbmcgPSBhd2FpdCB0aGlzLndhbGxldC5zaWduTWVzc2FnZShXYWxsZXRTaWduZXIuaWRlbnRpdHlTaWdSZXF1ZXN0VGV4dChrZXlCeXRlcykpO1xuICAgICAgICBjb25zdCB7IGJ5dGVzLCByZWNvdmVyeSB9ID0gc3BsaXRTaWduYXR1cmUoc2lnU3RyaW5nKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZSh7XG4gICAgICAgICAgICB3YWxsZXRFY2RzYUNvbXBhY3Q6IHtcbiAgICAgICAgICAgICAgICBieXRlcyxcbiAgICAgICAgICAgICAgICByZWNvdmVyeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lZFB1YmxpY0tleSh7IGtleUJ5dGVzLCBzaWduYXR1cmUgfSk7XG4gICAgfVxufVxuXG4vLyBWYWxpZGF0ZSBhIGtleS5cbmZ1bmN0aW9uIHNlY3AyNTZrMVVuY29tcHJlc3NlZENoZWNrKGtleSkge1xuICAgIGlmIChrZXkuYnl0ZXMubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHVibGljIGtleSBsZW5ndGg6ICR7a2V5LmJ5dGVzLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKGtleS5ieXRlc1swXSAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBwdWJsaWMga2V5IHByZWZpeDogJHtrZXkuYnl0ZXNbMF19YCk7XG4gICAgfVxufVxuY29uc3QgTVNfTlNfVElNRVNUQU1QX1RIUkVTSE9MRCA9IG5ldyBMb25nKDEwICoqIDkpLm11bCgxMCAqKiA5KTtcbi8vIEJhc2ljIHB1YmxpYyBrZXkgd2l0aG91dCBhIHNpZ25hdHVyZS5cbmNsYXNzIFVuc2lnbmVkUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKCFvYmo/LnNlY3AyNTZrMVVuY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwdWJsaWMga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZENoZWNrKG9iai5zZWNwMjU2azFVbmNvbXByZXNzZWQpO1xuICAgICAgICB0aGlzLnNlY3AyNTZrMVVuY29tcHJlc3NlZCA9IG9iai5zZWNwMjU2azFVbmNvbXByZXNzZWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlZE5zID0gb2JqLmNyZWF0ZWROcy50b1Vuc2lnbmVkKCk7XG4gICAgfVxuICAgIC8vIFRoZSB0aW1lIHRoZSBrZXkgd2FzIGdlbmVyYXRlZC5cbiAgICBnZW5lcmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcC50b051bWJlcigpKTtcbiAgICB9XG4gICAgaXNGcm9tTGVnYWN5S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVkTnMubGVzc1RoYW4oTVNfTlNfVElNRVNUQU1QX1RIUkVTSE9MRCk7XG4gICAgfVxuICAgIC8vIGNyZWF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRnJvbUxlZ2FjeUtleSgpID8gdGhpcy5jcmVhdGVkTnMgOiB0aGlzLmNyZWF0ZWROcy5kaXYoMTAwMDAwMCkpLnRvVW5zaWduZWQoKTtcbiAgICB9XG4gICAgLy8gVmVyaWZ5IHRoYXQgc2lnbmF0dXJlIHdhcyBjcmVhdGVkIGZyb20gdGhlIGRpZ2VzdCB1c2luZyBtYXRjaGluZyBwcml2YXRlIGtleS5cbiAgICB2ZXJpZnkoc2lnbmF0dXJlLCBkaWdlc3QpIHtcbiAgICAgICAgaWYgKCFzaWduYXR1cmUuZWNkc2FDb21wYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZ25hdHVyZS5lY2RzYUNvbXBhY3QuYnl0ZXMsIGRpZ2VzdCwgdGhpcy5zZWNwMjU2azFVbmNvbXByZXNzZWQuYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgcHJvdmlkZWQgcHVibGljIGtleSB3YXMgc2lnbmVkIGJ5IG1hdGNoaW5nIHByaXZhdGUga2V5LlxuICAgIGFzeW5jIHZlcmlmeUtleShwdWIpIHtcbiAgICAgICAgaWYgKCFwdWIuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlnZXN0ID0gYXdhaXQgc2hhMjU2KHB1Yi5ieXRlc1RvU2lnbigpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5KHB1Yi5zaWduYXR1cmUsIGRpZ2VzdCk7XG4gICAgfVxuICAgIC8vIElzIG90aGVyIHRoZSBzYW1lL2VxdWl2YWxlbnQgcHVibGljIGtleT9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsQnl0ZXModGhpcy5zZWNwMjU2azFVbmNvbXByZXNzZWQuYnl0ZXMsIG90aGVyLnNlY3AyNTZrMVVuY29tcHJlc3NlZC5ieXRlcyk7XG4gICAgfVxuICAgIC8vIERlcml2ZSBFdGhlcmV1bSBhZGRyZXNzIGZyb20gdGhpcyBwdWJsaWMga2V5LlxuICAgIGdldEV0aGVyZXVtQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKHRoaXMuc2VjcDI1NmsxVW5jb21wcmVzc2VkLmJ5dGVzKTtcbiAgICB9XG4gICAgLy8gRW5jb2RlIHB1YmxpYyBrZXkgaW50byBieXRlcy5cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LlVuc2lnbmVkUHVibGljS2V5LmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIHB1YmxpYyBrZXkgZnJvbSBieXRlcy5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5zaWduZWRQdWJsaWNLZXkocHVibGljS2V5LlVuc2lnbmVkUHVibGljS2V5LmRlY29kZShieXRlcykpO1xuICAgIH1cbn1cbi8vIFB1YmxpYyBrZXkgc2lnbmVkIGJ5IGFub3RoZXIga2V5IHBhaXIgb3IgYSB3YWxsZXQuXG5jbGFzcyBTaWduZWRQdWJsaWNLZXkgZXh0ZW5kcyBVbnNpZ25lZFB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghb2JqLmtleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGtleSBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwdWJsaWNLZXkuVW5zaWduZWRQdWJsaWNLZXkuZGVjb2RlKG9iai5rZXlCeXRlcykpO1xuICAgICAgICB0aGlzLmtleUJ5dGVzID0gb2JqLmtleUJ5dGVzO1xuICAgICAgICBpZiAoIW9iai5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcga2V5IHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUob2JqLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUga2V5IHdpdGhvdXQgdGhlIHNpZ25hdHVyZS5cbiAgICBnZXQgdW5zaWduZWRLZXkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5zaWduZWRQdWJsaWNLZXkoe1xuICAgICAgICAgICAgY3JlYXRlZE5zOiB0aGlzLmNyZWF0ZWROcyxcbiAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDogdGhpcy5zZWNwMjU2azFVbmNvbXByZXNzZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gcHVibGljIGtleSBvZiB0aGUgc2lnbmVyIG9mIHRoaXMga2V5LlxuICAgIHNpZ25lcktleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlLnNpZ25lcktleSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQXNzdW1lIHRoZSBrZXkgd2FzIHNpZ25lZCBieSBhIHdhbGxldCBhbmRcbiAgICAvLyByZXR1cm4gdGhlIHdhbGxldCBhZGRyZXNzIHRoYXQgdmFsaWRhdGVzXG4gICAgLy8gdGhlIHNpZ25hdHVyZSBvZiB0aGlzIGtleS5cbiAgICBhc3luYyB3YWxsZXRTaWduYXR1cmVBZGRyZXNzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmF0dXJlLndhbGxldEVjZHNhQ29tcGFjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IHdhcyBub3Qgc2lnbmVkIGJ5IGEgd2FsbGV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBrID0gYXdhaXQgdGhpcy5zaWduZXJLZXkoKTtcbiAgICAgICAgaWYgKCFwaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IHNpZ25hdHVyZSBub3QgdmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBrLmdldEV0aGVyZXVtQWRkcmVzcygpO1xuICAgIH1cbiAgICAvLyBJcyBvdGhlciB0aGUgc2FtZS9lcXVpdmFsZW50IHB1YmxpYyBrZXk/XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51bnNpZ25lZEtleS5lcXVhbHMob3RoZXIudW5zaWduZWRLZXkpICYmXG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZS5lcXVhbHMob3RoZXIuc2lnbmF0dXJlKSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBieXRlcyBvZiB0aGUgZW5jb2RlZCB1bnNpZ25lZCBrZXkuXG4gICAgYnl0ZXNUb1NpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUJ5dGVzO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgc2lnbmVkIGtleSBpbnRvIGJ5dGVzLlxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkuU2lnbmVkUHVibGljS2V5LmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIHNpZ25lZCBrZXkgZnJvbSBieXRlcy5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVkUHVibGljS2V5KHB1YmxpY0tleS5TaWduZWRQdWJsaWNLZXkuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxuICAgIHRvTGVnYWN5S2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNGcm9tTGVnYWN5S2V5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gbGVnYWN5IGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmU7XG4gICAgICAgIGlmIChzaWduYXR1cmUud2FsbGV0RWNkc2FDb21wYWN0KSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHtcbiAgICAgICAgICAgICAgICBlY2RzYUNvbXBhY3Q6IHNpZ25hdHVyZS53YWxsZXRFY2RzYUNvbXBhY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLFxuICAgICAgICAgICAgc2VjcDI1NmsxVW5jb21wcmVzc2VkOiB0aGlzLnNlY3AyNTZrMVVuY29tcHJlc3NlZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTGVnYWN5S2V5KGxlZ2FjeUtleSwgc2lnbmVkQnlXYWxsZXQpIHtcbiAgICAgICAgaWYgKCFsZWdhY3lLZXkuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXkgaXMgbm90IHNpZ25lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlID0gbGVnYWN5S2V5LnNpZ25hdHVyZTtcbiAgICAgICAgaWYgKHNpZ25lZEJ5V2FsbGV0KSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHtcbiAgICAgICAgICAgICAgICB3YWxsZXRFY2RzYUNvbXBhY3Q6IHNpZ25hdHVyZS5lY2RzYUNvbXBhY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNpZ25lZFB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXlCeXRlczogbGVnYWN5S2V5LmJ5dGVzVG9TaWduKCksXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIExFR0FDWTogUHVibGljS2V5IG9wdGlvbmFsbHkgc2lnbmVkIHdpdGggYW5vdGhlciB0cnVzdGVkIGtleSBwYWlyIG9yIGEgd2FsbGV0LlxuLy8gUHVibGljS2V5cyBjYW4gYmUgZ2VuZXJhdGVkIHRocm91Z2ggUHJpdmF0ZUtleS5nZW5lcmF0ZSgpXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBVbnNpZ25lZFB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNyZWF0ZWROczogb2JqLnRpbWVzdGFtcC5tdWwoMTAwMDAwMCksXG4gICAgICAgICAgICBzZWNwMjU2azFVbmNvbXByZXNzZWQ6IG9iai5zZWNwMjU2azFVbmNvbXByZXNzZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2JqLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGEgY2FzZSB3aGVyZSBGbHV0dGVyIHdhcyBwdWJsaXNoaW5nIHNpZ25hdHVyZXMgd2l0aCB3YWxsZXRFY2RzYUNvbXBhY3RcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgZWNkc2FDb21wYWN0IGZvciB2MSBrZXlzLlxuICAgICAgICAgICAgaWYgKCFvYmouc2lnbmF0dXJlLmVjZHNhQ29tcGFjdCAmJiBvYmouc2lnbmF0dXJlLndhbGxldEVjZHNhQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIGVjZHNhQ29tcGFjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IG9iai5zaWduYXR1cmUud2FsbGV0RWNkc2FDb21wYWN0LmJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Zlcnk6IG9iai5zaWduYXR1cmUud2FsbGV0RWNkc2FDb21wYWN0LnJlY292ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKG9iai5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0aW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZWROcy5kaXYoMTAwMDAwMCk7XG4gICAgfVxuICAgIGJ5dGVzVG9TaWduKCkge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LlB1YmxpY0tleS5lbmNvZGUoe1xuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHNlY3AyNTZrMVVuY29tcHJlc3NlZDogdGhpcy5zZWNwMjU2azFVbmNvbXByZXNzZWQsXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvLyBzaWduIHRoZSBrZXkgdXNpbmcgYSB3YWxsZXRcbiAgICBhc3luYyBzaWduV2l0aFdhbGxldCh3YWxsZXQpIHtcbiAgICAgICAgY29uc3Qgc2lnU3RyaW5nID0gYXdhaXQgd2FsbGV0LnNpZ25NZXNzYWdlKFdhbGxldFNpZ25lci5pZGVudGl0eVNpZ1JlcXVlc3RUZXh0KHRoaXMuYnl0ZXNUb1NpZ24oKSkpO1xuICAgICAgICBjb25zdCB7IGJ5dGVzLCByZWNvdmVyeSB9ID0gc3BsaXRTaWduYXR1cmUoc2lnU3RyaW5nKTtcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHtcbiAgICAgICAgICAgIGVjZHNhQ29tcGFjdDoge1xuICAgICAgICAgICAgICAgIGJ5dGVzLFxuICAgICAgICAgICAgICAgIHJlY292ZXJ5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFzc3VtZSB0aGUga2V5IHdhcyBzaWduZWQgYnkgYSB3YWxsZXQgYW5kXG4gICAgLy8gcmV0dXJuIHRoZSB3YWxsZXQgYWRkcmVzcyB0aGF0IHZhbGlkYXRlc1xuICAgIC8vIHRoZSBzaWduYXR1cmUgZm9yIHRoaXMga2V5LlxuICAgIHdhbGxldFNpZ25hdHVyZUFkZHJlc3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleSBpcyBub3Qgc2lnbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGhleFRvQnl0ZXMoaGFzaE1lc3NhZ2UoV2FsbGV0U2lnbmVyLmlkZW50aXR5U2lnUmVxdWVzdFRleHQodGhpcy5ieXRlc1RvU2lnbigpKSkpO1xuICAgICAgICBjb25zdCBwayA9IHRoaXMuc2lnbmF0dXJlLmdldFB1YmxpY0tleShkaWdlc3QpO1xuICAgICAgICBpZiAoIXBrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXkgc2lnbmF0dXJlIGlzIG1hbGZvcm1lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGsuZ2V0RXRoZXJldW1BZGRyZXNzKCk7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkuUHVibGljS2V5LmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXkuUHVibGljS2V5LmRlY29kZShieXRlcykpO1xuICAgIH1cbn1cblxuLy8gTEVHQUNZOiBQdWJsaWNLZXlCdW5kbGUgcGFja2FnZXMgYWxsIHRoZSBrZXlzIHRoYXQgYSBwYXJ0aWNpcGFudCBzaG91bGQgYWR2ZXJ0aXNlLlxuLy8gVGhlIFByZUtleSBtdXN0IGJlIHNpZ25lZCBieSB0aGUgSWRlbnRpdHlLZXkuXG4vLyBUaGUgSWRlbnRpdHlLZXkgbXVzdCBiZSBzaWduZWQgYnkgdGhlIHdhbGxldCB0byBhdXRoZW50aWNhdGUgaXQuXG5jbGFzcyBTaWduZWRQdWJsaWNLZXlCdW5kbGUge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZSkge1xuICAgICAgICBpZiAoIWJ1bmRsZS5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidW5kbGUucHJlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByZS1rZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IG5ldyBTaWduZWRQdWJsaWNLZXkoYnVuZGxlLmlkZW50aXR5S2V5KTtcbiAgICAgICAgdGhpcy5wcmVLZXkgPSBuZXcgU2lnbmVkUHVibGljS2V5KGJ1bmRsZS5wcmVLZXkpO1xuICAgIH1cbiAgICB3YWxsZXRTaWduYXR1cmVBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eUtleS53YWxsZXRTaWduYXR1cmVBZGRyZXNzKCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuaWRlbnRpdHlLZXkuZXF1YWxzKG90aGVyLmlkZW50aXR5S2V5KSAmJlxuICAgICAgICAgICAgdGhpcy5wcmVLZXkuZXF1YWxzKG90aGVyLnByZUtleSkpO1xuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LlNpZ25lZFB1YmxpY0tleUJ1bmRsZS5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIGlzRnJvbUxlZ2FjeUJ1bmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHlLZXkuaXNGcm9tTGVnYWN5S2V5KCkgJiYgdGhpcy5wcmVLZXkuaXNGcm9tTGVnYWN5S2V5KCk7XG4gICAgfVxuICAgIHRvTGVnYWN5QnVuZGxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleUJ1bmRsZSh7XG4gICAgICAgICAgICBpZGVudGl0eUtleTogdGhpcy5pZGVudGl0eUtleS50b0xlZ2FjeUtleSgpLFxuICAgICAgICAgICAgcHJlS2V5OiB0aGlzLnByZUtleS50b0xlZ2FjeUtleSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gcHVibGljS2V5LlNpZ25lZFB1YmxpY0tleUJ1bmRsZS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lZFB1YmxpY0tleUJ1bmRsZShkZWNvZGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21MZWdhY3lCdW5kbGUoYnVuZGxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVkUHVibGljS2V5QnVuZGxlKHtcbiAgICAgICAgICAgIC8vIE5vdGU6IEkgYW0gYXNzdW1pbmcgYWxsIFB1YmxpY0tleUJ1bmRsZXMgcGFzc2VkIGludG8gdGhpcyBoYXZlIGhhZCB0aGVpciBpZGVudGl0eSBrZXlzIHNpZ25lZCBieSBhIHdhbGxldFxuICAgICAgICAgICAgLy8gTWF5YmUgdGhhdCBpcyBub3QgdW5pdmVyc2FsbHkgdHJ1ZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICBpZGVudGl0eUtleTogU2lnbmVkUHVibGljS2V5LmZyb21MZWdhY3lLZXkoYnVuZGxlLmlkZW50aXR5S2V5LCB0cnVlKSxcbiAgICAgICAgICAgIHByZUtleTogU2lnbmVkUHVibGljS2V5LmZyb21MZWdhY3lLZXkoYnVuZGxlLnByZUtleSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIExFR0FDWTogUHVibGljS2V5QnVuZGxlIHBhY2thZ2VzIGFsbCB0aGUga2V5cyB0aGF0IGEgcGFydGljaXBhbnQgc2hvdWxkIGFkdmVydGlzZS5cbi8vIFRoZSBQcmVLZXkgbXVzdCBiZSBzaWduZWQgYnkgdGhlIElkZW50aXR5S2V5LlxuLy8gVGhlIElkZW50aXR5S2V5IGNhbiBiZSBzaWduZWQgYnkgdGhlIHdhbGxldCB0byBhdXRoZW50aWNhdGUgaXQuXG5jbGFzcyBQdWJsaWNLZXlCdW5kbGUge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZSkge1xuICAgICAgICBpZiAoIWJ1bmRsZS5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidW5kbGUucHJlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByZS1rZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IG5ldyBQdWJsaWNLZXkoYnVuZGxlLmlkZW50aXR5S2V5KTtcbiAgICAgICAgdGhpcy5wcmVLZXkgPSBuZXcgUHVibGljS2V5KGJ1bmRsZS5wcmVLZXkpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkZW50aXR5S2V5LmVxdWFscyhvdGhlci5pZGVudGl0eUtleSkgJiZcbiAgICAgICAgICAgIHRoaXMucHJlS2V5LmVxdWFscyhvdGhlci5wcmVLZXkpKTtcbiAgICB9XG4gICAgd2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHlLZXkud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LlB1YmxpY0tleUJ1bmRsZS5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHB1YmxpY0tleS5QdWJsaWNLZXlCdW5kbGUuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXlCdW5kbGUoZGVjb2RlZCk7XG4gICAgfVxufVxuXG5jbGFzcyBQcmVwYXJlZE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VFbnZlbG9wZSwgb25TZW5kKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUVudmVsb3BlID0gbWVzc2FnZUVudmVsb3BlO1xuICAgICAgICB0aGlzLm9uU2VuZCA9IG9uU2VuZDtcbiAgICB9XG4gICAgYXN5bmMgbWVzc2FnZUlEKCkge1xuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZUVudmVsb3BlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGVudmVsb3BlIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoYXdhaXQgc2hhMjU2KHRoaXMubWVzc2FnZUVudmVsb3BlLm1lc3NhZ2UpKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25TZW5kKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0cmVhbSBpbXBsZW1lbnRzIGFuIEFzeW5jaHJvbm91cyBJdGVyYWJsZSBvdmVyIG1lc3NhZ2VzIHJlY2VpdmVkIGZyb20gYSB0b3BpYy5cbiAqIEFzIHN1Y2ggY2FuIGJlIHVzZWQgd2l0aCBjb25zdHJ1Y3RzIGxpa2UgZm9yLWF3YWl0LW9mLCB5aWVsZCosIGFycmF5IGRlc3RydWN0aW5nLCBldGMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgdG9waWNzLCBkZWNvZGVyLCBjb250ZW50VG9waWNVcGRhdGVyLCBvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdGhpcy5uZXdNZXNzYWdlQ2FsbGJhY2soZGVjb2RlciwgY29udGVudFRvcGljVXBkYXRlcik7XG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uTG9zdCA9IG9uQ29ubmVjdGlvbkxvc3Q7XG4gICAgfVxuICAgIC8vIHJldHVybnMgbmV3IGNsb3N1cmUgdG8gaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgbmV3TWVzc2FnZUNhbGxiYWNrKGRlY29kZXIsIGNvbnRlbnRUb3BpY1VwZGF0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jIChlbnYpID0+IHtcbiAgICAgICAgICAgIGlmICghZW52Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IGRlY29kZXIoZW52KTtcbiAgICAgICAgICAgICAgICAvLyBkZWNvZGVyIGNhbiByZXR1cm4gdW5kZWZpbmVkIHRvIHNpZ25hbCBhIG1lc3NhZ2UgdG8gaWdub3JlL3NraXAuXG4gICAgICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgc3RyZWFtJ3MgY29udGVudCB0b3BpYyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFRvcGljVXBkYXRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3BpY3MgPSBjb250ZW50VG9waWNVcGRhdGVyKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BpY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWJzY3JpYmVUb1RvcGljcyh0b3BpY3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlzIHRoZXJlIGEgUHJvbWlzZSBhbHJlYWR5IHBlbmRpbmc/XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzLnJlc29sdmVycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8geWVzLCByZXNvbHZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKHsgdmFsdWU6IG1zZyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vLCBwdXNoIHRoZSBtZXNzYWdlIGludG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMudW5zaGlmdChtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNhbGxiYWNrIGZvciBzdHJlYW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5jbGllbnQuYXBpQ2xpZW50LnN1YnNjcmliZSh7XG4gICAgICAgICAgICBjb250ZW50VG9waWNzOiB0aGlzLnRvcGljcyxcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICBhc3luYyAoZW52KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIGF3YWl0IHRoaXM/LmNhbGxiYWNrKGVudik7XG4gICAgICAgIH0sIHRoaXMub25Db25uZWN0aW9uTG9zdCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoY2xpZW50LCB0b3BpY3MsIGRlY29kZXIsIGNvbnRlbnRUb3BpY1VwZGF0ZXIsIG9uQ29ubmVjdGlvbkxvc3QpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbShjbGllbnQsIHRvcGljcywgZGVjb2RlciwgY29udGVudFRvcGljVXBkYXRlciwgb25Db25uZWN0aW9uTG9zdCk7XG4gICAgICAgIGF3YWl0IHN0cmVhbS5zdGFydCgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICAvLyBUbyBtYWtlIFN0cmVhbSBwcm9wZXIgQXN5bmMgSXRlcmFibGVcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJuIHNob3VsZCBiZSBjYWxsZWQgaWYgdGhlIGludGVycHJldGVyIGRldGVjdHMgdGhhdCB0aGUgc3RyZWFtIHdvbid0IGJlIHVzZWQgYW55bW9yZSxcbiAgICAvLyBlLmcuIGEgZm9yL29mIGxvb3Agd2FzIGV4aXRlZCB2aWEgYSBicmVhay4gSXQgY2FuIGFsc28gYmUgY2FsbGVkIGV4cGxpY2l0bHkuXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3RhYmxlLWl0ZXJhdG9yLWludGVyZmFjZS1vcHRpb25hbC1wcm9wZXJ0aWVzXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIFN0cmVhbSB3aWxsIGJlIGNsb3NlZCBhZnRlciBpdCB3YXMgdXNlZCBpbiBhIGZvci1hd2FpdC1vZiBvciB5aWVsZCogb3Igc2ltaWxhci5cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaXB0aW9uTWFuYWdlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzLmZvckVhY2goKHJlc29sdmUpID0+IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWNvbmZ1c2luZy12b2lkLWV4cHJlc3Npb25cbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgfVxuICAgIC8vIFRvIG1ha2UgU3RyZWFtIHByb3BlciBBc3luYyBJdGVyYXRvclxuICAgIC8vIE5vdGUgdGhhdCBuZXh0KCkgd2lsbCBzdGlsbCBwcm92aWRlIHdoYXRldmVyIG1lc3NhZ2VzIHdlcmUgYWxyZWFkeSBwZW5kaW5nXG4gICAgLy8gZXZlbiBhZnRlciB0aGUgc3RyZWFtIHdhcyBjbG9zZWQgdmlhIHJldHVybigpLlxuICAgIG5leHQoKSB7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgbWVzc2FnZSBhbHJlYWR5IHBlbmRpbmc/XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMubWVzc2FnZXMucG9wKCk7XG4gICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIC8vIHllcywgcmV0dXJuIHJlc29sdmVkIHByb21pc2VcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogbXNnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJldHVybiBlbXB0eSBQcm9taXNlIGFuZCBxdWV1ZSBpdHMgcmVzb2x2ZXJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB0aGlzLnJlc29sdmVycy51bnNoaWZ0KHJlc29sdmUpKTtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgZnJvbSB0aGUgZXhpc3RpbmcgY29udGVudCB0b3BpY3MgYW5kIHJlc3Vic2NyaWJlIHRvIHRoZSBnaXZlbiB0b3BpY3MuXG4gICAgYXN5bmMgcmVzdWJzY3JpYmVUb1RvcGljcyh0b3BpY3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrIHx8ICF0aGlzLnN1YnNjcmlwdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY2FsbGJhY2sgZm9yIHN0cmVhbVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3Vic2NyaXB0aW9uTWFuYWdlcj8udXBkYXRlQ29udGVudFRvcGljcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25NYW5hZ2VyLnVwZGF0ZUNvbnRlbnRUb3BpY3ModG9waWNzKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmlwdGlvbk1hbmFnZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuY2xpZW50LmFwaUNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgY29udGVudFRvcGljczogdGhpcy50b3BpY3MsXG4gICAgICAgIH0sIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgYXN5bmMgKGVudikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICBhd2FpdCB0aGlzPy5jYWxsYmFjayhlbnYpO1xuICAgICAgICB9LCB0aGlzLm9uQ29ubmVjdGlvbkxvc3QpO1xuICAgIH1cbn1cblxuY29uc3QgeyBiNjREZWNvZGUsIGI2NEVuY29kZSB9ID0gZmV0Y2hlcjtcbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgYWIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBhYi5zZXQoYSk7XG4gICAgYWIuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYWI7XG59XG5mdW5jdGlvbiBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKSB7XG4gICAgLy8gQ3JlYXRlIGEgYnVmZmVyIGZvciBhIDMyLWJpdCBpbnRlZ2VyXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAvLyBTZXQgdGhlIG51bWJlciBpbiB0aGUgYnVmZmVyXG4gICAgdmlldy5zZXRJbnQzMigwLCBudW0sIHRydWUpOyAvLyB0cnVlIGZvciBsaXR0bGUtZW5kaWFuXG4gICAgLy8gQ3JlYXRlIFVpbnQ4QXJyYXkgZnJvbSBidWZmZXJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBhcnIuYnVmZmVyO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAvLyBSZWFkIHRoZSBudW1iZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgcmV0dXJuIHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7IC8vIHRydWUgZm9yIGxpdHRsZS1lbmRpYW5cbn1cblxuZnVuY3Rpb24gZGF0ZVRvTnMoZGF0ZSkge1xuICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoZGF0ZS52YWx1ZU9mKCkpLm11bHRpcGx5KDFfMDAwXzAwMCk7XG59XG5mdW5jdGlvbiBuc1RvRGF0ZShucykge1xuICAgIHJldHVybiBuZXcgRGF0ZShucy5kaXZpZGUoMV8wMDBfMDAwKS50b051bWJlcigpKTtcbn1cbmNvbnN0IHRvTmFub1N0cmluZyA9IChkKSA9PiB7XG4gICAgcmV0dXJuIGQgJiYgZGF0ZVRvTnMoZCkudG9TdHJpbmcoKTtcbn07XG5jb25zdCBmcm9tTmFub1N0cmluZyA9IChzKSA9PiB7XG4gICAgaWYgKCFzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuc1RvRGF0ZShMb25nLmZyb21TdHJpbmcocykpO1xufTtcblxuY2xhc3MgS2V5c3RvcmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cblxuLy8gVmFsaWRhdGVzIHRoZSBLZXlzdG9yZSByZXNwb25zZS4gVGhyb3dzIG9uIGVycm9ycyBvciBtaXNzaW5nIGZpZWxkcy5cbi8vIFJldHVybnMgYSB0eXBlIHdpdGggYWxsIHBvc3NpYmx5IHVuZGVmaW5lZCBmaWVsZHMgcmVxdWlyZWQgdG8gYmUgZGVmaW5lZFxuY29uc3QgZ2V0UmVzdWx0T3JUaHJvdyA9IChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihyZXNwb25zZS5lcnJvci5jb2RlLCByZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5yZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlRXJyb3Ioa2V5c3RvcmUuRXJyb3JDb2RlLkVSUk9SX0NPREVfVU5TUEVDSUZJRUQsIFwiTm8gcmVzdWx0IGZyb20gS2V5c3RvcmVcIik7XG4gICAgfVxuICAgIGlmIChcImVuY3J5cHRlZFwiIGluIHJlc3BvbnNlLnJlc3VsdCAmJiAhcmVzcG9uc2UucmVzdWx0LmVuY3J5cHRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNpcGhlcnRleHRcIik7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKFwiZGVjcnlwdGVkXCIgaW4gcmVzcG9uc2UucmVzdWx0ICYmICFyZXNwb25zZS5yZXN1bHQuZGVjcnlwdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGVjcnlwdGVkIHJlc3VsdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbn07XG5jb25zdCBidWlsZERlY3J5cHRWMVJlcXVlc3QgPSAobWVzc2FnZXMsIG15UHVibGljS2V5QnVuZGxlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdHM6IG1lc3NhZ2VzLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VuZGVyID0gbmV3IFB1YmxpY0tleUJ1bmRsZSh7XG4gICAgICAgICAgICAgICAgaWRlbnRpdHlLZXk6IG0uaGVhZGVyLnNlbmRlcj8uaWRlbnRpdHlLZXksXG4gICAgICAgICAgICAgICAgcHJlS2V5OiBtLmhlYWRlci5zZW5kZXI/LnByZUtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXNTZW5kZXIgPSBteVB1YmxpY0tleUJ1bmRsZS5lcXVhbHMoc2VuZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogbS5jaXBoZXJ0ZXh0LFxuICAgICAgICAgICAgICAgIHBlZXJLZXlzOiBpc1NlbmRlclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBQdWJsaWNLZXlCdW5kbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHlLZXk6IG0uaGVhZGVyLnJlY2lwaWVudD8uaWRlbnRpdHlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVLZXk6IG0uaGVhZGVyLnJlY2lwaWVudD8ucHJlS2V5LFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IHNlbmRlcixcbiAgICAgICAgICAgICAgICBoZWFkZXJCeXRlczogbS5oZWFkZXJCeXRlcyxcbiAgICAgICAgICAgICAgICBpc1NlbmRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgIH07XG59O1xuXG5jb25zdCBidWlsZENvbnRlbnRUb3BpYyA9IChuYW1lKSA9PiBgL3htdHAvMC8ke25hbWV9L3Byb3RvYDtcbmNvbnN0IGJ1aWxkRGlyZWN0TWVzc2FnZVRvcGljID0gKHNlbmRlciwgcmVjaXBpZW50KSA9PiB7XG4gICAgLy8gRUlQNTUgbm9ybWFsaXplIHRoZSBhZGRyZXNzIGNhc2UuXG4gICAgY29uc3QgbWVtYmVycyA9IFtnZXRBZGRyZXNzKHNlbmRlciksIGdldEFkZHJlc3MocmVjaXBpZW50KV07XG4gICAgbWVtYmVycy5zb3J0KCk7XG4gICAgcmV0dXJuIGJ1aWxkQ29udGVudFRvcGljKGBkbS0ke21lbWJlcnMuam9pbihcIi1cIil9YCk7XG59O1xuY29uc3QgYnVpbGREaXJlY3RNZXNzYWdlVG9waWNWMiA9IChyYW5kb21TdHJpbmcpID0+IHtcbiAgICByZXR1cm4gYnVpbGRDb250ZW50VG9waWMoYG0tJHtyYW5kb21TdHJpbmd9YCk7XG59O1xuY29uc3QgYnVpbGRVc2VyQ29udGFjdFRvcGljID0gKHdhbGxldEFkZHIpID0+IHtcbiAgICAvLyBFSVA1NSBub3JtYWxpemUgdGhlIGFkZHJlc3MgY2FzZS5cbiAgICByZXR1cm4gYnVpbGRDb250ZW50VG9waWMoYGNvbnRhY3QtJHtnZXRBZGRyZXNzKHdhbGxldEFkZHIpfWApO1xufTtcbmNvbnN0IGJ1aWxkVXNlckludHJvVG9waWMgPSAod2FsbGV0QWRkcikgPT4ge1xuICAgIC8vIEVJUDU1IG5vcm1hbGl6ZSB0aGUgYWRkcmVzcyBjYXNlLlxuICAgIHJldHVybiBidWlsZENvbnRlbnRUb3BpYyhgaW50cm8tJHtnZXRBZGRyZXNzKHdhbGxldEFkZHIpfWApO1xufTtcbmNvbnN0IGJ1aWxkVXNlckludml0ZVRvcGljID0gKHdhbGxldEFkZHIpID0+IHtcbiAgICAvLyBFSVA1NSBub3JtYWxpemUgdGhlIGFkZHJlc3MgY2FzZS5cbiAgICByZXR1cm4gYnVpbGRDb250ZW50VG9waWMoYGludml0ZS0ke2dldEFkZHJlc3Mod2FsbGV0QWRkcil9YCk7XG59O1xuY29uc3QgYnVpbGRVc2VyUHJpdmF0ZVN0b3JlVG9waWMgPSAoYWRkclByZWZpeGVkS2V5KSA9PiB7XG4gICAgLy8gZS5nLiBcIjB4MTExMTExMTExMTIyMjIyMjIyMjIzMzMzMzMzMzMzNDQ0NDQ0NDQ0NC9rZXlfYnVuZGxlXCJcbiAgICByZXR1cm4gYnVpbGRDb250ZW50VG9waWMoYHByaXZhdGVzdG9yZS0ke2FkZHJQcmVmaXhlZEtleX1gKTtcbn07XG5jb25zdCBidWlsZFVzZXJQcml2YXRlUHJlZmVyZW5jZXNUb3BpYyA9IChpZGVudGlmaWVyKSA9PiBidWlsZENvbnRlbnRUb3BpYyhgdXNlcnByZWZlcmVuY2VzLSR7aWRlbnRpZmllcn1gKTtcbi8vIHZhbGlkYXRlIHRoYXQgYSB0b3BpYyBvbmx5IGNvbnRhaW5zIEFTQ0lJIGNoYXJhY3RlcnMgMzMtMTI3XG5jb25zdCBpc1ZhbGlkVG9waWMgPSAodG9waWMpID0+IHtcbiAgICBjb25zdCByZWdleCA9IC9eW1xceDIxLVxceDdGXSskLztcbiAgICBjb25zdCBpbmRleCA9IHRvcGljLmluZGV4T2YoXCIwL1wiKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHVud3JhcHBlZFRvcGljID0gdG9waWMuc3Vic3RyaW5nKGluZGV4ICsgMiwgdG9waWMubGFzdEluZGV4T2YoXCIvcHJvdG9cIikpO1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh1bndyYXBwZWRUb3BpYyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVyc2F0aW9uVjEgYWxsb3dzIHlvdSB0byB2aWV3LCBzdHJlYW0sIGFuZCBzZW5kIG1lc3NhZ2VzIHRvL2Zyb20gYSBwZWVyIGFkZHJlc3NcbiAqL1xuY2xhc3MgQ29udmVyc2F0aW9uVjEge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgYWRkcmVzcywgY3JlYXRlZEF0KSB7XG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBlZXJBZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgIH1cbiAgICBnZXQgY2xpZW50QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGFsbG93KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb250YWN0cy5hbGxvdyhbdGhpcy5wZWVyQWRkcmVzc10pO1xuICAgIH1cbiAgICBhc3luYyBkZW55KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb250YWN0cy5kZW55KFt0aGlzLnBlZXJBZGRyZXNzXSk7XG4gICAgfVxuICAgIGdldCBpc0FsbG93ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb250YWN0cy5pc0FsbG93ZWQodGhpcy5wZWVyQWRkcmVzcyk7XG4gICAgfVxuICAgIGdldCBpc0RlbmllZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbnRhY3RzLmlzRGVuaWVkKHRoaXMucGVlckFkZHJlc3MpO1xuICAgIH1cbiAgICBnZXQgY29uc2VudFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY29udGFjdHMuY29uc2VudFN0YXRlKHRoaXMucGVlckFkZHJlc3MpO1xuICAgIH1cbiAgICBnZXQgdG9waWMoKSB7XG4gICAgICAgIHJldHVybiBidWlsZERpcmVjdE1lc3NhZ2VUb3BpYyh0aGlzLnBlZXJBZGRyZXNzLCB0aGlzLmNsaWVudC5hZGRyZXNzKTtcbiAgICB9XG4gICAgZ2V0IGVwaGVtZXJhbFRvcGljKCkge1xuICAgICAgICByZXR1cm4gYnVpbGREaXJlY3RNZXNzYWdlVG9waWModGhpcy5wZWVyQWRkcmVzcywgdGhpcy5jbGllbnQuYWRkcmVzcykucmVwbGFjZShcIi94bXRwLzAvZG0tXCIsIFwiL3htdHAvMC9kbUUtXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgbWVzc2FnZXMgdG8vZnJvbSB0aGUgcGVlckFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyBtZXNzYWdlcyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IHRvcGljID0gYnVpbGREaXJlY3RNZXNzYWdlVG9waWModGhpcy5wZWVyQWRkcmVzcywgdGhpcy5jbGllbnQuYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdGhpcy5jbGllbnQubGlzdEVudmVsb3Blcyh0b3BpYywgdGhpcy5wcm9jZXNzRW52ZWxvcGUuYmluZCh0aGlzKSwgb3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRCYXRjaChtZXNzYWdlcywgdG9waWMsIGZhbHNlKTtcbiAgICB9XG4gICAgbWVzc2FnZXNQYWdpbmF0ZWQob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubGlzdEVudmVsb3Blc1BhZ2luYXRlZCh0aGlzLnRvcGljLCBcbiAgICAgICAgLy8gVGhpcyB3b24ndCBiZSBwZXJmb3JtYW50IG9uY2Ugd2Ugc3RhcnQgc3VwcG9ydGluZyBhIHJlbW90ZSBrZXlzdG9yZVxuICAgICAgICAvLyBUT0RPOiBFaXRoZXIgYmV0dGVyIGJhdGNoIHN1cHBvcnQgb3Igd2UgZGl0Y2ggdGhpcyB1bmRlci11dGlsaXplZCBmZWF0dXJlXG4gICAgICAgIHRoaXMuZGVjb2RlTWVzc2FnZS5iaW5kKHRoaXMpLCBvcHRzKTtcbiAgICB9XG4gICAgLy8gZGVjb2RlTWVzc2FnZSB0YWtlcyBhbiBlbnZlbG9wZSBhbmQgZWl0aGVyIHJldHVybnMgYSBgRGVjb2RlZE1lc3NhZ2VgIG9yIHRocm93cyBpZiBhbiBlcnJvciBvY2N1cnNcbiAgICBhc3luYyBkZWNvZGVNZXNzYWdlKGVudikge1xuICAgICAgICBpZiAoIWVudi5jb250ZW50VG9waWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29udGVudCB0b3BpY1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCB0aGlzLnByb2Nlc3NFbnZlbG9wZShlbnYpO1xuICAgICAgICBjb25zdCBkZWNyeXB0UmVzdWx0cyA9IGF3YWl0IHRoaXMuZGVjcnlwdEJhdGNoKFttc2ddLCBlbnYuY29udGVudFRvcGljLCB0cnVlKTtcbiAgICAgICAgaWYgKCFkZWNyeXB0UmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3VsdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHRzWzBdO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShjb250ZW50LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIGxldCB0b3BpY3M7XG4gICAgICAgIGxldCByZWNpcGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRVc2VyQ29udGFjdCh0aGlzLnBlZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKCFyZWNpcGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVjaXBpZW50ICR7dGhpcy5wZWVyQWRkcmVzc30gaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZWNpcGllbnQgaW5zdGFuY2VvZiBQdWJsaWNLZXlCdW5kbGUpKSB7XG4gICAgICAgICAgICByZWNpcGllbnQgPSByZWNpcGllbnQudG9MZWdhY3lCdW5kbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnM/LmVwaGVtZXJhbCA/IHRoaXMuZXBoZW1lcmFsVG9waWMgOiB0aGlzLnRvcGljO1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50LmNvbnRhY3RzLmFkZHJlc3Nlcy5oYXModGhpcy5wZWVyQWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRvcGljcyA9IFtcbiAgICAgICAgICAgICAgICBidWlsZFVzZXJJbnRyb1RvcGljKHRoaXMucGVlckFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIGJ1aWxkVXNlckludHJvVG9waWModGhpcy5jbGllbnQuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuY29udGFjdHMuYWRkcmVzc2VzLmFkZCh0aGlzLnBlZXJBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvcGljcyA9IFt0b3BpY107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5lbmNvZGVDb250ZW50KGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCB0aGlzLmNyZWF0ZU1lc3NhZ2UocGF5bG9hZCwgcmVjaXBpZW50LCBvcHRpb25zPy50aW1lc3RhbXApO1xuICAgICAgICBjb25zdCBtc2dCeXRlcyA9IG1zZy50b0J5dGVzKCk7XG4gICAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogdG9waWMsXG4gICAgICAgICAgICBtZXNzYWdlOiBtc2dCeXRlcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcE5zOiB0b05hbm9TdHJpbmcobXNnLnNlbnQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkTWVzc2FnZShlbnYsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnB1Ymxpc2hFbnZlbG9wZXModG9waWNzLm1hcCgodG9waWMpID0+ICh7XG4gICAgICAgICAgICAgICAgY29udGVudFRvcGljOiB0b3BpYyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dCeXRlcyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG1zZy5zZW50LFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkTWVzc2FnZS5mcm9tVjFNZXNzYWdlKG1zZywgY29udGVudCwgb3B0aW9ucz8uY29udGVudFR5cGUgfHwgQ29udGVudFR5cGVUZXh0LCBwYXlsb2FkLCB0b3BpYywgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3RyZWFtIG9mIGFueSBuZXcgbWVzc2FnZXMgdG8vZnJvbSB0aGUgcGVlckFkZHJlc3NcbiAgICAgKi9cbiAgICBzdHJlYW1NZXNzYWdlcyhvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIHJldHVybiBTdHJlYW0uY3JlYXRlKHRoaXMuY2xpZW50LCBbdGhpcy50b3BpY10sIGFzeW5jIChlbnYpID0+IHRoaXMuZGVjb2RlTWVzc2FnZShlbnYpLCB1bmRlZmluZWQsIG9uQ29ubmVjdGlvbkxvc3QpO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzRW52ZWxvcGUoeyBtZXNzYWdlLCBjb250ZW50VG9waWMsIH0pIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8ICFtZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgZW52ZWxvcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IE1lc3NhZ2VWMS5mcm9tQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgc2VuZGVyQWRkcmVzcywgcmVjaXBpZW50QWRkcmVzcyB9ID0gZGVjb2RlZDtcbiAgICAgICAgLy8gRmlsdGVyIGZvciB0b3BpY3NcbiAgICAgICAgaWYgKCFzZW5kZXJBZGRyZXNzIHx8XG4gICAgICAgICAgICAhcmVjaXBpZW50QWRkcmVzcyB8fFxuICAgICAgICAgICAgIWNvbnRlbnRUb3BpYyB8fFxuICAgICAgICAgICAgYnVpbGREaXJlY3RNZXNzYWdlVG9waWMoc2VuZGVyQWRkcmVzcywgcmVjaXBpZW50QWRkcmVzcykgIT09IHRoaXMudG9waWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgZG8gbm90IG1hdGNoIGludGVuZGVkIHJlY2lwaWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gICAgc3RyZWFtRXBoZW1lcmFsKG9uQ29ubmVjdGlvbkxvc3QpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbS5jcmVhdGUodGhpcy5jbGllbnQsIFt0aGlzLmVwaGVtZXJhbFRvcGljXSwgdGhpcy5kZWNvZGVNZXNzYWdlLmJpbmQodGhpcyksIHVuZGVmaW5lZCwgb25Db25uZWN0aW9uTG9zdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHRvcGljcztcbiAgICAgICAgbGV0IHJlY2lwaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50LmdldFVzZXJDb250YWN0KHRoaXMucGVlckFkZHJlc3MpO1xuICAgICAgICBpZiAoIXJlY2lwaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWNpcGllbnQgJHt0aGlzLnBlZXJBZGRyZXNzfSBpcyBub3QgcmVnaXN0ZXJlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHJlY2lwaWVudCBpbnN0YW5jZW9mIFB1YmxpY0tleUJ1bmRsZSkpIHtcbiAgICAgICAgICAgIHJlY2lwaWVudCA9IHJlY2lwaWVudC50b0xlZ2FjeUJ1bmRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljID0gb3B0aW9ucz8uZXBoZW1lcmFsID8gdGhpcy5lcGhlbWVyYWxUb3BpYyA6IHRoaXMudG9waWM7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuY29udGFjdHMuYWRkcmVzc2VzLmhhcyh0aGlzLnBlZXJBZGRyZXNzKSkge1xuICAgICAgICAgICAgdG9waWNzID0gW1xuICAgICAgICAgICAgICAgIGJ1aWxkVXNlckludHJvVG9waWModGhpcy5wZWVyQWRkcmVzcyksXG4gICAgICAgICAgICAgICAgYnVpbGRVc2VySW50cm9Ub3BpYyh0aGlzLmNsaWVudC5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5jb250YWN0cy5hZGRyZXNzZXMuYWRkKHRoaXMucGVlckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9waWNzID0gW3RvcGljXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlIHx8IENvbnRlbnRUeXBlVGV4dDtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5lbmNvZGVDb250ZW50KGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCB0aGlzLmNyZWF0ZU1lc3NhZ2UocGF5bG9hZCwgcmVjaXBpZW50LCBvcHRpb25zPy50aW1lc3RhbXApO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5wdWJsaXNoRW52ZWxvcGVzKHRvcGljcy5tYXAoKHRvcGljKSA9PiAoe1xuICAgICAgICAgICAgY29udGVudFRvcGljOiB0b3BpYyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZy50b0J5dGVzKCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG1zZy5zZW50LFxuICAgICAgICB9KSkpO1xuICAgICAgICAvLyBpZiB0aGUgY29udmVyc2F0aW9uIGNvbnNlbnQgc3RhdGUgaXMgdW5rbm93biwgd2UgYXNzdW1lIHRoZSB1c2VyIGhhc1xuICAgICAgICAvLyBjb25zZW50ZWQgdG8gdGhlIGNvbnZlcnNhdGlvbiBieSBzZW5kaW5nIGEgbWVzc2FnZSBpbnRvIGl0XG4gICAgICAgIGlmICh0aGlzLmNvbnNlbnRTdGF0ZSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgICAgICAgICAgIC8vIGFkZCBjb252ZXJzYXRpb24gdG8gdGhlIGFsbG93IGxpc3RcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWxsb3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb2RlZE1lc3NhZ2UuZnJvbVYxTWVzc2FnZShtc2csIGNvbnRlbnQsIGNvbnRlbnRUeXBlLCBwYXlsb2FkLCB0b3BpYywgdGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHRCYXRjaChtZXNzYWdlcywgdG9waWMsIHRocm93T25FcnJvciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IChhd2FpdCB0aGlzLmNsaWVudC5rZXlzdG9yZS5kZWNyeXB0VjEoYnVpbGREZWNyeXB0VjFSZXF1ZXN0KG1lc3NhZ2VzLCB0aGlzLmNsaWVudC5wdWJsaWNLZXlCdW5kbGUpKSkucmVzcG9uc2VzO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWNyeXB0ZWQgfSA9IGdldFJlc3VsdE9yVGhyb3cocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChhd2FpdCB0aGlzLmJ1aWxkRGVjb2RlZE1lc3NhZ2UobWVzc2FnZSwgZGVjcnlwdGVkLCB0b3BpYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGRlY29kaW5nIGNvbnRlbnRcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGREZWNvZGVkTWVzc2FnZShtZXNzYWdlLCBkZWNyeXB0ZWQsIHRvcGljKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudCwgY29udGVudFR5cGUsIGVycm9yLCBjb250ZW50RmFsbGJhY2sgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmRlY29kZUNvbnRlbnQoZGVjcnlwdGVkKTtcbiAgICAgICAgcmV0dXJuIERlY29kZWRNZXNzYWdlLmZyb21WMU1lc3NhZ2UobWVzc2FnZSwgY29udGVudCwgY29udGVudFR5cGUsIGRlY3J5cHRlZCwgdG9waWMsIHRoaXMsIGVycm9yLCBjb250ZW50RmFsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVNZXNzYWdlKFxuICAgIC8vIFBheWxvYWQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG91dHB1dCBvZiBgY2xpZW50LmVuY29kZUNvbnRlbnRgXG4gICAgcGF5bG9hZCwgcmVjaXBpZW50LCB0aW1lc3RhbXApIHtcbiAgICAgICAgdGltZXN0YW1wID0gdGltZXN0YW1wIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBNZXNzYWdlVjEuZW5jb2RlKHRoaXMuY2xpZW50LmtleXN0b3JlLCBwYXlsb2FkLCB0aGlzLmNsaWVudC5wdWJsaWNLZXlCdW5kbGUsIHJlY2lwaWVudCwgdGltZXN0YW1wKTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnNhdGlvblYyXG4gKi9cbmNsYXNzIENvbnZlcnNhdGlvblYyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHRvcGljLCBwZWVyQWRkcmVzcywgY3JlYXRlZEF0LCBjb250ZXh0LCBjb25zZW50UHJvb2YpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5wZWVyQWRkcmVzcyA9IHBlZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLmNvbnNlbnRQcm9vZiA9IGNvbnNlbnRQcm9vZjtcbiAgICB9XG4gICAgZ2V0IGNsaWVudEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5hZGRyZXNzO1xuICAgIH1cbiAgICBhc3luYyBhbGxvdygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29udGFjdHMuYWxsb3coW3RoaXMucGVlckFkZHJlc3NdKTtcbiAgICB9XG4gICAgYXN5bmMgZGVueSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29udGFjdHMuZGVueShbdGhpcy5wZWVyQWRkcmVzc10pO1xuICAgIH1cbiAgICBnZXQgaXNBbGxvd2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY29udGFjdHMuaXNBbGxvd2VkKHRoaXMucGVlckFkZHJlc3MpO1xuICAgIH1cbiAgICBnZXQgaXNEZW5pZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb250YWN0cy5pc0RlbmllZCh0aGlzLnBlZXJBZGRyZXNzKTtcbiAgICB9XG4gICAgZ2V0IGNvbnNlbnRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbnRhY3RzLmNvbnNlbnRTdGF0ZSh0aGlzLnBlZXJBZGRyZXNzKTtcbiAgICB9XG4gICAgZ2V0IGNvbnNlbnRQcm9vZlBheWxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlbnRQcm9vZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIG1lc3NhZ2VzIHRvL2Zyb20gdGhlIHBlZXJBZGRyZXNzXG4gICAgICovXG4gICAgYXN5bmMgbWVzc2FnZXMob3B0cykge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IHRoaXMuY2xpZW50Lmxpc3RFbnZlbG9wZXModGhpcy50b3BpYywgdGhpcy5wcm9jZXNzRW52ZWxvcGUuYmluZCh0aGlzKSwgb3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRCYXRjaChtZXNzYWdlcywgZmFsc2UpO1xuICAgIH1cbiAgICBtZXNzYWdlc1BhZ2luYXRlZChvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5saXN0RW52ZWxvcGVzUGFnaW5hdGVkKHRoaXMudG9waWMsIHRoaXMuZGVjb2RlTWVzc2FnZS5iaW5kKHRoaXMpLCBvcHRzKTtcbiAgICB9XG4gICAgZ2V0IGVwaGVtZXJhbFRvcGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BpYy5yZXBsYWNlKFwiL3htdHAvMC9tXCIsIFwiL3htdHAvMC9tRVwiKTtcbiAgICB9XG4gICAgc3RyZWFtRXBoZW1lcmFsKG9uQ29ubmVjdGlvbkxvc3QpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbS5jcmVhdGUodGhpcy5jbGllbnQsIFt0aGlzLmVwaGVtZXJhbFRvcGljXSwgdGhpcy5kZWNvZGVNZXNzYWdlLmJpbmQodGhpcyksIHVuZGVmaW5lZCwgb25Db25uZWN0aW9uTG9zdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJlYW0gb2YgYW55IG5ldyBtZXNzYWdlcyB0by9mcm9tIHRoZSBwZWVyQWRkcmVzc1xuICAgICAqL1xuICAgIHN0cmVhbU1lc3NhZ2VzKG9uQ29ubmVjdGlvbkxvc3QpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbS5jcmVhdGUodGhpcy5jbGllbnQsIFt0aGlzLnRvcGljXSwgdGhpcy5kZWNvZGVNZXNzYWdlLmJpbmQodGhpcyksIHVuZGVmaW5lZCwgb25Db25uZWN0aW9uTG9zdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIGludG8gdGhlIGNvbnZlcnNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQsIHNob3VsZFB1c2ggfSA9IGF3YWl0IHRoaXMuY2xpZW50LmVuY29kZUNvbnRlbnQoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IHRoaXMuY3JlYXRlTWVzc2FnZShwYXlsb2FkLCBzaG91bGRQdXNoLCBvcHRpb25zPy50aW1lc3RhbXApO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnM/LmVwaGVtZXJhbCA/IHRoaXMuZXBoZW1lcmFsVG9waWMgOiB0aGlzLnRvcGljO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5wdWJsaXNoRW52ZWxvcGVzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9waWM6IHRvcGljLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZy50b0J5dGVzKCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBtc2cuc2VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlIHx8IENvbnRlbnRUeXBlVGV4dDtcbiAgICAgICAgLy8gaWYgdGhlIGNvbnZlcnNhdGlvbiBjb25zZW50IHN0YXRlIGlzIHVua25vd24sIHdlIGFzc3VtZSB0aGUgdXNlciBoYXNcbiAgICAgICAgLy8gY29uc2VudGVkIHRvIHRoZSBjb252ZXJzYXRpb24gYnkgc2VuZGluZyBhIG1lc3NhZ2UgaW50byBpdFxuICAgICAgICBpZiAodGhpcy5jb25zZW50U3RhdGUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgICAvLyBhZGQgY29udmVyc2F0aW9uIHRvIHRoZSBhbGxvdyBsaXN0XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFsbG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29kZWRNZXNzYWdlLmZyb21WMk1lc3NhZ2UobXNnLCBjb250ZW50LCBjb250ZW50VHlwZSwgdG9waWMsIHBheWxvYWQsIHRoaXMsIHRoaXMuY2xpZW50LmFkZHJlc3MpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVNZXNzYWdlKFxuICAgIC8vIFBheWxvYWQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhbHJlYWR5IGdvbmUgdGhyb3VnaCBgY2xpZW50LmVuY29kZUNvbnRlbnRgXG4gICAgcGF5bG9hZCwgc2hvdWxkUHVzaCwgdGltZXN0YW1wKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLnRvcGljLFxuICAgICAgICAgICAgY3JlYXRlZE5zOiBkYXRlVG9Ocyh0aW1lc3RhbXAgfHwgbmV3IERhdGUoKSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhlYWRlckJ5dGVzID0gbWVzc2FnZS5NZXNzYWdlSGVhZGVyVjIuZW5jb2RlKGhlYWRlcikuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHNoYTI1Nihjb25jYXQoaGVhZGVyQnl0ZXMsIHBheWxvYWQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0ge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpcy5jbGllbnQuc2lnbmVkUHVibGljS2V5QnVuZGxlLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBhd2FpdCB0aGlzLmNsaWVudC5rZXlzdG9yZS5zaWduRGlnZXN0KHtcbiAgICAgICAgICAgICAgICBkaWdlc3QsXG4gICAgICAgICAgICAgICAgcHJla2V5SW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaWduZWRCeXRlcyA9IGNvbnRlbnQuU2lnbmVkQ29udGVudC5lbmNvZGUoc2lnbmVkKS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWQ6IGNpcGhlcnRleHQsIHNlbmRlckhtYWMgfSA9IGF3YWl0IHRoaXMuZW5jcnlwdE1lc3NhZ2Uoc2lnbmVkQnl0ZXMsIGhlYWRlckJ5dGVzKTtcbiAgICAgICAgY29uc3QgcHJvdG9Nc2cgPSB7XG4gICAgICAgICAgICB2MTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdjI6IHsgaGVhZGVyQnl0ZXMsIGNpcGhlcnRleHQsIHNlbmRlckhtYWMsIHNob3VsZFB1c2ggfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBtZXNzYWdlLk1lc3NhZ2UuZW5jb2RlKHByb3RvTXNnKS5maW5pc2goKTtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VWMi5jcmVhdGUocHJvdG9Nc2csIGhlYWRlciwgYnl0ZXMsIHNlbmRlckhtYWMsIHNob3VsZFB1c2gpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0QmF0Y2gobWVzc2FnZXMsIHRocm93T25FcnJvciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IChhd2FpdCB0aGlzLmNsaWVudC5rZXlzdG9yZS5kZWNyeXB0VjIodGhpcy5idWlsZERlY3J5cHRSZXF1ZXN0KG1lc3NhZ2VzKSkpLnJlc3BvbnNlcztcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZXNbaV07XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVjcnlwdGVkIH0gPSBnZXRSZXN1bHRPclRocm93KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goYXdhaXQgdGhpcy5idWlsZERlY29kZWRNZXNzYWdlKG1lc3NhZ2UsIGRlY3J5cHRlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGRlY29kaW5nIGNvbnRlbnRcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgYnVpbGREZWNyeXB0UmVxdWVzdChtZXNzYWdlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdHM6IG1lc3NhZ2VzLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG0uY2lwaGVydGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyQnl0ZXM6IG0uaGVhZGVyQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogdGhpcy50b3BpYyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHRNZXNzYWdlKHBheWxvYWQsIGhlYWRlckJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2VzIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5rZXlzdG9yZS5lbmNyeXB0VjIoe1xuICAgICAgICAgICAgcmVxdWVzdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlckJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VG9waWM6IHRoaXMudG9waWMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWQsIHNlbmRlckhtYWMgfSA9IGdldFJlc3VsdE9yVGhyb3cocmVzcG9uc2VzWzBdKTtcbiAgICAgICAgcmV0dXJuIHsgZW5jcnlwdGVkLCBzZW5kZXJIbWFjIH07XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkRGVjb2RlZE1lc3NhZ2UobXNnLCBkZWNyeXB0ZWQpIHtcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBkZWNyeXB0ZWQgYnl0ZXMgaW50byBTaWduZWRDb250ZW50XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IGNvbnRlbnQuU2lnbmVkQ29udGVudC5kZWNvZGUoZGVjcnlwdGVkKTtcbiAgICAgICAgaWYgKCFzaWduZWQuc2VuZGVyPy5pZGVudGl0eUtleSB8fFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgICFzaWduZWQuc2VuZGVyPy5wcmVLZXkgfHxcbiAgICAgICAgICAgICFzaWduZWQuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbXBsZXRlIHNpZ25lZCBjb250ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlUHJla2V5cyhzaWduZWQpO1xuICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBhd2FpdCBzaGEyNTYoY29uY2F0KG1zZy5oZWFkZXJCeXRlcywgc2lnbmVkLnBheWxvYWQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAhbmV3IFNpZ25lZFB1YmxpY0tleShzaWduZWQuc2VuZGVyPy5wcmVLZXkpLnZlcmlmeShuZXcgU2lnbmF0dXJlKHNpZ25lZC5zaWduYXR1cmUpLCBkaWdlc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXJpdmUgdGhlIHNlbmRlciBhZGRyZXNzIGZyb20gdGhlIHZhbGlkIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gYXdhaXQgbmV3IFNpZ25lZFB1YmxpY0tleUJ1bmRsZShzaWduZWQuc2VuZGVyKS53YWxsZXRTaWduYXR1cmVBZGRyZXNzKCk7XG4gICAgICAgIGNvbnN0IHsgY29udGVudDogY29udGVudCQxLCBjb250ZW50VHlwZSwgZXJyb3IsIGNvbnRlbnRGYWxsYmFjayB9ID0gYXdhaXQgdGhpcy5jbGllbnQuZGVjb2RlQ29udGVudChzaWduZWQucGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBEZWNvZGVkTWVzc2FnZS5mcm9tVjJNZXNzYWdlKG1zZywgY29udGVudCQxLCBjb250ZW50VHlwZSwgdGhpcy50b3BpYywgc2lnbmVkLnBheWxvYWQsIHRoaXMsIHNlbmRlckFkZHJlc3MsIGVycm9yLCBjb250ZW50RmFsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlTWVzc2FnZShjb250ZW50LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgc2hvdWxkUHVzaCB9ID0gYXdhaXQgdGhpcy5jbGllbnQuZW5jb2RlQ29udGVudChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IHRoaXMuY3JlYXRlTWVzc2FnZShwYXlsb2FkLCBzaG91bGRQdXNoLCBvcHRpb25zPy50aW1lc3RhbXApO1xuICAgICAgICBjb25zdCBtc2dCeXRlcyA9IG1zZy50b0J5dGVzKCk7XG4gICAgICAgIGNvbnN0IHRvcGljID0gb3B0aW9ucz8uZXBoZW1lcmFsID8gdGhpcy5lcGhlbWVyYWxUb3BpYyA6IHRoaXMudG9waWM7XG4gICAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYzogdG9waWMsXG4gICAgICAgICAgICBtZXNzYWdlOiBtc2dCeXRlcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcE5zOiB0b05hbm9TdHJpbmcobXNnLnNlbnQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkTWVzc2FnZShlbnYsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnB1Ymxpc2hFbnZlbG9wZXMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFRvcGljOiB0b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbXNnLnNlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIERlY29kZWRNZXNzYWdlLmZyb21WMk1lc3NhZ2UobXNnLCBjb250ZW50LCBvcHRpb25zPy5jb250ZW50VHlwZSB8fCBDb250ZW50VHlwZVRleHQsIHRvcGljLCBwYXlsb2FkLCB0aGlzLCB0aGlzLmNsaWVudC5hZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NFbnZlbG9wZShlbnYpIHtcbiAgICAgICAgaWYgKCFlbnYubWVzc2FnZSB8fCAhZW52LmNvbnRlbnRUb3BpYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgZW52ZWxvcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnID0gbWVzc2FnZS5NZXNzYWdlLmRlY29kZShlbnYubWVzc2FnZSk7XG4gICAgICAgIGlmICghbXNnLnYyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1lc3NhZ2UgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBtZXNzYWdlLk1lc3NhZ2VIZWFkZXJWMi5kZWNvZGUobXNnLnYyLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgaWYgKGhlYWRlci50b3BpYyAhPT0gdGhpcy50b3BpYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9waWMgbWlzbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VWMi5jcmVhdGUobXNnLCBoZWFkZXIsIGVudi5tZXNzYWdlLCBtc2cudjIuc2VuZGVySG1hYywgbXNnLnYyLnNob3VsZFB1c2gpO1xuICAgIH1cbiAgICBhc3luYyBkZWNvZGVNZXNzYWdlKGVudikge1xuICAgICAgICBpZiAoIWVudi5jb250ZW50VG9waWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29udGVudCB0b3BpY1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCB0aGlzLnByb2Nlc3NFbnZlbG9wZShlbnYpO1xuICAgICAgICBjb25zdCBkZWNyeXB0UmVzdWx0cyA9IGF3YWl0IHRoaXMuZGVjcnlwdEJhdGNoKFttc2ddLCB0cnVlKTtcbiAgICAgICAgaWYgKCFkZWNyeXB0UmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3VsdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHRzWzBdO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUHJla2V5cyhzaWduZWQpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBwcmUga2V5IGlzIHNpZ25lZCBieSB0aGUgaWRlbnRpdHkga2V5XG4gICAgLy8gdGhpcyBpcyByZXF1aXJlZCB0byBjaGFpbiB0aGUgcHJla2V5LXNpZ25lZCBtZXNzYWdlIHRvIHRoZSBpZGVudGl0eSBrZXlcbiAgICAvLyBhbmQgZmluYWxseSB0byB0aGUgdXNlcidzIHdhbGxldCBhZGRyZXNzXG4gICAgY29uc3Qgc2VuZGVyUHJlS2V5ID0gc2lnbmVkLnNlbmRlcj8ucHJlS2V5O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFzZW5kZXJQcmVLZXkgfHwgIXNlbmRlclByZUtleS5zaWduYXR1cmUgfHwgIXNlbmRlclByZUtleS5rZXlCeXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByZS1rZXkgb3IgcHJlLWtleSBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIGNvbnN0IHNlbmRlcklkZW50aXR5S2V5ID0gc2lnbmVkLnNlbmRlcj8uaWRlbnRpdHlLZXk7XG4gICAgaWYgKCFzZW5kZXJJZGVudGl0eUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGlkZW50aXR5IGtleSBpbiBidW5kbGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGlzVmFsaWRQcmVrZXkgPSBhd2FpdCBuZXcgU2lnbmVkUHVibGljS2V5KHNlbmRlcklkZW50aXR5S2V5KS52ZXJpZnlLZXkobmV3IFNpZ25lZFB1YmxpY0tleShzZW5kZXJQcmVLZXkpKTtcbiAgICBpZiAoIWlzVmFsaWRQcmVrZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlIGtleSBub3Qgc2lnbmVkIGJ5IGlkZW50aXR5IGtleVwiKTtcbiAgICB9XG59XG5cbmNvbnN0IGhlYWRlckJ5dGVzQW5kQ2lwaGVydGV4dCA9IChtc2cpID0+IHtcbiAgICBpZiAobXNnLnYxPy5jaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbXNnLnYxLmhlYWRlckJ5dGVzLCBuZXcgQ2lwaGVydGV4dChtc2cudjEuY2lwaGVydGV4dCldO1xuICAgIH1cbiAgICBpZiAobXNnLnYyPy5jaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbXNnLnYyLmhlYWRlckJ5dGVzLCBuZXcgQ2lwaGVydGV4dChtc2cudjIuY2lwaGVydGV4dCldO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1lc3NhZ2UgdmVyc2lvblwiKTtcbn07XG4vLyBNZXNzYWdlIGlzIGJhc2ljIHVuaXQgb2YgY29tbXVuaWNhdGlvbiBvbiB0aGUgbmV0d29yay5cbi8vIE1lc3NhZ2UgdGltZXN0YW1wIGlzIHNldCBieSB0aGUgc2VuZGVyLlxuY2xhc3MgTWVzc2FnZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBieXRlcywgb2JqKSB7XG4gICAgICAgIFt0aGlzLmhlYWRlckJ5dGVzLCB0aGlzLmNpcGhlcnRleHRdID0gaGVhZGVyQnl0ZXNBbmRDaXBoZXJ0ZXh0KG9iaik7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICB9XG59XG4vLyBNZXNzYWdlIGhlYWRlciBjYXJyaWVzIHRoZSBzZW5kZXIgYW5kIHJlY2lwaWVudCBrZXlzIHVzZWQgdG8gcHJvdGVjdCBtZXNzYWdlLlxuLy8gTWVzc2FnZSB0aW1lc3RhbXAgaXMgc2V0IGJ5IHRoZSBzZW5kZXIuXG5jbGFzcyBNZXNzYWdlVjEgZXh0ZW5kcyBNZXNzYWdlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGJ5dGVzLCBvYmosIGhlYWRlciwgc2VuZGVyQWRkcmVzcykge1xuICAgICAgICBzdXBlcihpZCwgYnl0ZXMsIG9iaik7XG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlbmRlckFkZHJlc3MgPSBzZW5kZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvYmosIGhlYWRlciwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKCFoZWFkZXIuc2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG1lc3NhZ2Ugc2VuZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBuZXcgUHVibGljS2V5QnVuZGxlKGhlYWRlci5zZW5kZXIpLndhbGxldFNpZ25hdHVyZUFkZHJlc3MoKTtcbiAgICAgICAgY29uc3QgaWQgPSBieXRlc1RvSGV4KGF3YWl0IHNoYTI1NihieXRlcykpO1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMShpZCwgYnl0ZXMsIG9iaiwgaGVhZGVyLCBzZW5kZXJBZGRyZXNzKTtcbiAgICB9XG4gICAgZ2V0IHNlbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmhlYWRlci50aW1lc3RhbXAudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIC8vIHdhbGxldCBhZGRyZXNzIGRlcml2ZWQgZnJvbSB0aGUgc2lnbmF0dXJlIG9mIHRoZSBtZXNzYWdlIHJlY2lwaWVudFxuICAgIGdldCByZWNpcGllbnRBZGRyZXNzKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIXRoaXMuaGVhZGVyPy5yZWNpcGllbnQ/LmlkZW50aXR5S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuaGVhZGVyLnJlY2lwaWVudC5pZGVudGl0eUtleSkud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KGtleXN0b3JlLCBteVB1YmxpY0tleUJ1bmRsZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSAoYXdhaXQga2V5c3RvcmUuZGVjcnlwdFYxKGJ1aWxkRGVjcnlwdFYxUmVxdWVzdChbdGhpc10sIG15UHVibGljS2V5QnVuZGxlKSkpLnJlc3BvbnNlcztcbiAgICAgICAgaWYgKCFyZXNwb25zZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIEtleXN0b3JlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVjcnlwdGVkIH0gPSBnZXRSZXN1bHRPclRocm93KHJlc3BvbnNlc1swXSk7XG4gICAgICAgIHJldHVybiBkZWNyeXB0ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSQxID0gbWVzc2FnZS5NZXNzYWdlLmRlY29kZShieXRlcyk7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJCeXRlc10gPSBoZWFkZXJCeXRlc0FuZENpcGhlcnRleHQobWVzc2FnZSQxKTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbWVzc2FnZS5NZXNzYWdlSGVhZGVyVjEuZGVjb2RlKGhlYWRlckJ5dGVzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgbWVzc2FnZSBoZWFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXIuc2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG1lc3NhZ2Ugc2VuZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVhZGVyLnNlbmRlci5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBtZXNzYWdlIHNlbmRlciBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXIuc2VuZGVyLnByZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBtZXNzYWdlIHNlbmRlciBwcmUta2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVhZGVyLnJlY2lwaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBtZXNzYWdlIHJlY2lwaWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlci5yZWNpcGllbnQuaWRlbnRpdHlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgbWVzc2FnZSByZWNpcGllbnQgaWRlbnRpdHkta2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVhZGVyLnJlY2lwaWVudC5wcmVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgbWVzc2FnZSByZWNpcGllbnQgcHJlLWtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWVzc2FnZVYxLmNyZWF0ZShtZXNzYWdlJDEsIGhlYWRlciwgYnl0ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZW5jb2RlKGtleXN0b3JlLCBwYXlsb2FkLCBzZW5kZXIsIHJlY2lwaWVudCwgdGltZXN0YW1wKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogTG9uZy5mcm9tTnVtYmVyKHRpbWVzdGFtcC5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoZWFkZXJCeXRlcyA9IG1lc3NhZ2UuTWVzc2FnZUhlYWRlclYxLmVuY29kZShoZWFkZXIpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQga2V5c3RvcmUuZW5jcnlwdFYxKHtcbiAgICAgICAgICAgIHJlcXVlc3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlckJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHRzLnJlc3BvbnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZyb20gS2V5c3RvcmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlbmNyeXB0ZWQ6IGNpcGhlcnRleHQgfSA9IGdldFJlc3VsdE9yVGhyb3cocmVzdWx0cy5yZXNwb25zZXNbMF0pO1xuICAgICAgICBjb25zdCBwcm90b01zZyA9IHtcbiAgICAgICAgICAgIHYxOiB7IGhlYWRlckJ5dGVzLCBjaXBoZXJ0ZXh0IH0sXG4gICAgICAgICAgICB2MjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBieXRlcyA9IG1lc3NhZ2UuTWVzc2FnZS5lbmNvZGUocHJvdG9Nc2cpLmZpbmlzaCgpO1xuICAgICAgICByZXR1cm4gTWVzc2FnZVYxLmNyZWF0ZShwcm90b01zZywgaGVhZGVyLCBieXRlcyk7XG4gICAgfVxufVxuY2xhc3MgTWVzc2FnZVYyIGV4dGVuZHMgTWVzc2FnZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBieXRlcywgb2JqLCBoZWFkZXIsIHNlbmRlckhtYWMsIHNob3VsZFB1c2gpIHtcbiAgICAgICAgc3VwZXIoaWQsIGJ5dGVzLCBvYmopO1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5zZW5kZXJIbWFjID0gc2VuZGVySG1hYztcbiAgICAgICAgdGhpcy5zaG91bGRQdXNoID0gc2hvdWxkUHVzaDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvYmosIGhlYWRlciwgYnl0ZXMsIHNlbmRlckhtYWMsIHNob3VsZFB1c2gpIHtcbiAgICAgICAgY29uc3QgaWQgPSBieXRlc1RvSGV4KGF3YWl0IHNoYTI1NihieXRlcykpO1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMihpZCwgYnl0ZXMsIG9iaiwgaGVhZGVyLCBzZW5kZXJIbWFjLCBzaG91bGRQdXNoKTtcbiAgICB9XG4gICAgZ2V0IHNlbnQoKSB7XG4gICAgICAgIHJldHVybiBuc1RvRGF0ZSh0aGlzLmhlYWRlci5jcmVhdGVkTnMpO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBEZWNvZGVkTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoeyBpZCwgbWVzc2FnZVZlcnNpb24sIHNlbmRlckFkZHJlc3MsIHJlY2lwaWVudEFkZHJlc3MsIGNvbnZlcnNhdGlvbiwgY29udGVudEJ5dGVzLCBjb250ZW50VHlwZSwgY29udGVudFRvcGljLCBjb250ZW50LCBzZW50LCBlcnJvciwgY29udGVudEZhbGxiYWNrLCB9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlVmVyc2lvbiA9IG1lc3NhZ2VWZXJzaW9uO1xuICAgICAgICB0aGlzLnNlbmRlckFkZHJlc3MgPSBzZW5kZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLnJlY2lwaWVudEFkZHJlc3MgPSByZWNpcGllbnRBZGRyZXNzO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbjtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLnNlbnQgPSBzZW50O1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuY29udGVudFRvcGljID0gY29udGVudFRvcGljO1xuICAgICAgICB0aGlzLmNvbnRlbnRCeXRlcyA9IGNvbnRlbnRCeXRlcztcbiAgICAgICAgdGhpcy5jb250ZW50RmFsbGJhY2sgPSBjb250ZW50RmFsbGJhY2s7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLkRlY29kZWRNZXNzYWdlLmVuY29kZSh7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgY29udmVyc2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuY29udmVyc2F0aW9uLnRvcGljLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udmVyc2F0aW9uLmNvbnRleHQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWROczogZGF0ZVRvTnModGhpcy5jb252ZXJzYXRpb24uY3JlYXRlZEF0KSxcbiAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogdGhpcy5jb252ZXJzYXRpb24ucGVlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY29uc2VudFByb29mUGF5bG9hZDogdGhpcy5jb252ZXJzYXRpb24uY29uc2VudFByb29mID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW50TnM6IGRhdGVUb05zKHRoaXMuc2VudCksXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUJ5dGVzKGRhdGEsIGNsaWVudCkge1xuICAgICAgICBjb25zdCBwcm90b1ZhbCA9IG1lc3NhZ2UuRGVjb2RlZE1lc3NhZ2UuZGVjb2RlKGRhdGEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlVmVyc2lvbiA9IHByb3RvVmFsLm1lc3NhZ2VWZXJzaW9uO1xuICAgICAgICBpZiAobWVzc2FnZVZlcnNpb24gIT09IFwidjFcIiAmJiBtZXNzYWdlVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2UgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3RvVmFsLmNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udmVyc2F0aW9uIHJlZmVyZW5jZSBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRlbnQsIGNvbnRlbnRUeXBlLCBlcnJvciwgY29udGVudEZhbGxiYWNrIH0gPSBhd2FpdCBjbGllbnQuZGVjb2RlQ29udGVudChwcm90b1ZhbC5jb250ZW50Qnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IERlY29kZWRNZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnByb3RvVmFsLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlVmVyc2lvbixcbiAgICAgICAgICAgIHNlbnQ6IG5zVG9EYXRlKHByb3RvVmFsLnNlbnROcyksXG4gICAgICAgICAgICBjb252ZXJzYXRpb246IGNvbnZlcnNhdGlvblJlZmVyZW5jZVRvQ29udmVyc2F0aW9uKHByb3RvVmFsLmNvbnZlcnNhdGlvbiwgY2xpZW50LCBtZXNzYWdlVmVyc2lvbiksXG4gICAgICAgICAgICBjb250ZW50RmFsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVYxTWVzc2FnZShtZXNzYWdlLCBjb250ZW50LCBjb250ZW50VHlwZSwgY29udGVudEJ5dGVzLCBjb250ZW50VG9waWMsIGNvbnZlcnNhdGlvbiwgZXJyb3IsIGNvbnRlbnRGYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IGlkLCBzZW5kZXJBZGRyZXNzLCByZWNpcGllbnRBZGRyZXNzLCBzZW50IH0gPSBtZXNzYWdlO1xuICAgICAgICBpZiAoIXNlbmRlckFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmRlciBhZGRyZXNzIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtZXNzYWdlVmVyc2lvbjogXCJ2MVwiLFxuICAgICAgICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICAgIHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICAgICAgICBzZW50LFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRCeXRlcyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY29udGVudFRvcGljLFxuICAgICAgICAgICAgY29udmVyc2F0aW9uLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBjb250ZW50RmFsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVYyTWVzc2FnZShtZXNzYWdlLCBjb250ZW50LCBjb250ZW50VHlwZSwgY29udGVudFRvcGljLCBjb250ZW50Qnl0ZXMsIGNvbnZlcnNhdGlvbiwgc2VuZGVyQWRkcmVzcywgZXJyb3IsIGNvbnRlbnRGYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IGlkLCBzZW50IH0gPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gbmV3IERlY29kZWRNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbWVzc2FnZVZlcnNpb246IFwidjJcIixcbiAgICAgICAgICAgIHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgICBzZW50LFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRCeXRlcyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY29udGVudFRvcGljLFxuICAgICAgICAgICAgY29udmVyc2F0aW9uLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBjb250ZW50RmFsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnNhdGlvblJlZmVyZW5jZVRvQ29udmVyc2F0aW9uKHJlZmVyZW5jZSwgY2xpZW50LCB2ZXJzaW9uKSB7XG4gICAgaWYgKHZlcnNpb24gPT09IFwidjFcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvblYxKGNsaWVudCwgcmVmZXJlbmNlLnBlZXJBZGRyZXNzLCBuc1RvRGF0ZShyZWZlcmVuY2UuY3JlYXRlZE5zKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHZlcnNpb24gPT09IFwidjJcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvblYyKGNsaWVudCwgcmVmZXJlbmNlLnRvcGljLCByZWZlcmVuY2UucGVlckFkZHJlc3MsIG5zVG9EYXRlKHJlZmVyZW5jZS5jcmVhdGVkTnMpLCByZWZlcmVuY2UuY29udGV4dCwgcmVmZXJlbmNlLmNvbnNlbnRQcm9vZlBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbnZlcnNhdGlvbiB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUNvbnRlbnQoY29udGVudEJ5dGVzLCBjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmRlY29kZUNvbnRlbnQoY29udGVudEJ5dGVzKTtcbn1cblxuY2xhc3MgTm9NYXRjaGluZ1ByZUtleUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHByZUtleSkge1xuICAgICAgICBzdXBlcihgbm8gcHJlLWtleSBtYXRjaGVzOiAke2J5dGVzVG9IZXgocHJlS2V5LnNlY3AyNTZrMVVuY29tcHJlc3NlZC5ieXRlcyl9YCk7XG4gICAgfVxufVxuXG4vLyBQcml2YXRlS2V5QnVuZGxlIGJ1bmRsZXMgdGhlIHByaXZhdGUga2V5cyBjb3JyZXNwb25kaW5nIHRvIGEgUHVibGljS2V5QnVuZGxlIGZvciBjb252ZW5pZW5jZS5cbi8vIFRoaXMgYnVuZGxlIG11c3Qgbm90IGJlIHNoYXJlZCB3aXRoIGFueW9uZSwgYWx0aG91Z2ggd2lsbCBoYXZlIHRvIGJlIHBlcnNpc3RlZFxuLy8gc29tZWhvdyBzbyB0aGF0IG9sZGVyIG1lc3NhZ2VzIGNhbiBiZSBkZWNyeXB0ZWQgYWdhaW4uXG5jbGFzcyBQcml2YXRlS2V5QnVuZGxlVjIge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZSkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAyO1xuICAgICAgICBpZiAoIWJ1bmRsZS5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IG5ldyBTaWduZWRQcml2YXRlS2V5KGJ1bmRsZS5pZGVudGl0eUtleSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIHRoaXMucHJlS2V5cyA9IChidW5kbGUucHJlS2V5cyB8fCBbXSkubWFwKChrKSA9PiBuZXcgU2lnbmVkUHJpdmF0ZUtleShrKSk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IGtleSBidW5kbGUgd2l0aCB0aGUgcHJlS2V5IHNpZ25lZCBieXQgdGhlIGlkZW50aXR5S2V5LlxuICAgIC8vIE9wdGlvbmFsbHkgc2lnbiB0aGUgaWRlbnRpdHlLZXkgd2l0aCB0aGUgcHJvdmlkZWQgd2FsbGV0IGFzIHdlbGwuXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlKHdhbGxldCkge1xuICAgICAgICBjb25zdCBpZGVudGl0eUtleSA9IGF3YWl0IFNpZ25lZFByaXZhdGVLZXkuZ2VuZXJhdGUobmV3IFdhbGxldFNpZ25lcih3YWxsZXQpKTtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3IFByaXZhdGVLZXlCdW5kbGVWMih7XG4gICAgICAgICAgICBpZGVudGl0eUtleSxcbiAgICAgICAgICAgIHByZUtleXM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgYnVuZGxlLmFkZFByZUtleSgpO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgKGxhdGVzdCkgcHJlLWtleSAodG8gYmUgYWR2ZXJ0aXNlZCkuXG4gICAgZ2V0Q3VycmVudFByZUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlS2V5c1swXTtcbiAgICB9XG4gICAgLy8gRmluZCBwcmUta2V5IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlxuICAgIGZpbmRQcmVLZXkod2hpY2gpIHtcbiAgICAgICAgY29uc3QgcHJlS2V5ID0gdGhpcy5wcmVLZXlzLmZpbmQoKGtleSkgPT4ga2V5Lm1hdGNoZXMod2hpY2gpKTtcbiAgICAgICAgaWYgKCFwcmVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb01hdGNoaW5nUHJlS2V5RXJyb3Iod2hpY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVLZXk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHByZS1rZXkgdG8gYmUgdXNlZCBhcyB0aGUgY3VycmVudCBwcmUta2V5LlxuICAgIGFzeW5jIGFkZFByZUtleSgpIHtcbiAgICAgICAgdGhpcy5fcHVibGljS2V5QnVuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwcmVLZXkgPSBhd2FpdCBTaWduZWRQcml2YXRlS2V5LmdlbmVyYXRlKHRoaXMuaWRlbnRpdHlLZXkpO1xuICAgICAgICB0aGlzLnByZUtleXMudW5zaGlmdChwcmVLZXkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBrZXkgYnVuZGxlIHdpdGggdGhlIGN1cnJlbnQgcHJlLWtleS5cbiAgICBnZXRQdWJsaWNLZXlCdW5kbGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHVibGljS2V5QnVuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXlCdW5kbGUgPSBuZXcgU2lnbmVkUHVibGljS2V5QnVuZGxlKHtcbiAgICAgICAgICAgICAgICBpZGVudGl0eUtleTogdGhpcy5pZGVudGl0eUtleS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgcHJlS2V5OiB0aGlzLmdldEN1cnJlbnRQcmVLZXkoKS5wdWJsaWNLZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5QnVuZGxlO1xuICAgIH1cbiAgICAvLyBzaGFyZWRTZWNyZXQgZGVyaXZlcyBhIHNlY3JldCBmcm9tIHBlZXIncyBrZXkgYnVuZGxlcyB1c2luZyBhIHZhcmlhdGlvbiBvZiBYM0RIIHByb3RvY29sXG4gICAgLy8gd2hlcmUgdGhlIHNlbmRlcidzIGVwaGVtZXJhbCBrZXkgcGFpciBpcyByZXBsYWNlZCBieSB0aGUgc2VuZGVyJ3MgcHJlLWtleS5cbiAgICAvLyBAcGVlciBpcyB0aGUgcGVlcidzIHB1YmxpYyBrZXkgYnVuZGxlXG4gICAgLy8gQG15UHJlS2V5IGluZGljYXRlcyB3aGljaCBvZiBteSBwcmVLZXlzIHNob3VsZCBiZSB1c2VkIHRvIGRlcml2ZSB0aGUgc2VjcmV0XG4gICAgLy8gQHJlY2lwaWVudCBpbmRpY2F0ZXMgaWYgdGhpcyBpcyB0aGUgc2VuZGluZyBvciByZWNlaXZpbmcgc2lkZS5cbiAgICBhc3luYyBzaGFyZWRTZWNyZXQocGVlciwgbXlQcmVLZXksIGlzUmVjaXBpZW50KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghcGVlci5pZGVudGl0eUtleSB8fCAhcGVlci5wcmVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGVlciBrZXkgYnVuZGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHBlZXIuaWRlbnRpdHlLZXkudmVyaWZ5S2V5KHBlZXIucHJlS2V5KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBlZXIgcHJlS2V5IHNpZ25hdHVyZSBpbnZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghdGhpcy5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRoMSwgZGgyLCBwcmVLZXk7XG4gICAgICAgIGlmIChpc1JlY2lwaWVudCkge1xuICAgICAgICAgICAgcHJlS2V5ID0gdGhpcy5maW5kUHJlS2V5KG15UHJlS2V5KTtcbiAgICAgICAgICAgIGRoMSA9IHByZUtleS5zaGFyZWRTZWNyZXQocGVlci5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICBkaDIgPSB0aGlzLmlkZW50aXR5S2V5LnNoYXJlZFNlY3JldChwZWVyLnByZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmVLZXkgPSB0aGlzLmZpbmRQcmVLZXkobXlQcmVLZXkpO1xuICAgICAgICAgICAgZGgxID0gdGhpcy5pZGVudGl0eUtleS5zaGFyZWRTZWNyZXQocGVlci5wcmVLZXkpO1xuICAgICAgICAgICAgZGgyID0gcHJlS2V5LnNoYXJlZFNlY3JldChwZWVyLmlkZW50aXR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaDMgPSBwcmVLZXkuc2hhcmVkU2VjcmV0KHBlZXIucHJlS2V5KTtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZGgxLmxlbmd0aCArIGRoMi5sZW5ndGggKyBkaDMubGVuZ3RoKTtcbiAgICAgICAgc2VjcmV0LnNldChkaDEsIDApO1xuICAgICAgICBzZWNyZXQuc2V0KGRoMiwgZGgxLmxlbmd0aCk7XG4gICAgICAgIHNlY3JldC5zZXQoZGgzLCBkaDEubGVuZ3RoICsgZGgyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWNyZXQ7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVLZXkuUHJpdmF0ZUtleUJ1bmRsZS5lbmNvZGUoe1xuICAgICAgICAgICAgdjE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHYyOiB0aGlzLFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQdWJsaWNLZXlzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWRlbnRpdHlLZXkudmFsaWRhdGVQdWJsaWNLZXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZUtleXMuZXZlcnkoKGtleSkgPT4ga2V5LnZhbGlkYXRlUHVibGljS2V5KCkpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlS2V5cy5sZW5ndGggIT09IG90aGVyLnByZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVLZXlzW2ldLmVxdWFscyhvdGhlci5wcmVLZXlzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eUtleS5lcXVhbHMob3RoZXIuaWRlbnRpdHlLZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUxlZ2FjeUJ1bmRsZShidW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5QnVuZGxlVjIoe1xuICAgICAgICAgICAgaWRlbnRpdHlLZXk6IFNpZ25lZFByaXZhdGVLZXkuZnJvbUxlZ2FjeUtleShidW5kbGUuaWRlbnRpdHlLZXksIHRydWUpLFxuICAgICAgICAgICAgcHJlS2V5czogYnVuZGxlLnByZUtleXMubWFwKChrKSA9PiBTaWduZWRQcml2YXRlS2V5LmZyb21MZWdhY3lLZXkoaykpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBQcml2YXRlS2V5QnVuZGxlIGJ1bmRsZXMgdGhlIHByaXZhdGUga2V5cyBjb3JyZXNwb25kaW5nIHRvIGEgUHVibGljS2V5QnVuZGxlIGZvciBjb252ZW5pZW5jZS5cbi8vIFRoaXMgYnVuZGxlIG11c3Qgbm90IGJlIHNoYXJlZCB3aXRoIGFueW9uZSwgYWx0aG91Z2ggd2lsbCBoYXZlIHRvIGJlIHBlcnNpc3RlZFxuLy8gc29tZWhvdyBzbyB0aGF0IG9sZGVyIG1lc3NhZ2VzIGNhbiBiZSBkZWNyeXB0ZWQgYWdhaW4uXG5jbGFzcyBQcml2YXRlS2V5QnVuZGxlVjEge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZSkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgICAgICBpZiAoIWJ1bmRsZS5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IG5ldyBQcml2YXRlS2V5KGJ1bmRsZS5pZGVudGl0eUtleSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIHRoaXMucHJlS2V5cyA9IChidW5kbGUucHJlS2V5cyB8fCBbXSkubWFwKChrKSA9PiBuZXcgUHJpdmF0ZUtleShrKSk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IGtleSBidW5kbGUgd2l0aCB0aGUgcHJlS2V5IHNpZ25lZCBieXQgdGhlIGlkZW50aXR5S2V5LlxuICAgIC8vIE9wdGlvbmFsbHkgc2lnbiB0aGUgaWRlbnRpdHlLZXkgd2l0aCB0aGUgcHJvdmlkZWQgd2FsbGV0IGFzIHdlbGwuXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlKHdhbGxldCkge1xuICAgICAgICBjb25zdCBpZGVudGl0eUtleSA9IFByaXZhdGVLZXkuZ2VuZXJhdGUoKTtcbiAgICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICAgICAgYXdhaXQgaWRlbnRpdHlLZXkucHVibGljS2V5LnNpZ25XaXRoV2FsbGV0KHdhbGxldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3IFByaXZhdGVLZXlCdW5kbGVWMSh7XG4gICAgICAgICAgICBpZGVudGl0eUtleSxcbiAgICAgICAgICAgIHByZUtleXM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgYnVuZGxlLmFkZFByZUtleSgpO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgKGxhdGVzdCkgcHJlLWtleSAodG8gYmUgYWR2ZXJ0aXNlZCkuXG4gICAgZ2V0Q3VycmVudFByZUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlS2V5c1swXTtcbiAgICB9XG4gICAgLy8gRmluZCBwcmUta2V5IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlxuICAgIGZpbmRQcmVLZXkod2hpY2gpIHtcbiAgICAgICAgY29uc3QgcHJlS2V5ID0gdGhpcy5wcmVLZXlzLmZpbmQoKGtleSkgPT4ga2V5Lm1hdGNoZXMod2hpY2gpKTtcbiAgICAgICAgaWYgKCFwcmVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb01hdGNoaW5nUHJlS2V5RXJyb3Iod2hpY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVLZXk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHByZS1rZXkgdG8gYmUgdXNlZCBhcyB0aGUgY3VycmVudCBwcmUta2V5LlxuICAgIGFzeW5jIGFkZFByZUtleSgpIHtcbiAgICAgICAgdGhpcy5fcHVibGljS2V5QnVuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwcmVLZXkgPSBQcml2YXRlS2V5LmdlbmVyYXRlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuaWRlbnRpdHlLZXkuc2lnbktleShwcmVLZXkucHVibGljS2V5KTtcbiAgICAgICAgdGhpcy5wcmVLZXlzLnVuc2hpZnQocHJlS2V5KTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEga2V5IGJ1bmRsZSB3aXRoIHRoZSBjdXJyZW50IHByZS1rZXkuXG4gICAgZ2V0UHVibGljS2V5QnVuZGxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3B1YmxpY0tleUJ1bmRsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5QnVuZGxlID0gbmV3IFB1YmxpY0tleUJ1bmRsZSh7XG4gICAgICAgICAgICAgICAgaWRlbnRpdHlLZXk6IHRoaXMuaWRlbnRpdHlLZXkucHVibGljS2V5LFxuICAgICAgICAgICAgICAgIHByZUtleTogdGhpcy5nZXRDdXJyZW50UHJlS2V5KCkucHVibGljS2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleUJ1bmRsZTtcbiAgICB9XG4gICAgdmFsaWRhdGVQdWJsaWNLZXlzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWRlbnRpdHlLZXkudmFsaWRhdGVQdWJsaWNLZXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZUtleXMuZXZlcnkoKGtleSkgPT4ga2V5LnZhbGlkYXRlUHVibGljS2V5KCkpO1xuICAgIH1cbiAgICAvLyBzaGFyZWRTZWNyZXQgZGVyaXZlcyBhIHNlY3JldCBmcm9tIHBlZXIncyBrZXkgYnVuZGxlcyB1c2luZyBhIHZhcmlhdGlvbiBvZiBYM0RIIHByb3RvY29sXG4gICAgLy8gd2hlcmUgdGhlIHNlbmRlcidzIGVwaGVtZXJhbCBrZXkgcGFpciBpcyByZXBsYWNlZCBieSB0aGUgc2VuZGVyJ3MgcHJlLWtleS5cbiAgICAvLyBAcGVlciBpcyB0aGUgcGVlcidzIHB1YmxpYyBrZXkgYnVuZGxlXG4gICAgLy8gQG15UHJlS2V5IGluZGljYXRlcyB3aGljaCBvZiBteSBwcmVLZXlzIHNob3VsZCBiZSB1c2VkIHRvIGRlcml2ZSB0aGUgc2VjcmV0XG4gICAgLy8gQHJlY2lwaWVudCBpbmRpY2F0ZXMgaWYgdGhpcyBpcyB0aGUgc2VuZGluZyBvciByZWNlaXZpbmcgc2lkZS5cbiAgICBhc3luYyBzaGFyZWRTZWNyZXQocGVlciwgbXlQcmVLZXksIGlzUmVjaXBpZW50KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghcGVlci5pZGVudGl0eUtleSB8fCAhcGVlci5wcmVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGVlciBrZXkgYnVuZGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHBlZXIuaWRlbnRpdHlLZXkudmVyaWZ5S2V5KHBlZXIucHJlS2V5KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBlZXIgcHJlS2V5IHNpZ25hdHVyZSBpbnZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghdGhpcy5pZGVudGl0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpZGVudGl0eSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRoMSwgZGgyLCBwcmVLZXk7XG4gICAgICAgIGlmIChpc1JlY2lwaWVudCkge1xuICAgICAgICAgICAgcHJlS2V5ID0gdGhpcy5maW5kUHJlS2V5KG15UHJlS2V5KTtcbiAgICAgICAgICAgIGRoMSA9IHByZUtleS5zaGFyZWRTZWNyZXQocGVlci5pZGVudGl0eUtleSk7XG4gICAgICAgICAgICBkaDIgPSB0aGlzLmlkZW50aXR5S2V5LnNoYXJlZFNlY3JldChwZWVyLnByZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmVLZXkgPSB0aGlzLmZpbmRQcmVLZXkobXlQcmVLZXkpO1xuICAgICAgICAgICAgZGgxID0gdGhpcy5pZGVudGl0eUtleS5zaGFyZWRTZWNyZXQocGVlci5wcmVLZXkpO1xuICAgICAgICAgICAgZGgyID0gcHJlS2V5LnNoYXJlZFNlY3JldChwZWVyLmlkZW50aXR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaDMgPSBwcmVLZXkuc2hhcmVkU2VjcmV0KHBlZXIucHJlS2V5KTtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZGgxLmxlbmd0aCArIGRoMi5sZW5ndGggKyBkaDMubGVuZ3RoKTtcbiAgICAgICAgc2VjcmV0LnNldChkaDEsIDApO1xuICAgICAgICBzZWNyZXQuc2V0KGRoMiwgZGgxLmxlbmd0aCk7XG4gICAgICAgIHNlY3JldC5zZXQoZGgzLCBkaDEubGVuZ3RoICsgZGgyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWNyZXQ7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVLZXkuUHJpdmF0ZUtleUJ1bmRsZS5lbmNvZGUoe1xuICAgICAgICAgICAgdjE6IHRoaXMsXG4gICAgICAgICAgICB2MjogdW5kZWZpbmVkLFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvZGVQcml2YXRlS2V5QnVuZGxlKGJ5dGVzKSB7XG4gICAgY29uc3QgYiA9IHByaXZhdGVLZXkuUHJpdmF0ZUtleUJ1bmRsZS5kZWNvZGUoYnl0ZXMpO1xuICAgIGlmIChiLnYxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleUJ1bmRsZVYxKGIudjEpO1xuICAgIH1cbiAgICBpZiAoYi52Mikge1xuICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXlCdW5kbGVWMihiLnYyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBwcml2YXRlIGtleSBidW5kbGUgdmVyc2lvblwiKTtcbn1cblxuY2xhc3MgQXV0aERhdGEge1xuICAgIGNvbnN0cnVjdG9yKHsgd2FsbGV0QWRkciwgY3JlYXRlZE5zIH0pIHtcbiAgICAgICAgdGhpcy53YWxsZXRBZGRyID0gd2FsbGV0QWRkcjtcbiAgICAgICAgdGhpcy5jcmVhdGVkTnMgPSBjcmVhdGVkTnM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUod2FsbGV0QWRkciwgdGltZXN0YW1wKSB7XG4gICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhEYXRhKHtcbiAgICAgICAgICAgIHdhbGxldEFkZHIsXG4gICAgICAgICAgICBjcmVhdGVkTnM6IGRhdGVUb05zKHRpbWVzdGFtcCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF1dGhuLkF1dGhEYXRhLmRlY29kZShieXRlcyk7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aERhdGEocmVzKTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGF1dGhuLkF1dGhEYXRhLmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG59XG5cbmNsYXNzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkZW50aXR5S2V5LCBhdXRoRGF0YUJ5dGVzLCBhdXRoRGF0YVNpZ25hdHVyZSB9KSB7XG4gICAgICAgIGlmICghaWRlbnRpdHlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgaWRlbnRpdHkga2V5IGluIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXV0aERhdGFTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXV0aERhdGFTaWduYXR1cmUgaW4gdG9rZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGl0eUtleSA9IGlkZW50aXR5S2V5O1xuICAgICAgICB0aGlzLmF1dGhEYXRhQnl0ZXMgPSBhdXRoRGF0YUJ5dGVzO1xuICAgICAgICB0aGlzLmF1dGhEYXRhU2lnbmF0dXJlID0gYXV0aERhdGFTaWduYXR1cmU7XG4gICAgfVxuICAgIC8vIEdldCBBdXRoRGF0YSwgZ2VuZXJhdGluZyBmcm9tIGJ5dGVzIGFuZCBjYWNoZWluZyB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZFxuICAgIGdldCBhdXRoRGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRoRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aERhdGEgPSBBdXRoRGF0YS5mcm9tQnl0ZXModGhpcy5hdXRoRGF0YUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aERhdGE7XG4gICAgfVxuICAgIGdldCBhZ2VNcygpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIGNvbnN0IGF1dGhEYXRhID0gdGhpcy5hdXRoRGF0YTtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gYXV0aERhdGEuY3JlYXRlZE5zLmRpdigxXzAwMF8wMDApLnRvTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBub3cgLSBjcmVhdGVkQXQ7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBhdXRobi5Ub2tlbi5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihhdXRobi5Ub2tlbi5kZWNvZGUoYnl0ZXMpKTtcbiAgICB9XG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnRvQnl0ZXMoKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxufVxuXG5jb25zdCB3cmFwVG9rZW4gPSAodG9rZW4pID0+IHtcbiAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9rZW4odG9rZW4pO1xufTtcbmNsYXNzIEtleXN0b3JlQXV0aGVudGljYXRvciB7XG4gICAgY29uc3RydWN0b3Ioa2V5c3RvcmUpIHtcbiAgICAgICAgdGhpcy5rZXlzdG9yZSA9IGtleXN0b3JlO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVUb2tlbih0aW1lc3RhbXApIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmtleXN0b3JlLmNyZWF0ZUF1dGhUb2tlbih7XG4gICAgICAgICAgICB0aW1lc3RhbXBOczogdGltZXN0YW1wID8gZGF0ZVRvTnModGltZXN0YW1wKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cmFwVG9rZW4odG9rZW4pO1xuICAgIH1cbn1cblxuY29uc3Qgc2xlZXAgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5jb25zdCBkZWZhdWx0SXNSZXRyeWFibGVGbiA9IChlcnIpID0+ICEhZXJyO1xuLy8gSW1wbGVtZW50cyB0eXBlIHNhZmUgcmV0cmllcyBvZiBhcmJpdHJhcnkgYXN5bmMgZnVuY3Rpb25zXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYXN5bmMgZnVuY3Rpb24gcmV0cnkoZm4sIGFyZ3MsIG1heFJldHJpZXMsIHNsZWVwVGltZSwgaXNSZXRyeWFibGVGbiA9IGRlZmF1bHRJc1JldHJ5YWJsZUZuLCByZXRyeUNvdW50ID0gMSkge1xuICAgIGNvbnN0IGN1cnJSZXRyeSA9IHR5cGVvZiByZXRyeUNvdW50ID09PSBcIm51bWJlclwiID8gcmV0cnlDb3VudCA6IDE7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghaXNSZXRyeWFibGVGbihlKSB8fCBjdXJyUmV0cnkgPiBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwVGltZSk7XG4gICAgICAgIHJldHVybiByZXRyeShmbiwgYXJncywgbWF4UmV0cmllcywgc2xlZXBUaW1lLCBpc1JldHJ5YWJsZUZuLCBjdXJyUmV0cnkgKyAxKTtcbiAgICB9XG59XG4vLyBUYWtlcyBhbiBhc3luYyBnZW5lcmF0b3IgcmV0dXJuaW5nIHBhZ2VzIG9mIGVudmVsb3BlcyBhbmQgY29udmVydHMgdG8gYW4gYXN5bmNcbi8vIGdlbmVyYXRvciByZXR1cm5pbmcgcGFnZXMgb2YgYW4gYXJiaXRyYXJ5IHR5cGUgdXNpbmcgYSBtYXBwZXIgZnVuY3Rpb25cbmFzeW5jIGZ1bmN0aW9uKiBtYXBQYWdpbmF0ZWRTdHJlYW0oZ2VuLCBtYXBwZXIpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhZ2Ugb2YgZ2VuKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocGFnZS5tYXAobWFwcGVyKSk7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcHJvY2VzcyBlbnZlbG9wZSBkdWUgdG8gcmVhc29uOiBcIiwgcmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgb3V0O1xuICAgIH1cbn1cblxuY29uc3QgdmVyc2lvbiQxID0gXCIxMy4wLjJcIjtcblxuLy8gRGVmYXVsdCB0byAxMCBzZWNvbmRzIGxlc3MgdGhhbiBleHBlY3RlZCBleHBpcnkgdG8gZ2l2ZSBzb21lIHdpZ2dsZSByb29tIG5lYXIgdGhlIGVuZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3htdHAveG10cC1ub2RlLWdvL2Jsb2IvbWFpbi9wa2cvYXBpL2F1dGhlbnRpY2F0aW9uLmdvI0wxOFxuY29uc3QgREVGQVVMVF9NQVhfQUdFX1NFQ09ORFMgPSA2MCAqIDYwIC0gMTA7XG5jbGFzcyBBdXRoQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhlbnRpY2F0b3IsIGNhY2hlRXhwaXJ5U2Vjb25kcyA9IERFRkFVTFRfTUFYX0FHRV9TRUNPTkRTKSB7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRvciA9IGF1dGhlbnRpY2F0b3I7XG4gICAgICAgIHRoaXMubWF4QWdlTXMgPSBjYWNoZUV4cGlyeVNlY29uZHMgKiAxMDAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuIHx8IHRoaXMudG9rZW4uYWdlTXMgPiB0aGlzLm1heEFnZU1zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbi50b0Jhc2U2NCgpO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnRva2VuID0gYXdhaXQgdGhpcy5hdXRoZW50aWNhdG9yLmNyZWF0ZVRva2VuKCk7XG4gICAgfVxufVxuXG5jb25zdCBYTVRQX0RFVl9XQVJOSU5HID0gYFxuWFggICAgWFggTU0gICAgTU0gVFRUVFRUIFBQUFBQUCAgIEREREREICAgRUVFRUVFRSBWViAgICAgVlYgXG4gWFggIFhYICBNTU0gIE1NTSAgIFRUICAgUFAgICBQUCAgREQgIEREICBFRSAgICAgIFZWICAgICBWViBcbiAgWFhYWCAgIE1NIE1NIE1NICAgVFQgICBQUFBQUFAgICBERCAgIEREIEVFRUVFICAgIFZWICAgVlYgIFxuIFhYICBYWCAgTU0gICAgTU0gICBUVCAgIFBQICAgICAgIEREICAgREQgRUUgICAgICAgIFZWIFZWICAgXG5YWCAgICBYWCBNTSAgICBNTSAgIFRUICAgUFAgICAgICAgREREREREICBFRUVFRUVFICAgIFZWViAgICBcblxuQ29ubmVjdGVkIHRvIHRoZSBYTVRQICdkZXYnIG5ldHdvcmsuIFVzZSAncHJvZHVjdGlvbicgZm9yIHByb2R1Y3Rpb24gbWVzc2FnZXMuXG5odHRwczovL2dpdGh1Yi5jb20veG10cC94bXRwLWpzI3htdHAtcHJvZHVjdGlvbi1hbmQtZGV2LW5ldHdvcmstZW52aXJvbm1lbnRzXG5gO1xuXG5jb25zdCB7IE1lc3NhZ2VBcGksIFNvcnREaXJlY3Rpb24gfSA9IG1lc3NhZ2VBcGk7XG5jb25zdCBSRVRSWV9TTEVFUF9USU1FID0gMTAwO1xuY29uc3QgRVJSX0NPREVfVU5BVVRIRU5USUNBVEVEID0gMTY7XG5jb25zdCBjbGllbnRWZXJzaW9uSGVhZGVyS2V5ID0gXCJYLUNsaWVudC1WZXJzaW9uXCI7XG5jb25zdCBhcHBWZXJzaW9uSGVhZGVyS2V5ID0gXCJYLUFwcC1WZXJzaW9uXCI7XG5jb25zdCBBcGlVcmxzID0ge1xuICAgIGxvY2FsOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTU1NVwiLFxuICAgIGRldjogXCJodHRwczovL2Rldi54bXRwLm5ldHdvcmtcIixcbiAgICBwcm9kdWN0aW9uOiBcImh0dHBzOi8vcHJvZHVjdGlvbi54bXRwLm5ldHdvcmtcIixcbn07XG52YXIgR3JwY1N0YXR1cztcbihmdW5jdGlvbiAoR3JwY1N0YXR1cykge1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIkRFQURMSU5FX0VYQ0VFREVEXCJdID0gNF0gPSBcIkRFQURMSU5FX0VYQ0VFREVEXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA3XSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcbiAgICBHcnBjU3RhdHVzW0dycGNTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIEdycGNTdGF0dXNbR3JwY1N0YXR1c1tcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG4gICAgR3JwY1N0YXR1c1tHcnBjU3RhdHVzW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbn0pKEdycGNTdGF0dXMgfHwgKEdycGNTdGF0dXMgPSB7fSkpO1xuY2xhc3MgR3JwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KGVycikge1xuICAgICAgICByZXR1cm4gbmV3IEdycGNFcnJvcihlcnIubWVzc2FnZSwgZXJyLmNvZGUpO1xuICAgIH1cbn1cbmNvbnN0IGlzQWJvcnRFcnJvciA9IChlcnIpID0+IHtcbiAgICBpZiAoIWVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJhYm9ydGVkXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNBdXRoRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgaWYgKGVyciAmJiBcImNvZGVcIiBpbiBlcnIgJiYgZXJyLmNvZGUgPT09IEVSUl9DT0RFX1VOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGlzTm90QXV0aEVycm9yID0gKGVycikgPT4gIWlzQXV0aEVycm9yKGVycik7XG5jb25zdCBub3JtYWxpemVFbnZlbG9wZSA9IChlbnYpID0+IHtcbiAgICBpZiAoIWVudi5tZXNzYWdlIHx8ICFlbnYubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbnYubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbnYubWVzc2FnZSA9IGI2NERlY29kZShlbnYubWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xuLyoqXG4gKiBBcGlDbGllbnQgcHJvdmlkZXMgYSB3cmFwcGVyIGZvciBjYWxsaW5nIHRoZSBHUlBDIEdhdGV3YXkgZ2VuZXJhdGVkIGNvZGUuXG4gKiBJdCBhZGRzIHNvbWUgaGVscGVycyBmb3IgZGVhbGluZyB3aXRoIHBhZ2luYXRlZCBkYXRhIGFuZCBhdXRvbWF0aWNhbGx5IHJldHJpZXMgaWRlbXBvdGVudCBjYWxsc1xuICovXG5jbGFzcyBIdHRwQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoUHJlZml4LCBvcHRzKSB7XG4gICAgICAgIHRoaXMucGF0aFByZWZpeCA9IHBhdGhQcmVmaXg7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdHM/Lm1heFJldHJpZXMgfHwgNTtcbiAgICAgICAgdGhpcy5hcHBWZXJzaW9uID0gb3B0cz8uYXBwVmVyc2lvbjtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCJ4bXRwLWpzL1wiICsgdmVyc2lvbiQxO1xuICAgICAgICBpZiAocGF0aFByZWZpeCA9PT0gQXBpVXJscy5kZXYpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhYTVRQX0RFVl9XQVJOSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSYXcgbWV0aG9kIGZvciBxdWVyeWluZyB0aGUgQVBJXG4gICAgYXN5bmMgX3F1ZXJ5KHJlcSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgTWVzc2FnZUFwaS5RdWVyeSwgW1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhQcmVmaXg6IHRoaXMucGF0aFByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLCB0aGlzLm1heFJldHJpZXMsIFJFVFJZX1NMRUVQX1RJTUUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHRocm93IEdycGNFcnJvci5mcm9tT2JqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJhdyBtZXRob2QgZm9yIGJhdGNoLXF1ZXJ5aW5nIHRoZSBBUElcbiAgICBfYmF0Y2hRdWVyeShyZXEpIHtcbiAgICAgICAgcmV0dXJuIHJldHJ5KFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIE1lc3NhZ2VBcGkuQmF0Y2hRdWVyeSwgW1xuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhQcmVmaXg6IHRoaXMucGF0aFByZWZpeCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sIHRoaXMubWF4UmV0cmllcywgUkVUUllfU0xFRVBfVElNRSk7XG4gICAgfVxuICAgIC8vIFJhdyBtZXRob2QgZm9yIHB1Ymxpc2hpbmcgdG8gdGhlIEFQSVxuICAgIGFzeW5jIF9wdWJsaXNoKHJlcSwgYXR0ZW1wdE51bWJlciA9IDApIHtcbiAgICAgICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgdGhpcy5nZXRUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7YXV0aFRva2VufWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgTWVzc2FnZUFwaS5QdWJsaXNoLCBbXG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFByZWZpeDogdGhpcy5wYXRoUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSwgdGhpcy5tYXhSZXRyaWVzLCBSRVRSWV9TTEVFUF9USU1FLCBcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXRyeSBVbmF1dGhlbnRpY2F0ZWRFcnJvcnNcbiAgICAgICAgICAgIGlzTm90QXV0aEVycm9yKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRyeSBhdCBtb3N0IDJYLiBJZiByZWZyZXNoaW5nIHRoZSBhdXRoIHRva2VuIGRvZXNuJ3Qgd29yayB0aGUgZmlyc3QgdGltZSwgaXQgd29uJ3Qgd29yayB0aGUgc2Vjb25kIHRpbWVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBpZiAoaXNOb3RBdXRoRXJyb3IoZSkgfHwgYXR0ZW1wdE51bWJlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICB0aHJvdyBHcnBjRXJyb3IuZnJvbU9iamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aENhY2hlPy5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVibGlzaChyZXEsIGF0dGVtcHROdW1iZXIgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSYXcgbWV0aG9kIGZvciBzdWJzY3JpYmluZ1xuICAgIF9zdWJzY3JpYmUocmVxLCBjYiwgb25Db25uZWN0aW9uTG9zdCkge1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGRvU3Vic2NyaWJlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgTWVzc2FnZUFwaS5TdWJzY3JpYmUocmVxLCBjYiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFByZWZpeDogdGhpcy5wYXRoUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJTdHJlYW0gY29ubmVjdGlvbiBjbG9zZWQuIFJlc3Vic2NyaWJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29ubmVjdGlvbkxvc3Q/LigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyKSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJTdHJlYW0gY29ubmVjdGlvbiBjbG9zZWQuIFJlc3Vic2NyaWJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29ubmVjdGlvbkxvc3Q/LigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBkb1N1YnNjcmliZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBRdWVyeSBBUEkgdG8gcmV0dXJuIHRoZSBmdWxsIGNvbnRlbnRzIG9mIGFueSBzcGVjaWZpZWQgdG9waWNzXG4gICAgYXN5bmMgcXVlcnkocGFyYW1zLCB7IGRpcmVjdGlvbiA9IFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HLCBsaW1pdCwgcGFnZVNpemUsIH0pIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGNvbnN0IG1heFBhZ2VTaXplID0gcGFyYW1zLmNvbnRlbnRUb3BpYy5zdGFydHNXaXRoKFwidXNlcnByZWZlcmVuY2VzLVwiKVxuICAgICAgICAgICAgPyA1MDBcbiAgICAgICAgICAgIDogMTAwO1xuICAgICAgICAvLyBVc2UgcXVlcnlJdGVyYXRlUGFnZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS4gMS8xMDB0aCB0aGUgbnVtYmVyIG9mIFByb21pc2VzIHRvIHJlc29sdmUgY29tcGFyZWQgdG8gcXVlcnlTdHJlYW1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMucXVlcnlJdGVyYXRlUGFnZXMocGFyYW1zLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGxpbWl0IG9mIDwgMTAwLCB1c2UgdGhhdCBhcyB0aGUgcGFnZSBzaXplLiBPdGhlcndpc2UgdXNlIDEwMCBhbmQgc3RvcCBpZi93aGVuIGxpbWl0IHJlYWNoZWQuXG4gICAgICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemUgPyBNYXRoLm1pbihwYWdlU2l6ZSwgbWF4UGFnZVNpemUpIDogbWF4UGFnZVNpemUsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudmVsb3BlIG9mIHBhZ2UpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChlbnZlbG9wZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ICYmIG91dC5sZW5ndGggPT09IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8vIFdpbGwgcHJvZHVjZSBhbiBBc3luY0dlbmVyYXRvciBvZiBFbnZlbG9wZXNcbiAgICAvLyBVc2VzIHF1ZXJ5U3RyZWFtUGFnZXMgdW5kZXIgdGhlIGhvb2RcbiAgICBhc3luYyAqcXVlcnlJdGVyYXRvcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMucXVlcnlJdGVyYXRlUGFnZXMocGFyYW1zLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnZlbG9wZSBvZiBwYWdlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZW52ZWxvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhbiBhc3luYyBnZW5lcmF0b3IgdGhhdCB3aWxsIHBhZ2luYXRlIHRocm91Z2ggdGhlIFF1ZXJ5IEFQSSB1bnRpbCBpdCByZWFjaGVzIHRoZSBlbmRcbiAgICAvLyBXaWxsIHlpZWxkIGVhY2ggcGFnZSBvZiByZXN1bHRzIGFzIG5lZWRlZFxuICAgIGFzeW5jICpxdWVyeUl0ZXJhdGVQYWdlcyh7IGNvbnRlbnRUb3BpYywgc3RhcnRUaW1lLCBlbmRUaW1lIH0sIHsgZGlyZWN0aW9uLCBwYWdlU2l6ZSA9IDEwIH0pIHtcbiAgICAgICAgaWYgKCFjb250ZW50VG9waWMgfHwgIWNvbnRlbnRUb3BpYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBjb250ZW50IHRvcGljc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWVOcyA9IHRvTmFub1N0cmluZyhzdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBlbmRUaW1lTnMgPSB0b05hbm9TdHJpbmcoZW5kVGltZSk7XG4gICAgICAgIGxldCBjdXJzb3I7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmdJbmZvID0ge1xuICAgICAgICAgICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3F1ZXJ5KHtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9waWNzOiBbY29udGVudFRvcGljXSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVOcyxcbiAgICAgICAgICAgICAgICBlbmRUaW1lTnMsXG4gICAgICAgICAgICAgICAgcGFnaW5nSW5mbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5lbnZlbG9wZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHJlc3VsdC5lbnZlbG9wZXMubWFwKG5vcm1hbGl6ZUVudmVsb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQucGFnaW5nSW5mbz8uY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgICAgICBjdXJzb3IgPSByZXN1bHQucGFnaW5nSW5mbz8uY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRha2UgYSBsaXN0IG9mIHF1ZXJpZXMgYW5kIGV4ZWN1dGUgdGhlbSBpbiBiYXRjaGVzXG4gICAgYXN5bmMgYmF0Y2hRdWVyeShxdWVyaWVzKSB7XG4gICAgICAgIC8vIEdyb3VwIHF1ZXJpZXMgaW50byBiYXRjaGVzIG9mIDUwIChpbXBsaWNpdCBzZXJ2ZXItc2lkZSBsaW1pdCkgYW5kIHRoZW4gcGVyZm9ybSBCYXRjaFF1ZXJpZXNcbiAgICAgICAgY29uc3QgQkFUQ0hfU0laRSA9IDUwO1xuICAgICAgICAvLyBLZWVwIGEgbGlzdCBvZiBCYXRjaFF1ZXJ5UmVxdWVzdHMgdG8gZXhlY3V0ZSBhbGwgYXQgb25jZSBsYXRlclxuICAgICAgICBjb25zdCBiYXRjaFJlcXVlc3RzID0gW107XG4gICAgICAgIC8vIEFzc2VtYmxlIGJhdGNoZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyaWVzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyaWVzSW5CYXRjaCA9IHF1ZXJpZXMuc2xpY2UoaSwgaSArIEJBVENIX1NJWkUpO1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBiYXRjaCBxdWVyeSBieSBmaXJzdCBjb21waWxpbmcgYSBsaXN0IG9mIHJlcGVhdGVkIGluZGl2aWR1YWwgUXVlcnlSZXF1ZXN0c1xuICAgICAgICAgICAgLy8gdGhlbiBwb3B1bGF0aW5nIGEgQmF0Y2hRdWVyeVJlcXVlc3Qgd2l0aCB0aGF0IGxpc3RcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkUXVlcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeVBhcmFtcyBvZiBxdWVyaWVzSW5CYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdGVkUXVlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFRvcGljczogW3F1ZXJ5UGFyYW1zLmNvbnRlbnRUb3BpY10sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZU5zOiB0b05hbm9TdHJpbmcocXVlcnlQYXJhbXMuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZU5zOiB0b05hbm9TdHJpbmcocXVlcnlQYXJhbXMuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luZ0luZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBxdWVyeVBhcmFtcy5wYWdlU2l6ZSB8fCAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogcXVlcnlQYXJhbXMuZGlyZWN0aW9uIHx8IFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmF0Y2hRdWVyeVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdHM6IGNvbnN0cnVjdGVkUXVlcmllcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiYXRjaFJlcXVlc3RzLnB1c2goYmF0Y2hRdWVyeVJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGUgYmF0Y2hlc1xuICAgICAgICBjb25zdCBiYXRjaFF1ZXJ5UmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hSZXF1ZXN0cy5tYXAoYXN5bmMgKGJhdGNoKSA9PiB0aGlzLl9iYXRjaFF1ZXJ5KGJhdGNoKSkpO1xuICAgICAgICAvLyBGb3IgZXZlcnkgYmF0Y2gsIHJlYWQgYWxsIHJlc3BvbnNlcyB3aXRoaW4gdGhlIGJhdGNoLCBhbmQgYWRkIHRvIGEgbGlzdCBvZiBsaXN0cyBvZiBlbnZlbG9wZXNcbiAgICAgICAgLy8gb25lIHRvcC1sZXZlbCBsaXN0IGZvciBldmVyeSBvcmlnaW5hbCBxdWVyeVxuICAgICAgICBjb25zdCBhbGxFbnZlbG9wZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBiYXRjaFJlc3BvbnNlIG9mIGJhdGNoUXVlcnlSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmICghYmF0Y2hSZXNwb25zZS5yZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBlcnJvciBvbiBhbnkgb2YgdGhlIGJhdGNoIHF1ZXJ5IGlzIHByb3BhZ2F0ZWQgdG8gdGhlIGNhbGxlclxuICAgICAgICAgICAgICAgIC8vIGZvciBzaW1wbGljaXR5LCByYXRoZXIgdGhhbiB0cnlpbmcgdG8gcmV0dXJuIHBhcnRpYWwgcmVzdWx0c1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoUXVlcnlSZXNwb25zZSBtaXNzaW5nIHJlc3BvbnNlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnlSZXNwb25zZSBvZiBiYXRjaFJlc3BvbnNlLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeVJlc3BvbnNlLmVudmVsb3Blcykge1xuICAgICAgICAgICAgICAgICAgICBhbGxFbnZlbG9wZXMucHVzaChxdWVyeVJlc3BvbnNlLmVudmVsb3Blcy5tYXAobm9ybWFsaXplRW52ZWxvcGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGVudmVsb3BlcyBwcm92aWRlZCwgdGhlbiBhZGQgYW4gZW1wdHkgbGlzdFxuICAgICAgICAgICAgICAgICAgICBhbGxFbnZlbG9wZXMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxFbnZlbG9wZXM7XG4gICAgfVxuICAgIC8vIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIHRoZSBuZXR3b3JrXG4gICAgLy8gV2lsbCBjb252ZXJ0IHRpbWVzdGFtcHMgdG8gdGhlIGFwcHJvcHJpYXRlIGZvcm1hdCBleHBlY3RlZCBieSB0aGUgbmV0d29ya1xuICAgIGFzeW5jIHB1Ymxpc2gobWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgdG9TZW5kID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBjb250ZW50VG9waWMsIG1lc3NhZ2UsIHRpbWVzdGFtcCB9IG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRUb3BpYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IHRvcGljIGNhbm5vdCBiZSBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMCBsZW5ndGggbWVzc2FnZXMgbm90IGFsbG93ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdG9TZW5kLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb3BpYyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBOczogdG9OYW5vU3RyaW5nKGR0KSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBVaW50OEFycmF5LmZyb20obWVzc2FnZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVibGlzaCh7IGVudmVsb3BlczogdG9TZW5kIH0pO1xuICAgIH1cbiAgICAvLyBTdWJzY3JpYmUgdG8gYSBsaXN0IG9mIHRvcGljcy5cbiAgICAvLyBQcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIG5ldyBtZXNzYWdlXG4gICAgLy8gUmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGVuZCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgc3Vic2NyaWJlKHBhcmFtcywgY2FsbGJhY2ssIG9uQ29ubmVjdGlvbkxvc3QpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMuY29udGVudFRvcGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBsaXN0IG9mIGNvbnRlbnRUb3BpY3MgdG8gc3Vic2NyaWJlIHRvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUocGFyYW1zLCBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1jb25mdXNpbmctdm9pZC1leHByZXNzaW9uXG4gICAgICAgIChlbnYpID0+IGNhbGxiYWNrKG5vcm1hbGl6ZUVudmVsb3BlKGVudikpLCBvbkNvbm5lY3Rpb25Mb3N0KTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRoQ2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhDYWNoZSBpcyBub3Qgc2V0IG9uIEFQSSBDbGllbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aENhY2hlLmdldFRva2VuKCk7XG4gICAgfVxuICAgIHNldEF1dGhlbnRpY2F0b3IoYXV0aGVudGljYXRvciwgY2FjaGVFeHBpcnlTZWNvbmRzKSB7XG4gICAgICAgIHRoaXMuYXV0aENhY2hlID0gbmV3IEF1dGhDYWNoZShhdXRoZW50aWNhdG9yLCBjYWNoZUV4cGlyeVNlY29uZHMpO1xuICAgIH1cbiAgICBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5zZXQoY2xpZW50VmVyc2lvbkhlYWRlcktleSwgdGhpcy52ZXJzaW9uKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwVmVyc2lvbikge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoYXBwVmVyc2lvbkhlYWRlcktleSwgdGhpcy5hcHBWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5cbmNvbnN0IENMT0NLX1NLRVdfT0ZGU0VUX01TID0gMTAwMDA7XG5jbGFzcyBKb2JSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGpvYlR5cGUsIGtleXN0b3JlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZU9mZnNldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmpvYlR5cGUgPSBqb2JUeXBlO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgICAgIHRoaXMua2V5c3RvcmUgPSBrZXlzdG9yZTtcbiAgICB9XG4gICAgZ2V0IHByb3RvSm9iVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFByb3RvSm9iVHlwZSh0aGlzLmpvYlR5cGUpO1xuICAgIH1cbiAgICBhc3luYyBydW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSdW4gPSBhd2FpdCB0aGlzLmdldExhc3RSdW5UaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2sobGFzdFJ1blxuICAgICAgICAgICAgICAgID8gIXRoaXMuZGlzYWJsZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKGxhc3RSdW4uZ2V0VGltZSgpIC0gQ0xPQ0tfU0tFV19PRkZTRVRfTVMpXG4gICAgICAgICAgICAgICAgICAgIDogbGFzdFJ1blxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0TGFzdFJ1blRpbWUoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZXNldExhc3RSdW5UaW1lKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmtleXN0b3JlLnNldFJlZnJlc2hKb2Ioe1xuICAgICAgICAgICAgam9iVHlwZTogdGhpcy5wcm90b0pvYlR5cGUsXG4gICAgICAgICAgICBsYXN0UnVuTnM6IGRhdGVUb05zKG5ldyBEYXRlKDApKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldExhc3RSdW5UaW1lKCkge1xuICAgICAgICBjb25zdCB7IGxhc3RSdW5OcyB9ID0gYXdhaXQgdGhpcy5rZXlzdG9yZS5nZXRSZWZyZXNoSm9iKGtleXN0b3JlLkdldFJlZnJlc2hKb2JSZXF1ZXN0LmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgIGpvYlR5cGU6IHRoaXMucHJvdG9Kb2JUeXBlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChsYXN0UnVuTnMuZXF1YWxzKExvbmcuZnJvbU51bWJlcigwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zVG9EYXRlKGxhc3RSdW5Ocyk7XG4gICAgfVxuICAgIGFzeW5jIHNldExhc3RSdW5UaW1lKGxhc3RSdW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5rZXlzdG9yZS5zZXRSZWZyZXNoSm9iKHtcbiAgICAgICAgICAgIGpvYlR5cGU6IHRoaXMucHJvdG9Kb2JUeXBlLFxuICAgICAgICAgICAgbGFzdFJ1bk5zOiBkYXRlVG9OcyhsYXN0UnVuKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UHJvdG9Kb2JUeXBlKGpvYlR5cGUpIHtcbiAgICBjb25zdCBwcm90b0pvYlR5cGUgPSB7XG4gICAgICAgIHYxOiBrZXlzdG9yZS5Kb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfVjEsXG4gICAgICAgIHYyOiBrZXlzdG9yZS5Kb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfVjIsXG4gICAgICAgIFwidXNlci1wcmVmZXJlbmNlc1wiOiBrZXlzdG9yZS5Kb2JUeXBlLkpPQl9UWVBFX1JFRlJFU0hfUFBQUCxcbiAgICB9W2pvYlR5cGVdO1xuICAgIGlmICghcHJvdG9Kb2JUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBqb2IgdHlwZTogJHtqb2JUeXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9Kb2JUeXBlO1xufVxuXG5jb25zdCBtZXNzYWdlSGFzSGVhZGVycyA9IChtc2cpID0+IHtcbiAgICByZXR1cm4gQm9vbGVhbihtc2cucmVjaXBpZW50QWRkcmVzcyAmJiBtc2cuc2VuZGVyQWRkcmVzcyk7XG59O1xuLyoqXG4gKiBDb252ZXJzYXRpb25zIGFsbG93cyB5b3UgdG8gdmlldyBvbmdvaW5nIDE6MSBtZXNzYWdpbmcgc2Vzc2lvbnMgd2l0aCBhbm90aGVyIHdhbGxldFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgQ29udmVyc2F0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnYxSm9iUnVubmVyID0gbmV3IEpvYlJ1bm5lcihcInYxXCIsIGNsaWVudC5rZXlzdG9yZSk7XG4gICAgICAgIHRoaXMudjJKb2JSdW5uZXIgPSBuZXcgSm9iUnVubmVyKFwidjJcIiwgY2xpZW50LmtleXN0b3JlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgY29udmVyc2F0aW9ucyB3aXRoIHRoZSBjdXJyZW50IHdhbGxldCBmb3VuZCBpbiB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KCkge1xuICAgICAgICBjb25zdCBbdjFDb252b3MsIHYyQ29udm9zXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMubGlzdFYxQ29udmVyc2F0aW9ucygpLFxuICAgICAgICAgICAgdGhpcy5saXN0VjJDb252ZXJzYXRpb25zKCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gdjFDb252b3MuY29uY2F0KHYyQ29udm9zKTtcbiAgICAgICAgY29udmVyc2F0aW9ucy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xuICAgICAgICByZXR1cm4gY29udmVyc2F0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgY29udmVyc2F0aW9ucyBzdG9yZWQgaW4gdGhlIGNsaWVudCBjYWNoZSwgd2hpY2ggbWF5IG5vdCBpbmNsdWRlXG4gICAgICogY29udmVyc2F0aW9ucyBvbiB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0RnJvbUNhY2hlKCkge1xuICAgICAgICBjb25zdCBbdjFDb252b3MsIHYyQ29udm9zXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuZ2V0VjFDb252ZXJzYXRpb25zRnJvbUtleXN0b3JlKCksXG4gICAgICAgICAgICB0aGlzLmdldFYyQ29udmVyc2F0aW9uc0Zyb21LZXlzdG9yZSgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IHYxQ29udm9zLmNvbmNhdCh2MkNvbnZvcyk7XG4gICAgICAgIGNvbnZlcnNhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYi5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RWMUNvbnZlcnNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYxSm9iUnVubmVyLnJ1bihhc3luYyAobGF0ZXN0U2VlbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VlblBlZXJzID0gYXdhaXQgdGhpcy5nZXRJbnRyb2R1Y3Rpb25QZWVycyh7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBsYXRlc3RTZWVuLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9BU0NFTkRJTkcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmtleXN0b3JlLnNhdmVWMUNvbnZlcnNhdGlvbnMoe1xuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbnM6IEFycmF5LmZyb20oc2VlblBlZXJzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChbcGVlckFkZHJlc3MsIGNyZWF0ZWRBdF0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkTnM6IGRhdGVUb05zKGNyZWF0ZWRBdCksXG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiBidWlsZERpcmVjdE1lc3NhZ2VUb3BpYyhwZWVyQWRkcmVzcywgdGhpcy5jbGllbnQuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY29uc2VudFByb29mUGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChjKSA9PiBpc1ZhbGlkVG9waWMoYy50b3BpYykpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuY2xpZW50LmtleXN0b3JlLmdldFYxQ29udmVyc2F0aW9ucygpKS5jb252ZXJzYXRpb25zLm1hcCh0aGlzLmNvbnZlcnNhdGlvblJlZmVyZW5jZVRvVjEuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBWMiBjb252ZXJzYXRpb25zXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFYyQ29udmVyc2F0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudjJKb2JSdW5uZXIucnVuKGFzeW5jIChsYXN0UnVuKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIGNvbnZlcnNhdGlvbnMgYWxyZWFkeSBpbiB0aGUgS2V5U3RvcmVcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgdGhpcy5nZXRWMkNvbnZlcnNhdGlvbnNGcm9tS2V5c3RvcmUoKTtcbiAgICAgICAgICAgIC8vIExvYWQgYWxsIGNvbnZlcnNhdGlvbnMgc3RhcnRlZCBhZnRlciB0aGUgbmV3ZXN0IGNvbnZlcnNhdGlvbiBmb3VuZFxuICAgICAgICAgICAgY29uc3QgbmV3Q29udmVyc2F0aW9ucyA9IGF3YWl0IHRoaXMudXBkYXRlVjJDb252ZXJzYXRpb25zKGxhc3RSdW4pO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgU2V0IG9mIGFsbCB0aGUgZXhpc3RpbmcgdG9waWNzIHRvIGVuc3VyZSBubyBkdXBsaWNhdGVzIGFyZSBhZGRlZFxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUb3BpY3MgPSBuZXcgU2V0KGV4aXN0aW5nLm1hcCgoYykgPT4gYy50b3BpYykpO1xuICAgICAgICAgICAgLy8gQWRkIGFsbCBuZXcgY29udmVyc2F0aW9ucyB0byB0aGUgZXhpc3RpbmcgbGlzdFxuICAgICAgICAgICAgZm9yIChjb25zdCBjb252byBvZiBuZXdDb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1RvcGljcy5oYXMoY29udm8udG9waWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2goY29udm8pO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1RvcGljcy5hZGQoY29udm8udG9waWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvcnQgdGhlIHJlc3VsdCBzZXQgYnkgY3JlYXRpb24gdGltZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICAgIGV4aXN0aW5nLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGIuY3JlYXRlZEF0LmdldFRpbWUoKSk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRWMkNvbnZlcnNhdGlvbnNGcm9tS2V5c3RvcmUoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5jbGllbnQua2V5c3RvcmUuZ2V0VjJDb252ZXJzYXRpb25zKCkpLmNvbnZlcnNhdGlvbnMubWFwKHRoaXMuY29udmVyc2F0aW9uUmVmZXJlbmNlVG9WMi5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VjFDb252ZXJzYXRpb25zRnJvbUtleXN0b3JlKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuY2xpZW50LmtleXN0b3JlLmdldFYxQ29udmVyc2F0aW9ucygpKS5jb252ZXJzYXRpb25zLm1hcCh0aGlzLmNvbnZlcnNhdGlvblJlZmVyZW5jZVRvVjEuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBpbiBsaXN0VjJDb252ZXJzYXRpb25zIGFuZCBpbiBuZXdDb252ZXJzYXRpb25cbiAgICBhc3luYyB1cGRhdGVWMkNvbnZlcnNhdGlvbnMoc3RhcnRUaW1lKSB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlcyA9IGF3YWl0IHRoaXMuY2xpZW50Lmxpc3RJbnZpdGF0aW9ucyh7XG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fQVNDRU5ESU5HLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW52aXRlcyhlbnZlbG9wZXMpO1xuICAgIH1cbiAgICBhc3luYyBkZWNvZGVJbnZpdGVzKGVudmVsb3Blcywgc2hvdWxkVGhyb3cgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IHJlc3BvbnNlcyB9ID0gYXdhaXQgdGhpcy5jbGllbnQua2V5c3RvcmUuc2F2ZUludml0ZXMoe1xuICAgICAgICAgICAgcmVxdWVzdHM6IGVudmVsb3Blc1xuICAgICAgICAgICAgICAgIC5tYXAoKGVudikgPT4gKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBlbnYubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBOczogTG9uZy5mcm9tU3RyaW5nKGVudi50aW1lc3RhbXBOcyksXG4gICAgICAgICAgICAgICAgY29udGVudFRvcGljOiBlbnYuY29udGVudFRvcGljLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmVxKSA9PiBpc1ZhbGlkVG9waWMocmVxLmNvbnRlbnRUb3BpYykpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHRoaXMuc2F2ZUludml0ZVJlc3BvbnNlVG9Db252ZXJzYXRpb24ocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3Igc2F2aW5nIGludml0ZSByZXNwb25zZSB0byBjb252ZXJzYXRpb246IFwiLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgc2F2ZUludml0ZVJlc3BvbnNlVG9Db252ZXJzYXRpb24oeyByZXN1bHQsIGVycm9yLCB9KSB7XG4gICAgICAgIGlmIChlcnJvciB8fCAhcmVzdWx0IHx8ICFyZXN1bHQuY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZyb20ga2V5c3RvcmU6ICR7ZXJyb3I/LmNvZGV9ICR7ZXJyb3I/Lm1lc3NhZ2V9fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnNhdGlvblJlZmVyZW5jZVRvVjIocmVzdWx0LmNvbnZlcnNhdGlvbik7XG4gICAgfVxuICAgIGNvbnZlcnNhdGlvblJlZmVyZW5jZVRvVjIoY29udm9SZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJzYXRpb25WMih0aGlzLmNsaWVudCwgY29udm9SZWYudG9waWMsIGNvbnZvUmVmLnBlZXJBZGRyZXNzLCBuc1RvRGF0ZShjb252b1JlZi5jcmVhdGVkTnMpLCBjb252b1JlZi5jb250ZXh0LCBjb252b1JlZi5jb25zZW50UHJvb2ZQYXlsb2FkKTtcbiAgICB9XG4gICAgY29udmVyc2F0aW9uUmVmZXJlbmNlVG9WMShjb252b1JlZikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvblYxKHRoaXMuY2xpZW50LCBjb252b1JlZi5wZWVyQWRkcmVzcywgbnNUb0RhdGUoY29udm9SZWYuY3JlYXRlZE5zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgYW55IG5ld2x5IGNyZWF0ZWQgY29udmVyc2F0aW9ucy5cbiAgICAgKiBXaWxsIGRlZHVwZSB0byBub3QgcmV0dXJuIHRoZSBzYW1lIGNvbnZlcnNhdGlvbiB0d2ljZSBpbiB0aGUgc2FtZSBzdHJlYW0uXG4gICAgICogRG9lcyBub3QgZGVkdXBlIGFueSBvdGhlciBwcmV2aW91c2x5IHNlZW4gY29udmVyc2F0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbShvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIGNvbnN0IHNlZW5QZWVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgaW50cm9Ub3BpYyA9IGJ1aWxkVXNlckludHJvVG9waWModGhpcy5jbGllbnQuYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGludml0ZVRvcGljID0gYnVpbGRVc2VySW52aXRlVG9waWModGhpcy5jbGllbnQuYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5ld1BlZXIgPSAocGVlckFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgc2VlbiB0aGUgcGVlciBhbHJlYWR5IGluIHRoaXMgc3RyZWFtXG4gICAgICAgICAgICBpZiAoc2VlblBlZXJzLmhhcyhwZWVyQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuUGVlcnMuYWRkKHBlZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVDb252ZXJzYXRpb24gPSBhc3luYyAoZW52KSA9PiB7XG4gICAgICAgICAgICBpZiAoZW52LmNvbnRlbnRUb3BpYyA9PT0gaW50cm9Ub3BpYykge1xuICAgICAgICAgICAgICAgIGlmICghZW52Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgZW52ZWxvcGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IE1lc3NhZ2VWMS5mcm9tQnl0ZXMoZW52Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlZXJBZGRyZXNzID0gdGhpcy5nZXRQZWVyQWRkcmVzcyhtc2cpO1xuICAgICAgICAgICAgICAgIGlmICghbmV3UGVlcihwZWVyQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgbXNnLmRlY3J5cHQodGhpcy5jbGllbnQua2V5c3RvcmUsIHRoaXMuY2xpZW50LnB1YmxpY0tleUJ1bmRsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJzYXRpb25WMSh0aGlzLmNsaWVudCwgcGVlckFkZHJlc3MsIG1zZy5zZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuY29udGVudFRvcGljID09PSBpbnZpdGVUb3BpYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmRlY29kZUludml0ZXMoW2Vudl0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgaW52aXRlIHRvcGljXCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbaW50cm9Ub3BpYywgaW52aXRlVG9waWNdO1xuICAgICAgICByZXR1cm4gU3RyZWFtLmNyZWF0ZSh0aGlzLmNsaWVudCwgdG9waWNzLCBkZWNvZGVDb252ZXJzYXRpb24uYmluZCh0aGlzKSwgdW5kZWZpbmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyBtZXNzYWdlcyBmcm9tIGFsbCBjb252ZXJzYXRpb25zLlxuICAgICAqXG4gICAgICogV2hlbiBhIG5ldyBjb252ZXJzYXRpb24gaXMgaW5pdGlhdGVkIHdpdGggdGhlIGNsaWVudCdzIGFkZHJlc3MsIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIGl0IGFuZCBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgY29udmVyc2F0aW9ucyB0byB3YXRjaC5cbiAgICAgKiBDYWxsZXJzIHNob3VsZCBiZSBhd2FyZSB0aGUgZmlyc3QgbWVzc2FnZXMgaW4gYSBuZXdseSBjcmVhdGVkIGNvbnZlcnNhdGlvbiBhcmUgcGlja2VkIHVwIG9uIGEgYmVzdCBlZmZvcnQgYmFzaXMgYW5kIHRoZXJlIGFyZSBvdGhlciBwb3RlbnRpYWwgcmFjZSBjb25kaXRpb25zIHdoaWNoIG1heSBjYXVzZSBzb21lIG5ld2x5IGNyZWF0ZWQgY29udmVyc2F0aW9ucyB0byBiZSBtaXNzZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1BbGxNZXNzYWdlcyhvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIGNvbnN0IGludHJvVG9waWMgPSBidWlsZFVzZXJJbnRyb1RvcGljKHRoaXMuY2xpZW50LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCBpbnZpdGVUb3BpYyA9IGJ1aWxkVXNlckludml0ZVRvcGljKHRoaXMuY2xpZW50LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBuZXcgU2V0KFtpbnRyb1RvcGljLCBpbnZpdGVUb3BpY10pO1xuICAgICAgICBjb25zdCBjb252b01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBjb252ZXJzYXRpb24gb2YgYXdhaXQgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgIHRvcGljcy5hZGQoY29udmVyc2F0aW9uLnRvcGljKTtcbiAgICAgICAgICAgIGNvbnZvTWFwLnNldChjb252ZXJzYXRpb24udG9waWMsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlTWVzc2FnZSA9IGFzeW5jIChlbnYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUb3BpYyA9IGVudi5jb250ZW50VG9waWM7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRUb3BpYyB8fCAhZW52Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50VG9waWMgPT09IGludHJvVG9waWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCBNZXNzYWdlVjEuZnJvbUJ5dGVzKGVudi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VIYXNIZWFkZXJzKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBlZXJBZGRyZXNzID0gdGhpcy5nZXRQZWVyQWRkcmVzcyhtc2cpO1xuICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IGNyZWF0ZSBhIGNvbnZvIHRvIGRlY3J5cHQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBjb252byA9IG5ldyBDb252ZXJzYXRpb25WMSh0aGlzLmNsaWVudCwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzLCBtc2cuc2VudCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBkdXBsaWNhdGVzIHRoZSBwcm90byBkZXNlcmlhbGl6YXRpb24gdW5uZWNlc3NhcmlseVxuICAgICAgICAgICAgICAgIC8vIFJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0ZSB3b3JrXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZvLmRlY29kZU1lc3NhZ2UoZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBhcyBhbiBpbnZpdGUgYW5kIHJldHVybiB0aGUgZW52ZWxvcGVcbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvbnRlbnRUb3BpY1VwZGF0ZXIgZXZlcnl0aGluZyBpdCBuZWVkcyB0byBhZGQgdG8gdGhlIHRvcGljIGxpc3RcbiAgICAgICAgICAgIGlmIChjb250ZW50VG9waWMgPT09IGludml0ZVRvcGljKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuZGVjb2RlSW52aXRlcyhbZW52XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb252byA9IGNvbnZvTWFwLmdldChjb250ZW50VG9waWMpO1xuICAgICAgICAgICAgLy8gRGVjb2RlIGFzIGEgVjEgbWVzc2FnZSBpZiB0aGUgdG9waWMgbWF0Y2hlcyBhIFYxIGNvbnZvXG4gICAgICAgICAgICBpZiAoY29udm8gaW5zdGFuY2VvZiBDb252ZXJzYXRpb25WMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252by5kZWNvZGVNZXNzYWdlKGVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgYXMgYSBWMiBtZXNzYWdlIGlmIHRoZSB0b3BpYyBtYXRjaGVzIGEgVjIgY29udm9cbiAgICAgICAgICAgIGlmIChjb252byBpbnN0YW5jZW9mIENvbnZlcnNhdGlvblYyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZvLmRlY29kZU1lc3NhZ2UoZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biB0b3BpY1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdG9waWNcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZENvbnZvID0gKHRvcGljLCBjb252ZXJzYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0b3BpY3MuaGFzKHRvcGljKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnZvTWFwLnNldCh0b3BpYywgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgIHRvcGljcy5hZGQodG9waWMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUb3BpY1VwZGF0ZXIgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgVjEgbWVzc2FnZSBmcm9tIHRoZSBpbnRyb1RvcGljLCBzdG9yZSB0aGUgY29udmVyc2F0aW9uIGluIG91ciBtYXBwaW5nXG4gICAgICAgICAgICBpZiAobXNnIGluc3RhbmNlb2YgRGVjb2RlZE1lc3NhZ2UgJiYgbXNnLmNvbnRlbnRUb3BpYyA9PT0gaW50cm9Ub3BpYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZvID0gbmV3IENvbnZlcnNhdGlvblYxKHRoaXMuY2xpZW50LCBtc2cucmVjaXBpZW50QWRkcmVzcz8udG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnNlbmRlckFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgOiBtc2cucmVjaXBpZW50QWRkcmVzcywgbXNnLnNlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTmV3ID0gYWRkQ29udm8oY29udm8udG9waWMsIGNvbnZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOZXcgPyBBcnJheS5mcm9tKHRvcGljcy52YWx1ZXMoKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXNnIGluc3RhbmNlb2YgQ29udmVyc2F0aW9uVjIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc05ldyA9IGFkZENvbnZvKG1zZy50b3BpYywgbXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOZXcgPyBBcnJheS5mcm9tKHRvcGljcy52YWx1ZXMoKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHIgPSBhd2FpdCBTdHJlYW0uY3JlYXRlKHRoaXMuY2xpZW50LCBBcnJheS5mcm9tKHRvcGljcy52YWx1ZXMoKSksIGRlY29kZU1lc3NhZ2UsIGNvbnRlbnRUb3BpY1VwZGF0ZXIsIG9uQ29ubmVjdGlvbkxvc3QpO1xuICAgICAgICBjb25zdCBnZW4gPSAoYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRlKCkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2Ygc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERlY29kZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbnZlcnNhdGlvbiBWMiwgd2UgbWF5IGhhdmUgbWVzc2FnZXMgaW4gdGhlIG5ldyB0b3BpYyBiZWZvcmUgd2Ugc3RhcnRlZCBzdHJlYW1pbmcuXG4gICAgICAgICAgICAgICAgLy8gVG8gYmUgc2FmZSwgd2UgZmV0Y2ggYWxsIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIENvbnZlcnNhdGlvblYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udm9NZXNzYWdlIG9mIGF3YWl0IHZhbC5tZXNzYWdlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBjb252b01lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZ2VuZXJhdG9yJ3MgcmV0dXJuIG1ldGhvZCB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBzdHJlYW1cbiAgICAgICAgLy8gR2VuZXJhdG9ycyBieSBkZWZhdWx0IG5lZWQgdG8gd2FpdCB1bnRpbCB0aGUgbmV4dCB5aWVsZCB0byByZXR1cm4uXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhhdCdzIG9ubHkgd2hlbiB0aGUgbmV4dCBtZXNzYWdlIGFycml2ZXMuLi53aGljaCBjb3VsZCBiZSBhIGxvbmcgdGltZVxuICAgICAgICBnZW4ucmV0dXJuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuaW5nIHRoZSBzdHJlYW0gd2lsbCBjYXVzZSB0aGUgaXRlcmF0aW9uIHRvIGVuZCBpbnNpZGUgdGhlIGdlbmVyYXRvclxuICAgICAgICAgICAgLy8gVGhlIGdlbmVyYXRvciB3aWxsIHRoZW4gcmV0dXJuIG9uIGl0cyBvd25cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICBhd2FpdCBzdHI/LnJldHVybigpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuO1xuICAgIH1cbiAgICBhc3luYyBnZXRJbnRyb2R1Y3Rpb25QZWVycyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IHRvcGljID0gYnVpbGRVc2VySW50cm9Ub3BpYyh0aGlzLmNsaWVudC5hZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5saXN0RW52ZWxvcGVzKHRvcGljLCAoZW52KSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCFlbnYubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGVudmVsb3BlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2VWMS5mcm9tQnl0ZXMoZW52Lm1lc3NhZ2UpO1xuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgY29uc3Qgc2VlblBlZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgbWVzc2FnZXMgd2l0aG91dCBzZW5kZXIgb3IgcmVjaXBpZW50IGFkZHJlc3MgaGVhZGVyc1xuICAgICAgICAgICAgLy8gTWFrZXMgZ2V0UGVlckFkZHJlc3Mgc2FmZVxuICAgICAgICAgICAgaWYgKCFtZXNzYWdlSGFzSGVhZGVycyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGVlckFkZHJlc3MgPSB0aGlzLmdldFBlZXJBZGRyZXNzKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHBlZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGF2ZSA9IHNlZW5QZWVycy5nZXQocGVlckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZSB8fCBoYXZlID4gbWVzc2FnZS5zZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgbWVzc2FnZSBjYW4gYmUgZGVjcnlwdGVkIGJlZm9yZSB0cmVhdGluZyB0aGUgaW50cm8gYXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2UuZGVjcnlwdCh0aGlzLmNsaWVudC5rZXlzdG9yZSwgdGhpcy5jbGllbnQucHVibGljS2V5QnVuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5QZWVycy5zZXQocGVlckFkZHJlc3MsIG1lc3NhZ2Uuc2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWVuUGVlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29udmVyc2F0aW9uIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcy4gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcGVlciBpcyBub3QgZm91bmQgaW4gdGhlIFhNVFAgbmV0d29ya1xuICAgICAqL1xuICAgIGFzeW5jIG5ld0NvbnZlcnNhdGlvbihwZWVyQWRkcmVzcywgY29udGV4dCwgY29uc2VudFByb29mKSB7XG4gICAgICAgIC8vIERlZmluZSBhIGZ1bmN0aW9uIGZvciBtYXRjaGluZyBWMiBjb252ZXJzYXRpb25zXG4gICAgICAgIGNvbnN0IG1hdGNoZXJGbiA9IChjb252bykgPT4gY29udm8ucGVlckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gcGVlckFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgaXNNYXRjaGluZ0NvbnRleHQoY29udGV4dCwgY29udm8uY29udGV4dCA/PyB1bmRlZmluZWQpO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBWMiBjb252ZXJzYXRpb24gd2l0aCB0aGUgcGVlciBpbiBrZXlzdG9yZVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHRoaXMuZ2V0VjJDb252ZXJzYXRpb25zRnJvbUtleXN0b3JlKCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWF0Y2ggPSBleGlzdGluZy5maW5kKG1hdGNoZXJGbik7XG4gICAgICAgIGlmIChleGlzdGluZ01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFjdCA9IGF3YWl0IHRoaXMuY2xpZW50LmdldFVzZXJDb250YWN0KHBlZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKCFjb250YWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2lwaWVudCAke3BlZXJBZGRyZXNzfSBpcyBub3Qgb24gdGhlIFhNVFAgbmV0d29ya2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZWVyQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0aGlzLmNsaWVudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlbGYgbWVzc2FnaW5nIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIFYxIGNvbnZlcnNhdGlvbiBjb250aW51YXRpb25cbiAgICAgICAgaWYgKGNvbnRhY3QgaW5zdGFuY2VvZiBQdWJsaWNLZXlCdW5kbGUgJiYgIWNvbnRleHQ/LmNvbnZlcnNhdGlvbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvblYxKHRoaXMuY2xpZW50LCBwZWVyQWRkcmVzcywgbmV3IERhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gY29udmVyc2F0aW9uSWQsIGNoZWNrIGFuZCBzZWUgaWYgd2UgaGF2ZSBhbiBleGlzdGluZyBWMSBjb252ZXJzYXRpb25cbiAgICAgICAgaWYgKCFjb250ZXh0Py5jb252ZXJzYXRpb25JZCkge1xuICAgICAgICAgICAgY29uc3QgdjFDb252b3MgPSBhd2FpdCB0aGlzLmxpc3RWMUNvbnZlcnNhdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nQ29udm8gPSB2MUNvbnZvcy5maW5kKChjb252bykgPT4gY29udm8ucGVlckFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gcGVlckFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAvLyBJZiBpbnRybyBhbHJlYWR5IGV4aXN0cywgcmV0dXJuIFYxIGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgLy8gaWYgYm90aCBwZWVycyBoYXZlIFYxIGNvbXBhdGlibGUga2V5IGJ1bmRsZXNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0NvbnZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5zaWduZWRQdWJsaWNLZXlCdW5kbGUuaXNGcm9tTGVnYWN5QnVuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHJlc3VtZSBwcmUtZXhpc3RpbmcgVjEgY29udmVyc2F0aW9uOyBjbGllbnQga2V5cyBub3QgY29tcGF0aWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY29udGFjdCBpbnN0YW5jZW9mIFB1YmxpY0tleUJ1bmRsZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbnRhY3QuaXNGcm9tTGVnYWN5QnVuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHJlc3VtZSBwcmUtZXhpc3RpbmcgVjEgY29udmVyc2F0aW9uOyBwZWVyIGtleXMgbm90IGNvbXBhdGlibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ0NvbnZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvZXJjZSB0aGUgY29udGFjdCBpbnRvIGEgVjIgYnVuZGxlXG4gICAgICAgIGlmIChjb250YWN0IGluc3RhbmNlb2YgUHVibGljS2V5QnVuZGxlKSB7XG4gICAgICAgICAgICBjb250YWN0ID0gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21MZWdhY3lCdW5kbGUoY29udGFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudjJKb2JSdW5uZXIucnVuKGFzeW5jIChsYXN0UnVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtcyA9IGF3YWl0IHRoaXMudXBkYXRlVjJDb252ZXJzYXRpb25zKGxhc3RSdW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbU1hdGNoID0gbmV3SXRlbXMuZmluZChtYXRjaGVyRm4pO1xuICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRob3NlIG1hdGNoZXMsIHJldHVybiBpdCB0byB1cGRhdGUgdGhlIGNhY2hlXG4gICAgICAgICAgICBpZiAobmV3SXRlbU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0l0ZW1NYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVYyQ29udm8oXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb250YWN0LCBjb250ZXh0LCBjb25zZW50UHJvb2YpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVjJDb252byhyZWNpcGllbnQsIGNvbnRleHQsIGNvbnNlbnRQcm9vZikge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB7IHBheWxvYWQsIGNvbnZlcnNhdGlvbiB9ID0gYXdhaXQgdGhpcy5jbGllbnQua2V5c3RvcmUuY3JlYXRlSW52aXRlKHtcbiAgICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjcmVhdGVkTnM6IGRhdGVUb05zKHRpbWVzdGFtcCksXG4gICAgICAgICAgICBjb25zZW50UHJvb2YsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIXBheWxvYWQgfHwgIWNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgZmllbGQgbm90IHJldHVybmVkIGZyb20gS2V5c3RvcmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVlckFkZHJlc3MgPSBhd2FpdCByZWNpcGllbnQud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5wdWJsaXNoRW52ZWxvcGVzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9waWM6IGJ1aWxkVXNlckludml0ZVRvcGljKHBlZXJBZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudFRvcGljOiBidWlsZFVzZXJJbnZpdGVUb3BpYyh0aGlzLmNsaWVudC5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBhZGQgcGVlciBhZGRyZXNzIHRvIGFsbG93IGxpc3RcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29udGFjdHMuYWxsb3coW3BlZXJBZGRyZXNzXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnNhdGlvblJlZmVyZW5jZVRvVjIoY29udmVyc2F0aW9uKTtcbiAgICB9XG4gICAgZ2V0UGVlckFkZHJlc3MobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBwZWVyQWRkcmVzcyA9IG1lc3NhZ2UucmVjaXBpZW50QWRkcmVzcz8udG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgPyBtZXNzYWdlLnNlbmRlckFkZHJlc3NcbiAgICAgICAgICAgIDogbWVzc2FnZS5yZWNpcGllbnRBZGRyZXNzO1xuICAgICAgICAvLyBUaGlzIGFzc2VydGlvbiBpcyBzYWZlLCBzbyBsb25nIGFzIG1lc3NhZ2VzIGhhdmUgYmVlbiB0aHJvdWdoIHRoZSBmaWx0ZXJcbiAgICAgICAgcmV0dXJuIHBlZXJBZGRyZXNzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdDb250ZXh0KGNvbnRleHRBLCBjb250ZXh0Qikge1xuICAgIC8vIFVzZSA9PSB0byBhbGxvdyBudWxsIGFuZCB1bmRlZmluZWQgdG8gYmUgZXF1aXZhbGVudFxuICAgIHJldHVybiBjb250ZXh0QT8uY29udmVyc2F0aW9uSWQgPT09IGNvbnRleHRCPy5jb252ZXJzYXRpb25JZDtcbn1cblxuY2xhc3MgQnJvd3NlclN0b3JhZ2VQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBMb2NhbFN0b3JhZ2UuIFVzZSBlcGhlbWVyYWxQZXJzaXN0ZW5jZSBpbnN0ZWFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJvd3NlclN0b3JhZ2VQZXJzaXN0ZW5jZShsb2NhbFN0b3JhZ2UpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBnZXRJdGVtKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiaW5hcnlcIikpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgIH1cbn1cblxuLy8gRnVsbHkgaW4tbWVtb3J5IHBvbHlmaWxsIGZvciB0aGUgYnJvd3NlciBzdG9yYWdlIEFQSS5cbi8vIEJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01pdGNoZWxsQ2FzaC9ub2RlLXN0b3JhZ2UtcG9seWZpbGwgYnV0IGltcGxlbWVudGVkIGFzIGEgcG9ueWZpbGwgaW5zdGVhZCBvZiBhIHBvbHlmaWxsXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb255ZmlsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnNpemU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlU3RyaW5nKGtleSk7XG4gICAgICAgIGlmICh0aGlzLnN0b3JlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3RvcmUuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBrZXkoaW5kZXgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIFR5cGVFcnJvciBpbXBsZW1lbnRlZCBpbiBDaHJvbWUsIEZpcmVmb3ggdGhyb3dzIFwiU3RvcmFnZS5rZXk6IEF0IGxlYXN0IDFcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHBhc3NlZFwiLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdrZXknIG9uICdTdG9yYWdlJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gWy4uLnRoaXMuc3RvcmUua2V5cygpXTtcbiAgICAgICAgaWYgKGluZGV4ID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5c1tpbmRleF07XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVTdHJpbmcoa2V5KTtcbiAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVTdHJpbmcoa2V5KTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmUuc2V0KFN0cmluZyhrZXkpLCBTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTdHJpbmcodmFsKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEluTWVtb3J5UGVyc2lzdGVuY2UgZXh0ZW5kcyBCcm93c2VyU3RvcmFnZVBlcnNpc3RlbmNlIHtcbiAgICBzdGF0aWMgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJTdG9yYWdlUGVyc2lzdGVuY2UobmV3IExvY2FsU3RvcmFnZVBvbnlmaWxsKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgS2V5c3RvcmVQcm92aWRlclVuYXZhaWxhYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jbGFzcyBMb2NhbEF1dGhlbnRpY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGlkZW50aXR5S2V5KSB7XG4gICAgICAgIGlmICghaWRlbnRpdHlLZXkucHVibGljS2V5LnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZWQgcHVibGljIGtleSBpcyBub3Qgc2lnbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRlbnRpdHlLZXkgPSBpZGVudGl0eUtleTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVG9rZW4odGltZXN0YW1wKSB7XG4gICAgICAgIGNvbnN0IGF1dGhEYXRhID0gQXV0aERhdGEuY3JlYXRlKHRoaXMuaWRlbnRpdHlLZXkucHVibGljS2V5LndhbGxldFNpZ25hdHVyZUFkZHJlc3MoKSwgdGltZXN0YW1wIHx8IG5ldyBEYXRlKCkpO1xuICAgICAgICBjb25zdCBhdXRoRGF0YUJ5dGVzID0gYXV0aERhdGEudG9CeXRlcygpO1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoYXV0aERhdGFCeXRlcyk7XG4gICAgICAgIGNvbnN0IGF1dGhTaWcgPSBhd2FpdCB0aGlzLmlkZW50aXR5S2V5LnNpZ24oaGV4VG9CeXRlcyhkaWdlc3QpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihhdXRobi5Ub2tlbi5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICBpZGVudGl0eUtleTogcHVibGljS2V5LlB1YmxpY0tleS5mcm9tUGFydGlhbChcbiAgICAgICAgICAgIC8vIFRoZSBnZW5lcmF0ZWQgdHlwZXMgYXJlIG92ZXJseSBzdHJpY3QgYW5kIGRvbid0IGxpa2Ugb3VyIGFkZGl0aW9uYWwgbWV0aG9kc1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5S2V5LnB1YmxpY0tleSksXG4gICAgICAgICAgICBhdXRoRGF0YUJ5dGVzLFxuICAgICAgICAgICAgLy8gVGhlIGdlbmVyYXRlZCB0eXBlcyBhcmUgb3Zlcmx5IHN0cmljdCBhbmQgZG9uJ3QgbGlrZSBvdXIgYWRkaXRpb25hbCBtZXRob2RzXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGF1dGhEYXRhU2lnbmF0dXJlOiBzaWduYXR1cmUuU2lnbmF0dXJlLmZyb21QYXJ0aWFsKGF1dGhTaWcpLFxuICAgICAgICB9KSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGZpbGUgaXMgdGFrZW4gZnJvbSBgYml0Y2hhbi9lY2NyeXB0b2AgYW5kIHBvcnRlZCB0byBUUy4gQWxsIHJlZmVyZW5jZXMgdG8gYG5vZGVDcnlwdG9gIGhhdmUgYmVlbiByZXBsYWNlZCB3aXRoIGBicm93c2VyQ3J5cHRvYFxuLyoqXG4gKiBgZWxsaXB0aWNgIGlzIGEgQ29tbW9uSlMgbW9kdWxlIGFuZCBoYXMgaXNzdWVzIHdpdGggbmFtZWQgaW1wb3J0c1xuICogRE8gTk9UIENIQU5HRSBUSElTIFRPIEEgTkFNRUQgSU1QT1JUXG4gKi9cbmNvbnN0IEVDID0gZWxsaXB0aWMuZWM7XG5jb25zdCBlYyA9IG5ldyBFQyhcInNlY3AyNTZrMVwiKTtcbmNvbnN0IHN1YnRsZSA9IGNyeXB0by5zdWJ0bGU7XG5jb25zdCBFQ19HUk9VUF9PUkRFUiA9IEJ1ZmZlci5mcm9tKFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiLCBcImhleFwiKTtcbmNvbnN0IFpFUk8zMiA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2NhbGFyKHgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIWlzU2NhbGFyKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChwcml2YXRlS2V5LmNvbXBhcmUoWkVSTzMyKSA+IDAgJiYgLy8gPiAwXG4gICAgICAgIHByaXZhdGVLZXkuY29tcGFyZShFQ19HUk9VUF9PUkRFUikgPCAwKTsgLy8gPCBHXG59XG4vLyBDb21wYXJlIHR3byBidWZmZXJzIGluIGNvbnN0YW50IHRpbWUgdG8gcHJldmVudCB0aW1pbmcgYXR0YWNrcy5cbmZ1bmN0aW9uIGVxdWFsQ29uc3RUaW1lKGIxLCBiMikge1xuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCByZXMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzIHw9IGIxW2ldIF4gYjJbaV07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIH1cbiAgICByZXR1cm4gcmVzID09PSAwO1xufVxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoc2l6ZSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTUxMihtc2cpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBtc2cpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShkaWdlc3QpO1xufVxuZnVuY3Rpb24gZ2V0QWVzKG9wKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdiwga2V5LCBkYXRhKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHsgbmFtZTogXCJBRVMtQ0JDXCIgfTtcbiAgICAgICAgICAgIGNvbnN0IGtleXAgPSBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW29wXSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cFxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjcnlwdG9LZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNBbGdvcml0aG0gPSB7IG5hbWU6IFwiQUVTLUNCQ1wiLCBpdiB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0bGVbb3BdKGVuY0FsZ29yaXRobSwgY3J5cHRvS2V5LCBkYXRhKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzdWx0KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBhZXNDYmNFbmNyeXB0ID0gZ2V0QWVzKFwiZW5jcnlwdFwiKTtcbmNvbnN0IGFlc0NiY0RlY3J5cHQgPSBnZXRBZXMoXCJkZWNyeXB0XCIpO1xuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpIHtcbiAgICBjb25zdCBuZXdLZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogeyBuYW1lOiBcIlNIQS0yNTZcIiB9IH0sIGZhbHNlLCBbXCJzaWduXCJdKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXdhaXQgc3VidGxlLnNpZ24oeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSwgbmV3S2V5LCBtc2cpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZWZXJpZnkoa2V5LCBtc2csIHNpZykge1xuICAgIGNvbnN0IGV4cGVjdGVkU2lnID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpO1xuICAgIHJldHVybiBlcXVhbENvbnN0VGltZShleHBlY3RlZFNpZywgc2lnKTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpYyhwcml2YXRlS2V5KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgc3luYyBBUEkgc28gd2UgdGhyb3cgYW4gZXJyb3IgaW1tZWRpYXRlbHkuXG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgICAvLyBYWFgoS2FnYW1pKTogYGVsbGlwdGljLnV0aWxzLmVuY29kZWAgcmV0dXJucyBhcnJheSBmb3IgZXZlcnlcbiAgICAvLyBlbmNvZGluZyBleGNlcHQgYGhleGAuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhcImFycmF5XCIpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZShwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICAgICAgICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgICAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gMiB8fCBwdWJsaWNLZXlCWzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUEgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5QSk7XG4gICAgICAgIGNvbnN0IGtleUIgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleUIpO1xuICAgICAgICBjb25zdCBQeCA9IGtleUEuZGVyaXZlKGtleUIuZ2V0UHVibGljKCkpOyAvLyBCTiBpbnN0YW5jZVxuICAgICAgICByZXNvbHZlKEJ1ZmZlci5mcm9tKFB4LnRvQXJyYXkoKSkpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChwdWJsaWNLZXlUbywgbXNnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHVwbGljYXRlLXR5cGUtY29uc3RpdHVlbnRzXG5vcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgLy8gVGFrZSBJViBmcm9tIG9wdHMgb3IgZ2VuZXJhdGUgcmFuZG9tbHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGNvbnN0IGl2ID0gb3B0cz8uaXYgfHwgcmFuZG9tQnl0ZXMoMTYpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgbGV0IGVwaGVtUHJpdmF0ZUtleSA9IG9wdHM/LmVwaGVtUHJpdmF0ZUtleSB8fCByYW5kb21CeXRlcygzMik7XG4gICAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHVubGlrZWx5IHBvc3NpYmlsaXR5IHRoYXQgaXQgaXMgbm90IGEgdmFsaWQga2V5XG4gICAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShlcGhlbVByaXZhdGVLZXkpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmIChvcHRzPy5lcGhlbVByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVwaGVtUHJpdmF0ZUtleSBpcyBub3QgdmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXBoZW1Qcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgZXBoZW1lcmFsIHByaXZhdGUga2V5XG4gICAgY29uc3QgZXBoZW1lcmFsUHVibGljS2V5ID0gZ2V0UHVibGljKGVwaGVtUHJpdmF0ZUtleSk7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihhd2FpdCBkZXJpdmUoZXBoZW1Qcml2YXRlS2V5LCBwdWJsaWNLZXlUbykpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXdhaXQgYWVzQ2JjRW5jcnlwdChpdiwgZW5jcnlwdGlvbktleSwgbXNnKTtcbiAgICAvLyBHZXQgYSBNQUNcbiAgICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtpdiwgZXBoZW1lcmFsUHVibGljS2V5LCBjaXBoZXJ0ZXh0XSk7XG4gICAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24obWFjS2V5LCBkYXRhVG9NYWMpO1xuICAgIC8vIFJldHVybiB0aGUgcGF5bG9hZFxuICAgIHJldHVybiB7XG4gICAgICAgIGl2LFxuICAgICAgICBlcGhlbWVyYWxQdWJsaWNLZXksXG4gICAgICAgIGNpcGhlcnRleHQsXG4gICAgICAgIG1hYyxcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChwcml2YXRlS2V5LCBvcHRzKSB7XG4gICAgY29uc3QgcHggPSBhd2FpdCBkZXJpdmUocHJpdmF0ZUtleSwgb3B0cy5lcGhlbWVyYWxQdWJsaWNLZXkpO1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIocHgpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgb3B0cy5pdixcbiAgICAgICAgb3B0cy5lcGhlbWVyYWxQdWJsaWNLZXksXG4gICAgICAgIG9wdHMuY2lwaGVydGV4dCxcbiAgICBdKTtcbiAgICBhc3NlcnQoYXdhaXQgaG1hY1NoYTI1NlZlcmlmeShtYWNLZXksIGRhdGFUb01hYywgb3B0cy5tYWMpLCBcIkJhZCBtYWNcIik7XG4gICAgcmV0dXJuIGFlc0NiY0RlY3J5cHQob3B0cy5pdiwgZW5jcnlwdGlvbktleSwgb3B0cy5jaXBoZXJ0ZXh0KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG5hc3luYyBmdW5jdGlvbiB1c2VyUHJlZmVyZW5jZXNFbmNyeXB0KGlkZW50aXR5S2V5LCBwYXlsb2FkKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gaWRlbnRpdHlLZXkucHVibGljS2V5LnNlY3AyNTZrMVVuY29tcHJlc3NlZC5ieXRlcztcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gaWRlbnRpdHlLZXkuc2VjcDI1NmsxLmJ5dGVzO1xuICAgIHJldHVybiB1c2VyX3ByZWZlcmVuY2VzX2VuY3J5cHQocHVibGljS2V5LCBwcml2YXRlS2V5LCBwYXlsb2FkKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuYXN5bmMgZnVuY3Rpb24gdXNlclByZWZlcmVuY2VzRGVjcnlwdChpZGVudGl0eUtleSwgcGF5bG9hZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGlkZW50aXR5S2V5LnB1YmxpY0tleS5zZWNwMjU2azFVbmNvbXByZXNzZWQuYnl0ZXM7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGlkZW50aXR5S2V5LnNlY3AyNTZrMS5ieXRlcztcbiAgICByZXR1cm4gdXNlcl9wcmVmZXJlbmNlc19kZWNyeXB0KHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgcGF5bG9hZCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVXNlclByZWZlcmVuY2VzVG9waWMoaWRlbnRpdHlLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gaWRlbnRpdHlLZXkuc2VjcDI1NmsxLmJ5dGVzO1xuICAgIHJldHVybiBnZW5lcmF0ZV9wcml2YXRlX3ByZWZlcmVuY2VzX3RvcGljKHByaXZhdGVLZXkpO1xufVxuXG4vKipcbiAqIEludml0YXRpb25WMSBpcyBhIHByb3RvYnVmIG1lc3NhZ2UgdG8gYmUgZW5jcnlwdGVkIGFuZCB1c2VkIGFzIHRoZSBjaXBoZXJ0ZXh0IGluIGEgU2VhbGVkSW52aXRhdGlvblYxIG1lc3NhZ2VcbiAqL1xuY2xhc3MgSW52aXRhdGlvblYxIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHRvcGljLCBjb250ZXh0LCBhZXMyNTZHY21Ia2RmU2hhMjU2LCBjb25zZW50UHJvb2YsIH0pIHtcbiAgICAgICAgaWYgKCF0b3BpYyB8fCAhdG9waWMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHRvcGljXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWVzMjU2R2NtSGtkZlNoYTI1NiB8fFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgICFhZXMyNTZHY21Ia2RmU2hhMjU2LmtleU1hdGVyaWFsIHx8XG4gICAgICAgICAgICAhYWVzMjU2R2NtSGtkZlNoYTI1Ni5rZXlNYXRlcmlhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcga2V5IG1hdGVyaWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9waWMgPSB0b3BpYztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hZXMyNTZHY21Ia2RmU2hhMjU2ID0gYWVzMjU2R2NtSGtkZlNoYTI1NjtcbiAgICAgICAgdGhpcy5jb25zZW50UHJvb2YgPSBjb25zZW50UHJvb2Y7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20oY29udGV4dCwgY29uc2VudFByb29mKSB7XG4gICAgICAgIGNvbnN0IHRvcGljID0gYnVpbGREaXJlY3RNZXNzYWdlVG9waWNWMihCdWZmZXIuZnJvbShjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSkpXG4gICAgICAgICAgICAudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC89KiQvZywgXCJcIilcbiAgICAgICAgICAgIC8vIFJlcGxhY2Ugc2xhc2hlcyB3aXRoIGRhc2hlcyBzbyB0aGF0IHRoZSB0b3BpYyBpcyBzdGlsbCBlYXNpbHkgc3BsaXQgYnkgL1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHRyZWF0IHRoaXMgYXMgbmVlZGluZyB0byBiZSB2YWxpZCBCYXNlNjQgYW55d2hlcmVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCItXCIpKTtcbiAgICAgICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG4gICAgICAgIHJldHVybiBuZXcgSW52aXRhdGlvblYxKHtcbiAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgYWVzMjU2R2NtSGtkZlNoYTI1NjogeyBrZXlNYXRlcmlhbCB9LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGNvbnNlbnRQcm9vZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBpbnZpdGF0aW9uLkludml0YXRpb25WMS5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZpdGF0aW9uVjEoaW52aXRhdGlvbi5JbnZpdGF0aW9uVjEuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZWFsZWRJbnZpdGF0aW9uSGVhZGVyVjEgaXMgYSBwcm90b2J1ZiBtZXNzYWdlIHRvIGJlIHVzZWQgYXMgdGhlIGhlYWRlckJ5dGVzIGluIGEgU2VhbGVkSW52aXRhdGlvblYxXG4gKi9cbmNsYXNzIFNlYWxlZEludml0YXRpb25IZWFkZXJWMSB7XG4gICAgY29uc3RydWN0b3IoeyBzZW5kZXIsIHJlY2lwaWVudCwgY3JlYXRlZE5zLCB9KSB7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY2lwaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZWNpcGllbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kZXIgPSBuZXcgU2lnbmVkUHVibGljS2V5QnVuZGxlKHNlbmRlcik7XG4gICAgICAgIHRoaXMucmVjaXBpZW50ID0gbmV3IFNpZ25lZFB1YmxpY0tleUJ1bmRsZShyZWNpcGllbnQpO1xuICAgICAgICB0aGlzLmNyZWF0ZWROcyA9IGNyZWF0ZWROcztcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGludml0YXRpb24uU2VhbGVkSW52aXRhdGlvbkhlYWRlclYxLmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFNlYWxlZEludml0YXRpb25IZWFkZXJWMShpbnZpdGF0aW9uLlNlYWxlZEludml0YXRpb25IZWFkZXJWMS5kZWNvZGUoYnl0ZXMpKTtcbiAgICB9XG59XG5jbGFzcyBTZWFsZWRJbnZpdGF0aW9uVjEge1xuICAgIGNvbnN0cnVjdG9yKHsgaGVhZGVyQnl0ZXMsIGNpcGhlcnRleHQgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIWhlYWRlckJ5dGVzIHx8ICFoZWFkZXJCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgaGVhZGVyIGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjaXBoZXJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyQnl0ZXMgPSBoZWFkZXJCeXRlcztcbiAgICAgICAgdGhpcy5jaXBoZXJ0ZXh0ID0gbmV3IENpcGhlcnRleHQoY2lwaGVydGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2Vzc29yIG1ldGhvZCBmb3IgdGhlIGZ1bGwgaGVhZGVyIG9iamVjdFxuICAgICAqL1xuICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgIC8vIFVzZSBjYWNoZWQgdmFsdWUgaWYgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkZXIgPSBTZWFsZWRJbnZpdGF0aW9uSGVhZGVyVjEuZnJvbUJ5dGVzKHRoaXMuaGVhZGVyQnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRJbnZpdGF0aW9uIGRlY3J5cHRzIGFuZCByZXR1cm5zIHRoZSBJbnZpdGF0aW9uVjEgc3RvcmVkIGluIHRoZSBjaXBoZXJ0ZXh0IG9mIHRoZSBTZWFsZWQgSW52aXRhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldEludml0YXRpb24odmlld2VyKSB7XG4gICAgICAgIC8vIFVzZSBjYWNoZWQgdmFsdWUgaWYgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuX2ludml0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZpdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjb25zdHJ1Y3RvcnMgZm9yIGNoaWxkIGNsYXNzZXMgd2lsbCB2YWxpZGF0ZSB0aGF0IHRoaXMgaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXI7XG4gICAgICAgIGxldCBzZWNyZXQ7XG4gICAgICAgIGlmICh2aWV3ZXIuaWRlbnRpdHlLZXkubWF0Y2hlcyh0aGlzLmhlYWRlci5zZW5kZXIuaWRlbnRpdHlLZXkpKSB7XG4gICAgICAgICAgICBzZWNyZXQgPSBhd2FpdCB2aWV3ZXIuc2hhcmVkU2VjcmV0KGhlYWRlci5yZWNpcGllbnQsIGhlYWRlci5zZW5kZXIucHJlS2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWNyZXQgPSBhd2FpdCB2aWV3ZXIuc2hhcmVkU2VjcmV0KGhlYWRlci5zZW5kZXIsIGhlYWRlci5yZWNpcGllbnQucHJlS2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRCeXRlcyA9IGF3YWl0IGRlY3J5cHQkMSh0aGlzLmNpcGhlcnRleHQsIHNlY3JldCwgdGhpcy5oZWFkZXJCeXRlcyk7XG4gICAgICAgIHRoaXMuX2ludml0YXRpb24gPSBJbnZpdGF0aW9uVjEuZnJvbUJ5dGVzKGRlY3J5cHRlZEJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludml0YXRpb247XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBpbnZpdGF0aW9uLlNlYWxlZEludml0YXRpb25WMS5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFsZWRJbnZpdGF0aW9uVjEoaW52aXRhdGlvbi5TZWFsZWRJbnZpdGF0aW9uVjEuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGZvciBTZWFsZWRJbnZpdGF0aW9uVjEgYW5kIGFueSBmdXR1cmUgaXRlcmF0aW9ucyBvZiBTZWFsZWRJbnZpdGF0aW9uXG4gKi9cbmNsYXNzIFNlYWxlZEludml0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgdjEgfSkge1xuICAgICAgICBpZiAodjEpIHtcbiAgICAgICAgICAgIHRoaXMudjEgPSBuZXcgU2VhbGVkSW52aXRhdGlvblYxKHYxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdjEgb3IgdjIgaW52aXRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gaW52aXRhdGlvbi5TZWFsZWRJbnZpdGF0aW9uLmVuY29kZSh0aGlzKS5maW5pc2goKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFNlYWxlZEludml0YXRpb24oaW52aXRhdGlvbi5TZWFsZWRJbnZpdGF0aW9uLmRlY29kZShieXRlcykpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBzdGF0aWMgYXN5bmMgZnJvbUVudmVsb3BlKGVudikge1xuICAgICAgICBpZiAoIWVudi5tZXNzYWdlIHx8ICFlbnYudGltZXN0YW1wTnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW52aXRhdGlvbiBlbnZlbG9wZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFsZWQgPSBTZWFsZWRJbnZpdGF0aW9uLmZyb21CeXRlcyhlbnYubWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlVGltZSA9IExvbmcuZnJvbVN0cmluZyhlbnYudGltZXN0YW1wTnMpO1xuICAgICAgICBjb25zdCBoZWFkZXJUaW1lID0gc2VhbGVkLnYxPy5oZWFkZXIuY3JlYXRlZE5zO1xuICAgICAgICBpZiAoIWhlYWRlclRpbWUgfHwgIWhlYWRlclRpbWUuZXF1YWxzKGVudmVsb3BlVGltZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmVsb3BlIGFuZCBoZWFkZXIgdGltZXN0YW1wIG1pc3RtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTZWFsZWRJbnZpdGF0aW9uIHdpdGggYSBTZWFsZWRJbnZpdGF0aW9uVjEgcGF5bG9hZFxuICAgICAqIFdpbGwgZW5jcnlwdCBhbGwgY29udGVudHMgYW5kIHZhbGlkYXRlIGlucHV0c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVWMSh7IHNlbmRlciwgcmVjaXBpZW50LCBjcmVhdGVkLCBpbnZpdGF0aW9uLCB9KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckJ5dGVzID0gbmV3IFNlYWxlZEludml0YXRpb25IZWFkZXJWMSh7XG4gICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5nZXRQdWJsaWNLZXlCdW5kbGUoKSxcbiAgICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICAgIGNyZWF0ZWROczogZGF0ZVRvTnMoY3JlYXRlZCksXG4gICAgICAgIH0pLnRvQnl0ZXMoKTtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gYXdhaXQgc2VuZGVyLnNoYXJlZFNlY3JldChyZWNpcGllbnQsIHNlbmRlci5nZXRDdXJyZW50UHJlS2V5KCkucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGludml0YXRpb25CeXRlcyA9IGludml0YXRpb24udG9CeXRlcygpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXdhaXQgZW5jcnlwdCQxKGludml0YXRpb25CeXRlcywgc2VjcmV0LCBoZWFkZXJCeXRlcyk7XG4gICAgICAgIHJldHVybiBuZXcgU2VhbGVkSW52aXRhdGlvbih7XG4gICAgICAgICAgICB2MTogeyBoZWFkZXJCeXRlcywgY2lwaGVydGV4dCB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbnZhciBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfaW5zdGFuY2VzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcGVyc2lzdGVuY2UsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9wZXJzaXN0ZW5jZUtleSwgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX211dGV4LCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcmV2aXNpb24sIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV90b0J5dGVzO1xuY29uc3QgUFJJVkFURV9QUkVGRVJFTkNFU19BQ1RJT05TX1NUT1JBR0VfS0VZID0gXCJwcml2YXRlLXByZWZlcmVuY2VzL2FjdGlvbnNcIjtcbi8qKlxuICogUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmUgaG9sZHMgYSBtYXBwaW5nIG9mIG1lc3NhZ2UgdGltZXN0YW1wIC0+IHByaXZhdGVcbiAqIHByZWZlcmVuY2UgYWN0aW9uIGFuZCB3cml0ZXMgdG8gdGhlIHBlcnNpc3RlbmNlIGxheWVyIG9uIGNoYW5nZXNcbiAqL1xuY2xhc3MgUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBwZXJzaXN0ZW5jZUtleSwgaW5pdGlhbERhdGEgPSBuZXcgTWFwKCkpIHtcbiAgICAgICAgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9wZXJzaXN0ZW5jZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfbXV0ZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9yZXZpc2lvbi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcGVyc2lzdGVuY2VLZXksIHBlcnNpc3RlbmNlS2V5LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlLCBwZXJzaXN0ZW5jZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9yZXZpc2lvbiwgMCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9tdXRleCwgbmV3IE11dGV4KCksIFwiZlwiKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zTWFwID0gaW5pdGlhbERhdGE7XG4gICAgfVxuICAgIGdldCByZXZpc2lvbktleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlS2V5LCBcImZcIikgKyBcIi9yZXZpc2lvblwiO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gbmV3IFByaXZhdGVQcmVmZXJlbmNlc1N0b3JlKHBlcnNpc3RlbmNlLCBQUklWQVRFX1BSRUZFUkVOQ0VTX0FDVElPTlNfU1RPUkFHRV9LRVkpO1xuICAgICAgICBhd2FpdCBzdG9yZS5yZWZyZXNoKCk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFJldmlzaW9uID0gYXdhaXQgdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgICAgICBpZiAoY3VycmVudFJldmlzaW9uID4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcmV2aXNpb24sIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zTWFwID0gYXdhaXQgdGhpcy5sb2FkRnJvbVBlcnNpc3RlbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcmV2aXNpb24sIGN1cnJlbnRSZXZpc2lvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXZpc2lvbigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlLCBcImZcIikuZ2V0SXRlbSh0aGlzLnJldmlzaW9uS2V5KTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvTnVtYmVyKGRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSZXZpc2lvbihudW1iZXIpIHtcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcGVyc2lzdGVuY2UsIFwiZlwiKS5zZXRJdGVtKHRoaXMucmV2aXNpb25LZXksIG51bWJlclRvVWludDhBcnJheShudW1iZXIpKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZEZyb21QZXJzaXN0ZW5jZSgpIHtcbiAgICAgICAgY29uc3QgcmF3RGF0YSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlLCBcImZcIikuZ2V0SXRlbShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9wZXJzaXN0ZW5jZUtleSwgXCJmXCIpKTtcbiAgICAgICAgaWYgKCFyYXdEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXlzdG9yZS5Qcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXAuZGVjb2RlKHJhd0RhdGEpO1xuICAgICAgICBjb25zdCBhY3Rpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YS5hY3Rpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhY3Rpb25zTWFwLnNldChlbnRyaWVzW2ldWzBdLCBlbnRyaWVzW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9uc01hcDtcbiAgICB9XG4gICAgYXN5bmMgc3RvcmUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcGVyc2lzdGVuY2UsIFwiZlwiKS5zZXRJdGVtKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3BlcnNpc3RlbmNlS2V5LCBcImZcIiksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX2luc3RhbmNlcywgXCJtXCIsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV90b0J5dGVzKS5jYWxsKHRoaXMpKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfcmV2aXNpb24sIChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3JldmlzaW9uLCBcImZcIiksIF9hKyssIF9hKSwgXCJmXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnNldFJldmlzaW9uKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZhdGVQcmVmZXJlbmNlc1N0b3JlX3JldmlzaW9uLCBcImZcIikpO1xuICAgIH1cbiAgICBhc3luYyBhZGQoYWN0aW9uc01hcCkge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9tdXRleCwgXCJmXCIpLnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIGxldCBpc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShhY3Rpb25zTWFwLmtleXMoKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aW9uc01hcC5oYXMoa2V5c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zTWFwLnNldChrZXlzW2ldLCBhY3Rpb25zTWFwLmdldChrZXlzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRlIG5ldyB2YWx1ZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmx5IHdyaXRlIHRvIHBlcnNpc3RlbmNlIGlmIG5ldyB2YWx1ZXMgd2VyZSBhZGRlZFxuICAgICAgICAgICAgaWYgKGlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYWN0aW9ucygpIHtcbiAgICAgICAgLy8gc29ydCBhY3Rpb25zIGJ5IHRoZWlyIGtleXMgKHRpbWVzdGFtcHMpIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICBjb25zdCBzb3J0ZWRBY3Rpb25zID0gbmV3IE1hcChbLi4udGhpcy5hY3Rpb25zTWFwLmVudHJpZXMoKV0uc29ydCgoYSwgYikgPT4gXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGZyb21OYW5vU3RyaW5nKGFbMF0pLmdldFRpbWUoKSAtIGZyb21OYW5vU3RyaW5nKGJbMF0pLmdldFRpbWUoKSkpO1xuICAgICAgICByZXR1cm4gc29ydGVkQWN0aW9ucztcbiAgICB9XG4gICAgbG9va3VwKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zTWFwLmdldChrZXkpO1xuICAgIH1cbn1cbl9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9wZXJzaXN0ZW5jZSA9IG5ldyBXZWFrTWFwKCksIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9wZXJzaXN0ZW5jZUtleSA9IG5ldyBXZWFrTWFwKCksIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9tdXRleCA9IG5ldyBXZWFrTWFwKCksIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9yZXZpc2lvbiA9IG5ldyBXZWFrTWFwKCksIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfUHJpdmF0ZVByZWZlcmVuY2VzU3RvcmVfdG9CeXRlcyA9IGZ1bmN0aW9uIF9Qcml2YXRlUHJlZmVyZW5jZXNTdG9yZV90b0J5dGVzKCkge1xuICAgIHJldHVybiBrZXlzdG9yZS5Qcml2YXRlUHJlZmVyZW5jZXNBY3Rpb25NYXAuZW5jb2RlKHtcbiAgICAgICAgYWN0aW9uczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuYWN0aW9uc01hcCksXG4gICAgfSkuZmluaXNoKCk7XG59O1xuXG5jb25zdCBjb252ZXJ0RXJyb3IgPSAoZSwgXG4vLyBEZWZhdWx0IGVycm9yIGNvZGUgdG8gYXBwbHkgdG8gZXJyb3JzIHRoYXQgZG9uJ3QgaGF2ZSBvbmVcbmVycm9yQ29kZSkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgS2V5c3RvcmVFcnJvcikge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBLZXlzdG9yZUVycm9yKGVycm9yQ29kZSwgZS5tZXNzYWdlKTtcbn07XG5jb25zdCB3cmFwUmVzdWx0ID0gKHJlc3VsdCkgPT4gKHsgcmVzdWx0IH0pO1xuLy8gTWFwIGFuIGFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IG9mIHJlc3VsdHMgb3IgZXJyb3JzXG4vLyBUcmFuc2Zvcm0gYW55IGVycm9ycyB0aHJvd24gaW50byBgS2V5c3RvcmVFcnJvcmBzXG5jb25zdCBtYXBBbmRDb252ZXJ0RXJyb3JzID0gKGlucHV0LCBtYXBwZXIsIFxuLy8gRGVmYXVsdCBlcnJvciBjb2RlIHRvIGFwcGx5IHRvIGVycm9ycyB0aGF0IGRvbid0IGhhdmUgb25lXG5lcnJvckNvZGUpID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBCZSBzdXJlIHRvIGF3YWl0IG1hcHBlciByZXN1bHQgdG8gY2F0Y2ggZXJyb3JzXG4gICAgICAgICAgICByZXR1cm4gd3JhcFJlc3VsdChhd2FpdCBtYXBwZXIoaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogY29udmVydEVycm9yKGUsIGVycm9yQ29kZSkgfTtcbiAgICAgICAgfVxuICAgIH0pKTtcbn07XG4vLyBXcmFwIHRoZSBidW5kbGUgaW4gb3VyIGNsYXNzIGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcbmNvbnN0IHRvUHVibGljS2V5QnVuZGxlID0gKGJ1bmRsZSkgPT4ge1xuICAgIGlmIChidW5kbGUgaW5zdGFuY2VvZiBQdWJsaWNLZXlCdW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXlCdW5kbGUoYnVuZGxlKTtcbn07XG4vLyBXcmFwIHRoZSBidW5kbGUgaW4gb3VyIGNsYXNzIGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcbmNvbnN0IHRvU2lnbmVkUHVibGljS2V5QnVuZGxlID0gKGJ1bmRsZSkgPT4ge1xuICAgIGlmIChidW5kbGUgaW5zdGFuY2VvZiBTaWduZWRQdWJsaWNLZXlCdW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaWduZWRQdWJsaWNLZXlCdW5kbGUoYnVuZGxlKTtcbn07XG4vLyBUYWtlcyBvYmplY3QgYW5kIHJldHVybnMgdHJ1ZSBpZiBub25lIG9mIHRoZSBgb2JqZWN0RmllbGRzYCBhcmUgbnVsbCBvciB1bmRlZmluZWQgYW5kIG5vbmUgb2YgdGhlIGBhcnJheUZpZWxkc2AgYXJlIGVtcHR5XG5jb25zdCB2YWxpZGF0ZU9iamVjdCA9IChvYmosIG9iamVjdEZpZWxkcywgYXJyYXlGaWVsZHMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9iamVjdEZpZWxkcykge1xuICAgICAgICBpZiAoIW9ialtmaWVsZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZUVycm9yKGtleXN0b3JlLkVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQsIGBNaXNzaW5nIGZpZWxkICR7U3RyaW5nKGZpZWxkKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFycmF5RmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9ialtmaWVsZF07XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZG9lcyBub3Qga25vdyBpdCdzIGFuIGFycmF5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghdmFsIHx8ICF2YWw/Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlRXJyb3Ioa2V5c3RvcmUuRXJyb3JDb2RlLkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVCwgYE1pc3NpbmcgZmllbGQgJHtTdHJpbmcoZmllbGQpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGdldEtleU1hdGVyaWFsID0gKGludml0ZSkgPT4ge1xuICAgIGlmICghaW52aXRlPy5hZXMyNTZHY21Ia2RmU2hhMjU2Py5rZXlNYXRlcmlhbCkge1xuICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihrZXlzdG9yZS5FcnJvckNvZGUuRVJST1JfQ09ERV9JTlZBTElEX0lOUFVULCBcIk1pc3Npbmcga2V5IG1hdGVyaWFsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaW52aXRlLmFlczI1NkdjbUhrZGZTaGEyNTYua2V5TWF0ZXJpYWw7XG59O1xuY29uc3QgdG9waWNEYXRhVG9WMkNvbnZlcnNhdGlvblJlZmVyZW5jZSA9ICh7IGludml0YXRpb24sIGNyZWF0ZWROcywgcGVlckFkZHJlc3MsIH0pID0+ICh7XG4gICAgY29udGV4dDogaW52aXRhdGlvbi5jb250ZXh0LFxuICAgIHRvcGljOiBpbnZpdGF0aW9uLnRvcGljLFxuICAgIHBlZXJBZGRyZXNzLFxuICAgIGNyZWF0ZWROcyxcbiAgICBjb25zZW50UHJvb2ZQYXlsb2FkOiBpbnZpdGF0aW9uLmNvbnNlbnRQcm9vZixcbn0pO1xuY29uc3QgaXNDb21wbGV0ZVRvcGljRGF0YSA9IChvYmopID0+ICEhb2JqLmludml0YXRpb247XG5jb25zdCB0b3BpY0RhdGFUb01hcCA9ICh0b3BpY01hcCkgPT4ge1xuICAgIGNvbnN0IG91dCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh0b3BpY01hcC50b3BpY3MpKSB7XG4gICAgICAgIG91dC5zZXQoaywgdik7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuY29uc3QgYnVpbGRQZXJzaXN0ZW5jZUtleSA9IChlbnYsIHdhbGxldEFkZHJlc3MpID0+IGB4bXRwLyR7ZW52fS8ke3dhbGxldEFkZHJlc3N9L2A7XG5cbmNvbnN0IElOVklURV9TVE9SQUdFX0tFWSA9IFwiaW52aXRhdGlvbnMvdjFcIjtcbmNvbnN0IFYxX1NUT1JBR0VfS0VZID0gXCJjb252ZXJzYXRpb24tdjEvdjFcIjtcbi8qKlxuICogVjJTdG9yZSBob2xkcyBhIHNpbXBsZSBtYXAgb2YgdG9waWMgLT4gVG9waWNEYXRhIGFuZCB3cml0ZXMgdG8gdGhlIHBlcnNpc3RlbmNlIGxheWVyIG9uIGNoYW5nZXNcbiAqL1xuY2xhc3MgVjJTdG9yZSB7XG4gICAgY29uc3RydWN0b3IocGVyc2lzdGVuY2UsIHBlcnNpc3RlbmNlS2V5LCBpbml0aWFsRGF0YSA9IG5ldyBNYXAoKSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5yZXZpc2lvbiA9IDA7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICAgICAgdGhpcy50b3BpY01hcCA9IGluaXRpYWxEYXRhO1xuICAgIH1cbiAgICBnZXQgcmV2aXNpb25LZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgXCIvcmV2aXNpb25cIjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShwZXJzaXN0ZW5jZSkge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IElOVklURV9TVE9SQUdFX0tFWTtcbiAgICAgICAgY29uc3QgdjJTdG9yZSA9IG5ldyBWMlN0b3JlKHBlcnNpc3RlbmNlLCBwZXJzaXN0ZW5jZUtleSk7XG4gICAgICAgIGF3YWl0IHYyU3RvcmUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdjJTdG9yZTtcbiAgICB9XG4gICAgdmFsaWRhdGUodG9waWNEYXRhKSB7XG4gICAgICAgIHJldHVybiAoISF0b3BpY0RhdGEudG9waWMgJiZcbiAgICAgICAgICAgIHRvcGljRGF0YS50b3BpYy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBpc0NvbXBsZXRlVG9waWNEYXRhKHRvcGljRGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UmV2aXNpb24gPSBhd2FpdCB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgICAgIGlmIChjdXJyZW50UmV2aXNpb24gPiB0aGlzLnJldmlzaW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0b3BpYywgZGF0YV0gb2YgYXdhaXQgdGhpcy5sb2FkRnJvbVBlcnNpc3RlbmNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcGljTWFwLnNldCh0b3BpYywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXZpc2lvbiA9IGN1cnJlbnRSZXZpc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmV2aXNpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLmdldEl0ZW0odGhpcy5yZXZpc2lvbktleSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb051bWJlcihkYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UmV2aXNpb24obnVtYmVyKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2V0SXRlbSh0aGlzLnJldmlzaW9uS2V5LCBudW1iZXJUb1VpbnQ4QXJyYXkobnVtYmVyKSk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRGcm9tUGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLmdldEl0ZW0odGhpcy5wZXJzaXN0ZW5jZUtleSk7XG4gICAgICAgIGlmICghcmF3RGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNEYXRhVG9NYXAoa2V5c3RvcmUuVG9waWNNYXAuZGVjb2RlKHJhd0RhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcmUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2V0SXRlbSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLnRvQnl0ZXMoKSk7XG4gICAgICAgIHRoaXMucmV2aXNpb24rKztcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRSZXZpc2lvbih0aGlzLnJldmlzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkKHRvcGljRGF0YSkge1xuICAgICAgICBhd2FpdCB0aGlzLm11dGV4LnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIGxldCBpc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0b3BpY0RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUocm93KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHRvcGljIGRhdGFcIiwgcm93LnRvcGljKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9waWMsIC4uLmRhdGEgfSA9IHJvdztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgdmFsdWVzLiBGaXJzdCBpbnZpdGUgZm91bmQgaW4gdGhlIHN0b3JlIGZvciBhIGdpdmVuIHRvcGljIHdpbGwgYWx3YXlzIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGVzIGRvIG5vdCB0aHJvdyBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudG9waWNNYXAuaGFzKHRvcGljKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcGljTWFwLnNldCh0b3BpYywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgd3JpdGUgdG8gcGVyc2lzdGVuY2Ugb25jZSwgYW5kIG9ubHkgaWYgd2UgaGF2ZSBhZGRlZCBuZXcgaW52aXRlc1xuICAgICAgICAgICAgaWYgKGlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgdG9waWNzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMudG9waWNNYXAudmFsdWVzKCldO1xuICAgIH1cbiAgICBsb29rdXAodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9waWNNYXAuZ2V0KHRvcGljKTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXN0b3JlLlRvcGljTWFwLmVuY29kZSh7XG4gICAgICAgICAgICB0b3BpY3M6IE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnRvcGljTWFwKSxcbiAgICAgICAgfSkuZmluaXNoKCk7XG4gICAgfVxufVxuY2xhc3MgVjFTdG9yZSBleHRlbmRzIFYyU3RvcmUge1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUocGVyc2lzdGVuY2UpIHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VLZXkgPSBWMV9TVE9SQUdFX0tFWTtcbiAgICAgICAgY29uc3QgdjFTdG9yZSA9IG5ldyBWMVN0b3JlKHBlcnNpc3RlbmNlLCBwZXJzaXN0ZW5jZUtleSk7XG4gICAgICAgIGF3YWl0IHYxU3RvcmUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdjFTdG9yZTtcbiAgICB9XG4gICAgdmFsaWRhdGUodG9waWNEYXRhKSB7XG4gICAgICAgIHJldHVybiAhISh0b3BpY0RhdGEudG9waWMgJiZcbiAgICAgICAgICAgIHRvcGljRGF0YS50b3BpYy5sZW5ndGggJiZcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICB0b3BpY0RhdGEucGVlckFkZHJlc3M/Lmxlbmd0aCA+IDApO1xuICAgIH1cbn1cblxuY29uc3QgZGVjcnlwdFYxID0gYXN5bmMgKG15S2V5cywgcGVlcktleXMsIGNpcGhlcnRleHQsIGhlYWRlckJ5dGVzLCBpc1NlbmRlcikgPT4ge1xuICAgIGNvbnN0IHNlY3JldCA9IGF3YWl0IG15S2V5cy5zaGFyZWRTZWNyZXQocGVlcktleXMsIG15S2V5cy5nZXRDdXJyZW50UHJlS2V5KCkucHVibGljS2V5LCAvLyBhc3N1bWVzIHRoYXQgdGhlIGN1cnJlbnQgcHJlS2V5IGlzIHdoYXQgd2FzIHVzZWQgdG8gZW5jcnlwdFxuICAgICFpc1NlbmRlcik7XG4gICAgcmV0dXJuIGRlY3J5cHQkMShjaXBoZXJ0ZXh0LCBzZWNyZXQsIGhlYWRlckJ5dGVzKTtcbn07XG5jb25zdCBlbmNyeXB0VjEgPSBhc3luYyAoa2V5cywgcmVjaXBpZW50LCBtZXNzYWdlLCBoZWFkZXJCeXRlcykgPT4ge1xuICAgIGNvbnN0IHNlY3JldCA9IGF3YWl0IGtleXMuc2hhcmVkU2VjcmV0KHJlY2lwaWVudCwga2V5cy5nZXRDdXJyZW50UHJlS2V5KCkucHVibGljS2V5LCBmYWxzZSk7XG4gICAgcmV0dXJuIGVuY3J5cHQkMShtZXNzYWdlLCBzZWNyZXQsIGhlYWRlckJ5dGVzKTtcbn07XG5jb25zdCBkZWNyeXB0VjIgPSAoY2lwaGVydGV4dCwgc2VjcmV0LCBoZWFkZXJCeXRlcykgPT4gZGVjcnlwdCQxKGNpcGhlcnRleHQsIHNlY3JldCwgaGVhZGVyQnl0ZXMpO1xuY29uc3QgZW5jcnlwdFYyID0gKHBheWxvYWQsIHNlY3JldCwgaGVhZGVyQnl0ZXMpID0+IGVuY3J5cHQkMShwYXlsb2FkLCBzZWNyZXQsIGhlYWRlckJ5dGVzKTtcblxudmFyIF9Jbk1lbW9yeUtleXN0b3JlX3ByaXZhdGVQcmVmZXJlbmNlc1RvcGljO1xuY29uc3QgeyBFcnJvckNvZGUgfSA9IGtleXN0b3JlO1xuLy8gQ29uc3RhbnQsIDMyIGJ5dGUgc2FsdFxuLy8gRE8gTk9UIENIQU5HRVxuY29uc3QgSU5WSVRFX1NBTFQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoXCJfX1hNVFBfX0lOVklUQVRJT05fX1NBTFRfX1hNVFBfX1wiKTtcbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleShzZWNyZXQsIGluZm8pIHtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXQsIFwiSEtERlwiLCBmYWxzZSwgW1xuICAgICAgICBcImRlcml2ZUtleVwiLFxuICAgIF0pO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7IG5hbWU6IFwiSEtERlwiLCBoYXNoOiBcIlNIQS0yNTZcIiwgc2FsdDogSU5WSVRFX1NBTFQsIGluZm8gfSwga2V5LCB7IG5hbWU6IFwiQUVTLUdDTVwiLCBsZW5ndGg6IDI1NiB9LCB0cnVlLCBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSk7XG59XG5jbGFzcyBJbk1lbW9yeUtleXN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCB2MVN0b3JlLCB2MlN0b3JlLCBwcml2YXRlUHJlZmVyZW5jZXNTdG9yZSwgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgX0luTWVtb3J5S2V5c3RvcmVfcHJpdmF0ZVByZWZlcmVuY2VzVG9waWMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudjFLZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52MktleXMgPSBQcml2YXRlS2V5QnVuZGxlVjIuZnJvbUxlZ2FjeUJ1bmRsZShrZXlzKTtcbiAgICAgICAgdGhpcy52MVN0b3JlID0gdjFTdG9yZTtcbiAgICAgICAgdGhpcy52MlN0b3JlID0gdjJTdG9yZTtcbiAgICAgICAgdGhpcy5wcml2YXRlUHJlZmVyZW5jZXNTdG9yZSA9IHByaXZhdGVQcmVmZXJlbmNlc1N0b3JlO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0b3IgPSBuZXcgTG9jYWxBdXRoZW50aWNhdG9yKGtleXMuaWRlbnRpdHlLZXkpO1xuICAgICAgICB0aGlzLmpvYlN0YXRlUGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShrZXlzLCBwZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gbmV3IEluTWVtb3J5S2V5c3RvcmUoa2V5cywgYXdhaXQgVjFTdG9yZS5jcmVhdGUocGVyc2lzdGVuY2UpLCBhd2FpdCBWMlN0b3JlLmNyZWF0ZShwZXJzaXN0ZW5jZSksIGF3YWl0IFByaXZhdGVQcmVmZXJlbmNlc1N0b3JlLmNyZWF0ZShwZXJzaXN0ZW5jZSksIHBlcnNpc3RlbmNlKTtcbiAgICB9XG4gICAgZ2V0IHdhbGxldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYxS2V5cy5pZGVudGl0eUtleS5wdWJsaWNLZXkud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0VjEocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG1hcEFuZENvbnZlcnRFcnJvcnMocmVxLnJlcXVlc3RzLCBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlT2JqZWN0KHJlcSwgW1wicGF5bG9hZFwiLCBcInBlZXJLZXlzXCJdLCBbXCJoZWFkZXJCeXRlc1wiXSkpIDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgcGVlcktleXMsIGhlYWRlckJ5dGVzLCBpc1NlbmRlciB9ID0gcmVxO1xuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgZGVjcnlwdFYxKHRoaXMudjFLZXlzLCB0b1B1YmxpY0tleUJ1bmRsZShwZWVyS2V5cyksIHBheWxvYWQsIGhlYWRlckJ5dGVzLCBpc1NlbmRlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRlY3J5cHRlZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIGtleXN0b3JlLkVycm9yQ29kZS5FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEKTtcbiAgICAgICAgcmV0dXJuIGtleXN0b3JlLkRlY3J5cHRSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0VjIocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG1hcEFuZENvbnZlcnRFcnJvcnMocmVxLnJlcXVlc3RzLCBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlT2JqZWN0KHJlcSwgW1wicGF5bG9hZFwiXSwgW1wiaGVhZGVyQnl0ZXNcIl0pKSA7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQsIGhlYWRlckJ5dGVzLCBjb250ZW50VG9waWMgfSA9IHJlcTtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljRGF0YSA9IHRoaXMudjJTdG9yZS5sb29rdXAoY29udGVudFRvcGljKTtcbiAgICAgICAgICAgIGlmICghdG9waWNEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgd3JvbmcgZXJyb3IgdHlwZS4gV2lsbCBhZGQgdG8gdGhlIHByb3RvIHJlcG8gbGF0ZXJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihrZXlzdG9yZS5FcnJvckNvZGUuRVJST1JfQ09ERV9OT19NQVRDSElOR19QUkVLRVksIFwibm8gdG9waWMga2V5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgZGVjcnlwdFYyKHBheWxvYWQsIGdldEtleU1hdGVyaWFsKHRvcGljRGF0YS5pbnZpdGF0aW9uKSwgaGVhZGVyQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGVjcnlwdGVkIH07XG4gICAgICAgIH0sIEVycm9yQ29kZS5FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEKTtcbiAgICAgICAgcmV0dXJuIGtleXN0b3JlLkRlY3J5cHRSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0VjEocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG1hcEFuZENvbnZlcnRFcnJvcnMocmVxLnJlcXVlc3RzLCBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlT2JqZWN0KHJlcSwgW1wicGF5bG9hZFwiLCBcInJlY2lwaWVudFwiXSwgW1wiaGVhZGVyQnl0ZXNcIl0pKSA7XG4gICAgICAgICAgICBjb25zdCB7IHJlY2lwaWVudCwgcGF5bG9hZCwgaGVhZGVyQnl0ZXMgfSA9IHJlcTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdGVkOiBhd2FpdCBlbmNyeXB0VjEodGhpcy52MUtleXMsIHRvUHVibGljS2V5QnVuZGxlKHJlY2lwaWVudCksIHBheWxvYWQsIGhlYWRlckJ5dGVzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIEVycm9yQ29kZS5FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEKTtcbiAgICAgICAgcmV0dXJuIGtleXN0b3JlLkVuY3J5cHRSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVBdXRoVG9rZW4oeyB0aW1lc3RhbXBOcywgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdG9yLmNyZWF0ZVRva2VuKHRpbWVzdGFtcE5zID8gbnNUb0RhdGUodGltZXN0YW1wTnMpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXN5bmMgc2VsZkVuY3J5cHQocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG1hcEFuZENvbnZlcnRFcnJvcnMocmVxLnJlcXVlc3RzLCBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IHJlcTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihFcnJvckNvZGUuRVJST1JfQ09ERV9JTlZBTElEX0lOUFVULCBcIk1pc3NpbmcgZmllbGQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdGVkOiBhd2FpdCB1c2VyUHJlZmVyZW5jZXNFbmNyeXB0KHRoaXMudjFLZXlzLmlkZW50aXR5S2V5LCBwYXlsb2FkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQpO1xuICAgICAgICByZXR1cm4ga2V5c3RvcmUuU2VsZkVuY3J5cHRSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZWxmRGVjcnlwdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgbWFwQW5kQ29udmVydEVycm9ycyhyZXEucmVxdWVzdHMsIGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gcmVxO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZUVycm9yKEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQsIFwiTWlzc2luZyBmaWVsZCBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWNyeXB0ZWQ6IGF3YWl0IHVzZXJQcmVmZXJlbmNlc0RlY3J5cHQodGhpcy52MUtleXMuaWRlbnRpdHlLZXksIHBheWxvYWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgRXJyb3JDb2RlLkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVCk7XG4gICAgICAgIHJldHVybiBrZXlzdG9yZS5EZWNyeXB0UmVzcG9uc2UuZnJvbVBhcnRpYWwoe1xuICAgICAgICAgICAgcmVzcG9uc2VzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyKCkge1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgZ2VuZXJhdGVVc2VyUHJlZmVyZW5jZXNUb3BpYyh0aGlzLnYxS2V5cy5pZGVudGl0eUtleSk7XG4gICAgICAgIHJldHVybiBrZXlzdG9yZS5HZXRQcml2YXRlUHJlZmVyZW5jZXNUb3BpY0lkZW50aWZpZXJSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZW5jcnlwdFYyKHJlcSkge1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBtYXBBbmRDb252ZXJ0RXJyb3JzKHJlcS5yZXF1ZXN0cywgYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZU9iamVjdChyZXEsIFtcInBheWxvYWRcIl0sIFtcImhlYWRlckJ5dGVzXCJdKSkgO1xuICAgICAgICAgICAgY29uc3QgeyBwYXlsb2FkLCBoZWFkZXJCeXRlcywgY29udGVudFRvcGljIH0gPSByZXE7XG4gICAgICAgICAgICBjb25zdCB0b3BpY0RhdGEgPSB0aGlzLnYyU3RvcmUubG9va3VwKGNvbnRlbnRUb3BpYyk7XG4gICAgICAgICAgICBpZiAoIXRvcGljRGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZUVycm9yKEVycm9yQ29kZS5FUlJPUl9DT0RFX05PX01BVENISU5HX1BSRUtFWSwgXCJubyB0b3BpYyBrZXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlNYXRlcmlhbCA9IGdldEtleU1hdGVyaWFsKHRvcGljRGF0YS5pbnZpdGF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBlbmNyeXB0VjIocGF5bG9hZCwga2V5TWF0ZXJpYWwsIGhlYWRlckJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCAvIDYwIC8gNjAgLyAyNCAvIDMwKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgJHt0aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaH0tJHthd2FpdCB0aGlzLmdldEFjY291bnRBZGRyZXNzKCl9YDtcbiAgICAgICAgICAgIGNvbnN0IGhtYWMgPSBhd2FpdCBnZW5lcmF0ZUhtYWNTaWduYXR1cmUoa2V5TWF0ZXJpYWwsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbmZvKSwgaGVhZGVyQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWQ6IGNpcGhlcnRleHQsXG4gICAgICAgICAgICAgICAgc2VuZGVySG1hYzogaG1hYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQpO1xuICAgICAgICByZXR1cm4ga2V5c3RvcmUuRW5jcnlwdFJlc3BvbnNlLmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgIHJlc3BvbnNlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNhdmVJbnZpdGVzKHJlcSkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IFtdO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBtYXBBbmRDb252ZXJ0RXJyb3JzKHJlcS5yZXF1ZXN0cywgYXN5bmMgKHsgcGF5bG9hZCwgdGltZXN0YW1wTnMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VhbGVkID0gU2VhbGVkSW52aXRhdGlvbi5mcm9tQnl0ZXMocGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoc2VhbGVkLnYxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyVGltZSA9IHNlYWxlZC52MS5oZWFkZXIuY3JlYXRlZE5zO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVyVGltZS5lcXVhbHModGltZXN0YW1wTnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmVsb3BlIGFuZCBoZWFkZXIgdGltZXN0YW1wIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbmRlciA9IHNlYWxlZC52MS5oZWFkZXIuc2VuZGVyLmVxdWFscyh0aGlzLnYyS2V5cy5nZXRQdWJsaWNLZXlCdW5kbGUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52aXRhdGlvbiA9IGF3YWl0IHNlYWxlZC52MS5nZXRJbnZpdGF0aW9uKHRoaXMudjJLZXlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BpY0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGludml0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWROczogc2VhbGVkLnYxLmhlYWRlci5jcmVhdGVkTnMsXG4gICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBpc1NlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBzZWFsZWQudjEuaGVhZGVyLnJlY2lwaWVudC53YWxsZXRTaWduYXR1cmVBZGRyZXNzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYXdhaXQgc2VhbGVkLnYxLmhlYWRlci5zZW5kZXIud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaCh7IC4uLnRvcGljRGF0YSwgdG9waWM6IGludml0YXRpb24udG9waWMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uOiB0b3BpY0RhdGFUb1YyQ29udmVyc2F0aW9uUmVmZXJlbmNlKHRvcGljRGF0YSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgRXJyb3JDb2RlLkVSUk9SX0NPREVfSU5WQUxJRF9JTlBVVCk7XG4gICAgICAgIGF3YWl0IHRoaXMudjJTdG9yZS5hZGQodG9BZGQpO1xuICAgICAgICByZXR1cm4ga2V5c3RvcmUuU2F2ZUludml0ZXNSZXNwb25zZS5mcm9tUGFydGlhbCh7XG4gICAgICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnZpdGUocmVxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlT2JqZWN0KHJlcSwgW1wicmVjaXBpZW50XCJdLCBbXSkpIDtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBuc1RvRGF0ZShyZXEuY3JlYXRlZE5zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudCA9IHRvU2lnbmVkUHVibGljS2V5QnVuZGxlKHJlcS5yZWNpcGllbnQpO1xuICAgICAgICAgICAgY29uc3QgbXlBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgdGhlaXJBZGRyZXNzID0gYXdhaXQgcmVjaXBpZW50LndhbGxldFNpZ25hdHVyZUFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3JldCA9IGF3YWl0IHRoaXMudjJLZXlzLnNoYXJlZFNlY3JldChyZWNpcGllbnQsIHRoaXMudjJLZXlzLmdldEN1cnJlbnRQcmVLZXkoKS5wdWJsaWNLZXksIG15QWRkcmVzcyA8IHRoZWlyQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRBZGRyZXNzZXMgPSBbbXlBZGRyZXNzLCB0aGVpckFkZHJlc3NdLnNvcnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZ1N0cmluZyA9IFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIChyZXEuY29udGV4dD8uY29udmVyc2F0aW9uSWQgfHwgXCJcIikgKyBzb3J0ZWRBZGRyZXNzZXMuam9pbigpO1xuICAgICAgICAgICAgY29uc3QgbXNnQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobXNnU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljID0gYnl0ZXNUb0hleChhd2FpdCBobWFjU2hhMjU2U2lnbihCdWZmZXIuZnJvbShzZWNyZXQpLCBCdWZmZXIuZnJvbShtc2dCeXRlcykpKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9TdHJpbmcgPSBbXG4gICAgICAgICAgICAgICAgXCIwXCIsIC8vIHNlcXVlbmNlIG51bWJlclxuICAgICAgICAgICAgICAgIC4uLnNvcnRlZEFkZHJlc3NlcyxcbiAgICAgICAgICAgIF0uam9pbihcInxcIik7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGluZm9TdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGF3YWl0IGRlcml2ZUtleShzZWNyZXQsIGluZm8pO1xuICAgICAgICAgICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBuZXcgVWludDhBcnJheShhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInJhd1wiLCBkZXJpdmVkS2V5KSk7XG4gICAgICAgICAgICBjb25zdCBpbnZpdGF0aW9uID0gbmV3IEludml0YXRpb25WMSh7XG4gICAgICAgICAgICAgICAgdG9waWM6IGJ1aWxkRGlyZWN0TWVzc2FnZVRvcGljVjIodG9waWMpLFxuICAgICAgICAgICAgICAgIGFlczI1NkdjbUhrZGZTaGEyNTY6IHsga2V5TWF0ZXJpYWwgfSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiByZXEuY29udGV4dCxcbiAgICAgICAgICAgICAgICBjb25zZW50UHJvb2Y6IHJlcS5jb25zZW50UHJvb2YsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlYWxlZCA9IGF3YWl0IFNlYWxlZEludml0YXRpb24uY3JlYXRlVjEoe1xuICAgICAgICAgICAgICAgIHNlbmRlcjogdGhpcy52MktleXMsXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgaW52aXRhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9waWNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGludml0YXRpb24sXG4gICAgICAgICAgICAgICAgdG9waWM6IGludml0YXRpb24udG9waWMsXG4gICAgICAgICAgICAgICAgY3JlYXRlZE5zOiByZXEuY3JlYXRlZE5zLFxuICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBhd2FpdCByZWNpcGllbnQud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudjJTdG9yZS5hZGQoW3RvcGljRGF0YV0pO1xuICAgICAgICAgICAgcmV0dXJuIGtleXN0b3JlLkNyZWF0ZUludml0ZVJlc3BvbnNlLmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb246IHRvcGljRGF0YVRvVjJDb252ZXJzYXRpb25SZWZlcmVuY2UodG9waWNEYXRhKSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBzZWFsZWQudG9CeXRlcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBFcnJvckNvZGUuRVJST1JfQ09ERV9JTlZBTElEX0lOUFVUKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduRGlnZXN0KHJlcSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlT2JqZWN0KHJlcSwgW1wiZGlnZXN0XCJdLCBbXSkpIDtcbiAgICAgICAgY29uc3QgeyBkaWdlc3QsIGlkZW50aXR5S2V5LCBwcmVrZXlJbmRleCB9ID0gcmVxO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAoaWRlbnRpdHlLZXkpIHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMudjFLZXlzLmlkZW50aXR5S2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcmVrZXlJbmRleCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihwcmVrZXlJbmRleCkpIHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMudjFLZXlzLnByZUtleXNbcHJla2V5SW5kZXhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlRXJyb3IoRXJyb3JDb2RlLkVSUk9SX0NPREVfTk9fTUFUQ0hJTkdfUFJFS0VZLCBcIm5vIHByZWtleSBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZUVycm9yKEVycm9yQ29kZS5FUlJPUl9DT0RFX0lOVkFMSURfSU5QVVQsIFwibXVzdCBzcGVjaWZpZnkgaWRlbnRpdHlLZXkgb3IgcHJla2V5SW5kZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleS5zaWduKGRpZ2VzdCk7XG4gICAgfVxuICAgIGFzeW5jIHNhdmVWMUNvbnZlcnNhdGlvbnMoeyBjb252ZXJzYXRpb25zLCB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudjFTdG9yZS5hZGQoY29udmVyc2F0aW9ucy5tYXAoKGNvbnZvKSA9PiAoe1xuICAgICAgICAgICAgdG9waWM6IGJ1aWxkRGlyZWN0TWVzc2FnZVRvcGljKGNvbnZvLnBlZXJBZGRyZXNzLCB0aGlzLndhbGxldEFkZHJlc3MpLFxuICAgICAgICAgICAgcGVlckFkZHJlc3M6IGNvbnZvLnBlZXJBZGRyZXNzLFxuICAgICAgICAgICAgY3JlYXRlZE5zOiBjb252by5jcmVhdGVkTnMsXG4gICAgICAgICAgICBpbnZpdGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgYXN5bmMgZ2V0VjFDb252ZXJzYXRpb25zKCkge1xuICAgICAgICBjb25zdCBjb252b3MgPSB0aGlzLnYxU3RvcmUudG9waWNzLm1hcCh0aGlzLnRvcGljRGF0YVRvVjFDb252ZXJzYXRpb25SZWZlcmVuY2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnZlcnNhdGlvbnM6IGNvbnZvcyB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBnZXRWMkNvbnZlcnNhdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGNvbnZvcyA9IHRoaXMudjJTdG9yZS50b3BpY3MubWFwKChpbnZpdGUpID0+IHRvcGljRGF0YVRvVjJDb252ZXJzYXRpb25SZWZlcmVuY2UoaW52aXRlKSk7XG4gICAgICAgIGNvbnZvcy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWROcy5kaXYoMV8wMDBfMDAwKS5zdWIoYi5jcmVhdGVkTnMuZGl2KDFfMDAwXzAwMCkpLnRvTnVtYmVyKCkpO1xuICAgICAgICByZXR1cm4ga2V5c3RvcmUuR2V0Q29udmVyc2F0aW9uc1Jlc3BvbnNlLmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbnM6IGNvbnZvcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgIGFzeW5jIGdldFB1YmxpY0tleUJ1bmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudjFLZXlzLmdldFB1YmxpY0tleUJ1bmRsZSgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBnZXRQcml2YXRlS2V5QnVuZGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52MUtleXM7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY291bnRBZGRyZXNzKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWNjb3VudEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudEFkZHJlc3MgPSBhd2FpdCB0aGlzLnYyS2V5c1xuICAgICAgICAgICAgICAgIC5nZXRQdWJsaWNLZXlCdW5kbGUoKVxuICAgICAgICAgICAgICAgIC53YWxsZXRTaWduYXR1cmVBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudEFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlZnJlc2hKb2IoeyBqb2JUeXBlLCB9KSB7XG4gICAgICAgIGlmIChqb2JUeXBlID09PSBrZXlzdG9yZS5Kb2JUeXBlLkpPQl9UWVBFX1VOU1BFQ0lGSUVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihFcnJvckNvZGUuRVJST1JfQ09ERV9JTlZBTElEX0lOUFVULCBcImludmFsaWQgam9iIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFJ1blRpbWUgPSBhd2FpdCB0aGlzLmdldExhc3RSdW5UaW1lKGpvYlR5cGUpO1xuICAgICAgICByZXR1cm4ga2V5c3RvcmUuR2V0UmVmcmVzaEpvYlJlc3BvbnNlLmZyb21QYXJ0aWFsKHtcbiAgICAgICAgICAgIGxhc3RSdW5OczogbGFzdFJ1blRpbWUgfHwgTG9uZy5mcm9tTnVtYmVyKDApLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UmVmcmVzaEpvYih7IGpvYlR5cGUsIGxhc3RSdW5OcywgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2F3YWl0LXRoZW5hYmxlXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuYnVpbGRKb2JTdG9yYWdlS2V5KGpvYlR5cGUpO1xuICAgICAgICBhd2FpdCB0aGlzLmpvYlN0YXRlUGVyc2lzdGVuY2Uuc2V0SXRlbShrZXksIFVpbnQ4QXJyYXkuZnJvbShsYXN0UnVuTnMudG9CeXRlcygpKSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdG9waWNEYXRhVG9WMUNvbnZlcnNhdGlvblJlZmVyZW5jZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZWVyQWRkcmVzczogZGF0YS5wZWVyQWRkcmVzcyxcbiAgICAgICAgICAgIGNyZWF0ZWROczogZGF0YS5jcmVhdGVkTnMsXG4gICAgICAgICAgICB0b3BpYzogYnVpbGREaXJlY3RNZXNzYWdlVG9waWMoZGF0YS5wZWVyQWRkcmVzcywgdGhpcy53YWxsZXRBZGRyZXNzKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnNlbnRQcm9vZlBheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRKb2JTdG9yYWdlS2V5KGpvYlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGByZWZyZXNoSm9iLyR7am9iVHlwZS50b1N0cmluZygpfWA7XG4gICAgfVxuICAgIGFzeW5jIGdldExhc3RSdW5UaW1lKGpvYlR5cGUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmpvYlN0YXRlUGVyc2lzdGVuY2UuZ2V0SXRlbSh0aGlzLmJ1aWxkSm9iU3RvcmFnZUtleShqb2JUeXBlKSk7XG4gICAgICAgIGlmICghYnl0ZXMgfHwgIWJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CeXRlcyhbLi4uYnl0ZXNdKTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IGRlZmluZWQgYXMgcGFydCBvZiB0aGUgc3RhbmRhcmQgS2V5c3RvcmUgQVBJLCBidXQgaXMgYXZhaWxhYmxlXG4gICAgLy8gb24gdGhlIEluTWVtb3J5S2V5c3RvcmUgdG8gc3VwcG9ydCBsZWdhY3kgdXNlLWNhc2VzLlxuICAgIGxvb2t1cFRvcGljKHRvcGljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYyU3RvcmUubG9va3VwKHRvcGljKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VjJDb252ZXJzYXRpb25IbWFjS2V5cyhyZXEpIHtcbiAgICAgICAgY29uc3QgdGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2ggPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwIC8gNjAgLyA2MCAvIDI0IC8gMzApO1xuICAgICAgICBjb25zdCBobWFjS2V5cyA9IHt9O1xuICAgICAgICBsZXQgdG9waWNzID0gdGhpcy52MlN0b3JlLnRvcGljcztcbiAgICAgICAgLy8gaWYgc3BlY2lmaWMgdG9waWNzIGFyZSByZXF1ZXN0ZWQsIG9ubHkgaW5jbHVkZSB0aG9zZSB0b3BpY3NcbiAgICAgICAgaWYgKHJlcT8udG9waWNzKSB7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3MuZmlsdGVyKCh0b3BpY0RhdGEpID0+IHRvcGljRGF0YS5pbnZpdGF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXEudG9waWNzLmluY2x1ZGVzKHRvcGljRGF0YS5pbnZpdGF0aW9uLnRvcGljKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodG9waWNzLm1hcChhc3luYyAodG9waWNEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodG9waWNEYXRhLmludml0YXRpb24/LnRvcGljKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBnZXRLZXlNYXRlcmlhbCh0b3BpY0RhdGEuaW52aXRhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHRoaXJ0eURheVBlcmlvZHNTaW5jZUVwb2NoLFxuICAgICAgICAgICAgICAgICAgICB0aGlydHlEYXlQZXJpb2RzU2luY2VFcG9jaCArIDEsXG4gICAgICAgICAgICAgICAgXS5tYXAoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgJHt2YWx1ZX0tJHthd2FpdCB0aGlzLmdldEFjY291bnRBZGRyZXNzKCl9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG1hY0tleSA9IGF3YWl0IGhrZGZIbWFjS2V5KGtleU1hdGVyaWFsLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5mbykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcnR5RGF5UGVyaW9kc1NpbmNlRXBvY2g6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBDcnlwdG9LZXkgdG8gVWludDhBcnJheSB0byBtYXRjaCB0aGUgcHJvdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhtYWNLZXk6IGF3YWl0IGV4cG9ydEhtYWNLZXkoaG1hY0tleSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGhtYWNLZXlzW3RvcGljRGF0YS5pbnZpdGF0aW9uLnRvcGljXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHsgaG1hY0tleXMgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWMoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5NZW1vcnlLZXlzdG9yZV9wcml2YXRlUHJlZmVyZW5jZXNUb3BpYywgXCJmXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IGF3YWl0IHRoaXMuZ2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWNJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Jbk1lbW9yeUtleXN0b3JlX3ByaXZhdGVQcmVmZXJlbmNlc1RvcGljLCBidWlsZFVzZXJQcml2YXRlUHJlZmVyZW5jZXNUb3BpYyhpZGVudGlmaWVyKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbk1lbW9yeUtleXN0b3JlX3ByaXZhdGVQcmVmZXJlbmNlc1RvcGljLCBcImZcIik7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByaXZhdGVQcmVmZXJlbmNlKGFjdGlvbikge1xuICAgICAgICAvLyBlbmNyeXB0IGFjdGlvbiBwYXlsb2FkXG4gICAgICAgIC8vIHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSByZXNwb25zZVxuICAgICAgICBjb25zdCB7IHJlc3BvbnNlcyB9ID0gYXdhaXQgdGhpcy5zZWxmRW5jcnlwdCh7XG4gICAgICAgICAgICByZXF1ZXN0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcHJpdmF0ZVByZWZlcmVuY2VzLlByaXZhdGVQcmVmZXJlbmNlc0FjdGlvbi5lbmNvZGUoYWN0aW9uKS5maW5pc2goKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVuY3J5cHRlZCBtZXNzYWdlXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcmVzcG9uc2VzLnJlZHVjZSgocmVzdWx0LCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdD8uZW5jcnlwdGVkXG4gICAgICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29uY2F0KHJlc3BvbnNlLnJlc3VsdD8uZW5jcnlwdGVkKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcmVkdWNlLXR5cGUtcGFyYW1ldGVyXG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgY29uc3QgY29udGVudFRvcGljID0gYXdhaXQgdGhpcy5nZXRQcml2YXRlUHJlZmVyZW5jZXNUb3BpYygpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyByZXR1cm4gZW52ZWxvcGVzIHRvIHB1Ymxpc2hcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYyxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0UHJpdmF0ZVByZWZlcmVuY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUHJlZmVyZW5jZXNTdG9yZS5hY3Rpb25zO1xuICAgIH1cbiAgICBzYXZlUHJpdmF0ZVByZWZlcmVuY2VzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVByZWZlcmVuY2VzU3RvcmUuYWRkKGRhdGEpO1xuICAgIH1cbn1cbl9Jbk1lbW9yeUtleXN0b3JlX3ByaXZhdGVQcmVmZXJlbmNlc1RvcGljID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgVG9waWNQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCByZWNvcmQgaW4gYSB0b3BpYyBpZiBpdCBpcyBwcmVzZW50LlxuICAgIGFzeW5jIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZW52IG9mIHRoaXMuYXBpQ2xpZW50LnF1ZXJ5SXRlcmF0b3IoeyBjb250ZW50VG9waWM6IHRoaXMuYnVpbGRUb3BpYyhrZXkpIH0sIHtcbiAgICAgICAgICAgIHBhZ2VTaXplOiAxLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBtZXNzYWdlQXBpLlNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fREVTQ0VORElORyxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGlmICghZW52Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZW52Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBVaW50OEFycmF5LmZyb20odmFsdWUpO1xuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5wdWJsaXNoKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VG9waWM6IHRoaXMuYnVpbGRUb3BpYyhrZXkpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGtleXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc2V0QXV0aGVudGljYXRvcihhdXRoZW50aWNhdG9yKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50LnNldEF1dGhlbnRpY2F0b3IoYXV0aGVudGljYXRvcik7XG4gICAgfVxuICAgIGJ1aWxkVG9waWMoa2V5KSB7XG4gICAgICAgIHJldHVybiBidWlsZFVzZXJQcml2YXRlU3RvcmVUb3BpYyhrZXkpO1xuICAgIH1cbn1cblxuY29uc3QgSVZfTEVOR1RIID0gMTY7XG5jb25zdCBFUEhFTUVSQUxfUFVCTElDX0tFWV9MRU5HVEggPSA2NTtcbmNvbnN0IE1BQ19MRU5HVEggPSAzMjtcbmNvbnN0IEFFU19CTE9DS19TSVpFID0gMTY7XG5jb25zdCBhc3NlcnRFY2llc0xlbmd0aHMgPSAoZWNpZXMpID0+IHtcbiAgICBpZiAoZWNpZXMuaXYubGVuZ3RoICE9PSBJVl9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpdiBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmIChlY2llcy5lcGhlbWVyYWxQdWJsaWNLZXkubGVuZ3RoICE9PSBFUEhFTUVSQUxfUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlcGhlbVB1YmxpY0tleSBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmIChlY2llcy5jaXBoZXJ0ZXh0Lmxlbmd0aCA8IDEgfHxcbiAgICAgICAgZWNpZXMuY2lwaGVydGV4dC5sZW5ndGggJSBBRVNfQkxPQ0tfU0laRSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBpZiAoZWNpZXMubWFjLmxlbmd0aCAhPT0gTUFDX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1hYyBsZW5ndGhcIik7XG4gICAgfVxufTtcbmNsYXNzIFNpZ25lZEVjaWVzQ2lwaGVydGV4dCB7XG4gICAgY29uc3RydWN0b3IoeyBlY2llc0J5dGVzLCBzaWduYXR1cmUgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIWVjaWVzQnl0ZXMgfHwgIWVjaWVzQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlY2llc0J5dGVzIGlzIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduYXR1cmUgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWNpZXNCeXRlcyA9IGVjaWVzQnl0ZXM7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICB0aGlzLmNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LlNpZ25lZEVjaWVzQ2lwaGVydGV4dF9FY2llcy5kZWNvZGUoZWNpZXNCeXRlcyk7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0LlNpZ25lZEVjaWVzQ2lwaGVydGV4dC5lbmNvZGUodGhpcykuZmluaXNoKCk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJLZXkpIHtcbiAgICAgICAgcmV0dXJuIHB1YktleS52ZXJpZnkodGhpcy5zaWduYXR1cmUsIGF3YWl0IHNoYTI1Nih0aGlzLmVjaWVzQnl0ZXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGNpcGhlcnRleHQuU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0LmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZWRFY2llc0NpcGhlcnRleHQob2JqKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShlY2llcywgc2lnbmVyKSB7XG4gICAgICAgIGFzc2VydEVjaWVzTGVuZ3RocyhlY2llcyk7XG4gICAgICAgIGNvbnN0IGVjaWVzQnl0ZXMgPSBjaXBoZXJ0ZXh0LlNpZ25lZEVjaWVzQ2lwaGVydGV4dF9FY2llcy5lbmNvZGUoZWNpZXMpLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduZXIuc2lnbihhd2FpdCBzaGEyNTYoZWNpZXNCeXRlcykpO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lZEVjaWVzQ2lwaGVydGV4dCh7IGVjaWVzQnl0ZXMsIHNpZ25hdHVyZSB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5jcnlwdGVkUGVyc2lzdGVuY2UgaXMgYSBQZXJzaXN0ZW5jZSBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgRUNJRVMgdG8gZW5jcnlwdCBhbGwgdmFsdWVzXG4gKiBFQ0lFUyBlbmNyeXB0aW9uIHByb3RlY3RzIGFnYWluc3QgdW5hdXRob3JpemVkIHJlYWRzLCBidXQgbm90IHVuYXV0aG9yaXplZCB3cml0ZXMuXG4gKiBBIHRoaXJkIHBhcnR5IHdpdGggYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIHN0b3JlIGNvdWxkIHdyaXRlIG1hbGljaW91cyBkYXRhIHVzaW5nIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBvd25lclxuICovXG5jbGFzcyBFbmNyeXB0ZWRQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IocGVyc2lzdGVuY2UsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICB0aGlzLnByaXZhdGVLZXlCeXRlcyA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkuc2VjcDI1NmsxLmJ5dGVzKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBnZXRQdWJsaWModGhpcy5wcml2YXRlS2V5Qnl0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRJdGVtKGtleSkge1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKGVuY3J5cHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdChlbmNyeXB0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgdGhpcy5lbmNyeXB0KHZhbHVlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRJdGVtKGtleSwgZW5jcnlwdGVkKTtcbiAgICB9XG4gICAgYXN5bmMgZW5jcnlwdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlY2llcyA9IGF3YWl0IGVuY3J5cHQodGhpcy5wdWJsaWNLZXksIEJ1ZmZlci5mcm9tKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUVjaWVzKGVjaWVzKTtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlY2llcyA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemVFY2llcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY3J5cHQodGhpcy5wcml2YXRlS2V5Qnl0ZXMsIGVjaWVzKTtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyBzZXJpYWxpemVFY2llcyhkYXRhKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYW5kIHNpZ24gYSBgU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0YCBwYXlsb2FkIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkYXRhXG4gICAgICAgIGNvbnN0IHByb3RvVmFsID0gYXdhaXQgU2lnbmVkRWNpZXNDaXBoZXJ0ZXh0LmNyZWF0ZShkYXRhLCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gcHJvdG9WYWwudG9CeXRlcygpO1xuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZUVjaWVzKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHJvdG9WYWwgPSBTaWduZWRFY2llc0NpcGhlcnRleHQuZnJvbUJ5dGVzKGRhdGEpO1xuICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZSB1cG9uIGRlc2VyaWFsaXppbmdcbiAgICAgICAgaWYgKCEoYXdhaXQgcHJvdG9WYWwudmVyaWZ5KHRoaXMucHJpdmF0ZUtleS5wdWJsaWNLZXkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIHZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVjaWVzID0gcHJvdG9WYWwuY2lwaGVydGV4dDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKGVjaWVzLmNpcGhlcnRleHQpLFxuICAgICAgICAgICAgbWFjOiBCdWZmZXIuZnJvbShlY2llcy5tYWMpLFxuICAgICAgICAgICAgaXY6IEJ1ZmZlci5mcm9tKGVjaWVzLml2KSxcbiAgICAgICAgICAgIGVwaGVtZXJhbFB1YmxpY0tleTogQnVmZmVyLmZyb20oZWNpZXMuZXBoZW1lcmFsUHVibGljS2V5KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFByZWZpeGVkUGVyc2lzdGVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0SXRlbSh0aGlzLmJ1aWxkS2V5KGtleSkpO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2Uuc2V0SXRlbSh0aGlzLmJ1aWxkS2V5KGtleSksIHZhbHVlKTtcbiAgICB9XG4gICAgYnVpbGRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeCArIGtleTtcbiAgICB9XG59XG5cbmNvbnN0IGJ1aWxkUGVyc2lzdGVuY2VGcm9tT3B0aW9ucyA9IGFzeW5jIChvcHRzLCBrZXlzKSA9PiB7XG4gICAgaWYgKCFvcHRzLnBlcnNpc3RDb252ZXJzYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBJbk1lbW9yeVBlcnNpc3RlbmNlLmNyZWF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQga2V5cy5pZGVudGl0eUtleS5wdWJsaWNLZXkud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgIGNvbnN0IHByZWZpeCA9IGJ1aWxkUGVyc2lzdGVuY2VLZXkob3B0cy5lbnYsIGFkZHJlc3MpO1xuICAgIGNvbnN0IGJhc2VQZXJzaXN0ZW5jZSA9IG9wdHMuYmFzZVBlcnNpc3RlbmNlO1xuICAgIGNvbnN0IHNob3VsZEVuY3J5cHQgPSAhb3B0cy5kaXNhYmxlUGVyc2lzdGVuY2VFbmNyeXB0aW9uO1xuICAgIHJldHVybiBuZXcgUHJlZml4ZWRQZXJzaXN0ZW5jZShwcmVmaXgsIHNob3VsZEVuY3J5cHRcbiAgICAgICAgPyBuZXcgRW5jcnlwdGVkUGVyc2lzdGVuY2UoYmFzZVBlcnNpc3RlbmNlLCBrZXlzLmlkZW50aXR5S2V5KVxuICAgICAgICA6IGJhc2VQZXJzaXN0ZW5jZSk7XG59O1xuXG5jb25zdCBLRVlfQlVORExFX05BTUUgPSBcImtleV9idW5kbGVcIjtcbi8qKlxuICogRW5jcnlwdGVkS2V5U3RvcmUgd3JhcHMgU3RvcmUgdG8gZW5hYmxlIGVuY3J5cHRpb24gb2YgcHJpdmF0ZSBrZXkgYnVuZGxlc1xuICogdXNpbmcgYSB3YWxsZXQgc2lnbmF0dXJlLlxuICovXG5jbGFzcyBOZXR3b3JrS2V5TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Ioc2lnbmVyLCBwZXJzaXN0ZW5jZSwgcHJlRW5hYmxlSWRlbnRpdHlDYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICB0aGlzLnByZUVuYWJsZUlkZW50aXR5Q2FsbGJhY2sgPSBwcmVFbmFibGVJZGVudGl0eUNhbGxiYWNrO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdG9yYWdlQWRkcmVzcyhuYW1lKSB7XG4gICAgICAgIC8vIEkgdGhpbmsgd2Ugd2FudCB0byBuYW1lc3BhY2UgdGhlIHN0b3JhZ2UgYWRkcmVzcyBieSB3YWxsZXRcbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHN1cHBvcnQgc3dpdGNoaW5nIGJldHdlZW4gbXVsdGlwbGUgd2FsbGV0cyBpbiB0aGUgc2FtZSBicm93c2VyXG4gICAgICAgIGxldCB3YWxsZXRBZGRyZXNzID0gYXdhaXQgdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB3YWxsZXRBZGRyZXNzID0gZ2V0QWRkcmVzcyh3YWxsZXRBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGAke3dhbGxldEFkZHJlc3N9LyR7bmFtZX1gO1xuICAgIH1cbiAgICAvLyBSZXRyaWV2ZSBhIHByaXZhdGUga2V5IGJ1bmRsZSBmb3IgdGhlIGFjdGl2ZSB3YWxsZXQgYWRkcmVzcyBpbiB0aGUgc2lnbmVyXG4gICAgYXN5bmMgbG9hZFByaXZhdGVLZXlCdW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLmdldEl0ZW0oYXdhaXQgdGhpcy5nZXRTdG9yYWdlQWRkcmVzcyhLRVlfQlVORExFX05BTUUpKTtcbiAgICAgICAgaWYgKCFzdG9yYWdlQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYnVuZGxlLCBuZWVkc1VwZGF0ZV0gPSBhd2FpdCB0aGlzLmZyb21FbmNyeXB0ZWRCeXRlcyh0aGlzLnNpZ25lciwgVWludDhBcnJheS5mcm9tKHN0b3JhZ2VCdWZmZXIpKTtcbiAgICAgICAgLy8gSWYgYSB2ZXJzaW9uZWQgYnVuZGxlIGlzIG5vdCBmb3VuZCwgdGhlIGxlZ2FjeSBidW5kbGUgbmVlZHMgdG8gYmUgcmVzYXZlZCB0byB0aGUgc3RvcmUgaW5cbiAgICAgICAgLy8gdGhlIG5ldyBmb3JtYXQuIE9uY2UgYWxsIGJ1bmRsZXMgaGF2ZSBiZWVuIHVwZ3JhZGVkLCB0aGlzIG1pZ3JhdGlvbiBjb2RlIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcmVQcml2YXRlS2V5QnVuZGxlKGJ1bmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICB9XG4gICAgLy8gU3RvcmUgdGhlIHByaXZhdGUga2V5IGJ1bmRsZSBhdCBhbiBhZGRyZXNzIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgYWN0aXZlIHdhbGxldCBpbiB0aGUgc2lnbmVyXG4gICAgYXN5bmMgc3RvcmVQcml2YXRlS2V5QnVuZGxlKGJ1bmRsZSkge1xuICAgICAgICBjb25zdCBrZXlBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRTdG9yYWdlQWRkcmVzcyhLRVlfQlVORExFX05BTUUpO1xuICAgICAgICBjb25zdCBlbmNvZGVkQnVuZGxlID0gYXdhaXQgdGhpcy50b0VuY3J5cHRlZEJ5dGVzKGJ1bmRsZSwgdGhpcy5zaWduZXIpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldHVwIHRoZSBBdXRoZW50aWNhdG9yIHNvIHRoYXQgdGhlIHVuZGVybHlpbmcgc3RvcmUgY2FuIHB1Ymxpc2ggbWVzc2FnZXMgd2l0aG91dCBlcnJvclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucGVyc2lzdGVuY2Uuc2V0QXV0aGVudGljYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLnNldEF1dGhlbnRpY2F0b3IobmV3IExvY2FsQXV0aGVudGljYXRvcihidW5kbGUuaWRlbnRpdHlLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnNldEl0ZW0oa2V5QWRkcmVzcywgZW5jb2RlZEJ1bmRsZSk7XG4gICAgfVxuICAgIC8vIGVuY3J5cHRzL3NlcmlhbGl6ZXMgdGhlIGJ1bmRsZSBmb3Igc3RvcmFnZVxuICAgIGFzeW5jIHRvRW5jcnlwdGVkQnl0ZXMoYnVuZGxlLCB3YWxsZXQpIHtcbiAgICAgICAgLy8gc2VyaWFsaXplIHRoZSBjb250ZW50c1xuICAgICAgICBjb25zdCBieXRlcyA9IGJ1bmRsZS5lbmNvZGUoKTtcbiAgICAgICAgY29uc3Qgd1ByZUtleSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBzdG9yYWdlU2lnUmVxdWVzdFRleHQod1ByZUtleSk7XG4gICAgICAgIGNvbnN0IHdhbGxldEFkZHIgPSBhd2FpdCB3YWxsZXQuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodGhpcy5wcmVFbmFibGVJZGVudGl0eUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZUVuYWJsZUlkZW50aXR5Q2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWcgPSBhd2FpdCB3YWxsZXQuc2lnbk1lc3NhZ2UoaW5wdXQpO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgY29ycmVjdCwgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIGlucHV0LCBhbmQgcmV0cnkgaWYgbm90LiBUaGlzIG1pdGlnYXRlcyBhIGJ1ZyBpbiBpbnRlcmFjdGluZyB3aXRoXG4gICAgICAgIC8vIExlZGdlckxpdmUgZm9yIGlPUywgd2hlcmUgdGhlIHByZXZpb3VzIHNpZ25hdHVyZSByZXNwb25zZSBpc1xuICAgICAgICAvLyByZXR1cm5lZCBpbiBzb21lIGNhc2VzLlxuICAgICAgICBjb25zdCB2YWxpZCA9IHZlcmlmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczogd2FsbGV0QWRkcixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWcsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gaGV4VG9CeXRlcyhzaWcpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXdhaXQgZW5jcnlwdCQxKGJ5dGVzLCBzZWNyZXQpO1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleS5FbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlLmVuY29kZSh7XG4gICAgICAgICAgICB2MToge1xuICAgICAgICAgICAgICAgIHdhbGxldFByZUtleTogd1ByZUtleSxcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkuZmluaXNoKCk7XG4gICAgfVxuICAgIC8vIGRlY3J5cHRzL2Rlc2VyaWFsaXplcyB0aGUgYnVuZGxlIGZyb20gc3RvcmFnZSBieXRlc1xuICAgIGFzeW5jIGZyb21FbmNyeXB0ZWRCeXRlcyh3YWxsZXQsIGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IFtlQnVuZGxlLCBuZWVkc1VwZGF0ZV0gPSBnZXRFbmNyeXB0ZWRCdW5kbGUoYnl0ZXMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIWVCdW5kbGUud2FsbGV0UHJlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHdhbGxldCBwcmUta2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZUJ1bmRsZS5jaXBoZXJ0ZXh0Py5hZXMyNTZHY21Ia2RmU2hhMjU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGJ1bmRsZSBjaXBoZXJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZUVuYWJsZUlkZW50aXR5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJlRW5hYmxlSWRlbnRpdHlDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IGhleFRvQnl0ZXMoKGF3YWl0IHdhbGxldC5zaWduTWVzc2FnZShzdG9yYWdlU2lnUmVxdWVzdFRleHQoZUJ1bmRsZS53YWxsZXRQcmVLZXkpKSkpO1xuICAgICAgICAvLyBMZWRnZXIgdXNlcyB0aGUgbGFzdCBieXRlID0gdj1bMCwxLC4uLl0gYnV0IE1ldGFtYXNrIGFuZCBvdGhlciB3YWxsZXRzIGdlbmVyYXRlIHdpdGhcbiAgICAgICAgLy8gdisyNyBhcyB0aGUgbGFzdCBieXRlLiBXZSBuZWVkIHRvIHN1cHBvcnQgYm90aCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4gRG9pbmcgdGhpc1xuICAgICAgICAvLyBvbiB0aGUgZGVjcnlwdGlvbiBzaWRlIHByb3ZpZGVzIGFuIGltbWVkaWF0ZSByZXRyb2FjdGl2ZSBmaXguXG4gICAgICAgIC8vIExlZGdlciBpcyB1c2luZyB0aGUgY2Fub25pY2FsIHdheSwgd2hlcmVhcyBFdGhlcmV1bSBhZGRzIDI3IGR1ZSB0byBzb21lIGxlZ2FjeSBzdHVmZlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE5NzUxI2lzc3VlY29tbWVudC01MDQ5MDA3MzlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0aGUgb3JpZ2luYWwgdmVyc2lvbiBvZiB0aGUgc2lnbmF0dXJlIGZpcnN0XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IENpcGhlcnRleHQoZUJ1bmRsZS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGRlY3J5cHQkMShjaXBoZXJ0ZXh0LCBzZWNyZXQpO1xuICAgICAgICAgICAgY29uc3QgW2J1bmRsZSwgbmVlZHNVcGRhdGUyXSA9IGdldFByaXZhdGVCdW5kbGUoZGVjcnlwdGVkKTtcbiAgICAgICAgICAgIHJldHVybiBbYnVuZGxlLCBuZWVkc1VwZGF0ZSB8fCBuZWVkc1VwZGF0ZTJdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBBc3NlcnQgdGhhdCB0aGUgc2VjcmV0IGlzIGxlbmd0aCA2NSAoZW5jb2RlZCBzaWduYXR1cmUgKyByZWNvdmVyeSBieXRlKVxuICAgICAgICAgICAgaWYgKHNlY3JldC5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgNjUgYnl0ZXMgYmVmb3JlIHRyeWluZyBhIGRpZmZlcmVudCByZWNvdmVyeSBieXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJ5IHRoZSBvdGhlciB2ZXJzaW9uIG9mIHJlY292ZXJ5IGJ5dGUsIGVpdGhlciArMjcgb3IgLTI3XG4gICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IHNlY3JldFtzZWNyZXQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsZXQgbmV3U2VjcmV0ID0gc2VjcmV0LnNsaWNlKDAsIHNlY3JldC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChsYXN0Qnl0ZSA8IDI3KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNhbm9uaWNhbCBzaWduYXR1cmUsIHNvIHdlIG5lZWQgdG8gYWRkIDI3IHRvIHRoZSByZWNvdmVyeSBieXRlIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICBuZXdTZWNyZXQgPSBuZXcgVWludDhBcnJheShbLi4ubmV3U2VjcmV0LCBsYXN0Qnl0ZSArIDI3XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbm9jYWxpemVzIHYgdG8gMCBvciAxIChvciBtYXliZSAyIG9yIDMgYnV0IHZlcnkgdW5saWtlbHkpXG4gICAgICAgICAgICAgICAgbmV3U2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLm5ld1NlY3JldCwgbGFzdEJ5dGUgLSAyN10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBDaXBoZXJ0ZXh0KGVCdW5kbGUuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBkZWNyeXB0JDEoY2lwaGVydGV4dCwgbmV3U2VjcmV0KTtcbiAgICAgICAgICAgIGNvbnN0IFtidW5kbGUsIG5lZWRzVXBkYXRlMl0gPSBnZXRQcml2YXRlQnVuZGxlKGRlY3J5cHRlZCk7XG4gICAgICAgICAgICByZXR1cm4gW2J1bmRsZSwgbmVlZHNVcGRhdGUgfHwgbmVlZHNVcGRhdGUyXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGdldEVuY3J5cHRlZFYxQnVuZGxlIHJldHVybnMgdGhlIGRlY29kZWQgYnVuZGxlIGZyb20gdGhlIHByb3ZpZGVkIGJ5dGVzLiBJZiB0aGVyZSBpcyBhbiBlcnJvciBkZWNvZGluZyB0aGUgYnVuZGxlIGl0IGF0dGVtcHRzXG4vLyB0byBkZWNvZGUgdGhlIGJ1bmRsZSBhcyBhIGxlZ2FjeSBidW5kbGUuIEFkZGl0aW9uYWxseSByZXR1cm4gd2hldGhlciB0aGUgYnVuZGxlIGlzIGluIHRoZSBleHBlY3RlZCBmb3JtYXQuXG5mdW5jdGlvbiBnZXRFbmNyeXB0ZWRCdW5kbGUoYnl0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBiID0gcHJpdmF0ZUtleS5FbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlLmRlY29kZShieXRlcyk7XG4gICAgICAgIGlmIChiLnYxKSB7XG4gICAgICAgICAgICByZXR1cm4gW2IudjEsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbcHJpdmF0ZUtleS5FbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlVjEuZGVjb2RlKGJ5dGVzKSwgdHJ1ZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgYnVuZGxlIHZlcnNpb25cIik7XG59XG4vLyBnZXRQcml2YXRlVjFCdW5kbGUgcmV0dXJucyB0aGUgZGVjb2RlZCBidW5kbGUgZnJvbSB0aGUgcHJvdmlkZWQgYnl0ZXMuIElmIHRoZXJlIGlzIGFuIGVycm9yIGRlY29kaW5nIHRoZSBidW5kbGUgaXQgYXR0ZW1wdHNcbi8vIHRvIGRlY29kZSB0aGUgYnVuZGxlIGFzIGEgbGVnYWN5IGJ1bmRsZS4gQWRkaXRpb25hbGx5IHJldHVybiB3aGV0aGVyIHRoZSBidW5kbGUgaXMgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdC5cbmZ1bmN0aW9uIGdldFByaXZhdGVCdW5kbGUoYnl0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgVjJcbiAgICAgICAgY29uc3QgYiA9IGRlY29kZVByaXZhdGVLZXlCdW5kbGUoYnl0ZXMpO1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFByaXZhdGVLZXlCdW5kbGVWMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVjIgYnVuZGxlcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2IsIGZhbHNlXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBBZGRzIGEgZGVmYXVsdCBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgdGhlIHByb3RvXG4gICAgICAgIGNvbnN0IGIgPSBwcml2YXRlS2V5LlByaXZhdGVLZXlCdW5kbGVWMS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gW25ldyBQcml2YXRlS2V5QnVuZGxlVjEoYiksIHRydWVdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JhZ2VTaWdSZXF1ZXN0VGV4dChwcmVLZXkpIHtcbiAgICAvLyBOb3RlIHRoYXQgYW4gdXBkYXRlIHRvIHRoaXMgc2lnbmF0dXJlIHJlcXVlc3QgdGV4dCB3aWxsIHJlcXVpcmVcbiAgICAvLyBhZGRpdGlvbiBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBleGlzdGluZyBlbmNyeXB0ZWQgYnVuZGxlc1xuICAgIC8vIGFuZC9vciBhIG1pZ3JhdGlvbjsgb3RoZXJ3aXNlIGNsaWVudHMgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0b1xuICAgIC8vIGRlY3J5cHQgdGhvc2UgYnVuZGxlcy5cbiAgICByZXR1cm4gKFwiWE1UUCA6IEVuYWJsZSBJZGVudGl0eVxcblwiICtcbiAgICAgICAgYCR7Ynl0ZXNUb0hleChwcmVLZXkpfVxcbmAgK1xuICAgICAgICBcIlxcblwiICtcbiAgICAgICAgXCJGb3IgbW9yZSBpbmZvOiBodHRwczovL3htdHAub3JnL3NpZ25hdHVyZXMvXCIpO1xufVxuXG4vKipcbiAqIEtleUdlbmVyYXRvcktleXN0b3JlUHJvdmlkZXIgd2lsbCBjcmVhdGUgYSBuZXcgWE1UUCBgUHJpdmF0ZUtleUJ1bmRsZWAgYW5kIHBlcnNpc3QgaXQgdG8gdGhlIG5ldHdvcmtcbiAqIFRoaXMgcHJvdmlkZXIgc2hvdWxkIGFsd2F5cyBiZSBzcGVjaWZpZWQgbGFzdCBpbiB0aGUgbGlzdCBvZiBga2V5c3RvcmVQcm92aWRlcnNgIG9uIGNsaWVudCBjcmVhdGlvbixcbiAqIGFzIGl0IHdpbGwgb3ZlcndyaXRlIGFueSBYTVRQIGlkZW50aXRpZXMgYWxyZWFkeSBvbiB0aGUgbmV0d29ya1xuICovXG5jbGFzcyBLZXlHZW5lcmF0b3JLZXlzdG9yZVByb3ZpZGVyIHtcbiAgICBhc3luYyBuZXdLZXlzdG9yZShvcHRzLCBhcGlDbGllbnQsIHdhbGxldCkge1xuICAgICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlUHJvdmlkZXJVbmF2YWlsYWJsZUVycm9yKFwiV2FsbGV0IHJlcXVpcmVkIHRvIGdlbmVyYXRlIG5ldyBrZXlzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnByZUNyZWF0ZUlkZW50aXR5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGF3YWl0IG9wdHMucHJlQ3JlYXRlSWRlbnRpdHlDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IFByaXZhdGVLZXlCdW5kbGVWMS5nZW5lcmF0ZSh3YWxsZXQpO1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IE5ldHdvcmtLZXlNYW5hZ2VyKHdhbGxldCwgbmV3IFRvcGljUGVyc2lzdGVuY2UoYXBpQ2xpZW50KSwgb3B0cy5wcmVFbmFibGVJZGVudGl0eUNhbGxiYWNrKTtcbiAgICAgICAgYXdhaXQgbWFuYWdlci5zdG9yZVByaXZhdGVLZXlCdW5kbGUoYnVuZGxlKTtcbiAgICAgICAgcmV0dXJuIEluTWVtb3J5S2V5c3RvcmUuY3JlYXRlKGJ1bmRsZSwgYXdhaXQgYnVpbGRQZXJzaXN0ZW5jZUZyb21PcHRpb25zKG9wdHMsIGJ1bmRsZSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOZXR3b3JrS2V5c3RvcmVQcm92aWRlciB3aWxsIGxvb2sgb24gdGhlIFhNVFAgbmV0d29yayBmb3IgYW4gYEVuY3J5cHRlZFByaXZhdGVLZXlCdW5kbGVgXG4gKiBvbiB0aGUgdXNlcidzIHByaXZhdGUgc3RvcmFnZSB0b3BpYy4gSWYgZm91bmQsIHdpbGwgZGVjcnlwdCB0aGUgYnVuZGxlIHVzaW5nIGEgd2FsbGV0XG4gKiBzaWduYXR1cmUgYW5kIGluc3RhbnRpYXRlIGEgS2V5c3RvcmUgaW5zdGFuY2UgdXNpbmcgdGhlIGRlY3J5cHRlZCB2YWx1ZS5cbiAqL1xuY2xhc3MgTmV0d29ya0tleXN0b3JlUHJvdmlkZXIge1xuICAgIGFzeW5jIG5ld0tleXN0b3JlKG9wdHMsIGFwaUNsaWVudCwgd2FsbGV0KSB7XG4gICAgICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVQcm92aWRlclVuYXZhaWxhYmxlRXJyb3IoXCJObyB3YWxsZXQgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IE5ldHdvcmtLZXlNYW5hZ2VyKHdhbGxldCwgbmV3IFRvcGljUGVyc2lzdGVuY2UoYXBpQ2xpZW50KSwgb3B0cy5wcmVFbmFibGVJZGVudGl0eUNhbGxiYWNrKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGxvYWRlci5sb2FkUHJpdmF0ZUtleUJ1bmRsZSgpO1xuICAgICAgICBpZiAoIWtleXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZVByb3ZpZGVyVW5hdmFpbGFibGVFcnJvcihcIk5vIGtleXMgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluTWVtb3J5S2V5c3RvcmUuY3JlYXRlKGtleXMsIGF3YWl0IGJ1aWxkUGVyc2lzdGVuY2VGcm9tT3B0aW9ucyhvcHRzLCBrZXlzKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdGhlcmV1bSgpIHtcbiAgICByZXR1cm4gd2luZG93LmV0aGVyZXVtO1xufVxuXG5mdW5jdGlvbiBzZW12ZXJQYXJzZSh2ZXJzaW9uKSB7XG4gICAgY29uc3QgW21ham9yLCBtaW5vciwgLi4ucGF0Y2hdID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFqb3I6IE51bWJlcihtYWpvciksXG4gICAgICAgIG1pbm9yOiBOdW1iZXIobWlub3IpLFxuICAgICAgICAvLyBLZWVwIHBhdGNoIGFzIGEgc3RyaW5nIHNvIHRoYXQgaXQgY2FuIHN1cHBvcnQgcHJlcmVsZWFzZSB2ZXJzaW9uc1xuICAgICAgICBwYXRjaDogcGF0Y2guam9pbihcIi5cIiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzU2FtZU1ham9yVmVyc2lvbihhLCBiKSB7XG4gICAgLy8gSWYgbm8gdmVyc2lvbiBpcyBwcm92aWRlZCwgYXNzdW1lIGl0IGlzIHRoZSBzYW1lXG4gICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2VtdmVyUGFyc2UoYSkubWFqb3IgPT09IHNlbXZlclBhcnNlKGIpLm1ham9yO1xufVxuLy8gQ2hlY2tzIGlmIEEgc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBCIHNlbXZlclxuZnVuY3Rpb24gc2VtdmVyR3JlYXRlclRoYW4oYSwgYikge1xuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFTZW12ZXIgPSBzZW12ZXJQYXJzZShhKTtcbiAgICBjb25zdCBiU2VtdmVyID0gc2VtdmVyUGFyc2UoYik7XG4gICAgaWYgKGFTZW12ZXIubWFqb3IgIT09IGJTZW12ZXIubWFqb3IpIHtcbiAgICAgICAgcmV0dXJuIGFTZW12ZXIubWFqb3IgPiBiU2VtdmVyLm1ham9yO1xuICAgIH1cbiAgICBpZiAoYVNlbXZlci5taW5vciAhPT0gYlNlbXZlci5taW5vcikge1xuICAgICAgICByZXR1cm4gYVNlbXZlci5taW5vciA+IGJTZW12ZXIubWlub3I7XG4gICAgfVxuICAgIGlmICghYVNlbXZlci5wYXRjaCB8fCAhYlNlbXZlci5wYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaEdyZWF0ZXJUaGFuKGFTZW12ZXIucGF0Y2gsIGJTZW12ZXIucGF0Y2gpO1xufVxuLy8gSG9tZS1icmV3ZWQgYXR0ZW1wdCBhdCBjb21wYXJpbmcgcGF0Y2ggdmVyc2lvbnMgc28gd2UgZG9uJ3QgaGF2ZSB0byBpbXBvcnQgc2VtdmVyIHBhY2thZ2UuXG4vLyBFeGFtcGxlIGZ1bGwgdmVyc2lvbiBtaWdodCBiZSBcIjIuMC4xLWFscGhhLjFcIiwgYW5kIHRoaXMgd2lsbCBiZSBvcGVyYXRpbmcgb24gdGhlIFwiMS1hbHBoYS4xXCIgcG9ydGlvblxuZnVuY3Rpb24gcGF0Y2hHcmVhdGVyVGhhbihhLCBiKSB7XG4gICAgY29uc3QgW2FWZXJzaW9uLCBhRXh0cmFdID0gYS5zcGxpdChcIi1cIik7XG4gICAgY29uc3QgW2JWZXJzaW9uLCBiRXh0cmFdID0gYi5zcGxpdChcIi1cIik7XG4gICAgaWYgKE51bWJlcihhVmVyc2lvbikgIT09IE51bWJlcihiVmVyc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihhVmVyc2lvbikgPiBOdW1iZXIoYlZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAoIWFFeHRyYSB8fCAhYkV4dHJhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2FUYWcsIGFUYWdWZXJzaW9uXSA9IGFFeHRyYS5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgW2JUYWcsIGJUYWdWZXJzaW9uXSA9IGJFeHRyYS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGFUYWcgIT09IGJUYWcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIoYVRhZ1ZlcnNpb24pID4gTnVtYmVyKGJUYWdWZXJzaW9uKTtcbn1cblxuY29uc3QgeyBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlX0tleXN0b3JlU3RhdHVzOiBLZXlzdG9yZVN0YXR1cyQxLCBJbml0S2V5c3RvcmVSZXF1ZXN0LCBJbml0S2V5c3RvcmVSZXNwb25zZSwgR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0LCBHZXRLZXlzdG9yZVN0YXR1c1Jlc3BvbnNlLCB9ID0ga2V5c3RvcmU7XG5hc3luYyBmdW5jdGlvbiBzbmFwUlBDKG1ldGhvZCwgcnBjLCByZXEsIG1ldGEsIHNuYXBJZCkge1xuICAgIGxldCByZXFQYXJhbSA9IG51bGw7XG4gICAgaWYgKHJwYy5yZXEpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IHJwYy5yZXEuZW5jb2RlO1xuICAgICAgICBjb25zdCByZXFCeXRlcyA9IGVuY29kZXIocmVxKS5maW5pc2goKTtcbiAgICAgICAgcmVxUGFyYW0gPSBiNjRFbmNvZGUocmVxQnl0ZXMsIDAsIHJlcUJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlU3RyaW5nID0gYXdhaXQgc25hcFJlcXVlc3QobWV0aG9kLCByZXFQYXJhbSwgbWV0YSwgc25hcElkKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZVN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBhcnJheSByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJwYy5yZXMuZGVjb2RlKGI2NERlY29kZShyZXNwb25zZVN0cmluZykpO1xufVxuYXN5bmMgZnVuY3Rpb24gc25hcFJlcXVlc3QobWV0aG9kLCByZXEsIG1ldGEsIHNuYXBJZCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0YSB9O1xuICAgIGlmICh0eXBlb2YgcmVxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcmFtcy5yZXEgPSByZXE7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRFdGhlcmV1bSgpPy5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIndhbGxldF9pbnZva2VTbmFwXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgc25hcElkLFxuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UgfHwgdHlwZW9mIHJlc3BvbnNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIHZhbHVlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UucmVzO1xufVxuLy8gSWYgYSBicm93c2VyIGhhcyBtdWx0aXBsZSBwcm92aWRlcnMsIGJ1dCBvbmUgb2YgdGhlbSBzdXBwb3J0cyBNZXRhTWFzayBmbGFza1xuLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGVuc3VyZSB0aGF0IEZsYXNrIGlzIGJlaW5nIHVzZWQgYW5kIHJldHVybiB0cnVlLlxuLy8gRGVzaWduZWQgdG8gYmUgcmVzaXN0YW50IHRvIHByb3ZpZGVyIGNsb2JiZXJpbmcgYnkgUGhhbnRvbSBhbmQgQ0JXXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTW9udG95YS9zbmFwLWNvbm5lY3QtdGVzdC9ibG9iL21haW4vaW5kZXguaHRtbFxuYXN5bmMgZnVuY3Rpb24gaGFzTWV0YW1hc2tXaXRoU25hcHMoKSB7XG4gICAgY29uc3QgZXRoZXJldW0gPSBnZXRFdGhlcmV1bSgpO1xuICAgIC8vIE5haXZlIHdheSBvZiBkZXRlY3Rpbmcgc25hcHMgc3VwcG9ydFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKGV0aGVyZXVtPy5pc01ldGFNYXNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwid2FsbGV0X2dldFNuYXBzXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgdHlwZW9mIGV0aGVyZXVtPy5kZXRlY3RlZCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGV0aGVyZXVtLmRldGVjdGVkKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIGV0aGVyZXVtLmRldGVjdGVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIERldGVjdCBzbmFwcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfZ2V0U25hcHNcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBlbmZvcmNlcyBNZXRhTWFzayBhcyBwcm92aWRlclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgZXRoZXJldW0/LnNldFByb3ZpZGVyPy4ocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgdHlwZW9mIGV0aGVyZXVtPy5wcm92aWRlcnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShldGhlcmV1bS5wcm92aWRlcnMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgZXRoZXJldW0ucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIERldGVjdCBzbmFwcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfZ2V0U25hcHNcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZXRoZXJldW0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNuYXBzKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgcmV0dXJuIGF3YWl0IGdldEV0aGVyZXVtKCk/LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwid2FsbGV0X2dldFNuYXBzXCIsXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTbmFwKHNuYXBJZCwgdmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNuYXBzID0gYXdhaXQgZ2V0U25hcHMoKTtcbiAgICAgICAgaWYgKHNuYXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzbmFwcykuZmluZCgoc25hcCkgPT4gc25hcCAmJlxuICAgICAgICAgICAgICAgIHNuYXAuaWQgPT09IHNuYXBJZCAmJlxuICAgICAgICAgICAgICAgICghdmVyc2lvbiB8fCBpc1NhbWVNYWpvclZlcnNpb24oc25hcC52ZXJzaW9uLCB2ZXJzaW9uKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBvYnRhaW4gaW5zdGFsbGVkIHNuYXBcIiwgZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdFNuYXAoc25hcElkLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5wYXJhbXMgPSB7fSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgYXdhaXQgZ2V0RXRoZXJldW0oKT8ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfcmVxdWVzdFNuYXBzXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgW3NuYXBJZF06IHBhcmFtcyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmNvbnN0IGdldFdhbGxldFN0YXR1c0NvZGVjID0ge1xuICAgIHJlcTogR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0LFxuICAgIHJlczogR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZSxcbn07XG5hc3luYyBmdW5jdGlvbiBnZXRXYWxsZXRTdGF0dXMobWV0YSwgc25hcElkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzbmFwUlBDKFwiZ2V0S2V5c3RvcmVTdGF0dXNcIiwgZ2V0V2FsbGV0U3RhdHVzQ29kZWMsIHtcbiAgICAgICAgd2FsbGV0QWRkcmVzczogbWV0YS53YWxsZXRBZGRyZXNzLFxuICAgIH0sIG1ldGEsIHNuYXBJZCk7XG4gICAgaWYgKFtcbiAgICAgICAgS2V5c3RvcmVTdGF0dXMkMS5LRVlTVE9SRV9TVEFUVVNfVU5TUEVDSUZJRUQsXG4gICAgICAgIEtleXN0b3JlU3RhdHVzJDEuVU5SRUNPR05JWkVELFxuICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGF0dXMgc3BlY2lmaWVkIGluIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzO1xufVxuY29uc3QgaW5pdEtleXN0b3JlQ29kZWMgPSB7XG4gICAgcmVxOiBJbml0S2V5c3RvcmVSZXF1ZXN0LFxuICAgIHJlczogSW5pdEtleXN0b3JlUmVzcG9uc2UsXG59O1xuYXN5bmMgZnVuY3Rpb24gaW5pdFNuYXAoYnVuZGxlLCBlbnYsIHNuYXBJZCkge1xuICAgIGNvbnN0IHdhbGxldEFkZHJlc3MgPSBidW5kbGUuaWRlbnRpdHlLZXkucHVibGljS2V5LndhbGxldFNpZ25hdHVyZUFkZHJlc3MoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNuYXBSUEMoXCJpbml0S2V5c3RvcmVcIiwgaW5pdEtleXN0b3JlQ29kZWMsIHtcbiAgICAgICAgdjE6IGJ1bmRsZSxcbiAgICB9LCB7IHdhbGxldEFkZHJlc3MsIGVudiB9LCBzbmFwSWQpO1xuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgS2V5c3RvcmVFcnJvcihyZXNwb25zZS5lcnJvci5jb2RlLCByZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICB9XG59XG5cbmNvbnN0IGFwaURlZnMgPSB7XG4gICAgLyoqXG4gICAgICogRGVjcnlwdCBhIGJhdGNoIG9mIFYxIG1lc3NhZ2VzXG4gICAgICovXG4gICAgZGVjcnlwdFYxOiB7XG4gICAgICAgIHJlcToga2V5c3RvcmUuRGVjcnlwdFYxUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5EZWNyeXB0UmVzcG9uc2UsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGEgYmF0Y2ggb2YgVjIgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBkZWNyeXB0VjI6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5EZWNyeXB0VjJSZXF1ZXN0LFxuICAgICAgICByZXM6IGtleXN0b3JlLkRlY3J5cHRSZXNwb25zZSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgYSBiYXRjaCBvZiBWMSBtZXNzYWdlc1xuICAgICAqL1xuICAgIGVuY3J5cHRWMToge1xuICAgICAgICByZXE6IGtleXN0b3JlLkVuY3J5cHRWMVJlcXVlc3QsXG4gICAgICAgIHJlczoga2V5c3RvcmUuRW5jcnlwdFJlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBhIGJhdGNoIG9mIFYyIG1lc3NhZ2VzXG4gICAgICovXG4gICAgZW5jcnlwdFYyOiB7XG4gICAgICAgIHJlcToga2V5c3RvcmUuRW5jcnlwdFYyUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5FbmNyeXB0UmVzcG9uc2UsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUYWtlIGEgYmF0Y2ggb2YgaW52aXRlIG1lc3NhZ2VzIGFuZCBzdG9yZSB0aGUgYFRvcGljS2V5c2AgZm9yIGxhdGVyIHVzZSBpblxuICAgICAqIGRlY3J5cHRpbmcgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzYXZlSW52aXRlczoge1xuICAgICAgICByZXE6IGtleXN0b3JlLlNhdmVJbnZpdGVzUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5TYXZlSW52aXRlc1Jlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2VhbGVkL2VuY3J5cHRlZCBpbnZpdGUgYW5kIHN0b3JlIHRoZSBUb3BpYyBrZXlzIGluIHRoZSBLZXlzdG9yZVxuICAgICAqIGZvciBsYXRlciB1c2UuIFRoZSByZXR1cm5lZCBpbnZpdGUgcGF5bG9hZCBtdXN0IGJlIHNlbnQgdG8gdGhlIG5ldHdvcmsgZm9yXG4gICAgICogdGhlIG90aGVyIHBhcnR5IHRvIGJlIGFibGUgdG8gY29tbXVuaWNhdGUuXG4gICAgICovXG4gICAgY3JlYXRlSW52aXRlOiB7XG4gICAgICAgIHJlcToga2V5c3RvcmUuQ3JlYXRlSW52aXRlUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5DcmVhdGVJbnZpdGVSZXNwb25zZSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBYTVRQIGF1dGggdG9rZW4gdG8gYmUgdXNlZCBhcyBhIGhlYWRlciBvbiBYTVRQIEFQSSByZXF1ZXN0c1xuICAgICAqL1xuICAgIGNyZWF0ZUF1dGhUb2tlbjoge1xuICAgICAgICByZXE6IGtleXN0b3JlLkNyZWF0ZUF1dGhUb2tlblJlcXVlc3QsXG4gICAgICAgIHJlczogYXV0aG4uVG9rZW4sXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaWduIHRoZSBwcm92aWRlZCBkaWdlc3Qgd2l0aCBlaXRoZXIgdGhlIGBJZGVudGl0eUtleWAgb3IgYSBzcGVjaWZpZWRcbiAgICAgKiBgUHJlS2V5YFxuICAgICAqL1xuICAgIHNpZ25EaWdlc3Q6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5TaWduRGlnZXN0UmVxdWVzdCxcbiAgICAgICAgcmVzOiBzaWduYXR1cmUuU2lnbmF0dXJlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBgUHVibGljS2V5QnVuZGxlYCBhc3NvY2lhdGVkIHdpdGggdGhlIEtleXN0b3JlJ3MgcHJpdmF0ZSBrZXlzXG4gICAgICovXG4gICAgZ2V0UHVibGljS2V5QnVuZGxlOiB7XG4gICAgICAgIHJlcTogbnVsbCxcbiAgICAgICAgcmVzOiBwdWJsaWNLZXkuUHVibGljS2V5QnVuZGxlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhwb3J0IHRoZSBwcml2YXRlIGtleXMuIE1heSB0aHJvdyBhbiBlcnJvciBpZiB0aGUga2V5c3RvcmUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBkb2VzIG5vdCBhbGxvdyB0aGlzIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldFByaXZhdGVLZXlCdW5kbGU6IHtcbiAgICAgICAgcmVxOiBudWxsLFxuICAgICAgICByZXM6IHByaXZhdGVLZXkuUHJpdmF0ZUtleUJ1bmRsZVYxLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2F2ZSBWMSBDb252ZXJzYXRpb25zXG4gICAgICovXG4gICAgc2F2ZVYxQ29udmVyc2F0aW9uczoge1xuICAgICAgICByZXE6IGtleXN0b3JlLlNhdmVWMUNvbnZlcnNhdGlvbnNSZXF1ZXN0LFxuICAgICAgICByZXM6IGtleXN0b3JlLlNhdmVWMUNvbnZlcnNhdGlvbnNSZXNwb25zZSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgVjEgY29udmVyc2F0aW9uc1xuICAgICAqL1xuICAgIGdldFYxQ29udmVyc2F0aW9uczoge1xuICAgICAgICByZXE6IG51bGwsXG4gICAgICAgIHJlczoga2V5c3RvcmUuR2V0Q29udmVyc2F0aW9uc1Jlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBWMiBjb252ZXJzYXRpb25zXG4gICAgICovXG4gICAgZ2V0VjJDb252ZXJzYXRpb25zOiB7XG4gICAgICAgIHJlcTogbnVsbCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5HZXRDb252ZXJzYXRpb25zUmVzcG9uc2UsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSByZWZyZXNoIGpvYiBmcm9tIHRoZSBwZXJzaXN0ZW5jZVxuICAgICAqL1xuICAgIGdldFJlZnJlc2hKb2I6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5HZXRSZWZyZXNoSm9iUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5HZXRSZWZyZXNoSm9iUmVzcG9uc2UsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aW1lIG9mIGEgcmVmcmVzaCBqb2JcbiAgICAgKi9cbiAgICBzZXRSZWZyZXNoSm9iOiB7XG4gICAgICAgIHJlcToga2V5c3RvcmUuU2V0UmVmZXNoSm9iUmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5TZXRSZWZyZXNoSm9iUmVzcG9uc2UsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGEgYmF0Y2ggb2YgbWVzc2FnZXMgdG8geW91cnNlbGZcbiAgICAgKi9cbiAgICBzZWxmRW5jcnlwdDoge1xuICAgICAgICByZXE6IGtleXN0b3JlLlNlbGZFbmNyeXB0UmVxdWVzdCxcbiAgICAgICAgcmVzOiBrZXlzdG9yZS5TZWxmRW5jcnlwdFJlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjcnlwdCBhIGJhdGNoIG9mIG1lc3NhZ2VzIHRvIHlvdXJzZWxmXG4gICAgICovXG4gICAgc2VsZkRlY3J5cHQ6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5TZWxmRGVjcnlwdFJlcXVlc3QsXG4gICAgICAgIHJlczoga2V5c3RvcmUuRGVjcnlwdFJlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcml2YXRlIHByZWZlcmVuY2VzIHRvcGljIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBnZXRQcml2YXRlUHJlZmVyZW5jZXNUb3BpY0lkZW50aWZpZXI6IHtcbiAgICAgICAgcmVxOiBudWxsLFxuICAgICAgICByZXM6IGtleXN0b3JlLkdldFByaXZhdGVQcmVmZXJlbmNlc1RvcGljSWRlbnRpZmllclJlc3BvbnNlLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udmVyc2F0aW9uIEhNQUMga2V5cyBmb3IgdGhlIGN1cnJlbnQsIHByZXZpb3VzLCBhbmQgbmV4dFxuICAgICAqIDMwIGRheSBwZXJpb2RzIHNpbmNlIHRoZSBlcG9jaFxuICAgICAqL1xuICAgIGdldFYyQ29udmVyc2F0aW9uSG1hY0tleXM6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5HZXRDb252ZXJzYXRpb25IbWFjS2V5c1JlcXVlc3QsXG4gICAgICAgIHJlczoga2V5c3RvcmUuR2V0Q29udmVyc2F0aW9uSG1hY0tleXNSZXNwb25zZSxcbiAgICB9LFxufTtcbmNvbnN0IHNuYXBBcGlEZWZzID0ge1xuICAgIGdldEtleXN0b3JlU3RhdHVzOiB7XG4gICAgICAgIHJlcToga2V5c3RvcmUuR2V0S2V5c3RvcmVTdGF0dXNSZXF1ZXN0LFxuICAgICAgICByZXM6IGtleXN0b3JlLkdldEtleXN0b3JlU3RhdHVzUmVzcG9uc2UsXG4gICAgfSxcbiAgICBpbml0S2V5c3RvcmU6IHtcbiAgICAgICAgcmVxOiBrZXlzdG9yZS5Jbml0S2V5c3RvcmVSZXF1ZXN0LFxuICAgICAgICByZXM6IGtleXN0b3JlLkluaXRLZXlzdG9yZVJlc3BvbnNlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBTbmFwS2V5c3RvcmUod2FsbGV0QWRkcmVzcywgZW52LCBzbmFwSWQpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWRNZXRob2RzID0ge307XG4gICAgY29uc3Qgc25hcE1ldGEgPSB7XG4gICAgICAgIHdhbGxldEFkZHJlc3MsXG4gICAgICAgIGVudixcbiAgICB9O1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgcnBjXSBvZiBPYmplY3QuZW50cmllcyhzbmFwQXBpRGVmcykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgICAgIGdlbmVyYXRlZE1ldGhvZHNbbWV0aG9kXSA9IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgIGlmICghcnBjLnJlcSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwUlBDKG1ldGhvZCwgcnBjLCB1bmRlZmluZWQsIHNuYXBNZXRhLCBzbmFwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICByZXR1cm4gc25hcFJQQyhtZXRob2QsIHJwYywgcmVxLCBzbmFwTWV0YSwgc25hcElkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2VuZXJhdGVkTWV0aG9kcyxcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNhbGxpbmcgdGhlIGtleXN0b3JlLCBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIHdhbGxldCBhZGRyZXNzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgICAgICBhc3luYyBnZXRBY2NvdW50QWRkcmVzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXRBZGRyZXNzO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IHsgR2V0S2V5c3RvcmVTdGF0dXNSZXNwb25zZV9LZXlzdG9yZVN0YXR1czogS2V5c3RvcmVTdGF0dXMgfSA9IGtleXN0b3JlO1xuY29uc3QgU05BUF9MT0NBTF9PUklHSU4gPSBcImxvY2FsOmh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiO1xuLyoqXG4gKiBUaGUgU25hcCBrZXlzdG9yZSBwcm92aWRlciB3aWxsOlxuICogMS4gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgY2FwYWJsZSBvZiB1c2luZyBTbmFwc1xuICogMi4gQ2hlY2sgaWYgdGhlIHVzZXIgaGFzIGFscmVhZHkgc2V0dXAgdGhlIFNuYXAgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2V5c1xuICogMy4gSWYgbm90LCB3aWxsIGdldCBrZXlzIGZyb20gdGhlIG5ldHdvcmsgb3IgY3JlYXRlIG5ldyBrZXlzIGFuZCBzdG9yZSB0aGVtIGluIHRoZSBTbmFwXG4gKi9cbmNsYXNzIFNuYXBLZXlzdG9yZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzbmFwSWQgPSBTTkFQX0xPQ0FMX09SSUdJTiwgc25hcFZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5zbmFwSWQgPSBzbmFwSWQ7XG4gICAgICAgIHRoaXMuc25hcFZlcnNpb24gPSBzbmFwVmVyc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgbmV3S2V5c3RvcmUob3B0cywgYXBpQ2xpZW50LCB3YWxsZXQpIHtcbiAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlzdG9yZVByb3ZpZGVyVW5hdmFpbGFibGVFcnJvcihcIk5vIHdhbGxldCBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShhd2FpdCBoYXNNZXRhbWFza1dpdGhTbmFwcygpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlUHJvdmlkZXJVbmF2YWlsYWJsZUVycm9yKFwiTWV0YU1hc2sgd2l0aCBTbmFwcyBub3QgZGV0ZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0QWRkcmVzcyA9IGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGNvbnN0IGVudiA9IG9wdHMuZW52O1xuICAgICAgICBjb25zdCBoYXNTbmFwID0gYXdhaXQgZ2V0U25hcCh0aGlzLnNuYXBJZCwgdGhpcy5zbmFwVmVyc2lvbik7XG4gICAgICAgIGlmICghaGFzU25hcCB8fCBzZW12ZXJHcmVhdGVyVGhhbih0aGlzLnNuYXBWZXJzaW9uLCBoYXNTbmFwLnZlcnNpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0U25hcCh0aGlzLnNuYXBJZCwgdGhpcy5zbmFwVmVyc2lvbiA/IHsgdmVyc2lvbjogdGhpcy5zbmFwVmVyc2lvbiB9IDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IGNoZWNrU25hcExvYWRlZCh3YWxsZXRBZGRyZXNzLCBlbnYsIHRoaXMuc25hcElkKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IGJ1bmRsZUZyb21PcHRpb25zKG9wdHMsIGFwaUNsaWVudCwgd2FsbGV0KTtcbiAgICAgICAgICAgIGF3YWl0IGluaXRTbmFwKGJ1bmRsZSwgZW52LCB0aGlzLnNuYXBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNuYXBLZXlzdG9yZSh3YWxsZXRBZGRyZXNzLCBlbnYsIHRoaXMuc25hcElkKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVCdW5kbGUob3B0cywgYXBpQ2xpZW50LCB3YWxsZXQpIHtcbiAgICBjb25zdCB0bXBQcm92aWRlciA9IG5ldyBLZXlHZW5lcmF0b3JLZXlzdG9yZVByb3ZpZGVyKCk7XG4gICAgY29uc3QgdG1wS2V5c3RvcmUgPSBhd2FpdCB0bXBQcm92aWRlci5uZXdLZXlzdG9yZShvcHRzLCBhcGlDbGllbnQsIHdhbGxldCk7XG4gICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5QnVuZGxlVjEoYXdhaXQgdG1wS2V5c3RvcmUuZ2V0UHJpdmF0ZUtleUJ1bmRsZSgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1bmRsZUZyb21PcHRpb25zKG9wdHMsIGFwaUNsaWVudCwgd2FsbGV0KSB7XG4gICAgaWYgKG9wdHMucHJpdmF0ZUtleU92ZXJyaWRlKSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGRlY29kZVByaXZhdGVLZXlCdW5kbGUob3B0cy5wcml2YXRlS2V5T3ZlcnJpZGUpO1xuICAgICAgICBpZiAoIShidW5kbGUgaW5zdGFuY2VvZiBQcml2YXRlS2V5QnVuZGxlVjEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcml2YXRlIGtleSBidW5kbGUgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgIH1cbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcml2YXRlS2V5T3ZlcnJpZGUgb3Igd2FsbGV0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0T3JDcmVhdGVCdW5kbGUob3B0cywgYXBpQ2xpZW50LCB3YWxsZXQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0T3JDcmVhdGVCdW5kbGUob3B0cywgYXBpQ2xpZW50LCB3YWxsZXQpIHtcbiAgICAvLyBJIHJlYWxseSBkb24ndCBsb3ZlIHVzaW5nIG90aGVyIHByb3ZpZGVycyBpbnNpZGUgYSBwcm92aWRlci4gRmVlbHMgbGlrZSB0b28gbXVjaCBpbmRpcmVjdGlvblxuICAgIC8vIFRPRE86IFJlZmFjdG9yIGtleXN0b3JlIHByb3ZpZGVycyB0byBiZXR0ZXIgc3VwcG9ydCB0aGUgd2VpcmQgU25hcCBmbG93XG4gICAgY29uc3QgbmV0d29ya1Byb3ZpZGVyID0gbmV3IE5ldHdvcmtLZXlzdG9yZVByb3ZpZGVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG1wS2V5c3RvcmUgPSBhd2FpdCBuZXR3b3JrUHJvdmlkZXIubmV3S2V5c3RvcmUob3B0cywgYXBpQ2xpZW50LCB3YWxsZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXlCdW5kbGVWMShhd2FpdCB0bXBLZXlzdG9yZS5nZXRQcml2YXRlS2V5QnVuZGxlKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEtleXN0b3JlUHJvdmlkZXJVbmF2YWlsYWJsZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVuZGxlKG9wdHMsIGFwaUNsaWVudCwgd2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrU25hcExvYWRlZCh3YWxsZXRBZGRyZXNzLCBlbnYsIHNuYXBJZCkge1xuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGdldFdhbGxldFN0YXR1cyh7IHdhbGxldEFkZHJlc3MsIGVudiB9LCBzbmFwSWQpO1xuICAgIGlmIChzdGF0dXMgPT09IEtleXN0b3JlU3RhdHVzLktFWVNUT1JFX1NUQVRVU19JTklUSUFMSVpFRCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFN0YXRpY0tleXN0b3JlUHJvdmlkZXIgd2lsbCBsb29rIGZvciBhIGBwcml2YXRlS2V5T3ZlcnJpZGVgIGluIHRoZSBwcm92aWRlZCBvcHRpb25zLFxuICogYW5kIGJvb3RzdHJhcCBhIEtleXN0b3JlIHVzaW5nIHRob3NlIG9wdGlvbnMgaWYgcHJvdmlkZWQuXG4gKlxuICogSWYgbm8gYHByaXZhdGVLZXlPdmVycmlkZWAgaXMgc3VwcGxpZWQgd2lsbCB0aHJvdyBhIGBLZXlzdG9yZVByb3ZpZGVyVW5hdmFpbGFibGVFcnJvcmAgY2F1c2luZ1xuICogdGhlIGNsaWVudCB0byBjb250aW51ZSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgYEtleXN0b3JlUHJvdmlkZXJzYCBsaXN0LlxuICovXG5jbGFzcyBTdGF0aWNLZXlzdG9yZVByb3ZpZGVyIHtcbiAgICBhc3luYyBuZXdLZXlzdG9yZShvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleU92ZXJyaWRlIH0gPSBvcHRzO1xuICAgICAgICBpZiAoIXByaXZhdGVLZXlPdmVycmlkZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEtleXN0b3JlUHJvdmlkZXJVbmF2YWlsYWJsZUVycm9yKFwiTm8gcHJpdmF0ZSBrZXkgb3ZlcnJpZGUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVuZGxlID0gZGVjb2RlUHJpdmF0ZUtleUJ1bmRsZShwcml2YXRlS2V5T3ZlcnJpZGUpO1xuICAgICAgICBpZiAoYnVuZGxlIGluc3RhbmNlb2YgUHJpdmF0ZUtleUJ1bmRsZVYyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWMiBwcml2YXRlIGtleSBidW5kbGUgZm91bmQuIE9ubHkgVjEgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbk1lbW9yeUtleXN0b3JlLmNyZWF0ZShidW5kbGUsIGF3YWl0IGJ1aWxkUGVyc2lzdGVuY2VGcm9tT3B0aW9ucyhvcHRzLCBidW5kbGUpKTtcbiAgICB9XG59XG5cbmNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZnVuY3Rpb24gZ2V0U2lnbmVyKHdhbGxldCkge1xuICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNXYWxsZXRDbGllbnQod2FsbGV0KSkge1xuICAgICAgICByZXR1cm4gY29udmVydFdhbGxldENsaWVudFRvU2lnbmVyKHdhbGxldCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2FsbGV0LmdldEFkZHJlc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHdhbGxldCB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0O1xufVxuZnVuY3Rpb24gaXNXYWxsZXRDbGllbnQod2FsbGV0KSB7XG4gICAgcmV0dXJuIChcInR5cGVcIiBpbiB3YWxsZXQgJiZcbiAgICAgICAgKHdhbGxldC50eXBlID09PSBcIndhbGxldENsaWVudFwiIHx8IHdhbGxldC50eXBlID09PSBcImJhc2VcIikpO1xufVxuZnVuY3Rpb24gY29udmVydFdhbGxldENsaWVudFRvU2lnbmVyKHdhbGxldENsaWVudCkge1xuICAgIGNvbnN0IHsgYWNjb3VudCB9ID0gd2FsbGV0Q2xpZW50O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFhY2NvdW50IHx8ICFhY2NvdW50LmFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0Q2xpZW50IGlzIG5vdCBjb25maWd1cmVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICAgICAgZ2V0QWRkcmVzczogYXN5bmMgKCkgPT4gYWNjb3VudC5hZGRyZXNzLFxuICAgICAgICBzaWduTWVzc2FnZTogYXN5bmMgKG1lc3NhZ2UpID0+IHdhbGxldENsaWVudC5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgICBtZXNzYWdlOiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiB7IHJhdzogbWVzc2FnZSB9LFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cblxuLy8gVGhpcyBpbXBvcnQgaGFzIHRvIGNvbWUgZmlyc3Qgc28gdGhhdCB0aGUgcG9seWZpbGxzIGFyZSByZWdpc3RlcmVkIGJlZm9yZSB0aGUgc3RyZWFtIHBvbHlmaWxsc1xuLy9cbi8vIENvbXByZXNzaW9uXG4vL1xuYXN5bmMgZnVuY3Rpb24gZGVjb21wcmVzcyhlbmNvZGVkLCBtYXhTaXplKSB7XG4gICAgaWYgKGVuY29kZWQuY29tcHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmsgPSB7IGJ5dGVzOiBuZXcgVWludDhBcnJheShlbmNvZGVkLmNvbnRlbnQubGVuZ3RoKSB9O1xuICAgIGF3YWl0IHJlYWRTdHJlYW1Gcm9tQnl0ZXMoZW5jb2RlZC5jb250ZW50KVxuICAgICAgICAucGlwZVRocm91Z2gobmV3IERlY29tcHJlc3Npb25TdHJlYW0oY29tcHJlc3Npb25JZEZyb21Db2RlKGVuY29kZWQuY29tcHJlc3Npb24pKSlcbiAgICAgICAgLnBpcGVUbyh3cml0ZVN0cmVhbVRvQnl0ZXMoc2luaywgbWF4U2l6ZSkpO1xuICAgIGVuY29kZWQuY29udGVudCA9IHNpbmsuYnl0ZXM7XG59XG5hc3luYyBmdW5jdGlvbiBjb21wcmVzcyhlbmNvZGVkKSB7XG4gICAgaWYgKGVuY29kZWQuY29tcHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmsgPSB7IGJ5dGVzOiBuZXcgVWludDhBcnJheShlbmNvZGVkLmNvbnRlbnQubGVuZ3RoIC8gMTApIH07XG4gICAgYXdhaXQgcmVhZFN0cmVhbUZyb21CeXRlcyhlbmNvZGVkLmNvbnRlbnQpXG4gICAgICAgIC5waXBlVGhyb3VnaChuZXcgQ29tcHJlc3Npb25TdHJlYW0oY29tcHJlc3Npb25JZEZyb21Db2RlKGVuY29kZWQuY29tcHJlc3Npb24pKSlcbiAgICAgICAgLnBpcGVUbyh3cml0ZVN0cmVhbVRvQnl0ZXMoc2luaywgZW5jb2RlZC5jb250ZW50Lmxlbmd0aCArIDEwMDApKTtcbiAgICBlbmNvZGVkLmNvbnRlbnQgPSBzaW5rLmJ5dGVzO1xufVxuZnVuY3Rpb24gY29tcHJlc3Npb25JZEZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29udGVudC5Db21wcmVzc2lvbi5DT01QUkVTU0lPTl9HWklQKSB7XG4gICAgICAgIHJldHVybiBcImd6aXBcIjtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IGNvbnRlbnQuQ29tcHJlc3Npb24uQ09NUFJFU1NJT05fREVGTEFURSkge1xuICAgICAgICByZXR1cm4gXCJkZWZsYXRlXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBjb21wcmVzc2lvbiBhbGdvcml0aG1cIik7XG59XG5mdW5jdGlvbiByZWFkU3RyZWFtRnJvbUJ5dGVzKGJ5dGVzLCBjaHVua1NpemUgPSAxMDI0KSB7XG4gICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1jb25mdXNpbmctdm9pZC1leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSBwb3NpdGlvbiArIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGVuZCA9IGVuZCA8PSBieXRlcy5sZW5ndGggPyBlbmQgOiBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnl0ZXMuc3ViYXJyYXkocG9zaXRpb24sIGVuZCkpO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiB3cml0ZVN0cmVhbVRvQnl0ZXMoc2luaywgbWF4U2l6ZSkge1xuICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwb3NpdGlvbiArIGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4aW11bSBvdXRwdXQgc2l6ZSBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzaW5rLmJ5dGVzLmxlbmd0aCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHNpbmsuYnl0ZXMgPSBncm93Qnl0ZXMoc2luay5ieXRlcywgbWF4U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaW5rLmJ5dGVzLnNldChjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgc2luay5ieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzaW5rLmJ5dGVzID0gc2luay5ieXRlcy5zdWJhcnJheSgwLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBncm93Qnl0ZXMoYnl0ZXMsIG1heFNpemUpIHtcbiAgICBsZXQgbmV3U2l6ZSA9IGJ5dGVzLmxlbmd0aCAqIDI7XG4gICAgaWYgKG5ld1NpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIG5ld1NpemUgPSBtYXhTaXplO1xuICAgIH1cbiAgICBjb25zdCBiaWdnZXIgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTtcbiAgICBiaWdnZXIuc2V0KGJ5dGVzKTtcbiAgICByZXR1cm4gYmlnZ2VyO1xufVxuXG4vLyBEZWNvZGVzIGNvbnRhY3QgYnVuZGxlcyBmcm9tIHRoZSBjb250YWN0IHRvcGljLlxuZnVuY3Rpb24gZGVjb2RlQ29udGFjdEJ1bmRsZShieXRlcykge1xuICAgIGxldCBjYjtcbiAgICB0cnkge1xuICAgICAgICBjYiA9IGNvbnRhY3QuQ29udGFjdEJ1bmRsZS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IHBiID0gcHVibGljS2V5LlB1YmxpY0tleUJ1bmRsZS5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICBjYiA9IHsgdjE6IHsga2V5QnVuZGxlOiBuZXcgUHVibGljS2V5QnVuZGxlKHBiKSB9LCB2MjogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIGlmIChjYi52MT8ua2V5QnVuZGxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5QnVuZGxlKGNiLnYxLmtleUJ1bmRsZSk7XG4gICAgfVxuICAgIGlmIChjYi52Mj8ua2V5QnVuZGxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVkUHVibGljS2V5QnVuZGxlKGNiLnYyLmtleUJ1bmRsZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gb3IgaW52YWxpZCBjb250YWN0IGJ1bmRsZVwiKTtcbn1cbi8vIEVuY29kZXMgcHVibGljIGtleSBidW5kbGUgZm9yIHRoZSBjb250YWN0IHRvcGljLlxuZnVuY3Rpb24gZW5jb2RlQ29udGFjdEJ1bmRsZShidW5kbGUpIHtcbiAgICBpZiAoYnVuZGxlIGluc3RhbmNlb2YgUHVibGljS2V5QnVuZGxlKSB7XG4gICAgICAgIHJldHVybiBjb250YWN0LkNvbnRhY3RCdW5kbGUuZW5jb2RlKHtcbiAgICAgICAgICAgIHYxOiB7IGtleUJ1bmRsZTogYnVuZGxlIH0sXG4gICAgICAgICAgICB2MjogdW5kZWZpbmVkLFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250YWN0LkNvbnRhY3RCdW5kbGUuZW5jb2RlKHtcbiAgICAgICAgICAgIHYxOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2MjogeyBrZXlCdW5kbGU6IGJ1bmRsZSB9LFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICB9XG59XG5cbnZhciBfQ29udGFjdHNfaW5zdGFuY2VzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIF9Db250YWN0c19qb2JSdW5uZXIsIF9Db250YWN0c192YWxpZGF0ZUNvbnNlbnRTaWduYXR1cmU7XG5jbGFzcyBDb25zZW50TGlzdEVudHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZW50cnlUeXBlLCBwZXJtaXNzaW9uVHlwZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW50cnlUeXBlID0gZW50cnlUeXBlO1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25UeXBlID0gcGVybWlzc2lvblR5cGU7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmVudHJ5VHlwZX0tJHt0aGlzLnZhbHVlfWA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWRkcmVzcyhhZGRyZXNzLCBwZXJtaXNzaW9uVHlwZSA9IFwidW5rbm93blwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc2VudExpc3RFbnRyeShhZGRyZXNzLCBcImFkZHJlc3NcIiwgcGVybWlzc2lvblR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdyb3VwSWQoZ3JvdXBJZCwgcGVybWlzc2lvblR5cGUgPSBcInVua25vd25cIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnNlbnRMaXN0RW50cnkoZ3JvdXBJZCwgXCJncm91cElkXCIsIHBlcm1pc3Npb25UeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbmJveElkKGluYm94SWQsIHBlcm1pc3Npb25UeXBlID0gXCJ1bmtub3duXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zZW50TGlzdEVudHJ5KGluYm94SWQsIFwiaW5ib3hJZFwiLCBwZXJtaXNzaW9uVHlwZSk7XG4gICAgfVxufVxuY2xhc3MgQ29uc2VudExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBhbGxvdyhhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tQWRkcmVzcyhhZGRyZXNzLCBcImFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMuZW50cmllcy5zZXQoZW50cnkua2V5LCBcImFsbG93ZWRcIik7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgZGVueShhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tQWRkcmVzcyhhZGRyZXNzLCBcImRlbmllZFwiKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzLnNldChlbnRyeS5rZXksIFwiZGVuaWVkXCIpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIGFsbG93R3JvdXAoZ3JvdXBJZCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IENvbnNlbnRMaXN0RW50cnkuZnJvbUdyb3VwSWQoZ3JvdXBJZCwgXCJhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLmVudHJpZXMuc2V0KGVudHJ5LmtleSwgXCJhbGxvd2VkXCIpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIGRlbnlHcm91cChncm91cElkKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tR3JvdXBJZChncm91cElkLCBcImRlbmllZFwiKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzLnNldChlbnRyeS5rZXksIFwiZGVuaWVkXCIpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIGFsbG93SW5ib3hJZChpbmJveElkKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tSW5ib3hJZChpbmJveElkLCBcImFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMuZW50cmllcy5zZXQoZW50cnkua2V5LCBcImFsbG93ZWRcIik7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgZGVueUluYm94SWQoaW5ib3hJZCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IENvbnNlbnRMaXN0RW50cnkuZnJvbUluYm94SWQoaW5ib3hJZCwgXCJkZW5pZWRcIik7XG4gICAgICAgIHRoaXMuZW50cmllcy5zZXQoZW50cnkua2V5LCBcImRlbmllZFwiKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICBzdGF0ZShhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5nZXQoZW50cnkua2V5KSA/PyBcInVua25vd25cIjtcbiAgICB9XG4gICAgZ3JvdXBTdGF0ZShncm91cElkKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQ29uc2VudExpc3RFbnRyeS5mcm9tR3JvdXBJZChncm91cElkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5nZXQoZW50cnkua2V5KSA/PyBcInVua25vd25cIjtcbiAgICB9XG4gICAgaW5ib3hJZFN0YXRlKGluYm94SWQpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBDb25zZW50TGlzdEVudHJ5LmZyb21JbmJveElkKGluYm94SWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmdldChlbnRyeS5rZXkpID8/IFwidW5rbm93blwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgbWVzc2FnZXMgYW5kIHNhdmUgdGhlbSB0byB0aGUga2V5c3RvcmVcbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVNZXNzYWdlcyhtZXNzYWdlTWFwKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gQXJyYXkuZnJvbShtZXNzYWdlTWFwLnZhbHVlcygpKTtcbiAgICAgICAgLy8gZGVjcnlwdCBtZXNzYWdlc1xuICAgICAgICBjb25zdCB7IHJlc3BvbnNlcyB9ID0gYXdhaXQgdGhpcy5jbGllbnQua2V5c3RvcmUuc2VsZkRlY3J5cHQoe1xuICAgICAgICAgICAgcmVxdWVzdHM6IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHsgcGF5bG9hZDogbWVzc2FnZSB9KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlRW50cmllcyA9IEFycmF5LmZyb20obWVzc2FnZU1hcC5rZXlzKCkpLm1hcCgoa2V5LCBpbmRleCkgPT4gW2tleSwgcmVzcG9uc2VzW2luZGV4XV0pO1xuICAgICAgICAvLyBkZWNvZGUgZGVjcnlwdGVkIG1lc3NhZ2VzIGludG8gYWN0aW9ucywgY29udmVydCB0byBtYXBcbiAgICAgICAgY29uc3QgYWN0aW9uc01hcCA9IGRlY3J5cHRlZE1lc3NhZ2VFbnRyaWVzLnJlZHVjZSgocmVzdWx0LCBba2V5LCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQ/LmRlY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHByaXZhdGVQcmVmZXJlbmNlcy5Qcml2YXRlUHJlZmVyZW5jZXNBY3Rpb24uZGVjb2RlKHJlc3BvbnNlLnJlc3VsdC5kZWNyeXB0ZWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICAgICAgLy8gc2F2ZSBhY3Rpb25zIHRvIGtleXN0b3JlXG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmtleXN0b3JlLnNhdmVQcml2YXRlUHJlZmVyZW5jZXMoYWN0aW9uc01hcCk7XG4gICAgICAgIHJldHVybiBhY3Rpb25zTWFwO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFByb2Nlc3MgYWN0aW9ucyBhbmQgdXBkYXRlIGludGVybmFsIGNvbnNlbnQgbGlzdFxuICAgICAqL1xuICAgIHByb2Nlc3NBY3Rpb25zKGFjdGlvbnNNYXApIHtcbiAgICAgICAgLy8gYWN0aW9ucyB0byBwcm9jZXNzXG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBBcnJheS5mcm9tKGFjdGlvbnNNYXAudmFsdWVzKCkpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvbnNlbnQgbGlzdFxuICAgICAgICBhY3Rpb25zLmZvckVhY2goKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgYWN0aW9uLmFsbG93QWRkcmVzcz8ud2FsbGV0QWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93KGFkZHJlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3Rpb24uZGVueUFkZHJlc3M/LndhbGxldEFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZW55KGFkZHJlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3Rpb24uYWxsb3dHcm91cD8uZ3JvdXBJZHMuZm9yRWFjaCgoZ3JvdXBJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dHcm91cChncm91cElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aW9uLmRlbnlHcm91cD8uZ3JvdXBJZHMuZm9yRWFjaCgoZ3JvdXBJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVueUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3Rpb24uYWxsb3dJbmJveElkPy5pbmJveElkcy5mb3JFYWNoKChpbmJveElkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0luYm94SWQoaW5ib3hJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFjdGlvbi5kZW55SW5ib3hJZD8uaW5ib3hJZHMuZm9yRWFjaCgoaW5ib3hJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVueUluYm94SWQoaW5ib3hJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUb3BpYyA9IGF3YWl0IHRoaXMuY2xpZW50LmtleXN0b3JlLmdldFByaXZhdGVQcmVmZXJlbmNlc1RvcGljKCk7XG4gICAgICAgIHJldHVybiBTdHJlYW0uY3JlYXRlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLmNsaWVudCwgW2NvbnRlbnRUb3BpY10sIGFzeW5jIChlbnZlbG9wZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVudmVsb3BlcyB3aXRob3V0IG1lc3NhZ2Ugb3IgdGltZXN0YW1wXG4gICAgICAgICAgICBpZiAoIWVudmVsb3BlLm1lc3NhZ2UgfHwgIWVudmVsb3BlLnRpbWVzdGFtcE5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlY29kZSBtZXNzYWdlIGFuZCBzYXZlIHRvIGtleXN0b3JlXG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zTWFwID0gYXdhaXQgdGhpcy5kZWNvZGVNZXNzYWdlcyhuZXcgTWFwKFtbZW52ZWxvcGUudGltZXN0YW1wTnMsIGVudmVsb3BlLm1lc3NhZ2VdXSkpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnNlbnQgbGlzdFxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWN0aW9ucyhhY3Rpb25zTWFwKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgYWN0aW9uXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uc01hcC5nZXQoZW52ZWxvcGUudGltZXN0YW1wTnMpO1xuICAgICAgICB9LCB1bmRlZmluZWQsIG9uQ29ubmVjdGlvbkxvc3QpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy8gY2xlYXIgZXhpc3RpbmcgZW50cmllc1xuICAgICAgICB0aGlzLmVudHJpZXMuY2xlYXIoKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZChzdGFydFRpbWUpIHtcbiAgICAgICAgY29uc3QgY29udGVudFRvcGljID0gYXdhaXQgdGhpcy5jbGllbnQua2V5c3RvcmUuZ2V0UHJpdmF0ZVByZWZlcmVuY2VzVG9waWMoKTtcbiAgICAgICAgLy8gZ2V0IHByaXZhdGUgcHJlZmVyZW5jZXMgZnJvbSB0aGUgbmV0d29ya1xuICAgICAgICBjb25zdCBtZXNzYWdlRW50cmllcyA9IChhd2FpdCB0aGlzLmNsaWVudC5saXN0RW52ZWxvcGVzKGNvbnRlbnRUb3BpYywgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgICAgICBhc3luYyAoeyBtZXNzYWdlLCB0aW1lc3RhbXBOcyB9KSA9PiBbdGltZXN0YW1wTnMsIG1lc3NhZ2VdLCB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGV4Y2VwdGlvbiBmb3IgcHJpdmF0ZSBwcmVmZXJlbmNlcyB0b3BpY1xuICAgICAgICAgICAgcGFnZVNpemU6IDUwMCxcbiAgICAgICAgICAgIC8vIGVuc3VyZSBtZXNzYWdlcyBhcmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgICBkaXJlY3Rpb246IG1lc3NhZ2VBcGkuU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9BU0NFTkRJTkcsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBtZXNzYWdlcyB3aXRoIG5vIHRpbWVzdGFtcFxuICAgICAgICAgICAgLmZpbHRlcigoW3RpbWVzdGFtcE5zXSkgPT4gQm9vbGVhbih0aW1lc3RhbXBOcykpO1xuICAgICAgICAvLyBkZWNvZGUgbWVzc2FnZXMgYW5kIHNhdmUgdGhlbSB0byBrZXlzdG9yZVxuICAgICAgICBhd2FpdCB0aGlzLmRlY29kZU1lc3NhZ2VzKG5ldyBNYXAobWVzc2FnZUVudHJpZXMpKTtcbiAgICAgICAgLy8gZ2V0IGFsbCBhY3Rpb25zIGZyb20ga2V5c3RvcmVcbiAgICAgICAgY29uc3QgYWN0aW9uc01hcCA9IHRoaXMuY2xpZW50LmtleXN0b3JlLmdldFByaXZhdGVQcmVmZXJlbmNlcygpO1xuICAgICAgICAvLyByZXNldCBjb25zZW50IGxpc3RcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBwcm9jZXNzIGFjdGlvbnMgYW5kIHVwZGF0ZSBjb25zZW50IGxpc3RcbiAgICAgICAgdGhpcy5wcm9jZXNzQWN0aW9ucyhhY3Rpb25zTWFwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgICB9XG4gICAgYXN5bmMgcHVibGlzaChlbnRyaWVzKSB7XG4gICAgICAgIC8vIHRoaXMgcmVkdWNlIGlzIHB1cnBvc2VmdWxseSB2ZXJib3NlIGZvciB0eXBlIHNhZmV0eVxuICAgICAgICBjb25zdCBhY3Rpb24gPSBlbnRyaWVzLnJlZHVjZSgocmVzdWx0LCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgbGV0IGFjdGlvbktleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZUtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZXM7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBwZXJtaXNzaW9uIHR5cGVzXG4gICAgICAgICAgICBpZiAoZW50cnkucGVybWlzc2lvblR5cGUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZW50cnkuZW50cnlUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjoge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25LZXkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucGVybWlzc2lvblR5cGUgPT09IFwiYWxsb3dlZFwiID8gXCJhbGxvd0FkZHJlc3NcIiA6IFwiZGVueUFkZHJlc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkgPSBcIndhbGxldEFkZHJlc3Nlc1wiO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZXN1bHRbYWN0aW9uS2V5XT8uW3ZhbHVlS2V5XSA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJncm91cElkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uS2V5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlcm1pc3Npb25UeXBlID09PSBcImFsbG93ZWRcIiA/IFwiYWxsb3dHcm91cFwiIDogXCJkZW55R3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkgPSBcImdyb3VwSWRzXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJlc3VsdFthY3Rpb25LZXldPy5bdmFsdWVLZXldID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImluYm94SWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25LZXkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucGVybWlzc2lvblR5cGUgPT09IFwiYWxsb3dlZFwiID8gXCJhbGxvd0luYm94SWRcIiA6IFwiZGVueUluYm94SWRcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkgPSBcImluYm94SWRzXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJlc3VsdFthY3Rpb25LZXldPy5bdmFsdWVLZXldID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgIFthY3Rpb25LZXldOiB7XG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZUtleV06IFsuLi52YWx1ZXMsIGVudHJ5LnZhbHVlXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXJlZHVjZS10eXBlLXBhcmFtZXRlclxuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIGdldCBlbnZlbG9wZXMgdG8gcHVibGlzaCAodGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lKVxuICAgICAgICBjb25zdCBlbnZlbG9wZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5rZXlzdG9yZS5jcmVhdGVQcml2YXRlUHJlZmVyZW5jZShhY3Rpb24pO1xuICAgICAgICAvLyBwdWJsaXNoIHByaXZhdGUgcHJlZmVyZW5jZXMgdXBkYXRlXG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnB1Ymxpc2hFbnZlbG9wZXMoZW52ZWxvcGVzKTtcbiAgICAgICAgLy8gcGVyc2lzdCBuZXdseSBwdWJsaXNoZWQgcHJpdmF0ZSBwcmVmZXJlbmNlIHRvIGtleXN0b3JlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5jbGllbnQua2V5c3RvcmUuc2F2ZVByaXZhdGVQcmVmZXJlbmNlcyhcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgbmV3IE1hcChbW2VudmVsb3Blc1swXS50aW1lc3RhbXAuZ2V0VGltZSgpLnRvU3RyaW5nKCksIGFjdGlvbl1dKSk7XG4gICAgICAgIC8vIHVwZGF0ZSBsb2NhbCBlbnRyaWVzIGFmdGVyIHB1Ymxpc2hpbmdcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNldChlbnRyeS5rZXksIGVudHJ5LnBlcm1pc3Npb25UeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ29udGFjdHMge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICBfQ29udGFjdHNfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ29udGFjdHNfam9iUnVubmVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBuZXcgQ29uc2VudExpc3QoY2xpZW50KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db250YWN0c19qb2JSdW5uZXIsIG5ldyBKb2JSdW5uZXIoXCJ1c2VyLXByZWZlcmVuY2VzXCIsIGNsaWVudC5rZXlzdG9yZSksIFwiZlwiKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZENvbnNlbnRMaXN0KHN0YXJ0VGltZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfam9iUnVubmVyLCBcImZcIikucnVuKGFzeW5jIChsYXN0UnVuKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGxvdyBmb3Igb3ZlcnJpZGUgb2Ygc3RhcnRUaW1lXG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5sb2FkKHN0YXJ0VGltZSA/PyBsYXN0UnVuKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvbnZlcnNhdGlvbnMubGlzdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkQ29uc2VudFByb29mQWRkcmVzc2VzID0gY29udmVyc2F0aW9ucy5yZWR1Y2UoKHJlc3VsdCwgY29udmVyc2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJzYXRpb24uY29uc2VudFByb29mICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNlbnRTdGF0ZShjb252ZXJzYXRpb24ucGVlckFkZHJlc3MpID09PSBcInVua25vd25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfaW5zdGFuY2VzLCBcIm1cIiwgX0NvbnRhY3RzX3ZhbGlkYXRlQ29uc2VudFNpZ25hdHVyZSkuY2FsbCh0aGlzLCBjb252ZXJzYXRpb24uY29uc2VudFByb29mLCBjb252ZXJzYXRpb24ucGVlckFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjb252ZXJzYXRpb24ucGVlckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXJlZHVjZS10eXBlLXBhcmFtZXRlclxuICAgICAgICAgICAgICAgIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRDb25zZW50UHJvb2ZBZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvbnRhY3RzLmFsbG93KHZhbGlkQ29uc2VudFByb29mQWRkcmVzc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaENvbnNlbnRMaXN0KCkge1xuICAgICAgICAvLyBjbGVhciBleGlzdGluZyBjb25zZW50IGxpc3RcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5yZXNldCgpO1xuICAgICAgICAvLyByZXNldCBsYXN0IHJ1biB0aW1lIHRvIHRoZSBlcG9jaFxuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19qb2JSdW5uZXIsIFwiZlwiKS5yZXNldExhc3RSdW5UaW1lKCk7XG4gICAgICAgIC8vIHJlbG9hZCB0aGUgY29uc2VudCBsaXN0XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRDb25zZW50TGlzdCgpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1Db25zZW50TGlzdChvbkNvbm5lY3Rpb25Mb3N0KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnN0cmVhbShvbkNvbm5lY3Rpb25Mb3N0KTtcbiAgICB9XG4gICAgc2V0Q29uc2VudExpc3RFbnRyaWVzKGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBcImZcIikucmVzZXQoKTtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnBlcm1pc3Npb25UeXBlID09PSBcImFsbG93ZWRcIikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBcImZcIikuYWxsb3coZW50cnkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5LnBlcm1pc3Npb25UeXBlID09PSBcImRlbmllZFwiKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5kZW55KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQWxsb3dlZChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnN0YXRlKGFkZHJlc3MpID09PSBcImFsbG93ZWRcIjtcbiAgICB9XG4gICAgaXNEZW5pZWQoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5zdGF0ZShhZGRyZXNzKSA9PT0gXCJkZW5pZWRcIjtcbiAgICB9XG4gICAgaXNHcm91cEFsbG93ZWQoZ3JvdXBJZCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5ncm91cFN0YXRlKGdyb3VwSWQpID09PSBcImFsbG93ZWRcIjtcbiAgICB9XG4gICAgaXNHcm91cERlbmllZChncm91cElkKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLmdyb3VwU3RhdGUoZ3JvdXBJZCkgPT09IFwiZGVuaWVkXCI7XG4gICAgfVxuICAgIGlzSW5ib3hBbGxvd2VkKGluYm94SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBcImZcIikuaW5ib3hJZFN0YXRlKGluYm94SWQpID09PSBcImFsbG93ZWRcIjtcbiAgICB9XG4gICAgaXNJbmJveERlbmllZChpbmJveElkKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLmluYm94SWRTdGF0ZShpbmJveElkKSA9PT0gXCJkZW5pZWRcIjtcbiAgICB9XG4gICAgY29uc2VudFN0YXRlKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBcImZcIikuc3RhdGUoYWRkcmVzcyk7XG4gICAgfVxuICAgIGdyb3VwQ29uc2VudFN0YXRlKGdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbnRhY3RzX2NvbnNlbnRMaXN0LCBcImZcIikuZ3JvdXBTdGF0ZShncm91cElkKTtcbiAgICB9XG4gICAgaW5ib3hDb25zZW50U3RhdGUoaW5ib3hJZCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5pbmJveElkU3RhdGUoaW5ib3hJZCk7XG4gICAgfVxuICAgIGFzeW5jIGFsbG93KGFkZHJlc3Nlcykge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnB1Ymxpc2goYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gQ29uc2VudExpc3RFbnRyeS5mcm9tQWRkcmVzcyhhZGRyZXNzLCBcImFsbG93ZWRcIikpKTtcbiAgICB9XG4gICAgYXN5bmMgZGVueShhZGRyZXNzZXMpIHtcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5wdWJsaXNoKGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IENvbnNlbnRMaXN0RW50cnkuZnJvbUFkZHJlc3MoYWRkcmVzcywgXCJkZW5pZWRcIikpKTtcbiAgICB9XG4gICAgYXN5bmMgYWxsb3dHcm91cHMoZ3JvdXBJZHMpIHtcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29udGFjdHNfY29uc2VudExpc3QsIFwiZlwiKS5wdWJsaXNoKGdyb3VwSWRzLm1hcCgoZ3JvdXBJZCkgPT4gQ29uc2VudExpc3RFbnRyeS5mcm9tR3JvdXBJZChncm91cElkLCBcImFsbG93ZWRcIikpKTtcbiAgICB9XG4gICAgYXN5bmMgZGVueUdyb3Vwcyhncm91cElkcykge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnB1Ymxpc2goZ3JvdXBJZHMubWFwKChncm91cElkKSA9PiBDb25zZW50TGlzdEVudHJ5LmZyb21Hcm91cElkKGdyb3VwSWQsIFwiZGVuaWVkXCIpKSk7XG4gICAgfVxuICAgIGFzeW5jIGFsbG93SW5ib3hlcyhpbmJveElkcykge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnB1Ymxpc2goaW5ib3hJZHMubWFwKChpbmJveElkKSA9PiBDb25zZW50TGlzdEVudHJ5LmZyb21JbmJveElkKGluYm94SWQsIFwiYWxsb3dlZFwiKSkpO1xuICAgIH1cbiAgICBhc3luYyBkZW55SW5ib3hlcyhpbmJveElkcykge1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db250YWN0c19jb25zZW50TGlzdCwgXCJmXCIpLnB1Ymxpc2goaW5ib3hJZHMubWFwKChpbmJveElkKSA9PiBDb25zZW50TGlzdEVudHJ5LmZyb21JbmJveElkKGluYm94SWQsIFwiZGVuaWVkXCIpKSk7XG4gICAgfVxufVxuX0NvbnRhY3RzX2NvbnNlbnRMaXN0ID0gbmV3IFdlYWtNYXAoKSwgX0NvbnRhY3RzX2pvYlJ1bm5lciA9IG5ldyBXZWFrTWFwKCksIF9Db250YWN0c19pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQ29udGFjdHNfdmFsaWRhdGVDb25zZW50U2lnbmF0dXJlID0gZnVuY3Rpb24gX0NvbnRhY3RzX3ZhbGlkYXRlQ29uc2VudFNpZ25hdHVyZSh7IHNpZ25hdHVyZSwgdGltZXN0YW1wIH0sIHBlZXJBZGRyZXNzKSB7XG4gICAgY29uc3QgdGltZXN0YW1wTXMgPSBOdW1iZXIodGltZXN0YW1wKTtcbiAgICBpZiAoIXNpZ25hdHVyZSB8fCAhdGltZXN0YW1wTXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB0aW1lc3RhbXAgc2hvdWxkIGJlIGluIHRoZSBwYXN0XG4gICAgaWYgKHRpbWVzdGFtcE1zID4gRGF0ZS5ub3coKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHRpbWVzdGFtcCBzaG91bGQgYmUgd2l0aGluIHRoZSBsYXN0IDMwIGRheXNcbiAgICBpZiAodGltZXN0YW1wTXMgPCBEYXRlLm5vdygpIC0gMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlRGF0YSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUNvbnNlbnRNZXNzYWdlKHBlZXJBZGRyZXNzLCB0aW1lc3RhbXBNcyk7XG4gICAgY29uc3QgZGlnZXN0ID0gaGV4VG9CeXRlcyhoYXNoTWVzc2FnZShtZXNzYWdlKSk7XG4gICAgLy8gUmVjb3ZlciBwdWJsaWMga2V5XG4gICAgY29uc3QgcHVibGljS2V5ID0gZWNkc2FTaWduZXJLZXkoZGlnZXN0LCBzaWduYXR1cmVEYXRhKTtcbiAgICByZXR1cm4gcHVibGljS2V5Py5nZXRFdGhlcmV1bUFkZHJlc3MoKSA9PT0gdGhpcy5jbGllbnQuYWRkcmVzcztcbn07XG5cbi8qKlxuICogV2hlcmUgbWVzc2FnZSBiYWNrdXBzIHNob3VsZCBiZSBzdG9yZWRcbiAqL1xudmFyIEJhY2t1cFR5cGU7XG4oZnVuY3Rpb24gKEJhY2t1cFR5cGUpIHtcbiAgICBCYWNrdXBUeXBlW0JhY2t1cFR5cGVbXCJub25lXCJdID0gMF0gPSBcIm5vbmVcIjtcbiAgICBCYWNrdXBUeXBlW0JhY2t1cFR5cGVbXCJ4bXRwVG9waWNTdG9yZVwiXSA9IDFdID0gXCJ4bXRwVG9waWNTdG9yZVwiO1xufSkoQmFja3VwVHlwZSB8fCAoQmFja3VwVHlwZSA9IHt9KSk7XG5cbmNvbnN0IEJBQ0tVUF9UWVBFJDEgPSBCYWNrdXBUeXBlLm5vbmU7XG5jbGFzcyBOb0JhY2t1cENsaWVudCB7XG4gICAgc3RhdGljIGNyZWF0ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBCQUNLVVBfVFlQRSQxLFxuICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFja3VwVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEJBQ0tVUF9UWVBFJDE7XG4gICAgfVxufVxuXG5jb25zdCBCQUNLVVBfVFlQRSA9IEJhY2t1cFR5cGUueG10cFRvcGljU3RvcmU7XG5jbGFzcyBUb3BpY1N0b3JlQmFja3VwQ2xpZW50IHtcbiAgICBzdGF0aWMgY3JlYXRlQ29uZmlndXJhdGlvbih3YWxsZXRBZGRyZXNzKSB7XG4gICAgICAgIC8vIFRPRE86IHJhbmRvbWx5IGdlbmVyYXRlIHRvcGljIGFuZCBlbmNyeXB0aW9uIGtleVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogQkFDS1VQX1RZUEUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgdG9waWM6IFwiaGlzdG9yeS12MDpcIiArIHdhbGxldEFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgZ2V0IGJhY2t1cFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBCQUNLVVBfVFlQRTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhY2t1cCBjbGllbnQgb2YgdGhlIGNvcnJlY3QgcHJvdmlkZXIgdHlwZSAoZS5nLiB4bXRwIGJhY2t1cCwgbm8gYmFja3VwLCBldGMpLlxuICogVXNlcyBhbiBleGlzdGluZyB1c2VyIHByZWZlcmVuY2UgZnJvbSB0aGUgYmFja2VuZCBpZiBpdCBleGlzdHMsIGVsc2UgcHJvbXB0cyBmb3IgYSBuZXdcbiAqIG9uZSB1c2luZyB0aGUgYHByb3ZpZGVyU2VsZWN0b3JgXG4gKiBAcGFyYW0gd2FsbGV0QWRkcmVzcyBUaGUgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHVzZXIncyB3YWxsZXRcbiAqIEBwYXJhbSBzZWxlY3RCYWNrdXBQcm92aWRlciBBIGNhbGxiYWNrIGZvciBkZXRlcm1pbmluZyB0aGUgcHJvdmlkZXIgdG8gdXNlLCBpbiB0aGUgZXZlbnQgdGhlcmUgaXMgbm9cbiAqIGV4aXN0aW5nIHVzZXIgcHJlZmVyZW5jZS4gVGhlIGFwcCBjYW4gZGVmaW5lIHRoZSBwb2xpY3kgdG8gdXNlIGhlcmUgKGUuZy4gcHJvbXB0IHRoZSB1c2VyLFxuICogb3IgZGVmYXVsdCB0byBhIGNlcnRhaW4gcHJvdmlkZXIgdHlwZSkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCYWNrdXBDbGllbnQ+fSBBIGJhY2t1cCBjbGllbnQgb2YgdGhlIGNvcnJlY3QgdHlwZVxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVCYWNrdXBDbGllbnQod2FsbGV0QWRkcmVzcywgc2VsZWN0QmFja3VwUHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gYXdhaXQgZmV0Y2hPckNyZWF0ZUNvbmZpZ3VyYXRpb24od2FsbGV0QWRkcmVzcywgc2VsZWN0QmFja3VwUHJvdmlkZXIpO1xuICAgIHN3aXRjaCAoY29uZmlndXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgQmFja3VwVHlwZS5ub25lOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb0JhY2t1cENsaWVudChjb25maWd1cmF0aW9uKTtcbiAgICAgICAgY2FzZSBCYWNrdXBUeXBlLnhtdHBUb3BpY1N0b3JlOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb3BpY1N0b3JlQmFja3VwQ2xpZW50KGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoT3JDcmVhdGVDb25maWd1cmF0aW9uKHdhbGxldEFkZHJlc3MsIHNlbGVjdEJhY2t1cFByb3ZpZGVyKSB7XG4gICAgLy8gVE9ETzogcmV0dXJuIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgYmFja2VuZCBpZiBpdCBleGlzdHNcbiAgICBsZXQgYmFja3VwQ29uZmlndXJhdGlvbjtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHNlbGVjdEJhY2t1cFByb3ZpZGVyKCk7XG4gICAgc3dpdGNoIChwcm92aWRlci50eXBlKSB7XG4gICAgICAgIGNhc2UgQmFja3VwVHlwZS5ub25lOlxuICAgICAgICAgICAgYmFja3VwQ29uZmlndXJhdGlvbiA9IE5vQmFja3VwQ2xpZW50LmNyZWF0ZUNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJhY2t1cFR5cGUueG10cFRvcGljU3RvcmU6XG4gICAgICAgICAgICBiYWNrdXBDb25maWd1cmF0aW9uID1cbiAgICAgICAgICAgICAgICBUb3BpY1N0b3JlQmFja3VwQ2xpZW50LmNyZWF0ZUNvbmZpZ3VyYXRpb24od2FsbGV0QWRkcmVzcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogUGVyc2lzdCBuZXcgY29uZmlndXJhdGlvbiB0byBiYWNrZW5kXG4gICAgcmV0dXJuIGJhY2t1cENvbmZpZ3VyYXRpb247XG59XG5cbmNvbnN0IHZlcnNpb24gPSBcIjEuMy42XCI7XG5jb25zdCBwYWNrYWdlTmFtZSA9IFwiQHhtdHAvc25hcFwiO1xuXG5jb25zdCB7IENvbXByZXNzaW9uIH0gPSBjb250ZW50O1xuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuLy8gRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgY29udGVudCBzaXplXG5jb25zdCBNYXhDb250ZW50U2l6ZSA9IDEwMCAqIDEwMjQgKiAxMDI0OyAvLyAxMDBNXG4vKipcbiAqIFByb3ZpZGUgYSBkZWZhdWx0IGNsaWVudCBjb25maWd1cmF0aW9uLiBUaGVzZSBzZXR0aW5ncyBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24sIG9yIGFzIGEgc3RhcnRpbmcgcG9pbnQgZm9yIGN1c3RvbSBjb25maWd1cmF0aW9uc1xuICogQHBhcmFtIG9wdHMgYWRkaXRpb25hbCBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKG9wdHMpIHtcbiAgICBjb25zdCBfZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIHByaXZhdGVLZXlPdmVycmlkZTogdW5kZWZpbmVkLFxuICAgICAgICBlbnY6IFwiZGV2XCIsXG4gICAgICAgIGFwaVVybDogdW5kZWZpbmVkLFxuICAgICAgICBjb2RlY3M6IFtuZXcgVGV4dENvZGVjKCldLFxuICAgICAgICBtYXhDb250ZW50U2l6ZTogTWF4Q29udGVudFNpemUsXG4gICAgICAgIHBlcnNpc3RDb252ZXJzYXRpb25zOiB0cnVlLFxuICAgICAgICBza2lwQ29udGFjdFB1Ymxpc2hpbmc6IGZhbHNlLFxuICAgICAgICB1c2VTbmFwczogZmFsc2UsXG4gICAgICAgIGJhc2VQZXJzaXN0ZW5jZTogaXNCcm93c2VyKClcbiAgICAgICAgICAgID8gQnJvd3NlclN0b3JhZ2VQZXJzaXN0ZW5jZS5jcmVhdGUoKVxuICAgICAgICAgICAgOiBJbk1lbW9yeVBlcnNpc3RlbmNlLmNyZWF0ZSgpLFxuICAgICAgICBkaXNhYmxlUGVyc2lzdGVuY2VFbmNyeXB0aW9uOiBmYWxzZSxcbiAgICAgICAga2V5c3RvcmVQcm92aWRlcnM6IGRlZmF1bHRLZXlzdG9yZVByb3ZpZGVycygpLFxuICAgICAgICBhcGlDbGllbnRGYWN0b3J5OiBjcmVhdGVIdHRwQXBpQ2xpZW50RnJvbU9wdGlvbnMsXG4gICAgfTtcbiAgICBpZiAob3B0cz8uY29kZWNzKSB7XG4gICAgICAgIG9wdHMuY29kZWNzID0gX2RlZmF1bHRPcHRpb25zLmNvZGVjcy5jb25jYXQob3B0cy5jb2RlY3MpO1xuICAgIH1cbiAgICBpZiAob3B0cz8udXNlU25hcHMpIHtcbiAgICAgICAgb3B0cy5rZXlzdG9yZVByb3ZpZGVycyA9IFtcbiAgICAgICAgICAgIG5ldyBTbmFwS2V5c3RvcmVQcm92aWRlcihgbnBtOiR7cGFja2FnZU5hbWV9YCwgdmVyc2lvbiksXG4gICAgICAgICAgICAuLi5fZGVmYXVsdE9wdGlvbnMua2V5c3RvcmVQcm92aWRlcnMsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLl9kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9O1xufVxuLyoqXG4gKiBDbGllbnQgY2xhc3MgaW5pdGlhdGVzIGNvbm5lY3Rpb24gdG8gdGhlIFhNVFAgbmV0d29yay5cbiAqIFNob3VsZCBiZSBjcmVhdGVkIHdpdGggYGF3YWl0IENsaWVudC5jcmVhdGUob3B0aW9ucylgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpY0tleUJ1bmRsZSwgYXBpQ2xpZW50LCBiYWNrdXBDbGllbnQsIGtleXN0b3JlKSB7XG4gICAgICAgIHRoaXMua25vd25QdWJsaWNLZXlCdW5kbGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUga2V5cyBhbmQgbGVnYWN5S2V5c1xuICAgICAgICB0aGlzLmtleXN0b3JlID0ga2V5c3RvcmU7XG4gICAgICAgIHRoaXMucHVibGljS2V5QnVuZGxlID0gcHVibGljS2V5QnVuZGxlO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBwdWJsaWNLZXlCdW5kbGUud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgICAgICB0aGlzLl9jb252ZXJzYXRpb25zID0gbmV3IENvbnZlcnNhdGlvbnModGhpcyk7XG4gICAgICAgIHRoaXMuX2NvZGVjcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbWF4Q29udGVudFNpemUgPSBNYXhDb250ZW50U2l6ZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuX2JhY2t1cENsaWVudCA9IGJhY2t1cENsaWVudDtcbiAgICAgICAgdGhpcy5jb250YWN0cyA9IG5ldyBDb250YWN0cyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbnZlcnNhdGlvbnN9XG4gICAgICovXG4gICAgZ2V0IGNvbnZlcnNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJzYXRpb25zO1xuICAgIH1cbiAgICBnZXQgYmFja3VwVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2t1cENsaWVudC5iYWNrdXBUeXBlO1xuICAgIH1cbiAgICBnZXQgc2lnbmVkUHVibGljS2V5QnVuZGxlKCkge1xuICAgICAgICByZXR1cm4gU2lnbmVkUHVibGljS2V5QnVuZGxlLmZyb21MZWdhY3lCdW5kbGUodGhpcy5wdWJsaWNLZXlCdW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHN0YXJ0IGEgY2xpZW50IGFzc29jaWF0ZWQgd2l0aCBnaXZlbiB3YWxsZXQuXG4gICAgICogQHBhcmFtIHdhbGxldCB0aGUgd2FsbGV0IGFzIGEgU2lnbmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG9wdHMgc3BlY2lmeSBob3cgdG8gdG8gY29ubmVjdCB0byB0aGUgbmV0d29ya1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hcmd1bWVudHNcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHdhbGxldCwgb3B0cykge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBnZXRTaWduZXIod2FsbGV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKG9wdHMpO1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSBvcHRpb25zLmFwaUNsaWVudEZhY3Rvcnkob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGtleXN0b3JlID0gYXdhaXQgYm9vdHN0cmFwS2V5c3RvcmUob3B0aW9ucywgYXBpQ2xpZW50LCBzaWduZXIpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlCdW5kbGUgPSBuZXcgUHVibGljS2V5QnVuZGxlKGF3YWl0IGtleXN0b3JlLmdldFB1YmxpY0tleUJ1bmRsZSgpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmxpY0tleUJ1bmRsZS53YWxsZXRTaWduYXR1cmVBZGRyZXNzKCk7XG4gICAgICAgIGFwaUNsaWVudC5zZXRBdXRoZW50aWNhdG9yKG5ldyBLZXlzdG9yZUF1dGhlbnRpY2F0b3Ioa2V5c3RvcmUpKTtcbiAgICAgICAgY29uc3QgYmFja3VwQ2xpZW50ID0gYXdhaXQgQ2xpZW50LnNldHVwQmFja3VwQ2xpZW50KGFkZHJlc3MsIG9wdGlvbnMuZW52KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudChwdWJsaWNLZXlCdW5kbGUsIGFwaUNsaWVudCwgYmFja3VwQ2xpZW50LCBrZXlzdG9yZSk7XG4gICAgICAgIGF3YWl0IGNsaWVudC5pbml0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIFhNVFAgUHJpdmF0ZUtleUJ1bmRsZSBmcm9tIHRoZSBTREsgYXMgYSBgVWludDhBcnJheWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGJ1bmRsZSBjYW4gdGhlbiBiZSBwcm92aWRlZCBhcyBgcHJpdmF0ZUtleU92ZXJyaWRlYCBpbiBhXG4gICAgICogc3Vic2VxdWVudCBjYWxsIHRvIGBDbGllbnQuY3JlYXRlKC4uLilgXG4gICAgICpcbiAgICAgKiBCZSB2ZXJ5IGNhcmVmdWwgd2l0aCB0aGVzZSBrZXlzLCBhcyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgICogaW1wZXJzb25hdGUgYSB1c2VyIG9uIHRoZSBYTVRQIG5ldHdvcmsgYW5kIHJlYWQgdGhlIHVzZXInc1xuICAgICAqIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1wYXJhbWV0ZXJzXG4gICAgc3RhdGljIGFzeW5jIGdldEtleXMod2FsbGV0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IENsaWVudC5jcmVhdGUoZ2V0U2lnbmVyKHdhbGxldCksIG9wdHMpO1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgY2xpZW50LmtleXN0b3JlLmdldFByaXZhdGVLZXlCdW5kbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5QnVuZGxlVjEoa2V5cykuZW5jb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBjYWxsZXIgd2hldGhlciB0aGUgYnJvd3NlciBoYXMgYSBTbmFwcy1jb21wYXRpYmxlIHZlcnNpb24gb2YgTWV0YU1hc2sgaW5zdGFsbGVkXG4gICAgICovXG4gICAgc3RhdGljIGlzU25hcHNSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIGhhc01ldGFtYXNrV2l0aFNuYXBzKCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzZXR1cEJhY2t1cENsaWVudCh3YWxsZXRBZGRyZXNzLCBlbnYpIHtcbiAgICAgICAgLy8gSGFyZC1jb2RlIHRoZSBwcm92aWRlciB0byB1c2UgZm9yIG5vd1xuICAgICAgICBjb25zdCBzZWxlY3RCYWNrdXBQcm92aWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudiA9PT0gXCJsb2NhbFwiID8gQmFja3VwVHlwZS54bXRwVG9waWNTdG9yZSA6IEJhY2t1cFR5cGUubm9uZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlQmFja3VwQ2xpZW50KHdhbGxldEFkZHJlc3MsIHNlbGVjdEJhY2t1cFByb3ZpZGVyKTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMuY29kZWNzLmZvckVhY2goKGNvZGVjKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29kZWMoY29kZWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWF4Q29udGVudFNpemUgPSBvcHRpb25zLm1heENvbnRlbnRTaXplO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcENvbnRhY3RQdWJsaXNoaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZVVzZXJDb250YWN0UHVibGlzaGVkKG9wdGlvbnMucHVibGlzaExlZ2FjeUNvbnRhY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdyYWNlZnVsbHkgc2h1dCBkb3duIHRoZSBjbGllbnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgZW5zdXJlVXNlckNvbnRhY3RQdWJsaXNoZWQobGVnYWN5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYXdhaXQgZ2V0VXNlckNvbnRhY3RGcm9tTmV0d29yayh0aGlzLmFwaUNsaWVudCwgdGhpcy5hZGRyZXNzKTtcbiAgICAgICAgaWYgKGJ1bmRsZSAmJlxuICAgICAgICAgICAgYnVuZGxlIGluc3RhbmNlb2YgU2lnbmVkUHVibGljS2V5QnVuZGxlICYmXG4gICAgICAgICAgICB0aGlzLnNpZ25lZFB1YmxpY0tleUJ1bmRsZS5lcXVhbHMoYnVuZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRFTVBPUkFSWTogcHVibGlzaCBWMSBjb250YWN0IHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBvbmUgaW4gdGhlIHRvcGljXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUtdjcgY2xpZW50cy5cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gcHJlLXY3IGNsaWVudHMgYXJlIGRlcHJlY2F0ZWRcbiAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVXNlckNvbnRhY3QodHJ1ZSk7XG4gICAgICAgIGlmICghbGVnYWN5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hVc2VyQ29udGFjdChsZWdhY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBSSVZBVEU6IHB1Ymxpc2ggdGhlIGtleSBidW5kbGUgaW50byB0aGUgY29udGFjdCB0b3BpY1xuICAgIC8vIGxlZnQgcHVibGljIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgYXN5bmMgcHVibGlzaFVzZXJDb250YWN0KGxlZ2FjeSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGxlZ2FjeSA/IHRoaXMucHVibGljS2V5QnVuZGxlIDogdGhpcy5zaWduZWRQdWJsaWNLZXlCdW5kbGU7XG4gICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEVudmVsb3BlcyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudFRvcGljOiBidWlsZFVzZXJDb250YWN0VG9waWModGhpcy5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVDb250YWN0QnVuZGxlKGJ1bmRsZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIFB1YmxpY0tleUJ1bmRsZSBpZiBvbmUgaXMga25vd24gZm9yIHRoZSBnaXZlbiBhZGRyZXNzIG9yIGZldGNoZXNcbiAgICAgKiBvbmUgZnJvbSB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogVGhpcyB0aHJvd3MgaWYgZWl0aGVyIHRoZSBhZGRyZXNzIGlzIGludmFsaWQgb3IgdGhlIGNvbnRhY3QgaXMgbm90IHB1Ymxpc2hlZC5cbiAgICAgKiBTZWUgYWxzbyBbI2Nhbk1lc3NhZ2VdLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJDb250YWN0KHBlZXJBZGRyZXNzKSB7XG4gICAgICAgIHBlZXJBZGRyZXNzID0gZ2V0QWRkcmVzcyhwZWVyQWRkcmVzcyk7IC8vIEVJUDU1IG5vcm1hbGl6ZSB0aGUgYWRkcmVzcyBjYXNlLlxuICAgICAgICBjb25zdCBleGlzdGluZ0J1bmRsZSA9IHRoaXMua25vd25QdWJsaWNLZXlCdW5kbGVzLmdldChwZWVyQWRkcmVzcyk7XG4gICAgICAgIGlmIChleGlzdGluZ0J1bmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQnVuZGxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0J1bmRsZSA9IGF3YWl0IGdldFVzZXJDb250YWN0RnJvbU5ldHdvcmsodGhpcy5hcGlDbGllbnQsIHBlZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKG5ld0J1bmRsZSkge1xuICAgICAgICAgICAgdGhpcy5rbm93blB1YmxpY0tleUJ1bmRsZXMuc2V0KHBlZXJBZGRyZXNzLCBuZXdCdW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdCdW5kbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElkZW50aWNhbCB0byBnZXRVc2VyQ29udGFjdCBidXQgZm9yIG11bHRpcGxlIHBlZXIgYWRkcmVzc2VzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlckNvbnRhY3RzKHBlZXJBZGRyZXNzZXMpIHtcbiAgICAgICAgLy8gRUlQNTUgbm9ybWFsaXplIGFsbCBwZWVyIGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzc2VzID0gcGVlckFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IGdldEFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICAvLyBUaGUgbG9naWMgaGVyZSBpcyB0cmlja3kgYmVjYXVzZSB3ZSBuZWVkIHRvIGRvIGEgYmF0Y2ggcXVlcnkgZm9yIGFueSB1bmNhY2hlZCBidW5kbGVzLFxuICAgICAgICAvLyB0aGVuIGludGVybGVhdmUgYmFjayBpbnRvIGFuIG9yZGVyZWQgYXJyYXkuIFNvIHdlIGNyZWF0ZSBhIG1hcDxzdHJpbmcsIGtleWJ1bmRsZXx1bmRlZmluZWQ+XG4gICAgICAgIC8vIGFuZCBmaWxsIGl0IHdpdGggY2FjaGVkIHZhbHVlcywgdGhlbiB0YWtlIGFueSB1bmRlZmluZWQgZW50cmllcyBhbmQgZm9ybSBhIEJhdGNoUXVlcnkgZnJvbSB0aG9zZS5cbiAgICAgICAgY29uc3QgYWRkcmVzc1RvQnVuZGxlID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB1bmNhY2hlZEFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygbm9ybWFsaXplZEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdCdW5kbGUgPSB0aGlzLmtub3duUHVibGljS2V5QnVuZGxlcy5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdCdW5kbGUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzVG9CdW5kbGUuc2V0KGFkZHJlc3MsIGV4aXN0aW5nQnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NUb0J1bmRsZS5zZXQoYWRkcmVzcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB1bmNhY2hlZEFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBkbyBhIGdldFVzZXJDb250YWN0c0Zyb21OZXR3b3JrIGNhbGxcbiAgICAgICAgY29uc3QgbmV3QnVuZGxlcyA9IGF3YWl0IGdldFVzZXJDb250YWN0c0Zyb21OZXR3b3JrKHRoaXMuYXBpQ2xpZW50LCB1bmNhY2hlZEFkZHJlc3Nlcyk7XG4gICAgICAgIC8vIE5vdyBtZXJnZSB0aGUgbmV3QnVuZGxlcyBpbnRvIHRoZSBhZGRyZXNzVG9CdW5kbGUgbWFwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3QnVuZGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHVuY2FjaGVkQWRkcmVzc2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3QnVuZGxlc1tpXTtcbiAgICAgICAgICAgIGFkZHJlc3NUb0J1bmRsZS5zZXQoYWRkcmVzcywgYnVuZGxlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBidW5kbGUgaXMgbm90IHVuZGVmaW5lZCwgY2FjaGUgaXRcbiAgICAgICAgICAgIGlmIChidW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtub3duUHVibGljS2V5QnVuZGxlcy5zZXQoYWRkcmVzcywgYnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5IHJldHVybiB0aGUgYnVuZGxlcyBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgaW5wdXQgYWRkcmVzc2VzXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkQWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gYWRkcmVzc1RvQnVuZGxlLmdldChhZGRyZXNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZm9yY2UgZ2V0VXNlckNvbnRhY3QgZmV0Y2ggY29udGFjdCBmcm9tIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGZvcmdldENvbnRhY3QocGVlckFkZHJlc3MpIHtcbiAgICAgICAgcGVlckFkZHJlc3MgPSBnZXRBZGRyZXNzKHBlZXJBZGRyZXNzKTsgLy8gRUlQNTUgbm9ybWFsaXplIHRoZSBhZGRyZXNzIGNhc2UuXG4gICAgICAgIHRoaXMua25vd25QdWJsaWNLZXlCdW5kbGVzLmRlbGV0ZShwZWVyQWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIEBwZWVyQWRkcmVzcyBjYW4gYmUgbWVzc2FnZWQsIHNwZWNpZmljYWxseVxuICAgICAqIGl0IGNoZWNrcyB0aGF0IGEgUHVibGljS2V5QnVuZGxlIGNhbiBiZSBmb3VuZCBmb3IgdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyBjYW5NZXNzYWdlKHBlZXJBZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwZWVyQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0cyA9IGF3YWl0IHRoaXMuZ2V0VXNlckNvbnRhY3RzKHBlZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdHMubWFwKChjb250YWN0KSA9PiAhIWNvbnRhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWxzZSBkbyB0aGUgc2luZ2xlIGFkZHJlc3MgY2FzZVxuICAgICAgICAgICAgY29uc3Qga2V5QnVuZGxlID0gYXdhaXQgdGhpcy5nZXRVc2VyQ29udGFjdChwZWVyQWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4ga2V5QnVuZGxlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgdGhyb3dpbmcsIGEgYmFkIGFkZHJlc3Mgc2hvdWxkIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjYW5NZXNzYWdlKHBlZXJBZGRyZXNzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IG9wdHM/LmFwaVVybCB8fCBBcGlVcmxzW29wdHM/LmVudiB8fCBcImRldlwiXTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gbmV3IEh0dHBBcGlDbGllbnQoYXBpVXJsLCB7XG4gICAgICAgICAgICBhcHBWZXJzaW9uOiBvcHRzPy5hcHBWZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGVlckFkZHJlc3MpKSB7XG4gICAgICAgICAgICBjb25zdCByYXdQZWVyQWRkcmVzc2VzID0gcGVlckFkZHJlc3M7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbm9ybWFsaXplIGVhY2ggb2YgdGhlIHBlZXIgYWRkcmVzc2VzXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkUGVlckFkZHJlc3NlcyA9IHJhd1BlZXJBZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiBnZXRBZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgICAgIC8vIFRoZSBnZXRVc2VyQ29udGFjdHNGcm9tTmV0d29yayB3aWxsIHJldHVybiBmYWxzZSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgICAgICAvLyBvbiBpbnZhbGlkIGVudmVsb3Blc1xuICAgICAgICAgICAgY29uc3QgY29udGFjdHMgPSBhd2FpdCBnZXRVc2VyQ29udGFjdHNGcm9tTmV0d29yayhhcGlDbGllbnQsIG5vcm1hbGl6ZWRQZWVyQWRkcmVzc2VzKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWN0cy5tYXAoKGNvbnRhY3QpID0+ICEhY29udGFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZXJBZGRyZXNzID0gZ2V0QWRkcmVzcyhwZWVyQWRkcmVzcyk7IC8vIEVJUDU1IG5vcm1hbGl6ZSB0aGUgYWRkcmVzcyBjYXNlLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5QnVuZGxlID0gYXdhaXQgZ2V0VXNlckNvbnRhY3RGcm9tTmV0d29yayhhcGlDbGllbnQsIHBlZXJBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGtleUJ1bmRsZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVudmVsb3BlKGVudikge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVudi5tZXNzYWdlO1xuICAgICAgICBpZiAoIWVudi5jb250ZW50VG9waWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29udGVudCB0b3BpY1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIWJ5dGVzIHx8ICFieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwdWJsaXNoIGVtcHR5IG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG1ldGhvZCBmb3IgcHVibGlzaGluZyBlbnZlbG9wZXMgdG8gdGhlIFhNVFAgbmV0d29yayB3aXRoXG4gICAgICogbm8gcHJlLXByb2Nlc3Npbmcgb3IgZW5jcnlwdGlvbiBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseVxuICAgICAqIEBwYXJhbSBlbnZlbG9wZXMgUHVibGlzaFBhcmFtc1tdXG4gICAgICovXG4gICAgYXN5bmMgcHVibGlzaEVudmVsb3BlcyhlbnZlbG9wZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnYgb2YgZW52ZWxvcGVzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlRW52ZWxvcGUoZW52KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5wdWJsaXNoKGVudmVsb3Blcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY29kZWMgdG8gYmUgYXV0b21hdGljYWxseSB1c2VkIGZvciBlbmNvZGluZy9kZWNvZGluZ1xuICAgICAqIG1lc3NhZ2VzIG9mIHRoZSBnaXZlbiBDb250ZW50IFR5cGVcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXJndW1lbnRzXG4gICAgcmVnaXN0ZXJDb2RlYyhjb2RlYykge1xuICAgICAgICBjb25zdCBpZCA9IGNvZGVjLmNvbnRlbnRUeXBlO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtpZC5hdXRob3JpdHlJZH0vJHtpZC50eXBlSWR9YDtcbiAgICAgICAgdGhpcy5fY29kZWNzLnNldChrZXksIGNvZGVjKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBtYXRjaGluZyBjb2RlYyBmb3IgYSBnaXZlbiBgQ29udGVudFR5cGVJZGAgZnJvbSB0aGVcbiAgICAgKiBjbGllbnQncyBjb2RlYyByZWdpc3RyeVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hcmd1bWVudHNcbiAgICBjb2RlY0Zvcihjb250ZW50VHlwZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtjb250ZW50VHlwZS5hdXRob3JpdHlJZH0vJHtjb250ZW50VHlwZS50eXBlSWR9YDtcbiAgICAgICAgY29uc3QgY29kZWMgPSB0aGlzLl9jb2RlY3MuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY29kZWMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLnZlcnNpb25NYWpvciA+IGNvZGVjLmNvbnRlbnRUeXBlLnZlcnNpb25NYWpvcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYXJiaXRyYXJ5IGNvbnRlbnQgaW50byBhIHNlcmlhbGl6ZWQgYEVuY29kZWRDb250ZW50YCBpbnN0YW5jZVxuICAgICAqIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBlbmNvZGVDb250ZW50KGNvbnRlbnQkMSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlIHx8IENvbnRlbnRUeXBlVGV4dDtcbiAgICAgICAgY29uc3QgY29kZWMgPSB0aGlzLmNvZGVjRm9yKGNvbnRlbnRUeXBlKTtcbiAgICAgICAgaWYgKCFjb2RlYykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRlbnQgdHlwZSBcIiArIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkID0gY29kZWMuZW5jb2RlKGNvbnRlbnQkMSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrID0gY29kZWMuZmFsbGJhY2soY29udGVudCQxKTtcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgICBlbmNvZGVkLmZhbGxiYWNrID0gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zPy5jb21wcmVzc2lvbiA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgLy8gZG8gbm90IGNvbXByZXNzIGNvbnRlbnQgbGVzcyB0aGFuIDEwIGJ5dGVzXG4gICAgICAgICAgICBlbmNvZGVkLmNvbnRlbnQubGVuZ3RoID49IDEwKSB7XG4gICAgICAgICAgICBlbmNvZGVkLmNvbXByZXNzaW9uID0gb3B0aW9ucy5jb21wcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjb21wcmVzcyhlbmNvZGVkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGNvbnRlbnQuRW5jb2RlZENvbnRlbnQuZW5jb2RlKGVuY29kZWQpLmZpbmlzaCgpLFxuICAgICAgICAgICAgc2hvdWxkUHVzaDogY29kZWMuc2hvdWxkUHVzaChjb250ZW50JDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBkZWNvZGVDb250ZW50KGNvbnRlbnRCeXRlcykge1xuICAgICAgICBjb25zdCBlbmNvZGVkQ29udGVudCA9IGNvbnRlbnQuRW5jb2RlZENvbnRlbnQuZGVjb2RlKGNvbnRlbnRCeXRlcyk7XG4gICAgICAgIGlmICghZW5jb2RlZENvbnRlbnQudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjb250ZW50IHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQkMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gbmV3IENvbnRlbnRUeXBlSWQoZW5jb2RlZENvbnRlbnQudHlwZSk7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgYXdhaXQgZGVjb21wcmVzcyhlbmNvZGVkQ29udGVudCwgMTAwMCk7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5jb2RlY0Zvcihjb250ZW50VHlwZSk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgY29udGVudCQxID0gY29kZWMuZGVjb2RlKGVuY29kZWRDb250ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRlbnQgdHlwZSBcIiArIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgY29udGVudDogY29udGVudCQxLFxuICAgICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGNvbnRlbnRGYWxsYmFjazogZW5jb2RlZENvbnRlbnQuZmFsbGJhY2ssXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxpc3RJbnZpdGF0aW9ucyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RFbnZlbG9wZXMoYnVpbGRVc2VySW52aXRlVG9waWModGhpcy5hZGRyZXNzKSwgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgICAgICBhc3luYyAoZW52KSA9PiBlbnYsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHN0b3JlZCBtZXNzYWdlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICpcbiAgICAgKiBBIHNwZWNpZmllZCBtYXBwZXIgZnVuY3Rpb24gd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2ggZW52ZWxvcGUuXG4gICAgICogSWYgdGhlIG1hcHBlciBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IgZHVyaW5nIHByb2Nlc3NpbmcsIHRoZVxuICAgICAqIGVudmVsb3BlIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RFbnZlbG9wZXModG9waWMsIG1hcHBlciwgb3B0cykge1xuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2VTaXplIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBlbnZlbG9wZXMgPSBhd2FpdCB0aGlzLmFwaUNsaWVudC5xdWVyeSh7IGNvbnRlbnRUb3BpYzogdG9waWMsIHN0YXJ0VGltZSwgZW5kVGltZSB9LCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IG9wdHMuZGlyZWN0aW9uIHx8IG1lc3NhZ2VBcGkuU29ydERpcmVjdGlvbi5TT1JUX0RJUkVDVElPTl9BU0NFTkRJTkcsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudiBvZiBlbnZlbG9wZXMpIHtcbiAgICAgICAgICAgIGlmICghZW52Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1hcHBlcihlbnYpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBpbiBsaXN0RW52ZWxvcGVzIG1hcHBlclwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBtZXNzYWdlcyBvbiBhIGdpdmVuIHNldCBvZiBjb250ZW50IHRvcGljcywgeWllbGRpbmcgb25lIHBhZ2UgYXQgYSB0aW1lXG4gICAgICovXG4gICAgbGlzdEVudmVsb3Blc1BhZ2luYXRlZChjb250ZW50VG9waWMsIG1hcHBlciwgb3B0cykge1xuICAgICAgICByZXR1cm4gbWFwUGFnaW5hdGVkU3RyZWFtKHRoaXMuYXBpQ2xpZW50LnF1ZXJ5SXRlcmF0ZVBhZ2VzKHtcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpYyxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogb3B0cz8uc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kVGltZTogb3B0cz8uZW5kVGltZSxcbiAgICAgICAgfSwgeyBkaXJlY3Rpb246IG9wdHM/LmRpcmVjdGlvbiwgcGFnZVNpemU6IG9wdHM/LnBhZ2VTaXplIHx8IDEwMCB9KSwgbWFwcGVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVIdHRwQXBpQ2xpZW50RnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGFwaVVybCA9IG9wdGlvbnMuYXBpVXJsIHx8IEFwaVVybHNbb3B0aW9ucy5lbnZdO1xuICAgIHJldHVybiBuZXcgSHR0cEFwaUNsaWVudChhcGlVcmwsIHsgYXBwVmVyc2lvbjogb3B0aW9ucy5hcHBWZXJzaW9uIH0pO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSBhIGtleSBidW5kbGUgZnJvbSBnaXZlbiB1c2VyJ3MgY29udGFjdCB0b3BpY1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyQ29udGFjdEZyb21OZXR3b3JrKGFwaUNsaWVudCwgcGVlckFkZHJlc3MpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBhcGlDbGllbnQucXVlcnlJdGVyYXRvcih7IGNvbnRlbnRUb3BpYzogYnVpbGRVc2VyQ29udGFjdFRvcGljKHBlZXJBZGRyZXNzKSB9LCB7IHBhZ2VTaXplOiA1LCBkaXJlY3Rpb246IFNvcnREaXJlY3Rpb24uU09SVF9ESVJFQ1RJT05fREVTQ0VORElORyB9KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGVudiBvZiBzdHJlYW0pIHtcbiAgICAgICAgaWYgKCFlbnYubWVzc2FnZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBrZXlCdW5kbGUgPSBkZWNvZGVDb250YWN0QnVuZGxlKGVudi5tZXNzYWdlKTtcbiAgICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgYWRkcmVzcyA9IGF3YWl0IGtleUJ1bmRsZT8ud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzPy50b0xvd2VyQ2FzZSgpID09PSBwZWVyQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5QnVuZGxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJldHJpZXZlIGEgbGlzdCBvZiBrZXkgYnVuZGxlcyBnaXZlbiBhIGxpc3Qgb2YgdXNlciBhZGRyZXNzZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckNvbnRhY3RzRnJvbU5ldHdvcmsoYXBpQ2xpZW50LCBwZWVyQWRkcmVzc2VzKSB7XG4gICAgY29uc3QgdXNlckNvbnRhY3RUb3BpY3MgPSBwZWVyQWRkcmVzc2VzLm1hcChidWlsZFVzZXJDb250YWN0VG9waWMpO1xuICAgIGNvbnN0IHRvcGljVG9FbnZlbG9wZXMgPSBhd2FpdCBhcGlDbGllbnQuYmF0Y2hRdWVyeSh1c2VyQ29udGFjdFRvcGljcy5tYXAoKHRvcGljKSA9PiAoe1xuICAgICAgICBjb250ZW50VG9waWM6IHRvcGljLFxuICAgICAgICBwYWdlU2l6ZTogNSxcbiAgICAgICAgZGlyZWN0aW9uOiBTb3J0RGlyZWN0aW9uLlNPUlRfRElSRUNUSU9OX0RFU0NFTkRJTkcsXG4gICAgfSkpKTtcbiAgICAvLyBUcmFuc2Zvcm0gdG9waWNUb0VudmVsb3BlcyBpbnRvIGEgbGlzdCBvZiBQdWJsaWNLZXlCdW5kbGVzIG9yIHVuZGVmaW5lZFxuICAgIC8vIGJ5IGdvaW5nIHRocm91Z2ggZWFjaCBtZXNzYWdlIGFuZCBhdHRlbXB0aW5nIHRvIGRlY29kZVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZWVyQWRkcmVzc2VzLm1hcChhc3luYyAoYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGVzID0gdG9waWNUb0VudmVsb3Blc1tpbmRleF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmICghZW52ZWxvcGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZW52IG9mIGVudmVsb3Blcykge1xuICAgICAgICAgICAgaWYgKCFlbnYubWVzc2FnZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5QnVuZGxlID0gZGVjb2RlQ29udGFjdEJ1bmRsZShlbnYubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzaWduaW5nQWRkcmVzcyA9IGF3YWl0IGtleUJ1bmRsZT8ud2FsbGV0U2lnbmF0dXJlQWRkcmVzcygpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHNpZ25pbmdBZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUJ1bmRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlJlY2VpdmVkIGNvbnRhY3QgYnVuZGxlIHdpdGggaW5jb3JyZWN0IGFkZHJlc3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJJbnZhbGlkIGNvbnRhY3QgYnVuZGxlXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSkpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgbGlzdCBvZiBgS2V5c3RvcmVQcm92aWRlcnNgIHVzZWQgaW4gdGhlIFNES1xuICpcbiAqIFBhcnRpY3VsYXJseSB1c2VmdWwgaWYgYSBkZXZlbG9wZXIgd2FudHMgdG8gYWRkIHRoZWlyIG93blxuICogcHJvdmlkZXIgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3Qgd2hpbGUgZmFsbGluZyBiYWNrIHRvIHRoZVxuICogZGVmYXVsdCBmdW5jdGlvbmFsaXR5XG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRLZXlzdG9yZVByb3ZpZGVycygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgYSBgcHJpdmF0ZUtleU92ZXJyaWRlYCBpcyBwcm92aWRlZCBhbmQgdXNlIHRoYXRcbiAgICAgICAgbmV3IFN0YXRpY0tleXN0b3JlUHJvdmlkZXIoKSxcbiAgICAgICAgLy8gTmV4dCBjaGVjayB0byBzZWUgaWYgYSBFbmNyeXB0ZWRQcml2YXRlS2V5QnVuZGxlIGV4aXN0cyBvbiB0aGUgbmV0d29yayBmb3IgdGhlIHdhbGxldFxuICAgICAgICBuZXcgTmV0d29ya0tleXN0b3JlUHJvdmlkZXIoKSxcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IHR3byBmYWlsZWQgd2l0aCBgS2V5c3RvcmVQcm92aWRlclVuYXZhaWxhYmxlRXJyb3JgLCB0aGVuIGdlbmVyYXRlIGEgbmV3IGtleSBhbmQgd3JpdGUgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICAgICAgbmV3IEtleUdlbmVyYXRvcktleXN0b3JlUHJvdmlkZXIoKSxcbiAgICBdO1xufVxuLyoqXG4gKiBUYWtlIGFuIGFycmF5IG9mIEtleXN0b3JlUHJvdmlkZXJzIGZyb20gdGhlIG9wdGlvbnMgYW5kIHRyeSB0aGVtIHVudGlsIG9uZSBzdWNjZWVkc1xuICovXG5hc3luYyBmdW5jdGlvbiBib290c3RyYXBLZXlzdG9yZShvcHRzLCBhcGlDbGllbnQsIHdhbGxldCkge1xuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2Ygb3B0cy5rZXlzdG9yZVByb3ZpZGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLm5ld0tleXN0b3JlKG9wdHMsIGFwaUNsaWVudCwgd2FsbGV0ID8/IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEtleXN0b3JlUHJvdmlkZXJVbmF2YWlsYWJsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8ga2V5c3RvcmUgcHJvdmlkZXJzIGF2YWlsYWJsZVwiKTtcbn1cblxuZXhwb3J0IHsgQXBpVXJscywgQXV0aENhY2hlLCBCcm93c2VyU3RvcmFnZVBlcnNpc3RlbmNlLCBDaXBoZXJ0ZXh0LCBDbGllbnQsIENvbXByZXNzaW9uLCBDb25zZW50TGlzdEVudHJ5LCBDb252ZXJzYXRpb25WMSwgQ29udmVyc2F0aW9uVjIsIENvbnZlcnNhdGlvbnMsIERlY29kZWRNZXNzYWdlLCBFbmNyeXB0ZWRQZXJzaXN0ZW5jZSwgSHR0cEFwaUNsaWVudCwgSW5NZW1vcnlLZXlzdG9yZSwgSW5NZW1vcnlQZXJzaXN0ZW5jZSwgSW52aXRhdGlvblYxLCBLZXlHZW5lcmF0b3JLZXlzdG9yZVByb3ZpZGVyLCBMb2NhbEF1dGhlbnRpY2F0b3IsIE1lc3NhZ2VWMSwgTWVzc2FnZVYyLCBOZXR3b3JrS2V5c3RvcmVQcm92aWRlciwgUHJlZml4ZWRQZXJzaXN0ZW5jZSwgUHJpdmF0ZUtleSwgUHJpdmF0ZUtleUJ1bmRsZVYxLCBQcml2YXRlS2V5QnVuZGxlVjIsIFB1YmxpY0tleSwgUHVibGljS2V5QnVuZGxlLCBTZWFsZWRJbnZpdGF0aW9uLCBTaWduYXR1cmUsIFNpZ25lZFB1YmxpY0tleSwgU2lnbmVkUHVibGljS2V5QnVuZGxlLCBTbmFwS2V5c3RvcmVQcm92aWRlciBhcyBTbmFwUHJvdmlkZXIsIFNvcnREaXJlY3Rpb24sIFN0YXRpY0tleXN0b3JlUHJvdmlkZXIsIFN0cmVhbSwgYnVpbGRDb250ZW50VG9waWMsIGJ1aWxkRGlyZWN0TWVzc2FnZVRvcGljLCBidWlsZERpcmVjdE1lc3NhZ2VUb3BpY1YyLCBidWlsZFVzZXJDb250YWN0VG9waWMsIGJ1aWxkVXNlckludHJvVG9waWMsIGJ1aWxkVXNlckludml0ZVRvcGljLCBidWlsZFVzZXJQcml2YXRlU3RvcmVUb3BpYywgZGF0ZVRvTnMsIGRlY29kZUNvbnRhY3RCdW5kbGUsIGRlY29kZUNvbnRlbnQsIGRlY3J5cHQkMSBhcyBkZWNyeXB0LCBkZWZhdWx0S2V5c3RvcmVQcm92aWRlcnMsIGVuY3J5cHQkMSBhcyBlbmNyeXB0LCBleHBvcnRIbWFjS2V5LCBmcm9tTmFub1N0cmluZywgZ2VuZXJhdGVIbWFjU2lnbmF0dXJlLCBoa2RmSG1hY0tleSwgaW1wb3J0SG1hY0tleSwgYXBpRGVmcyBhcyBrZXlzdG9yZUFwaURlZnMsIG1hcFBhZ2luYXRlZFN0cmVhbSwgbnNUb0RhdGUsIHJldHJ5LCBzbmFwQXBpRGVmcyBhcyBzbmFwS2V5c3RvcmVBcGlEZWZzLCB0b05hbm9TdHJpbmcsIHZlcmlmeUhtYWNTaWduYXR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/N2U2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/M2IxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/OTUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNERBQTREO0FBQzVELDRC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O0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz80NjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzk5YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztB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bmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2MxMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/secp256k1.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/secp256k1.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzPzRiNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcz8xZDhkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_sha2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_sha2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/MGVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_u64.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_u64.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/MDM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz80NzlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVTtBQUNsQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEIsUUFBUSxpREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/ZWE1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/MjMwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha3.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha3.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDSztBQUM0QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhDQUFLO0FBQ3hEO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsaURBQUs7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQWU7QUFDckQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUCxrREFBa0QscUVBQTBCLFdBQVc7QUFDaEY7QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz9jNjFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzPzU5YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/async-mutex/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/async-mutex/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E_ALREADY_LOCKED: () => (/* binding */ E_ALREADY_LOCKED),\n/* harmony export */   E_CANCELED: () => (/* binding */ E_CANCELED),\n/* harmony export */   E_TIMEOUT: () => (/* binding */ E_TIMEOUT),\n/* harmony export */   Mutex: () => (/* binding */ Mutex),\n/* harmony export */   Semaphore: () => (/* binding */ Semaphore),\n/* harmony export */   tryAcquire: () => (/* binding */ tryAcquire),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nconst E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE1BQWdDO0FBQ25ELDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxtQkFBbUI7QUFDckYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsTUFBZ0M7QUFDbkQsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsTUFBZ0M7QUFDakQsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvaW5kZXgubWpzP2NjOTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRV9USU1FT1VUID0gbmV3IEVycm9yKCd0aW1lb3V0IHdoaWxlIHdhaXRpbmcgZm9yIG11dGV4IHRvIGJlY29tZSBhdmFpbGFibGUnKTtcbmNvbnN0IEVfQUxSRUFEWV9MT0NLRUQgPSBuZXcgRXJyb3IoJ211dGV4IGFscmVhZHkgbG9ja2VkJyk7XG5jb25zdCBFX0NBTkNFTEVEID0gbmV3IEVycm9yKCdyZXF1ZXN0IGZvciBsb2NrIGNhbmNlbGVkJyk7XG5cbnZhciBfX2F3YWl0ZXIkMiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9jYW5jZWxFcnJvciA9IEVfQ0FOQ0VMRUQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIHRoaXMuX2NhbmNlbEVycm9yID0gX2NhbmNlbEVycm9yO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnMgPSBbXTtcbiAgICB9XG4gICAgYWNxdWlyZSh3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB7IHJlc29sdmUsIHJlamVjdCwgd2VpZ2h0LCBwcmlvcml0eSB9O1xuICAgICAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleEZyb21FbmQodGhpcy5fcXVldWUsIChvdGhlcikgPT4gcHJpb3JpdHkgPD0gb3RoZXIucHJpb3JpdHkpO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xICYmIHdlaWdodCA8PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWRzIGltbWVkaWF0ZSBkaXNwYXRjaCwgc2tpcCB0aGUgcXVldWVcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEl0ZW0odGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrXzEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGNhbGxiYWNrLCB3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgcmVsZWFzZV0gPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICBpZiAodGhpcy5fY291bGRMb2NrSW1tZWRpYXRlbHkod2VpZ2h0LCBwcmlvcml0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpbnNlcnRTb3J0ZWQodGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdLCB7IHJlc29sdmUsIHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA8PSAwO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfVxuICAgIHJlbGVhc2Uod2VpZ2h0ID0gMSkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICB0aGlzLl92YWx1ZSArPSB3ZWlnaHQ7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKChlbnRyeSkgPT4gZW50cnkucmVqZWN0KHRoaXMuX2NhbmNlbEVycm9yKSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgfVxuICAgIF9kaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgICB0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5fcXVldWVbMF0ud2VpZ2h0IDw9IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEl0ZW0odGhpcy5fcXVldWUuc2hpZnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGlzcGF0Y2hJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZSAtPSBpdGVtLndlaWdodDtcbiAgICAgICAgaXRlbS5yZXNvbHZlKFtwcmV2aW91c1ZhbHVlLCB0aGlzLl9uZXdSZWxlYXNlcihpdGVtLndlaWdodCldKTtcbiAgICB9XG4gICAgX25ld1JlbGVhc2VyKHdlaWdodCkge1xuICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2Uod2VpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2RyYWluVW5sb2NrV2FpdGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgd2VpZ2h0ID0gdGhpcy5fdmFsdWU7IHdlaWdodCA+IDA7IHdlaWdodC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGVycyA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXdhaXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHdhaXRlcnMuZm9yRWFjaCgod2FpdGVyKSA9PiB3YWl0ZXIucmVzb2x2ZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlZFByaW9yaXR5ID0gdGhpcy5fcXVldWVbMF0ucHJpb3JpdHk7XG4gICAgICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHdhaXRlcnMuZmluZEluZGV4KCh3YWl0ZXIpID0+IHdhaXRlci5wcmlvcml0eSA8PSBxdWV1ZWRQcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgKGkgPT09IC0xID8gd2FpdGVycyA6IHdhaXRlcnMuc3BsaWNlKDAsIGkpKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgod2FpdGVyID0+IHdhaXRlci5yZXNvbHZlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY291bGRMb2NrSW1tZWRpYXRlbHkod2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eSA8IHByaW9yaXR5KSAmJlxuICAgICAgICAgICAgd2VpZ2h0IDw9IHRoaXMuX3ZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydFNvcnRlZChhLCB2KSB7XG4gICAgY29uc3QgaSA9IGZpbmRJbmRleEZyb21FbmQoYSwgKG90aGVyKSA9PiB2LnByaW9yaXR5IDw9IG90aGVyLnByaW9yaXR5KTtcbiAgICBhLnNwbGljZShpICsgMSwgMCwgdik7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXhGcm9tRW5kKGEsIHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxudmFyIF9fYXdhaXRlciQxID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBNdXRleCB7XG4gICAgY29uc3RydWN0b3IoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc2VtYXBob3JlID0gbmV3IFNlbWFwaG9yZSgxLCBjYW5jZWxFcnJvcik7XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChwcmlvcml0eSA9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHJlbGVhc2VyXSA9IHlpZWxkIHRoaXMuX3NlbWFwaG9yZS5hY3F1aXJlKDEsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUucnVuRXhjbHVzaXZlKCgpID0+IGNhbGxiYWNrKCksIDEsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jayhwcmlvcml0eSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS53YWl0Rm9yVW5sb2NrKDEsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpKVxuICAgICAgICAgICAgdGhpcy5fc2VtYXBob3JlLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gd2l0aFRpbWVvdXQoc3luYywgdGltZW91dCwgdGltZW91dEVycm9yID0gRV9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNxdWlyZTogKHdlaWdodE9yUHJpb3JpdHksIHByaW9yaXR5KSA9PiB7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKGlzU2VtYXBob3JlKHN5bmMpKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIChpc1NlbWFwaG9yZShzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzeW5jLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3luYy5hY3F1aXJlKHByaW9yaXR5KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBBcnJheS5pc0FycmF5KHRpY2tldCkgPyB0aWNrZXRbMV0gOiB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGlja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaywgd2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRpY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodGlja2V0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlKHdlaWdodCkge1xuICAgICAgICAgICAgc3luYy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICB3YWl0Rm9yVW5sb2NrOiAod2VpZ2h0T3JQcmlvcml0eSwgcHJpb3JpdHkpID0+IHtcbiAgICAgICAgICAgIGxldCB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaXNTZW1hcGhvcmUoc3luYykpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB3ZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KHRpbWVvdXRFcnJvciksIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIChpc1NlbWFwaG9yZShzeW5jKVxuICAgICAgICAgICAgICAgICAgICA/IHN5bmMud2FpdEZvclVubG9jayh3ZWlnaHQsIHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICA6IHN5bmMud2FpdEZvclVubG9jayhwcmlvcml0eSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTG9ja2VkOiAoKSA9PiBzeW5jLmlzTG9ja2VkKCksXG4gICAgICAgIGdldFZhbHVlOiAoKSA9PiBzeW5jLmdldFZhbHVlKCksXG4gICAgICAgIHNldFZhbHVlOiAodmFsdWUpID0+IHN5bmMuc2V0VmFsdWUodmFsdWUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpc1NlbWFwaG9yZShzeW5jKSB7XG4gICAgcmV0dXJuIHN5bmMuZ2V0VmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saXNuZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB0cnlBY3F1aXJlKHN5bmMsIGFscmVhZHlBY3F1aXJlZEVycm9yID0gRV9BTFJFQURZX0xPQ0tFRCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIHdpdGhUaW1lb3V0KHN5bmMsIDAsIGFscmVhZHlBY3F1aXJlZEVycm9yKTtcbn1cblxuZXhwb3J0IHsgRV9BTFJFQURZX0xPQ0tFRCwgRV9DQU5DRUxFRCwgRV9USU1FT1VULCBNdXRleCwgU2VtYXBob3JlLCB0cnlBY3F1aXJlLCB3aXRoVGltZW91dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/async-mutex/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   publicKeyToAddress: () => (/* binding */ publicKeyToAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_address_getAddress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/address/getAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var _utils_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/hash/keccak256.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js\");\n\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nfunction publicKeyToAddress(publicKey) {\n    const address = (0,_utils_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)(`0x${publicKey.substring(4)}`).substring(26);\n    return (0,_utils_address_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.checksumAddress)(`0x${address}`);\n}\n//# sourceMappingURL=publicKeyToAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjY291bnRzL3V0aWxzL3B1YmxpY0tleVRvQWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDVjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLG1FQUFTLE1BQU0sdUJBQXVCO0FBQzFELFdBQVcsNkVBQWUsTUFBTSxRQUFRO0FBQ3hDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWNjb3VudHMvdXRpbHMvcHVibGljS2V5VG9BZGRyZXNzLmpzP2ViNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2hlY2tzdW1BZGRyZXNzLCB9IGZyb20gJy4uLy4uL3V0aWxzL2FkZHJlc3MvZ2V0QWRkcmVzcy5qcyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIH0gZnJvbSAnLi4vLi4vdXRpbHMvaGFzaC9rZWNjYWsyNTYuanMnO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgYW4gRUNEU0EgcHVibGljIGtleSB0byBhbiBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1YmxpY0tleVRvQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBhZGRyZXNzID0ga2VjY2FrMjU2KGAweCR7cHVibGljS2V5LnN1YnN0cmluZyg0KX1gKS5zdWJzdHJpbmcoMjYpO1xuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3MoYDB4JHthZGRyZXNzfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljS2V5VG9BZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/constants/strings.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/constants/strings.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presignMessagePrefix: () => (/* binding */ presignMessagePrefix)\n/* harmony export */ });\nconst presignMessagePrefix = '\\x19Ethereum Signed Message:\\n';\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9zdHJpbmdzLmpzPzQ0NDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHByZXNpZ25NZXNzYWdlUHJlZml4ID0gJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/constants/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/address.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/address.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js\");\n\nclass InvalidAddressError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ address }) {\n        super(`Address \"${address}\" is invalid.`, {\n            metaMessages: [\n                '- Address must be a hex value of 20 bytes (40 hex characters).',\n                '- Address must match its checksum counterpart.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAddressError'\n        });\n    }\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDO0FBQy9CLGtDQUFrQywrQ0FBUztBQUNsRCxrQkFBa0IsU0FBUztBQUMzQiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYWRkcmVzcy5qcz9iMjE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzIH0pIHtcbiAgICAgICAgc3VwZXIoYEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnLSBBZGRyZXNzIG11c3QgYmUgYSBoZXggdmFsdWUgb2YgMjAgYnl0ZXMgKDQwIGhleCBjaGFyYWN0ZXJzKS4nLFxuICAgICAgICAgICAgICAgICctIEFkZHJlc3MgbXVzdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZEFkZHJlc3NFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/utils.js\");\n\nclass BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        super();\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ViemError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()\n        });\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: https://viem.sh${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ2pDO0FBQ1AsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFVO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVMsRUFBRSxvQkFBb0IsY0FBYyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQyx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9iYXNlLmpzPzM5NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIGFyZ3MgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFNZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1ZpZW1FcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldFZlcnNpb24oKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gYXJncy5jYXVzZS5kZXRhaWxzXG4gICAgICAgICAgICA6IGFyZ3MuY2F1c2U/Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IGFyZ3MuY2F1c2UubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogYXJncy5kZXRhaWxzO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gYXJncy5jYXVzZS5kb2NzUGF0aCB8fCBhcmdzLmRvY3NQYXRoXG4gICAgICAgICAgICA6IGFyZ3MuZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uKGFyZ3MubWV0YU1lc3NhZ2VzID8gWy4uLmFyZ3MubWV0YU1lc3NhZ2VzLCAnJ10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZG9jc1BhdGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgYERvY3M6IGh0dHBzOi8vdmllbS5zaCR7ZG9jc1BhdGh9JHthcmdzLmRvY3NTbHVnID8gYCMke2FyZ3MuZG9jc1NsdWd9YCA6ICcnfWAsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgPyBbYERldGFpbHM6ICR7ZGV0YWlsc31gXSA6IFtdKSxcbiAgICAgICAgICAgIGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBpZiAoYXJncy5jYXVzZSlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBhcmdzLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWV0YU1lc3NhZ2VzID0gYXJncy5tZXRhTWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiB3YWxrKHRoaXMsIGZuKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3YWxrKGVyciwgZm4pIHtcbiAgICBpZiAoZm4/LihlcnIpKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgJ2NhdXNlJyBpbiBlcnIpXG4gICAgICAgIHJldHVybiB3YWxrKGVyci5jYXVzZSwgZm4pO1xuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/data.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/data.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesLengthError: () => (/* binding */ InvalidBytesLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js\");\n\nclass SliceOffsetOutOfBoundsError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \"${offset}\" is out-of-bounds (size: ${size}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nclass SizeExceedsPaddingSizeError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeExceedsPaddingSizeError'\n        });\n    }\n}\nclass InvalidBytesLengthError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesLengthError'\n        });\n    }\n}\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0M7QUFDL0IsMENBQTBDLCtDQUFTO0FBQzFELGtCQUFrQix5QkFBeUI7QUFDM0MsdUJBQXVCLDhDQUE4QyxhQUFhLE9BQU8sNEJBQTRCLEtBQUs7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sMENBQTBDLCtDQUFTO0FBQzFELGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFFBQVEsS0FBSywwQkFBMEIsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTyxzQ0FBc0MsK0NBQVM7QUFDdEQsa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsb0JBQW9CLFlBQVksRUFBRSxNQUFNLGVBQWUsTUFBTSxFQUFFLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2RhdGEuanM/ZTUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlRXJyb3IgfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXCIke29mZnNldH1cIiBpcyBvdXQtb2YtYm91bmRzIChzaXplOiAke3NpemV9KS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplICgke3NpemV9KSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoJHt0YXJnZXRTaXplfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNMZW5ndGhFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBpcyBleHBlY3RlZCB0byBiZSAke3RhcmdldFNpemV9ICR7dHlwZX0gbG9uZywgYnV0IGlzICR7c2l6ZX0gJHt0eXBlfSBsb25nLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSW52YWxpZEJ5dGVzTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/encoding.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/encoding.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js\");\n\nclass IntegerOutOfRangeError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \"${value}\" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'IntegerOutOfRangeError'\n        });\n    }\n}\nclass InvalidBytesBooleanError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesBooleanError'\n        });\n    }\n}\nclass InvalidHexBooleanError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor(hex) {\n        super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexBooleanError'\n        });\n    }\n}\nclass InvalidHexValueError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor(value) {\n        super(`Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexValueError'\n        });\n    }\n}\nclass SizeOverflowError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeOverflowError'\n        });\n    }\n}\n//# sourceMappingURL=encoding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDL0IscUNBQXFDLCtDQUFTO0FBQ3JELGtCQUFrQixnQ0FBZ0M7QUFDbEQseUJBQXlCLE1BQU0sbUJBQW1CLFVBQVUsU0FBUyxPQUFPLGdDQUFnQyxPQUFPLGdCQUFnQixVQUFVLEtBQUssS0FBSyxJQUFJLGVBQWUsSUFBSSxHQUFHO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLHVDQUF1QywrQ0FBUztBQUN2RDtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLHFDQUFxQywrQ0FBUztBQUNyRDtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLG1DQUFtQywrQ0FBUztBQUNuRDtBQUNBLDRCQUE0QixNQUFNLHNCQUFzQixhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPLGdDQUFnQywrQ0FBUztBQUNoRCxrQkFBa0Isb0JBQW9CO0FBQ3RDLG9DQUFvQyxTQUFTLHFCQUFxQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9lbmNvZGluZy5qcz82ZTQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY2xhc3MgSW50ZWdlck91dE9mUmFuZ2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgTnVtYmVyIFwiJHt2YWx1ZX1cIiBpcyBub3QgaW4gc2FmZSAke3NpemUgPyBgJHtzaXplICogOH0tYml0ICR7c2lnbmVkID8gJ3NpZ25lZCcgOiAndW5zaWduZWQnfSBgIDogJyd9aW50ZWdlciByYW5nZSAke21heCA/IGAoJHttaW59IHRvICR7bWF4fSlgIDogYChhYm92ZSAke21pbn0pYH1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcIiR7Ynl0ZXN9XCIgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi4gVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIDAgb3IgMSB2YWx1ZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhCb29sZWFuRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhleCkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFwiJHtoZXh9XCIgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi4gVGhlIGhleCB2YWx1ZSBtdXN0IGJlIFwiMHgwXCIgKGZhbHNlKSBvciBcIjB4MVwiICh0cnVlKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRIZXhCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VmFsdWVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcIiR7dmFsdWV9XCIgaXMgYW4gb2RkIGxlbmd0aCAoJHt2YWx1ZS5sZW5ndGh9KS4gSXQgbXVzdCBiZSBhbiBldmVuIGxlbmd0aC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0ludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgY2Fubm90IGV4Y2VlZCAke21heFNpemV9IGJ5dGVzLiBHaXZlbiBzaXplOiAke2dpdmVuU2l6ZX0gYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContractAddress: () => (/* binding */ getContractAddress),\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/version.js\");\n\nconst getContractAddress = (address) => address;\nconst getUrl = (url) => url;\nconst getVersion = () => `viem@${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQU8sQ0FBQztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvdXRpbHMuanM/YmVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdEFkZHJlc3MgPSAoYWRkcmVzcykgPT4gYWRkcmVzcztcbmV4cG9ydCBjb25zdCBnZXRVcmwgPSAodXJsKSA9PiB1cmw7XG5leHBvcnQgY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IGB2aWVtQCR7dmVyc2lvbn1gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/version.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/version.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '2.7.15';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy92ZXJzaW9uLmpzPzE4OTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43LjE1Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksumAddress: () => (/* binding */ checksumAddress),\n/* harmony export */   getAddress: () => (/* binding */ getAddress)\n/* harmony export */ });\n/* harmony import */ var _errors_address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/address.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/address.js\");\n/* harmony import */ var _encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../encoding/toBytes.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var _hash_keccak256_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hash/keccak256.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var _isAddress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddress.js\");\n\n\n\n\nfunction checksumAddress(address_, chainId) {\n    const hexAddress = chainId\n        ? `${chainId}${address_.toLowerCase()}`\n        : address_.substring(2).toLowerCase();\n    const hash = (0,_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_1__.stringToBytes)(hexAddress), 'bytes');\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n            address[i] = address[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n            address[i + 1] = address[i + 1].toUpperCase();\n        }\n    }\n    return `0x${address.join('')}`;\n}\nfunction getAddress(address, chainId) {\n    if (!(0,_isAddress_js__WEBPACK_IMPORTED_MODULE_2__.isAddress)(address))\n        throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_3__.InvalidAddressError({ address });\n    return checksumAddress(address, chainId);\n}\n//# sourceMappingURL=getAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvZ2V0QWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEQ7QUFDTjtBQUNQO0FBQ047QUFDcEM7QUFDUDtBQUNBLGFBQWEsUUFBUSxFQUFFLHVCQUF1QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBUyxDQUFDLG1FQUFhO0FBQ3hDLHVEQUF1RCxRQUFRO0FBQy9ELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNPO0FBQ1AsU0FBUyx3REFBUztBQUNsQixrQkFBa0IsbUVBQW1CLEdBQUcsU0FBUztBQUNqRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWRkcmVzcy9nZXRBZGRyZXNzLmpzPzJhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9hZGRyZXNzLmpzJztcbmltcG9ydCB7IHN0cmluZ1RvQnl0ZXMsIH0gZnJvbSAnLi4vZW5jb2RpbmcvdG9CeXRlcy5qcyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tICcuLi9oYXNoL2tlY2NhazI1Ni5qcyc7XG5pbXBvcnQgeyBpc0FkZHJlc3MgfSBmcm9tICcuL2lzQWRkcmVzcy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tzdW1BZGRyZXNzKGFkZHJlc3NfLCBjaGFpbklkKSB7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGNoYWluSWRcbiAgICAgICAgPyBgJHtjaGFpbklkfSR7YWRkcmVzc18udG9Mb3dlckNhc2UoKX1gXG4gICAgICAgIDogYWRkcmVzc18uc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IGtlY2NhazI1NihzdHJpbmdUb0J5dGVzKGhleEFkZHJlc3MpLCAnYnl0ZXMnKTtcbiAgICBjb25zdCBhZGRyZXNzID0gKGNoYWluSWQgPyBoZXhBZGRyZXNzLnN1YnN0cmluZyhgJHtjaGFpbklkfTB4YC5sZW5ndGgpIDogaGV4QWRkcmVzcykuc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBhZGRyZXNzW2ldKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ldID0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBhZGRyZXNzW2kgKyAxXSkge1xuICAgICAgICAgICAgYWRkcmVzc1tpICsgMV0gPSBhZGRyZXNzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgMHgke2FkZHJlc3Muam9pbignJyl9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MsIGNoYWluSWQpIHtcbiAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzIH0pO1xuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3MoYWRkcmVzcywgY2hhaW5JZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRBZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddress.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddress.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress)\n/* harmony export */ });\n/* harmony import */ var _lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lru.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/lru.js\");\n/* harmony import */ var _getAddress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js\");\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\nconst isAddressCache = /*#__PURE__*/ new _lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192);\nfunction isAddress(address, { strict = true } = {}) {\n    if (isAddressCache.has(address))\n        return isAddressCache.get(address);\n    const result = (() => {\n        if (!addressRegex.test(address))\n            return false;\n        if (address.toLowerCase() === address)\n            return true;\n        if (strict)\n            return (0,_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.checksumAddress)(address) === address;\n        return true;\n    })();\n    isAddressCache.set(address, result);\n    return result;\n}\n//# sourceMappingURL=isAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvaXNBZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNlO0FBQ2xELHFDQUFxQyxHQUFHO0FBQ3hDLHlDQUF5QywyQ0FBTTtBQUN4Qyw4QkFBOEIsZ0JBQWdCLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZTtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hZGRyZXNzL2lzQWRkcmVzcy5qcz9kMDc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExydU1hcCB9IGZyb20gJy4uL2xydS5qcyc7XG5pbXBvcnQgeyBjaGVja3N1bUFkZHJlc3MgfSBmcm9tICcuL2dldEFkZHJlc3MuanMnO1xuY29uc3QgYWRkcmVzc1JlZ2V4ID0gL14weFthLWZBLUYwLTldezQwfSQvO1xuY29uc3QgaXNBZGRyZXNzQ2FjaGUgPSAvKiNfX1BVUkVfXyovIG5ldyBMcnVNYXAoODE5Mik7XG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MsIHsgc3RyaWN0ID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAoaXNBZGRyZXNzQ2FjaGUuaGFzKGFkZHJlc3MpKVxuICAgICAgICByZXR1cm4gaXNBZGRyZXNzQ2FjaGUuZ2V0KGFkZHJlc3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9ICgoKSA9PiB7XG4gICAgICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QoYWRkcmVzcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmljdClcbiAgICAgICAgICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKCk7XG4gICAgaXNBZGRyZXNzQ2FjaGUuc2V0KGFkZHJlc3MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddressEqual.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddressEqual.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddressEqual: () => (/* binding */ isAddressEqual)\n/* harmony export */ });\n/* harmony import */ var _errors_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/address.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/address.js\");\n/* harmony import */ var _isAddress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddress.js\");\n\n\nfunction isAddressEqual(a, b) {\n    if (!(0,_isAddress_js__WEBPACK_IMPORTED_MODULE_0__.isAddress)(a, { strict: false }))\n        throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError({ address: a });\n    if (!(0,_isAddress_js__WEBPACK_IMPORTED_MODULE_0__.isAddress)(b, { strict: false }))\n        throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvaXNBZGRyZXNzRXF1YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStEO0FBQ3BCO0FBQ3BDO0FBQ1AsU0FBUyx3REFBUyxNQUFNLGVBQWU7QUFDdkMsa0JBQWtCLG1FQUFtQixHQUFHLFlBQVk7QUFDcEQsU0FBUyx3REFBUyxNQUFNLGVBQWU7QUFDdkMsa0JBQWtCLG1FQUFtQixHQUFHLFlBQVk7QUFDcEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvaXNBZGRyZXNzRXF1YWwuanM/MWM5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkQWRkcmVzc0Vycm9yLCB9IGZyb20gJy4uLy4uL2Vycm9ycy9hZGRyZXNzLmpzJztcbmltcG9ydCB7IGlzQWRkcmVzcyB9IGZyb20gJy4vaXNBZGRyZXNzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NFcXVhbChhLCBiKSB7XG4gICAgaWYgKCFpc0FkZHJlc3MoYSwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3M6IGEgfSk7XG4gICAgaWYgKCFpc0FkZHJlc3MoYiwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3M6IGIgfSk7XG4gICAgcmV0dXJuIGEudG9Mb3dlckNhc2UoKSA9PT0gYi50b0xvd2VyQ2FzZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBZGRyZXNzRXF1YWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddressEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/concat.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/concat.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   concatHex: () => (/* binding */ concatHex)\n/* harmony export */ });\nfunction concat(values) {\n    if (typeof values[0] === 'string')\n        return concatHex(values);\n    return concatBytes(values);\n}\nfunction concatBytes(values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const arr of values) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n    return result;\n}\nfunction concatHex(values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n//# sourceMappingURL=concat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvY29uY2F0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvY29uY2F0LmpzPzc3NTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCh2YWx1ZXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlc1swXSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBjb25jYXRIZXgodmFsdWVzKTtcbiAgICByZXR1cm4gY29uY2F0Qnl0ZXModmFsdWVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyh2YWx1ZXMpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGFyciBvZiB2YWx1ZXMpIHtcbiAgICAgICAgbGVuZ3RoICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBhcnIgb2YgdmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRIZXgodmFsdWVzKSB7XG4gICAgcmV0dXJuIGAweCR7dmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4LnJlcGxhY2UoJzB4JywgJycpLCAnJyl9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/concat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isHex: () => (/* binding */ isHex)\n/* harmony export */ });\nfunction isHex(value, { strict = true } = {}) {\n    if (!value)\n        return false;\n    if (typeof value !== 'string')\n        return false;\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');\n}\n//# sourceMappingURL=isHex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNIZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLHdCQUF3QixnQkFBZ0IsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL2lzSGV4LmpzPzYzMWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzSGV4KHZhbHVlLCB7IHN0cmljdCA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmljdCA/IC9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSA6IHZhbHVlLnN0YXJ0c1dpdGgoJzB4Jyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0hleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/pad.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/pad.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padHex: () => (/* binding */ padHex)\n/* harmony export */ });\n/* harmony import */ var _errors_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors/data.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/data.js\");\n\nfunction pad(hexOrBytes, { dir, size = 32 } = {}) {\n    if (typeof hexOrBytes === 'string')\n        return padHex(hexOrBytes, { dir, size });\n    return padBytes(hexOrBytes, { dir, size });\n}\nfunction padHex(hex_, { dir, size = 32 } = {}) {\n    if (size === null)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _errors_data_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nfunction padBytes(bytes, { dir, size = 32 } = {}) {\n    if (size === null)\n        return bytes;\n    if (bytes.length > size)\n        throw new _errors_data_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n//# sourceMappingURL=pad.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvcGFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0U7QUFDN0QsMkJBQTJCLGlCQUFpQixJQUFJO0FBQ3ZEO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0Msa0NBQWtDLFdBQVc7QUFDN0M7QUFDTyx3QkFBd0IsaUJBQWlCLElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0VBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ08sMkJBQTJCLGlCQUFpQixJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3RUFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9wYWQuanM/YTIwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IsIH0gZnJvbSAnLi4vLi4vZXJyb3JzL2RhdGEuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChoZXhPckJ5dGVzLCB7IGRpciwgc2l6ZSA9IDMyIH0gPSB7fSkge1xuICAgIGlmICh0eXBlb2YgaGV4T3JCeXRlcyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBwYWRIZXgoaGV4T3JCeXRlcywgeyBkaXIsIHNpemUgfSk7XG4gICAgcmV0dXJuIHBhZEJ5dGVzKGhleE9yQnl0ZXMsIHsgZGlyLCBzaXplIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhZEhleChoZXhfLCB7IGRpciwgc2l6ZSA9IDMyIH0gPSB7fSkge1xuICAgIGlmIChzaXplID09PSBudWxsKVxuICAgICAgICByZXR1cm4gaGV4XztcbiAgICBjb25zdCBoZXggPSBoZXhfLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGlmIChoZXgubGVuZ3RoID4gc2l6ZSAqIDIpXG4gICAgICAgIHRocm93IG5ldyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnaGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYWRCeXRlcyhieXRlcywgeyBkaXIsIHNpemUgPSAzMiB9ID0ge30pIHtcbiAgICBpZiAoc2l6ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/pad.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/size.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/size.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _isHex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js\");\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nfunction size(value) {\n    if ((0,_isHex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(value, { strict: false }))\n        return Math.ceil((value.length - 2) / 2);\n    return value.length;\n}\n//# sourceMappingURL=size.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvc2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsZ0RBQUssVUFBVSxlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvc2l6ZS5qcz8xNmQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSGV4IH0gZnJvbSAnLi9pc0hleC5qcyc7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgdGhlIHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSAoaGV4IG9yIGJ5dGUgYXJyYXkpIHRvIHJldHJpZXZlIHRoZSBzaXplIG9mLlxuICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIHZhbHVlIChpbiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgaWYgKGlzSGV4KHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/size.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/trim.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/trim.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\nfunction trim(hexOrBytes, { dir = 'left' } = {}) {\n    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (typeof hexOrBytes === 'string') {\n        if (data.length === 1 && dir === 'right')\n            data = `${data}0`;\n        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\n    }\n    return data;\n}\n//# sourceMappingURL=trim.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvdHJpbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sNEJBQTRCLGVBQWUsSUFBSTtBQUN0RDtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isb0JBQW9CLDRCQUE0QixLQUFLLFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS90cmltLmpzP2MxOWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHRyaW0oaGV4T3JCeXRlcywgeyBkaXIgPSAnbGVmdCcgfSA9IHt9KSB7XG4gICAgbGV0IGRhdGEgPSB0eXBlb2YgaGV4T3JCeXRlcyA9PT0gJ3N0cmluZycgPyBoZXhPckJ5dGVzLnJlcGxhY2UoJzB4JywgJycpIDogaGV4T3JCeXRlcztcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgaGV4T3JCeXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRpciA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICAgIGRhdGEgPSBgJHtkYXRhfTBgO1xuICAgICAgICByZXR1cm4gYDB4JHtkYXRhLmxlbmd0aCAlIDIgPT09IDEgPyBgMCR7ZGF0YX1gIDogZGF0YX1gO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/trim.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   hexToBigInt: () => (/* binding */ hexToBigInt),\n/* harmony export */   hexToBool: () => (/* binding */ hexToBool),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   hexToString: () => (/* binding */ hexToString)\n/* harmony export */ });\n/* harmony import */ var _errors_encoding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/encoding.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/encoding.js\");\n/* harmony import */ var _data_size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/size.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/size.js\");\n/* harmony import */ var _data_trim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/trim.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/trim.js\");\n/* harmony import */ var _toBytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toBytes.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n\n\n\n\nfunction assertSize(hexOrBytes, { size }) {\n    if ((0,_data_size_js__WEBPACK_IMPORTED_MODULE_0__.size)(hexOrBytes) > size)\n        throw new _errors_encoding_js__WEBPACK_IMPORTED_MODULE_1__.SizeOverflowError({\n            givenSize: (0,_data_size_js__WEBPACK_IMPORTED_MODULE_0__.size)(hexOrBytes),\n            maxSize: size,\n        });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nfunction fromHex(hex, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return hexToNumber(hex, opts);\n    if (to === 'bigint')\n        return hexToBigInt(hex, opts);\n    if (to === 'string')\n        return hexToString(hex, opts);\n    if (to === 'boolean')\n        return hexToBool(hex, opts);\n    return (0,_toBytes_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nfunction hexToBigInt(hex, opts = {}) {\n    const { signed } = opts;\n    if (opts.size)\n        assertSize(hex, { size: opts.size });\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    if (value <= max)\n        return value;\n    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nfunction hexToBool(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = (0,_data_trim_js__WEBPACK_IMPORTED_MODULE_3__.trim)(hex);\n    }\n    if ((0,_data_trim_js__WEBPACK_IMPORTED_MODULE_3__.trim)(hex) === '0x00')\n        return false;\n    if ((0,_data_trim_js__WEBPACK_IMPORTED_MODULE_3__.trim)(hex) === '0x01')\n        return true;\n    throw new _errors_encoding_js__WEBPACK_IMPORTED_MODULE_1__.InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nfunction hexToNumber(hex, opts = {}) {\n    return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nfunction hexToString(hex, opts = {}) {\n    let bytes = (0,_toBytes_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(hex);\n    if (opts.size) {\n        assertSize(bytes, { size: opts.size });\n        bytes = (0,_data_trim_js__WEBPACK_IMPORTED_MODULE_3__.trim)(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromHex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL2Zyb21IZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFzRjtBQUN0QztBQUNUO0FBQ0c7QUFDbkMsa0NBQWtDLE1BQU07QUFDL0MsUUFBUSxtREFBSztBQUNiLGtCQUFrQixrRUFBaUI7QUFDbkMsdUJBQXVCLG1EQUFLO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixvR0FBb0csVUFBVTtBQUM5RztBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksU0FBUztBQUNyQjtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsa0dBQWtHLFVBQVU7QUFDNUc7QUFDQTtBQUNPLGtDQUFrQztBQUN6QztBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxjQUFjLG1EQUFJO0FBQ2xCO0FBQ0EsUUFBUSxtREFBSTtBQUNaO0FBQ0EsUUFBUSxtREFBSTtBQUNaO0FBQ0EsY0FBYyx1RUFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixvR0FBb0csVUFBVTtBQUM5RztBQUNBO0FBQ08sbUNBQW1DO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsZ0JBQWdCLHVEQUFVO0FBQzFCO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QyxnQkFBZ0IsbURBQUksVUFBVSxjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL2Zyb21IZXguanM/MzkxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yLCBTaXplT3ZlcmZsb3dFcnJvciwgfSBmcm9tICcuLi8uLi9lcnJvcnMvZW5jb2RpbmcuanMnO1xuaW1wb3J0IHsgc2l6ZSBhcyBzaXplXyB9IGZyb20gJy4uL2RhdGEvc2l6ZS5qcyc7XG5pbXBvcnQgeyB0cmltIH0gZnJvbSAnLi4vZGF0YS90cmltLmpzJztcbmltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tICcuL3RvQnl0ZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoaGV4T3JCeXRlcywgeyBzaXplIH0pIHtcbiAgICBpZiAoc2l6ZV8oaGV4T3JCeXRlcykgPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgU2l6ZU92ZXJmbG93RXJyb3Ioe1xuICAgICAgICAgICAgZ2l2ZW5TaXplOiBzaXplXyhoZXhPckJ5dGVzKSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemUsXG4gICAgICAgIH0pO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgaGV4IHN0cmluZyBpbnRvIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgYm9vbGVhbiwgb3IgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy9mcm9tSGV4XG4gKiAtIEV4YW1wbGU6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy9mcm9tSGV4I3VzYWdlXG4gKlxuICogQHBhcmFtIGhleCBIZXggc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB0b09yT3B0cyBUeXBlIHRvIGNvbnZlcnQgdG8gb3Igb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGZyb21IZXggfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGZyb21IZXgoJzB4MWE0JywgJ251bWJlcicpXG4gKiAvLyA0MjBcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZnJvbUhleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnLCAnc3RyaW5nJylcbiAqIC8vICdIZWxsbyB3b3JsZCdcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZnJvbUhleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywge1xuICogICBzaXplOiAzMixcbiAqICAgdG86ICdzdHJpbmcnXG4gKiB9KVxuICogLy8gJ0hlbGxvIHdvcmxkJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgsIHRvT3JPcHRzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHR5cGVvZiB0b09yT3B0cyA9PT0gJ3N0cmluZycgPyB7IHRvOiB0b09yT3B0cyB9IDogdG9Pck9wdHM7XG4gICAgY29uc3QgdG8gPSBvcHRzLnRvO1xuICAgIGlmICh0byA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBoZXhUb051bWJlcihoZXgsIG9wdHMpO1xuICAgIGlmICh0byA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiBoZXhUb0JpZ0ludChoZXgsIG9wdHMpO1xuICAgIGlmICh0byA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBoZXhUb1N0cmluZyhoZXgsIG9wdHMpO1xuICAgIGlmICh0byA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gaGV4VG9Cb29sKGhleCwgb3B0cyk7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4LCBvcHRzKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIGhleCB2YWx1ZSBpbnRvIGEgYmlnaW50LlxuICpcbiAqIC0gRG9jczogaHR0cHM6Ly92aWVtLnNoL2RvY3MvdXRpbGl0aWVzL2Zyb21IZXgjaGV4dG9iaWdpbnRcbiAqXG4gKiBAcGFyYW0gaGV4IEhleCB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgQmlnSW50IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBoZXhUb0JpZ0ludCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gaGV4VG9CaWdJbnQoJzB4MWE0JywgeyBzaWduZWQ6IHRydWUgfSlcbiAqIC8vIDQyMG5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaGV4VG9CaWdJbnQgfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGhleFRvQmlnSW50KCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyA0MjBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0JpZ0ludChoZXgsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkIH0gPSBvcHRzO1xuICAgIGlmIChvcHRzLnNpemUpXG4gICAgICAgIGFzc2VydFNpemUoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAtIEJpZ0ludChgMHgkeydmJy5wYWRTdGFydChzaXplICogMiwgJ2YnKX1gKSAtIDFuO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgaGV4IHZhbHVlIGludG8gYSBib29sZWFuLlxuICpcbiAqIC0gRG9jczogaHR0cHM6Ly92aWVtLnNoL2RvY3MvdXRpbGl0aWVzL2Zyb21IZXgjaGV4dG9ib29sXG4gKlxuICogQHBhcmFtIGhleCBIZXggdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIEJvb2xlYW4gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhleFRvQm9vbCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gaGV4VG9Cb29sKCcweDAxJylcbiAqIC8vIHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaGV4VG9Cb29sIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBoZXhUb0Jvb2woJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIHRydWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQm9vbChoZXhfLCBvcHRzID0ge30pIHtcbiAgICBsZXQgaGV4ID0gaGV4XztcbiAgICBpZiAob3B0cy5zaXplKSB7XG4gICAgICAgIGFzc2VydFNpemUoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICAgICAgaGV4ID0gdHJpbShoZXgpO1xuICAgIH1cbiAgICBpZiAodHJpbShoZXgpID09PSAnMHgwMCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHJpbShoZXgpID09PSAnMHgwMScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG4vKipcbiAqIERlY29kZXMgYSBoZXggc3RyaW5nIGludG8gYSBudW1iZXIuXG4gKlxuICogLSBEb2NzOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvZnJvbUhleCNoZXh0b251bWJlclxuICpcbiAqIEBwYXJhbSBoZXggSGV4IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBOdW1iZXIgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhleFRvTnVtYmVyIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBoZXhUb051bWJlcignMHgxYTQnKVxuICogLy8gNDIwXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhleFRvTnVtYmVyIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBoZXhUb0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gNDIwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBOdW1iZXIoaGV4VG9CaWdJbnQoaGV4LCBvcHRzKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSBoZXggdmFsdWUgaW50byBhIFVURi04IHN0cmluZy5cbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy9mcm9tSGV4I2hleHRvc3RyaW5nXG4gKlxuICogQHBhcmFtIGhleCBIZXggdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIFN0cmluZyB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaGV4VG9TdHJpbmcgfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGhleFRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMScpXG4gKiAvLyAnSGVsbG8gd29ybGQhJ1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBoZXhUb1N0cmluZyB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gaGV4VG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIHtcbiAqICBzaXplOiAzMixcbiAqIH0pXG4gKiAvLyAnSGVsbG8gd29ybGQnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1N0cmluZyhoZXgsIG9wdHMgPSB7fSkge1xuICAgIGxldCBieXRlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICBpZiAob3B0cy5zaXplKSB7XG4gICAgICAgIGFzc2VydFNpemUoYnl0ZXMsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICAgICAgICBieXRlcyA9IHRyaW0oYnl0ZXMsIHsgZGlyOiAncmlnaHQnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21IZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boolToBytes: () => (/* binding */ boolToBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   numberToBytes: () => (/* binding */ numberToBytes),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   toBytes: () => (/* binding */ toBytes)\n/* harmony export */ });\n/* harmony import */ var _errors_base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/base.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/base.js\");\n/* harmony import */ var _data_isHex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/isHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js\");\n/* harmony import */ var _data_pad_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/pad.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var _fromHex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fromHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js\");\n/* harmony import */ var _toHex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\");\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nfunction toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if ((0,_data_isHex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nfunction boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        (0,_fromHex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize)(bytes, { size: opts.size });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_2__.pad)(bytes, { size: opts.size });\n    }\n    return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nfunction hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        (0,_fromHex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize)(hex, { size: opts.size });\n        hex = (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_2__.pad)(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _errors_base_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nfunction numberToBytes(value, opts) {\n    const hex = (0,_toHex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(value, opts);\n    return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nfunction stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        (0,_fromHex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize)(bytes, { size: opts.size });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_2__.pad)(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\n//# sourceMappingURL=toBytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL3RvQnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNSO0FBQ0o7QUFDSztBQUNBO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QiwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ08saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVSxVQUFVLGlCQUFpQjtBQUM3QyxlQUFlLGlEQUFHLFVBQVUsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUM7QUFDQTtBQUNBLFFBQVEsdURBQVUsUUFBUSxpQkFBaUI7QUFDM0MsY0FBYyxpREFBRyxRQUFRLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVMsNEJBQTRCLGlCQUFpQixFQUFFLGlCQUFpQixRQUFRLFVBQVU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ087QUFDUCxnQkFBZ0Isc0RBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRLHVEQUFVLFVBQVUsaUJBQWlCO0FBQzdDLGVBQWUsaURBQUcsVUFBVSwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5jb2RpbmcvdG9CeXRlcy5qcz8wNmYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9iYXNlLmpzJztcbmltcG9ydCB7IGlzSGV4IH0gZnJvbSAnLi4vZGF0YS9pc0hleC5qcyc7XG5pbXBvcnQgeyBwYWQgfSBmcm9tICcuLi9kYXRhL3BhZC5qcyc7XG5pbXBvcnQgeyBhc3NlcnRTaXplIH0gZnJvbSAnLi9mcm9tSGV4LmpzJztcbmltcG9ydCB7IG51bWJlclRvSGV4LCB9IGZyb20gJy4vdG9IZXguanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vKipcbiAqIEVuY29kZXMgYSBVVEYtOCBzdHJpbmcsIGhleCB2YWx1ZSwgYmlnaW50LCBudW1iZXIgb3IgYm9vbGVhbiB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogLSBEb2NzOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9CeXRlc1xuICogLSBFeGFtcGxlOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9CeXRlcyN1c2FnZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgQnl0ZSBhcnJheSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gdG9CeXRlcygnSGVsbG8gd29ybGQnKVxuICogLy8gVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gdG9CeXRlcyg0MjApXG4gKiAvLyBVaW50OEFycmF5KFsxLCAxNjRdKVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB0b0J5dGVzIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSB0b0J5dGVzKDQyMCwgeyBzaXplOiA0IH0pXG4gKiAvLyBVaW50OEFycmF5KFswLCAwLCAxLCAxNjRdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUsIG9wdHMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuIGJvb2xUb0J5dGVzKHZhbHVlLCBvcHRzKTtcbiAgICBpZiAoaXNIZXgodmFsdWUpKVxuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSwgb3B0cyk7XG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUsIG9wdHMpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgYm9vbGVhbiBpbnRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0J5dGVzI2Jvb2x0b2J5dGVzXG4gKlxuICogQHBhcmFtIHZhbHVlIEJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIEJ5dGUgYXJyYXkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGJvb2xUb0J5dGVzIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBib29sVG9CeXRlcyh0cnVlKVxuICogLy8gVWludDhBcnJheShbMV0pXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGJvb2xUb0J5dGVzIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBib29sVG9CeXRlcyh0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xUb0J5dGVzKHZhbHVlLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGJ5dGVzWzBdID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIG9wdHMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXNzZXJ0U2l6ZShieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgICAgIHJldHVybiBwYWQoYnl0ZXMsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyBXZSB1c2UgdmVyeSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBjaGFyQ29kZU1hcCA9IHtcbiAgICB6ZXJvOiA0OCxcbiAgICBuaW5lOiA1NyxcbiAgICBBOiA2NSxcbiAgICBGOiA3MCxcbiAgICBhOiA5NyxcbiAgICBmOiAxMDIsXG59O1xuZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgaGV4IHN0cmluZyBpbnRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0J5dGVzI2hleHRvYnl0ZXNcbiAqXG4gKiBAcGFyYW0gaGV4IEhleCBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIEJ5dGUgYXJyYXkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGhleFRvQnl0ZXMoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGhleFRvQnl0ZXMoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJywgeyBzaXplOiAzMiB9KVxuICogLy8gVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4Xywgb3B0cyA9IHt9KSB7XG4gICAgbGV0IGhleCA9IGhleF87XG4gICAgaWYgKG9wdHMuc2l6ZSkge1xuICAgICAgICBhc3NlcnRTaXplKGhleCwgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgICAgIGhleCA9IHBhZChoZXgsIHsgZGlyOiAncmlnaHQnLCBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgfVxuICAgIGxldCBoZXhTdHJpbmcgPSBoZXguc2xpY2UoMik7XG4gICAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyKVxuICAgICAgICBoZXhTdHJpbmcgPSBgMCR7aGV4U3RyaW5nfWA7XG4gICAgY29uc3QgbGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgaiA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5pYmJsZUxlZnQgPSBjaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBjb25zdCBuaWJibGVSaWdodCA9IGNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGlmIChuaWJibGVMZWZ0ID09PSB1bmRlZmluZWQgfHwgbmliYmxlUmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaW5kZXhdID0gbmliYmxlTGVmdCAqIDE2ICsgbmliYmxlUmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBpbnRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0J5dGVzI251bWJlcnRvYnl0ZXNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgTnVtYmVyIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBCeXRlIGFycmF5IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBudW1iZXJUb0J5dGVzIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBudW1iZXJUb0J5dGVzKDQyMClcbiAqIC8vIFVpbnQ4QXJyYXkoWzEsIDE2NF0pXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IG51bWJlclRvQnl0ZXMgfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IG51bWJlclRvQnl0ZXMoNDIwLCB7IHNpemU6IDQgfSlcbiAqIC8vIFVpbnQ4QXJyYXkoWzAsIDAsIDEsIDE2NF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzKHZhbHVlLCBvcHRzKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtYmVyVG9IZXgodmFsdWUsIG9wdHMpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBVVEYtOCBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogLSBEb2NzOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9CeXRlcyNzdHJpbmd0b2J5dGVzXG4gKlxuICogQHBhcmFtIHZhbHVlIFN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgQnl0ZSBhcnJheSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc3RyaW5nVG9CeXRlcyB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gc3RyaW5nVG9CeXRlcygnSGVsbG8gd29ybGQhJylcbiAqIC8vIFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzdHJpbmdUb0J5dGVzIH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBzdHJpbmdUb0J5dGVzKCdIZWxsbyB3b3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFzc2VydFNpemUoYnl0ZXMsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICAgICAgICByZXR1cm4gcGFkKGJ5dGVzLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZTogb3B0cy5zaXplIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0J5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boolToHex: () => (/* binding */ boolToHex),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   numberToHex: () => (/* binding */ numberToHex),\n/* harmony export */   stringToHex: () => (/* binding */ stringToHex),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _errors_encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors/encoding.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/errors/encoding.js\");\n/* harmony import */ var _data_pad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/pad.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var _fromHex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fromHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js\");\n\n\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nfunction toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nfunction boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        (0,_fromHex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize)(hex, { size: opts.size });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_1__.pad)(hex, { size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nfunction bytesToHex(value, opts = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++) {\n        string += hexes[value[i]];\n    }\n    const hex = `0x${string}`;\n    if (typeof opts.size === 'number') {\n        (0,_fromHex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize)(hex, { size: opts.size });\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_1__.pad)(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nfunction numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new _errors_encoding_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return (0,_data_pad_js__WEBPACK_IMPORTED_MODULE_1__.pad)(hex, { size });\n    return hex;\n}\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nfunction stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\n//# sourceMappingURL=toHex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL3RvSGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW1FO0FBQzlCO0FBQ0s7QUFDMUMseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQix1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ08sK0JBQStCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMscUJBQXFCLGNBQWM7QUFDbkM7QUFDQSxRQUFRLHVEQUFVLFFBQVEsaUJBQWlCO0FBQzNDLGVBQWUsaURBQUcsUUFBUSxpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsd0dBQXdHLFVBQVU7QUFDbEg7QUFDQTtBQUNPLG9DQUFvQztBQUMzQztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0EsUUFBUSx1REFBVSxRQUFRLGlCQUFpQjtBQUMzQyxlQUFlLGlEQUFHLFFBQVEsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUVBQXNCO0FBQ3hDLCtCQUErQixTQUFTLEVBQUUsT0FBTztBQUNqRCxvQkFBb0IsU0FBUyxFQUFFLE9BQU87QUFDdEM7QUFDQTtBQUNBLHNCQUFzQixPQUFPLEVBQUUsT0FBTztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxlQUFlLGlEQUFHLFFBQVEsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQiw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL3RvSGV4LmpzP2ZlOWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50ZWdlck91dE9mUmFuZ2VFcnJvciwgfSBmcm9tICcuLi8uLi9lcnJvcnMvZW5jb2RpbmcuanMnO1xuaW1wb3J0IHsgcGFkIH0gZnJvbSAnLi4vZGF0YS9wYWQuanMnO1xuaW1wb3J0IHsgYXNzZXJ0U2l6ZSB9IGZyb20gJy4vZnJvbUhleC5qcyc7XG5jb25zdCBoZXhlcyA9IC8qI19fUFVSRV9fKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBCeXRlQXJyYXkgaW50byBhIGhleCBzdHJpbmdcbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0hleFxuICogLSBFeGFtcGxlOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9IZXgjdXNhZ2VcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAqIEByZXR1cm5zIEhleCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdG9IZXggfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IHRvSGV4KCdIZWxsbyB3b3JsZCcpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHRvSGV4IH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSB0b0hleCg0MjApXG4gKiAvLyAnMHgxYTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHRvSGV4IH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSB0b0hleCgnSGVsbG8gd29ybGQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiBudW1iZXJUb0hleCh2YWx1ZSwgb3B0cyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvSGV4KHZhbHVlLCBvcHRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gYm9vbFRvSGV4KHZhbHVlLCBvcHRzKTtcbiAgICByZXR1cm4gYnl0ZXNUb0hleCh2YWx1ZSwgb3B0cyk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIGludG8gYSBoZXggc3RyaW5nXG4gKlxuICogLSBEb2NzOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9IZXgjYm9vbHRvaGV4XG4gKlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBIZXggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGJvb2xUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gYm9vbFRvSGV4KHRydWUpXG4gKiAvLyAnMHgxJ1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBib29sVG9IZXggfSBmcm9tICd2aWVtJ1xuICogY29uc3QgZGF0YSA9IGJvb2xUb0hleChmYWxzZSlcbiAqIC8vICcweDAnXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGJvb2xUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gYm9vbFRvSGV4KHRydWUsIHsgc2l6ZTogMzIgfSlcbiAqIC8vICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib29sVG9IZXgodmFsdWUsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBhc3NlcnRTaXplKGhleCwgeyBzaXplOiBvcHRzLnNpemUgfSk7XG4gICAgICAgIHJldHVybiBwYWQoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJ5dGVzIGFycmF5IGludG8gYSBoZXggc3RyaW5nXG4gKlxuICogLSBEb2NzOiBodHRwczovL3ZpZW0uc2gvZG9jcy91dGlsaXRpZXMvdG9IZXgjYnl0ZXN0b2hleFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgSGV4IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pLCB7IHNpemU6IDMyIH0pXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleCh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmd9YDtcbiAgICBpZiAodHlwZW9mIG9wdHMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xuICAgICAgICByZXR1cm4gcGFkKGhleCwgeyBkaXI6ICdyaWdodCcsIHNpemU6IG9wdHMuc2l6ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBvciBiaWdpbnQgaW50byBhIGhleCBzdHJpbmdcbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0hleCNudW1iZXJ0b2hleFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgSGV4IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBudW1iZXJUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gbnVtYmVyVG9IZXgoNDIwKVxuICogLy8gJzB4MWE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBudW1iZXJUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gbnVtYmVyVG9IZXgoNDIwLCB7IHNpemU6IDMyIH0pXG4gKiAvLyAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0J1xuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWVfLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0cztcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludCh2YWx1ZV8pO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlXyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWF4VmFsdWUgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIH1cbiAgICBjb25zdCBtaW5WYWx1ZSA9IHR5cGVvZiBtYXhWYWx1ZSA9PT0gJ2JpZ2ludCcgJiYgc2lnbmVkID8gLW1heFZhbHVlIC0gMW4gOiAwO1xuICAgIGlmICgobWF4VmFsdWUgJiYgdmFsdWUgPiBtYXhWYWx1ZSkgfHwgdmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWVfID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWVffSR7c3VmZml4fWAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBgMHgkeyhzaWduZWQgJiYgdmFsdWUgPCAwXG4gICAgICAgID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlKVxuICAgICAgICA6IHZhbHVlKS50b1N0cmluZygxNil9YDtcbiAgICBpZiAoc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBhZChoZXgsIHsgc2l6ZSB9KTtcbiAgICByZXR1cm4gaGV4O1xufVxuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vKipcbiAqIEVuY29kZXMgYSBVVEYtOCBzdHJpbmcgaW50byBhIGhleCBzdHJpbmdcbiAqXG4gKiAtIERvY3M6IGh0dHBzOi8vdmllbS5zaC9kb2NzL3V0aWxpdGllcy90b0hleCNzdHJpbmd0b2hleFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICogQHJldHVybnMgSGV4IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzdHJpbmdUb0hleCB9IGZyb20gJ3ZpZW0nXG4gKiBjb25zdCBkYXRhID0gc3RyaW5nVG9IZXgoJ0hlbGxvIFdvcmxkIScpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHN0cmluZ1RvSGV4IH0gZnJvbSAndmllbSdcbiAqIGNvbnN0IGRhdGEgPSBzdHJpbmdUb0hleCgnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvSGV4KHZhbHVlXywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdmFsdWUgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZV8pO1xuICAgIHJldHVybiBieXRlc1RvSGV4KHZhbHVlLCBvcHRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvSGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _data_isHex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/isHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js\");\n/* harmony import */ var _encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../encoding/toBytes.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var _encoding_toHex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../encoding/toHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\");\n\n\n\n\nfunction keccak256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)((0,_data_isHex_js__WEBPACK_IMPORTED_MODULE_1__.isHex)(value, { strict: false }) ? (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return (0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(bytes);\n}\n//# sourceMappingURL=keccak256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gva2VjY2FrMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdEO0FBQ1A7QUFDUTtBQUNKO0FBQ3RDO0FBQ1A7QUFDQSxrQkFBa0IsOERBQVUsQ0FBQyxxREFBSyxVQUFVLGVBQWUsSUFBSSw2REFBTztBQUN0RTtBQUNBO0FBQ0EsV0FBVyx5REFBSztBQUNoQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gva2VjY2FrMjU2LmpzPzAyMzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBpc0hleCB9IGZyb20gJy4uL2RhdGEvaXNIZXguanMnO1xuaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJy4uL2VuY29kaW5nL3RvQnl0ZXMuanMnO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuLi9lbmNvZGluZy90b0hleC5qcyc7XG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KHZhbHVlLCB0b18pIHtcbiAgICBjb25zdCB0byA9IHRvXyB8fCAnaGV4JztcbiAgICBjb25zdCBieXRlcyA9IGtlY2Nha18yNTYoaXNIZXgodmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KSA/IHRvQnl0ZXModmFsdWUpIDogdmFsdWUpO1xuICAgIGlmICh0byA9PT0gJ2J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiB0b0hleChieXRlcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/lru.js":
/*!************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/lru.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize)\n            this.delete(this.keys().next().value);\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2xydS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeG10cC94bXRwLWpzL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvbHJ1LmpzP2VlOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXAgd2l0aCBhIExSVSAoTGVhc3QgcmVjZW50bHkgdXNlZCkgcG9saWN5LlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX3JlcGxhY2VtZW50X3BvbGljaWVzI0xSVVxuICovXG5leHBvcnQgY2xhc3MgTHJ1TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5tYXhTaXplICYmIHRoaXMuc2l6ZSA+IHRoaXMubWF4U2l6ZSlcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5cygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxydS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hashMessage.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hashMessage.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage)\n/* harmony export */ });\n/* harmony import */ var _constants_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/strings.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/constants/strings.js\");\n/* harmony import */ var _data_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/concat.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/concat.js\");\n/* harmony import */ var _encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/toBytes.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var _hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/keccak256.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/hash/keccak256.js\");\n\n\n\n\nfunction hashMessage(message, to_) {\n    const messageBytes = (() => {\n        if (typeof message === 'string')\n            return (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(message);\n        if (message.raw instanceof Uint8Array)\n            return message.raw;\n        return (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(message.raw);\n    })();\n    const prefixBytes = (0,_encoding_toBytes_js__WEBPACK_IMPORTED_MODULE_0__.stringToBytes)(`${_constants_strings_js__WEBPACK_IMPORTED_MODULE_1__.presignMessagePrefix}${messageBytes.length}`);\n    return (0,_hash_keccak256_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_data_concat_js__WEBPACK_IMPORTED_MODULE_3__.concat)([prefixBytes, messageBytes]), to_);\n}\n//# sourceMappingURL=hashMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9oYXNoTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRTtBQUN2QjtBQUNzQjtBQUNoQjtBQUMxQztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQWE7QUFDaEM7QUFDQTtBQUNBLGVBQWUsNkRBQU87QUFDdEIsS0FBSztBQUNMLHdCQUF3QixtRUFBYSxJQUFJLHVFQUFvQixDQUFDLEVBQUUsb0JBQW9CO0FBQ3BGLFdBQVcsNkRBQVMsQ0FBQyx1REFBTTtBQUMzQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9oYXNoTWVzc2FnZS5qcz8xZjBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByZXNpZ25NZXNzYWdlUHJlZml4IH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAnLi4vZGF0YS9jb25jYXQuanMnO1xuaW1wb3J0IHsgc3RyaW5nVG9CeXRlcywgdG9CeXRlcywgfSBmcm9tICcuLi9lbmNvZGluZy90b0J5dGVzLmpzJztcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gJy4uL2hhc2gva2VjY2FrMjU2LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlLCB0b18pIHtcbiAgICBjb25zdCBtZXNzYWdlQnl0ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLnJhdyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5yYXc7XG4gICAgICAgIHJldHVybiB0b0J5dGVzKG1lc3NhZ2UucmF3KTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHByZWZpeEJ5dGVzID0gc3RyaW5nVG9CeXRlcyhgJHtwcmVzaWduTWVzc2FnZVByZWZpeH0ke21lc3NhZ2VCeXRlcy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW3ByZWZpeEJ5dGVzLCBtZXNzYWdlQnl0ZXNdKSwgdG9fKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hNZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hashMessage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hexToSignature.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hexToSignature.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hexToSignature: () => (/* binding */ hexToSignature)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/encoding/toHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\");\n\n\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * hexToSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nfunction hexToSignature(signatureHex) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));\n    const v = BigInt(`0x${signatureHex.slice(130)}`);\n    return { r: (0,_utils_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(r, { size: 32 }), s: (0,_utils_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(s, { size: 32 }), v };\n}\n//# sourceMappingURL=hexToSignature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9oZXhUb1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0Q7QUFDUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ087QUFDUCxZQUFZLE9BQU8sRUFBRSw4REFBUztBQUM5QiwwQkFBMEIsd0JBQXdCO0FBQ2xELGFBQWEsR0FBRyxxRUFBVyxNQUFNLFVBQVUsTUFBTSxxRUFBVyxNQUFNLFVBQVU7QUFDNUU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvaGV4VG9TaWduYXR1cmUuanM/NTRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBudW1iZXJUb0hleCwgfSBmcm9tICcuLi8uLi91dGlscy9lbmNvZGluZy90b0hleC5qcyc7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBQYXJzZXMgYSBoZXggZm9ybWF0dGVkIHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZUhleCBTaWduYXR1cmUgaW4gaGV4IGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBzdHJ1Y3R1cmVkIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaGV4VG9TaWduYXR1cmUoJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYycpXG4gKiAvLyB7IHI6ICcweC4uLicsIHM6ICcweC4uLicsIHY6IDI4biB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1NpZ25hdHVyZShzaWduYXR1cmVIZXgpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlSGV4LnNsaWNlKDIsIDEzMCkpO1xuICAgIGNvbnN0IHYgPSBCaWdJbnQoYDB4JHtzaWduYXR1cmVIZXguc2xpY2UoMTMwKX1gKTtcbiAgICByZXR1cm4geyByOiBudW1iZXJUb0hleChyLCB7IHNpemU6IDMyIH0pLCBzOiBudW1iZXJUb0hleChzLCB7IHNpemU6IDMyIH0pLCB2IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXhUb1NpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hexToSignature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverAddress.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverAddress.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _accounts_utils_publicKeyToAddress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../accounts/utils/publicKeyToAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js\");\n/* harmony import */ var _recoverPublicKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./recoverPublicKey.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverPublicKey.js\");\n\n\nasync function recoverAddress({ hash, signature, }) {\n    return (0,_accounts_utils_publicKeyToAddress_js__WEBPACK_IMPORTED_MODULE_0__.publicKeyToAddress)(await (0,_recoverPublicKey_js__WEBPACK_IMPORTED_MODULE_1__.recoverPublicKey)({ hash: hash, signature }));\n}\n//# sourceMappingURL=recoverAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyQWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Y7QUFDdkI7QUFDbEQsZ0NBQWdDLGtCQUFrQjtBQUN6RCxXQUFXLHlGQUFrQixPQUFPLHNFQUFnQixHQUFHLHVCQUF1QjtBQUM5RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyQWRkcmVzcy5qcz83Zjk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHB1YmxpY0tleVRvQWRkcmVzcyB9IGZyb20gJy4uLy4uL2FjY291bnRzL3V0aWxzL3B1YmxpY0tleVRvQWRkcmVzcy5qcyc7XG5pbXBvcnQgeyByZWNvdmVyUHVibGljS2V5IH0gZnJvbSAnLi9yZWNvdmVyUHVibGljS2V5LmpzJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyh7IGhhc2gsIHNpZ25hdHVyZSwgfSkge1xuICAgIHJldHVybiBwdWJsaWNLZXlUb0FkZHJlc3MoYXdhaXQgcmVjb3ZlclB1YmxpY0tleSh7IGhhc2g6IGhhc2gsIHNpZ25hdHVyZSB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvdmVyQWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverAddress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverMessageAddress.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverMessageAddress.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recoverMessageAddress: () => (/* binding */ recoverMessageAddress)\n/* harmony export */ });\n/* harmony import */ var _hashMessage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashMessage.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/hashMessage.js\");\n/* harmony import */ var _recoverAddress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./recoverAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverAddress.js\");\n\n\nasync function recoverMessageAddress({ message, signature, }) {\n    return (0,_recoverAddress_js__WEBPACK_IMPORTED_MODULE_0__.recoverAddress)({ hash: (0,_hashMessage_js__WEBPACK_IMPORTED_MODULE_1__.hashMessage)(message), signature });\n}\n//# sourceMappingURL=recoverMessageAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyTWVzc2FnZUFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ087QUFDL0MsdUNBQXVDLHFCQUFxQjtBQUNuRSxXQUFXLGtFQUFjLEdBQUcsTUFBTSw0REFBVyxzQkFBc0I7QUFDbkU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvcmVjb3Zlck1lc3NhZ2VBZGRyZXNzLmpzP2EzNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaE1lc3NhZ2UgfSBmcm9tICcuL2hhc2hNZXNzYWdlLmpzJztcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzLCB9IGZyb20gJy4vcmVjb3ZlckFkZHJlc3MuanMnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY292ZXJNZXNzYWdlQWRkcmVzcyh7IG1lc3NhZ2UsIHNpZ25hdHVyZSwgfSkge1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyh7IGhhc2g6IGhhc2hNZXNzYWdlKG1lc3NhZ2UpLCBzaWduYXR1cmUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvdmVyTWVzc2FnZUFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverMessageAddress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverPublicKey.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverPublicKey.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey)\n/* harmony export */ });\n/* harmony import */ var _data_isHex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/isHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/data/isHex.js\");\n/* harmony import */ var _encoding_fromHex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../encoding/fromHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/fromHex.js\");\n/* harmony import */ var _encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../encoding/toHex.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/encoding/toHex.js\");\n\n\n\nasync function recoverPublicKey({ hash, signature, }) {\n    const signatureHex = (0,_data_isHex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(signature) ? signature : (0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(signature);\n    const hashHex = (0,_data_isHex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(hash) ? hash : (0,_encoding_toHex_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(hash);\n    // Derive v = recoveryId + 27 from end of the signature (27 is added when signing the message)\n    // The recoveryId represents the y-coordinate on the secp256k1 elliptic curve and can have a value [0, 1].\n    let v = (0,_encoding_fromHex_js__WEBPACK_IMPORTED_MODULE_2__.hexToNumber)(`0x${signatureHex.slice(130)}`);\n    if (v === 0 || v === 1)\n        v += 27;\n    const { secp256k1 } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/@noble/curves/esm/secp256k1.js\"));\n    const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130))\n        .addRecoveryBit(v - 27)\n        .recoverPublicKey(hashHex.substring(2))\n        .toHex(false);\n    return `0x${publicKey}`;\n}\n//# sourceMappingURL=recoverPublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyUHVibGljS2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDWTtBQUNSO0FBQ3RDLGtDQUFrQyxrQkFBa0I7QUFDM0QseUJBQXlCLHFEQUFLLDBCQUEwQix5REFBSztBQUM3RCxvQkFBb0IscURBQUssZ0JBQWdCLHlEQUFLO0FBQzlDO0FBQ0E7QUFDQSxZQUFZLGlFQUFXLE1BQU0sd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQSxZQUFZLFlBQVksUUFBUSxxTUFBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyUHVibGljS2V5LmpzP2VlOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIZXggfSBmcm9tICcuLi9kYXRhL2lzSGV4LmpzJztcbmltcG9ydCB7IGhleFRvTnVtYmVyIH0gZnJvbSAnLi4vZW5jb2RpbmcvZnJvbUhleC5qcyc7XG5pbXBvcnQgeyB0b0hleCB9IGZyb20gJy4uL2VuY29kaW5nL3RvSGV4LmpzJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KHsgaGFzaCwgc2lnbmF0dXJlLCB9KSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gaXNIZXgoc2lnbmF0dXJlKSA/IHNpZ25hdHVyZSA6IHRvSGV4KHNpZ25hdHVyZSk7XG4gICAgY29uc3QgaGFzaEhleCA9IGlzSGV4KGhhc2gpID8gaGFzaCA6IHRvSGV4KGhhc2gpO1xuICAgIC8vIERlcml2ZSB2ID0gcmVjb3ZlcnlJZCArIDI3IGZyb20gZW5kIG9mIHRoZSBzaWduYXR1cmUgKDI3IGlzIGFkZGVkIHdoZW4gc2lnbmluZyB0aGUgbWVzc2FnZSlcbiAgICAvLyBUaGUgcmVjb3ZlcnlJZCByZXByZXNlbnRzIHRoZSB5LWNvb3JkaW5hdGUgb24gdGhlIHNlY3AyNTZrMSBlbGxpcHRpYyBjdXJ2ZSBhbmQgY2FuIGhhdmUgYSB2YWx1ZSBbMCwgMV0uXG4gICAgbGV0IHYgPSBoZXhUb051bWJlcihgMHgke3NpZ25hdHVyZUhleC5zbGljZSgxMzApfWApO1xuICAgIGlmICh2ID09PSAwIHx8IHYgPT09IDEpXG4gICAgICAgIHYgKz0gMjc7XG4gICAgY29uc3QgeyBzZWNwMjU2azEgfSA9IGF3YWl0IGltcG9ydCgnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZUhleC5zdWJzdHJpbmcoMiwgMTMwKSlcbiAgICAgICAgLmFkZFJlY292ZXJ5Qml0KHYgLSAyNylcbiAgICAgICAgLnJlY292ZXJQdWJsaWNLZXkoaGFzaEhleC5zdWJzdHJpbmcoMikpXG4gICAgICAgIC50b0hleChmYWxzZSk7XG4gICAgcmV0dXJuIGAweCR7cHVibGljS2V5fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvdmVyUHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverPublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/verifyMessage.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/verifyMessage.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyMessage: () => (/* binding */ verifyMessage)\n/* harmony export */ });\n/* harmony import */ var _address_getAddress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/getAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var _address_isAddressEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/isAddressEqual.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/address/isAddressEqual.js\");\n/* harmony import */ var _recoverMessageAddress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./recoverMessageAddress.js */ \"(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/recoverMessageAddress.js\");\n\n\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.\n *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure\n *        wallet interoperability.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}\n *\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nasync function verifyMessage({ address, message, signature, }) {\n    return (0,_address_isAddressEqual_js__WEBPACK_IMPORTED_MODULE_0__.isAddressEqual)((0,_address_getAddress_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address), await (0,_recoverMessageAddress_js__WEBPACK_IMPORTED_MODULE_2__.recoverMessageAddress)({ message, signature }));\n}\n//# sourceMappingURL=verifyMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhtdHAveG10cC1qcy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS92ZXJpZnlNZXNzYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDUztBQUNLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCO0FBQ3hCLG9EQUFvRDtBQUNwRDtBQUNPLCtCQUErQiw4QkFBOEI7QUFDcEUsV0FBVywwRUFBYyxDQUFDLGtFQUFVLGlCQUFpQixnRkFBcUIsR0FBRyxvQkFBb0I7QUFDakc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4bXRwL3htdHAtanMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvdmVyaWZ5TWVzc2FnZS5qcz8xZjI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tICcuLi9hZGRyZXNzL2dldEFkZHJlc3MuanMnO1xuaW1wb3J0IHsgaXNBZGRyZXNzRXF1YWwsIH0gZnJvbSAnLi4vYWRkcmVzcy9pc0FkZHJlc3NFcXVhbC5qcyc7XG5pbXBvcnQgeyByZWNvdmVyTWVzc2FnZUFkZHJlc3MsIH0gZnJvbSAnLi9yZWNvdmVyTWVzc2FnZUFkZHJlc3MuanMnO1xuLyoqXG4gKiBWZXJpZnkgdGhhdCBhIG1lc3NhZ2Ugd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqXG4gKiBOb3RlOiAgT25seSBzdXBwb3J0cyBFeHRlcm5hbGx5IE93bmVkIEFjY291bnRzLiBEb2VzIG5vdCBzdXBwb3J0IENvbnRyYWN0IEFjY291bnRzLlxuICogICAgICAgIEl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0byB1c2UgYHB1YmxpY0NsaWVudC52ZXJpZnlNZXNzYWdlYCBpbnN0ZWFkIHRvIGVuc3VyZVxuICogICAgICAgIHdhbGxldCBpbnRlcm9wZXJhYmlsaXR5LlxuICpcbiAqIC0gRG9jcyB7QGxpbmsgaHR0cHM6Ly92aWVtLnNoL2RvY3MvdXRpbGl0aWVzL3ZlcmlmeU1lc3NhZ2V9XG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSB7QGxpbmsgVmVyaWZ5TWVzc2FnZVBhcmFtZXRlcnN9XG4gKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLiB7QGxpbmsgVmVyaWZ5TWVzc2FnZVJldHVyblR5cGV9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKHsgYWRkcmVzcywgbWVzc2FnZSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgcmV0dXJuIGlzQWRkcmVzc0VxdWFsKGdldEFkZHJlc3MoYWRkcmVzcyksIGF3YWl0IHJlY292ZXJNZXNzYWdlQWRkcmVzcyh7IG1lc3NhZ2UsIHNpZ25hdHVyZSB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJpZnlNZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xmtp/xmtp-js/node_modules/viem/_esm/utils/signature/verifyMessage.js\n");

/***/ })

};
;